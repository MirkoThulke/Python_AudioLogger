{"traceEvents": [{"ph": "M", "pid": 7720, "tid": 7720, "name": "process_name", "args": {"name": "Process-2"}}, {"ph": "M", "pid": 7720, "tid": 14588, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 7720, "tid": 14588, "ts": 255915357791.788, "ph": "X", "dur": 14.2, "name": "iinfo.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:692)", "cat": "FEE"}, {"pid": 7720, "tid": 14588, "ts": 255915357811.588, "ph": "X", "dur": 1.8, "name": "iinfo.max (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:716)", "cat": "FEE"}, {"pid": 7720, "tid": 14588, "ts": 255915357867.188, "ph": "X", "dur": 11.2, "name": "MyFrame (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:789)", "cat": "FEE"}, {"pid": 7720, "tid": 14588, "ts": 255915357860.088, "ph": "X", "dur": 119.5, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 7720, "tid": 14588, "ts": 255915357987.488, "ph": "X", "dur": 2.1, "name": "MyApp (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:991)", "cat": "FEE"}, {"pid": 7720, "tid": 14588, "ts": 255915357984.388, "ph": "X", "dur": 76.8, "name": "builtins.__build_class__", "cat": "FEE"}], "viztracer_metadata": {"version": "1.0.3", "overflow": false, "baseTimeNanoseconds": 1746031909540740300}, "file_info": {"files": {"C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py": ["\"\"\"Machine limits for Float32 and Float64 and (long double) if available...\n\n\"\"\"\n__all__ = ['finfo', 'iinfo']\n\nimport warnings\n\nfrom .._utils import set_module\nfrom ._machar import MachAr\nfrom . import numeric\nfrom . import numerictypes as ntypes\nfrom .numeric import array, inf, nan\nfrom .umath import log10, exp2, nextafter, isnan\n\n\ndef _fr0(a):\n    \"\"\"fix rank-0 --> rank-1\"\"\"\n    if a.ndim == 0:\n        a = a.copy()\n        a.shape = (1,)\n    return a\n\n\ndef _fr1(a):\n    \"\"\"fix rank > 0 --> rank-0\"\"\"\n    if a.size == 1:\n        a = a.copy()\n        a.shape = ()\n    return a\n\n\nclass MachArLike:\n    \"\"\" Object to simulate MachAr instance \"\"\"\n    def __init__(self, ftype, *, eps, epsneg, huge, tiny,\n                 ibeta, smallest_subnormal=None, **kwargs):\n        self.params = _MACHAR_PARAMS[ftype]\n        self.ftype = ftype\n        self.title = self.params['title']\n        # Parameter types same as for discovered MachAr object.\n        if not smallest_subnormal:\n            self._smallest_subnormal = nextafter(\n                self.ftype(0), self.ftype(1), dtype=self.ftype)\n        else:\n            self._smallest_subnormal = smallest_subnormal\n        self.epsilon = self.eps = self._float_to_float(eps)\n        self.epsneg = self._float_to_float(epsneg)\n        self.xmax = self.huge = self._float_to_float(huge)\n        self.xmin = self._float_to_float(tiny)\n        self.smallest_normal = self.tiny = self._float_to_float(tiny)\n        self.ibeta = self.params['itype'](ibeta)\n        self.__dict__.update(kwargs)\n        self.precision = int(-log10(self.eps))\n        self.resolution = self._float_to_float(\n            self._float_conv(10) ** (-self.precision))\n        self._str_eps = self._float_to_str(self.eps)\n        self._str_epsneg = self._float_to_str(self.epsneg)\n        self._str_xmin = self._float_to_str(self.xmin)\n        self._str_xmax = self._float_to_str(self.xmax)\n        self._str_resolution = self._float_to_str(self.resolution)\n        self._str_smallest_normal = self._float_to_str(self.xmin)\n\n    @property\n    def smallest_subnormal(self):\n        \"\"\"Return the value for the smallest subnormal.\n\n        Returns\n        -------\n        smallest_subnormal : float\n            value for the smallest subnormal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest subnormal is zero.\n        \"\"\"\n        # Check that the calculated value is not zero, in case it raises a\n        # warning.\n        value = self._smallest_subnormal\n        if self.ftype(0) == value:\n            warnings.warn(\n                'The value of the smallest subnormal for {} type '\n                'is zero.'.format(self.ftype), UserWarning, stacklevel=2)\n\n        return self._float_to_float(value)\n\n    @property\n    def _str_smallest_subnormal(self):\n        \"\"\"Return the string representation of the smallest subnormal.\"\"\"\n        return self._float_to_str(self.smallest_subnormal)\n\n    def _float_to_float(self, value):\n        \"\"\"Converts float to float.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return _fr1(self._float_conv(value))\n\n    def _float_conv(self, value):\n        \"\"\"Converts float to conv.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return array([value], self.ftype)\n\n    def _float_to_str(self, value):\n        \"\"\"Converts float to str.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return self.params['fmt'] % array(_fr0(value)[0], self.ftype)\n\n\n_convert_to_float = {\n    ntypes.csingle: ntypes.single,\n    ntypes.complex128: ntypes.float64,\n    ntypes.clongdouble: ntypes.longdouble\n    }\n\n# Parameters for creating MachAr / MachAr-like objects\n_title_fmt = 'numpy {} precision floating point number'\n_MACHAR_PARAMS = {\n    ntypes.double: dict(\n        itype = ntypes.int64,\n        fmt = '%24.16e',\n        title = _title_fmt.format('double')),\n    ntypes.single: dict(\n        itype = ntypes.int32,\n        fmt = '%15.7e',\n        title = _title_fmt.format('single')),\n    ntypes.longdouble: dict(\n        itype = ntypes.longlong,\n        fmt = '%s',\n        title = _title_fmt.format('long double')),\n    ntypes.half: dict(\n        itype = ntypes.int16,\n        fmt = '%12.5e',\n        title = _title_fmt.format('half'))}\n\n# Key to identify the floating point type.  Key is result of\n#\n#    ftype = np.longdouble        # or float64, float32, etc.\n#    v = (ftype(-1.0) / ftype(10.0))\n#    v.view(v.dtype.newbyteorder('<')).tobytes()\n#\n# Uses division to work around deficiencies in strtold on some platforms.\n# See:\n# https://perl5.git.perl.org/perl.git/blob/3118d7d684b56cbeb702af874f4326683c45f045:/Configure\n\n_KNOWN_TYPES = {}\ndef _register_type(machar, bytepat):\n    _KNOWN_TYPES[bytepat] = machar\n\n\n_float_ma = {}\n\n\ndef _register_known_types():\n    # Known parameters for float16\n    # See docstring of MachAr class for description of parameters.\n    f16 = ntypes.float16\n    float16_ma = MachArLike(f16,\n                            machep=-10,\n                            negep=-11,\n                            minexp=-14,\n                            maxexp=16,\n                            it=10,\n                            iexp=5,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(f16(-10)),\n                            epsneg=exp2(f16(-11)),\n                            huge=f16(65504),\n                            tiny=f16(2 ** -14))\n    _register_type(float16_ma, b'f\\xae')\n    _float_ma[16] = float16_ma\n\n    # Known parameters for float32\n    f32 = ntypes.float32\n    float32_ma = MachArLike(f32,\n                            machep=-23,\n                            negep=-24,\n                            minexp=-126,\n                            maxexp=128,\n                            it=23,\n                            iexp=8,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(f32(-23)),\n                            epsneg=exp2(f32(-24)),\n                            huge=f32((1 - 2 ** -24) * 2**128),\n                            tiny=exp2(f32(-126)))\n    _register_type(float32_ma, b'\\xcd\\xcc\\xcc\\xbd')\n    _float_ma[32] = float32_ma\n\n    # Known parameters for float64\n    f64 = ntypes.float64\n    epsneg_f64 = 2.0 ** -53.0\n    tiny_f64 = 2.0 ** -1022.0\n    float64_ma = MachArLike(f64,\n                            machep=-52,\n                            negep=-53,\n                            minexp=-1022,\n                            maxexp=1024,\n                            it=52,\n                            iexp=11,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=2.0 ** -52.0,\n                            epsneg=epsneg_f64,\n                            huge=(1.0 - epsneg_f64) / tiny_f64 * f64(4),\n                            tiny=tiny_f64)\n    _register_type(float64_ma, b'\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf')\n    _float_ma[64] = float64_ma\n\n    # Known parameters for IEEE 754 128-bit binary float\n    ld = ntypes.longdouble\n    epsneg_f128 = exp2(ld(-113))\n    tiny_f128 = exp2(ld(-16382))\n    # Ignore runtime error when this is not f128\n    with numeric.errstate(all='ignore'):\n        huge_f128 = (ld(1) - epsneg_f128) / tiny_f128 * ld(4)\n    float128_ma = MachArLike(ld,\n                             machep=-112,\n                             negep=-113,\n                             minexp=-16382,\n                             maxexp=16384,\n                             it=112,\n                             iexp=15,\n                             ibeta=2,\n                             irnd=5,\n                             ngrd=0,\n                             eps=exp2(ld(-112)),\n                             epsneg=epsneg_f128,\n                             huge=huge_f128,\n                             tiny=tiny_f128)\n    # IEEE 754 128-bit binary float\n    _register_type(float128_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\xfb\\xbf')\n    _float_ma[128] = float128_ma\n\n    # Known parameters for float80 (Intel 80-bit extended precision)\n    epsneg_f80 = exp2(ld(-64))\n    tiny_f80 = exp2(ld(-16382))\n    # Ignore runtime error when this is not f80\n    with numeric.errstate(all='ignore'):\n        huge_f80 = (ld(1) - epsneg_f80) / tiny_f80 * ld(4)\n    float80_ma = MachArLike(ld,\n                            machep=-63,\n                            negep=-64,\n                            minexp=-16382,\n                            maxexp=16384,\n                            it=63,\n                            iexp=15,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(ld(-63)),\n                            epsneg=epsneg_f80,\n                            huge=huge_f80,\n                            tiny=tiny_f80)\n    # float80, first 10 bytes containing actual storage\n    _register_type(float80_ma, b'\\xcd\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xfb\\xbf')\n    _float_ma[80] = float80_ma\n\n    # Guessed / known parameters for double double; see:\n    # https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic\n    # These numbers have the same exponent range as float64, but extended\n    # number of digits in the significand.\n    huge_dd = nextafter(ld(inf), ld(0), dtype=ld)\n    # As the smallest_normal in double double is so hard to calculate we set\n    # it to NaN.\n    smallest_normal_dd = nan\n    # Leave the same value for the smallest subnormal as double\n    smallest_subnormal_dd = ld(nextafter(0., 1.))\n    float_dd_ma = MachArLike(ld,\n                             machep=-105,\n                             negep=-106,\n                             minexp=-1022,\n                             maxexp=1024,\n                             it=105,\n                             iexp=11,\n                             ibeta=2,\n                             irnd=5,\n                             ngrd=0,\n                             eps=exp2(ld(-105)),\n                             epsneg=exp2(ld(-106)),\n                             huge=huge_dd,\n                             tiny=smallest_normal_dd,\n                             smallest_subnormal=smallest_subnormal_dd)\n    # double double; low, high order (e.g. PPC 64)\n    _register_type(float_dd_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99Y<\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf')\n    # double double; high, low order (e.g. PPC 64 le)\n    _register_type(float_dd_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf\\x9a\\x99\\x99\\x99\\x99\\x99Y<')\n    _float_ma['dd'] = float_dd_ma\n\n\ndef _get_machar(ftype):\n    \"\"\" Get MachAr instance or MachAr-like instance\n\n    Get parameters for floating point type, by first trying signatures of\n    various known floating point types, then, if none match, attempting to\n    identify parameters by analysis.\n\n    Parameters\n    ----------\n    ftype : class\n        Numpy floating point type class (e.g. ``np.float64``)\n\n    Returns\n    -------\n    ma_like : instance of :class:`MachAr` or :class:`MachArLike`\n        Object giving floating point parameters for `ftype`.\n\n    Warns\n    -----\n    UserWarning\n        If the binary signature of the float type is not in the dictionary of\n        known float types.\n    \"\"\"\n    params = _MACHAR_PARAMS.get(ftype)\n    if params is None:\n        raise ValueError(repr(ftype))\n    # Detect known / suspected types\n    # ftype(-1.0) / ftype(10.0) is better than ftype('-0.1') because stold\n    # may be deficient\n    key = (ftype(-1.0) / ftype(10.))\n    key = key.view(key.dtype.newbyteorder(\"<\")).tobytes()\n    ma_like = None\n    if ftype == ntypes.longdouble:\n        # Could be 80 bit == 10 byte extended precision, where last bytes can\n        # be random garbage.\n        # Comparing first 10 bytes to pattern first to avoid branching on the\n        # random garbage.\n        ma_like = _KNOWN_TYPES.get(key[:10])\n    if ma_like is None:\n        # see if the full key is known.\n        ma_like = _KNOWN_TYPES.get(key)\n    if ma_like is None and len(key) == 16:\n        # machine limits could be f80 masquerading as np.float128,\n        # find all keys with length 16 and make new dict, but make the keys\n        # only 10 bytes long, the last bytes can be random garbage\n        _kt = {k[:10]: v for k, v in _KNOWN_TYPES.items() if len(k) == 16}\n        ma_like = _kt.get(key[:10])\n    if ma_like is not None:\n        return ma_like\n    # Fall back to parameter discovery\n    warnings.warn(\n        f'Signature {key} for {ftype} does not match any known type: '\n        'falling back to type probe function.\\n'\n        'This warnings indicates broken support for the dtype!',\n        UserWarning, stacklevel=2)\n    return _discovered_machar(ftype)\n\n\ndef _discovered_machar(ftype):\n    \"\"\" Create MachAr instance with found information on float types\n\n    TODO: MachAr should be retired completely ideally.  We currently only\n          ever use it system with broken longdouble (valgrind, WSL).\n    \"\"\"\n    params = _MACHAR_PARAMS[ftype]\n    return MachAr(lambda v: array([v], ftype),\n                  lambda v: _fr0(v.astype(params['itype']))[0],\n                  lambda v: array(_fr0(v)[0], ftype),\n                  lambda v: params['fmt'] % array(_fr0(v)[0], ftype),\n                  params['title'])\n\n\n@set_module('numpy')\nclass finfo:\n    \"\"\"\n    finfo(dtype)\n\n    Machine limits for floating point types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    dtype : dtype\n        Returns the dtype for which `finfo` returns information. For complex\n        input, the returned dtype is the associated ``float*`` dtype for its\n        real and complex components.\n    eps : float\n        The difference between 1.0 and the next smallest representable float\n        larger than 1.0. For example, for 64-bit binary floats in the IEEE-754\n        standard, ``eps = 2**-52``, approximately 2.22e-16.\n    epsneg : float\n        The difference between 1.0 and the next smallest representable float\n        less than 1.0. For example, for 64-bit binary floats in the IEEE-754\n        standard, ``epsneg = 2**-53``, approximately 1.11e-16.\n    iexp : int\n        The number of bits in the exponent portion of the floating point\n        representation.\n    machep : int\n        The exponent that yields `eps`.\n    max : floating point number of the appropriate type\n        The largest representable number.\n    maxexp : int\n        The smallest positive power of the base (2) that causes overflow.\n    min : floating point number of the appropriate type\n        The smallest representable number, typically ``-max``.\n    minexp : int\n        The most negative power of the base (2) consistent with there\n        being no leading 0's in the mantissa.\n    negep : int\n        The exponent that yields `epsneg`.\n    nexp : int\n        The number of bits in the exponent including its sign and bias.\n    nmant : int\n        The number of bits in the mantissa.\n    precision : int\n        The approximate number of decimal digits to which this kind of\n        float is precise.\n    resolution : floating point number of the appropriate type\n        The approximate decimal resolution of this type, i.e.,\n        ``10**-precision``.\n    tiny : float\n        An alias for `smallest_normal`, kept for backwards compatibility.\n    smallest_normal : float\n        The smallest positive floating point number with 1 as leading bit in\n        the mantissa following IEEE-754 (see Notes).\n    smallest_subnormal : float\n        The smallest positive floating point number with 0 as leading bit in\n        the mantissa following IEEE-754.\n\n    Parameters\n    ----------\n    dtype : float, dtype, or instance\n        Kind of floating point or complex floating point\n        data-type about which to get information.\n\n    See Also\n    --------\n    iinfo : The equivalent for integer data types.\n    spacing : The distance between a value and the nearest adjacent number\n    nextafter : The next floating point value after x1 towards x2\n\n    Notes\n    -----\n    For developers of NumPy: do not instantiate this at the module level.\n    The initial calculation of these parameters is expensive and negatively\n    impacts import times.  These objects are cached, so calling ``finfo()``\n    repeatedly inside your functions is not a problem.\n\n    Note that ``smallest_normal`` is not actually the smallest positive\n    representable value in a NumPy floating point type. As in the IEEE-754\n    standard [1]_, NumPy floating point types make use of subnormal numbers to\n    fill the gap between 0 and ``smallest_normal``. However, subnormal numbers\n    may have significantly reduced precision [2]_.\n\n    This function can also be used for complex data types as well. If used,\n    the output will be the same as the corresponding real float type\n    (e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).\n    However, the output is true for the real and imaginary components.\n\n    References\n    ----------\n    .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,\n           pp.1-70, 2008, https://doi.org/10.1109/IEEESTD.2008.4610935\n    .. [2] Wikipedia, \"Denormal Numbers\",\n           https://en.wikipedia.org/wiki/Denormal_number\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.finfo(np.float64).dtype\n    dtype('float64')\n    >>> np.finfo(np.complex64).dtype\n    dtype('float32')\n\n    \"\"\"\n\n    _finfo_cache = {}\n\n    def __new__(cls, dtype):\n        try:\n            obj = cls._finfo_cache.get(dtype)  # most common path\n            if obj is not None:\n                return obj\n        except TypeError:\n            pass\n\n        if dtype is None:\n            # Deprecated in NumPy 1.25, 2023-01-16\n            warnings.warn(\n                \"finfo() dtype cannot be None. This behavior will \"\n                \"raise an error in the future. (Deprecated in NumPy 1.25)\",\n                DeprecationWarning,\n                stacklevel=2\n            )\n\n        try:\n            dtype = numeric.dtype(dtype)\n        except TypeError:\n            # In case a float instance was given\n            dtype = numeric.dtype(type(dtype))\n\n        obj = cls._finfo_cache.get(dtype)\n        if obj is not None:\n            return obj\n        dtypes = [dtype]\n        newdtype = ntypes.obj2sctype(dtype)\n        if newdtype is not dtype:\n            dtypes.append(newdtype)\n            dtype = newdtype\n        if not issubclass(dtype, numeric.inexact):\n            raise ValueError(\"data type %r not inexact\" % (dtype))\n        obj = cls._finfo_cache.get(dtype)\n        if obj is not None:\n            return obj\n        if not issubclass(dtype, numeric.floating):\n            newdtype = _convert_to_float[dtype]\n            if newdtype is not dtype:\n                # dtype changed, for example from complex128 to float64\n                dtypes.append(newdtype)\n                dtype = newdtype\n\n                obj = cls._finfo_cache.get(dtype, None)\n                if obj is not None:\n                    # the original dtype was not in the cache, but the new\n                    # dtype is in the cache. we add the original dtypes to\n                    # the cache and return the result\n                    for dt in dtypes:\n                        cls._finfo_cache[dt] = obj\n                    return obj\n        obj = object.__new__(cls)._init(dtype)\n        for dt in dtypes:\n            cls._finfo_cache[dt] = obj\n        return obj\n\n    def _init(self, dtype):\n        self.dtype = numeric.dtype(dtype)\n        machar = _get_machar(dtype)\n\n        for word in ['precision', 'iexp',\n                     'maxexp', 'minexp', 'negep',\n                     'machep']:\n            setattr(self, word, getattr(machar, word))\n        for word in ['resolution', 'epsneg', 'smallest_subnormal']:\n            setattr(self, word, getattr(machar, word).flat[0])\n        self.bits = self.dtype.itemsize * 8\n        self.max = machar.huge.flat[0]\n        self.min = -self.max\n        self.eps = machar.eps.flat[0]\n        self.nexp = machar.iexp\n        self.nmant = machar.it\n        self._machar = machar\n        self._str_tiny = machar._str_xmin.strip()\n        self._str_max = machar._str_xmax.strip()\n        self._str_epsneg = machar._str_epsneg.strip()\n        self._str_eps = machar._str_eps.strip()\n        self._str_resolution = machar._str_resolution.strip()\n        self._str_smallest_normal = machar._str_smallest_normal.strip()\n        self._str_smallest_subnormal = machar._str_smallest_subnormal.strip()\n        return self\n\n    def __str__(self):\n        fmt = (\n            'Machine parameters for %(dtype)s\\n'\n            '---------------------------------------------------------------\\n'\n            'precision = %(precision)3s   resolution = %(_str_resolution)s\\n'\n            'machep = %(machep)6s   eps =        %(_str_eps)s\\n'\n            'negep =  %(negep)6s   epsneg =     %(_str_epsneg)s\\n'\n            'minexp = %(minexp)6s   tiny =       %(_str_tiny)s\\n'\n            'maxexp = %(maxexp)6s   max =        %(_str_max)s\\n'\n            'nexp =   %(nexp)6s   min =        -max\\n'\n            'smallest_normal = %(_str_smallest_normal)s   '\n            'smallest_subnormal = %(_str_smallest_subnormal)s\\n'\n            '---------------------------------------------------------------\\n'\n            )\n        return fmt % self.__dict__\n\n    def __repr__(self):\n        c = self.__class__.__name__\n        d = self.__dict__.copy()\n        d['klass'] = c\n        return ((\"%(klass)s(resolution=%(resolution)s, min=-%(_str_max)s,\"\n                 \" max=%(_str_max)s, dtype=%(dtype)s)\") % d)\n\n    @property\n    def smallest_normal(self):\n        \"\"\"Return the value for the smallest normal.\n\n        Returns\n        -------\n        smallest_normal : float\n            Value for the smallest normal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest normal is requested for\n            double-double.\n        \"\"\"\n        # This check is necessary because the value for smallest_normal is\n        # platform dependent for longdouble types.\n        if isnan(self._machar.smallest_normal.flat[0]):\n            warnings.warn(\n                'The value of smallest normal is undefined for double double',\n                UserWarning, stacklevel=2)\n        return self._machar.smallest_normal.flat[0]\n\n    @property\n    def tiny(self):\n        \"\"\"Return the value for tiny, alias of smallest_normal.\n\n        Returns\n        -------\n        tiny : float\n            Value for the smallest normal, alias of smallest_normal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest normal is requested for\n            double-double.\n        \"\"\"\n        return self.smallest_normal\n\n\n@set_module('numpy')\nclass iinfo:\n    \"\"\"\n    iinfo(type)\n\n    Machine limits for integer types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    dtype : dtype\n        Returns the dtype for which `iinfo` returns information.\n    min : int\n        The smallest integer expressible by the type.\n    max : int\n        The largest integer expressible by the type.\n\n    Parameters\n    ----------\n    int_type : integer type, dtype, or instance\n        The kind of integer data type to get information about.\n\n    See Also\n    --------\n    finfo : The equivalent for floating point data types.\n\n    Examples\n    --------\n    With types:\n\n    >>> import numpy as np\n    >>> ii16 = np.iinfo(np.int16)\n    >>> ii16.min\n    -32768\n    >>> ii16.max\n    32767\n    >>> ii32 = np.iinfo(np.int32)\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    With instances:\n\n    >>> ii32 = np.iinfo(np.int32(10))\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    \"\"\"\n\n    _min_vals = {}\n    _max_vals = {}\n\n    def __init__(self, int_type):\n        try:\n            self.dtype = numeric.dtype(int_type)\n        except TypeError:\n            self.dtype = numeric.dtype(type(int_type))\n        self.kind = self.dtype.kind\n        self.bits = self.dtype.itemsize * 8\n        self.key = \"%s%d\" % (self.kind, self.bits)\n        if self.kind not in 'iu':\n            raise ValueError(\"Invalid integer data type %r.\" % (self.kind,))\n\n    @property\n    def min(self):\n        \"\"\"Minimum value of given dtype.\"\"\"\n        if self.kind == 'u':\n            return 0\n        else:\n            try:\n                val = iinfo._min_vals[self.key]\n            except KeyError:\n                val = int(-(1 << (self.bits-1)))\n                iinfo._min_vals[self.key] = val\n            return val\n\n    @property\n    def max(self):\n        \"\"\"Maximum value of given dtype.\"\"\"\n        try:\n            val = iinfo._max_vals[self.key]\n        except KeyError:\n            if self.kind == 'u':\n                val = int((1 << self.bits) - 1)\n            else:\n                val = int((1 << (self.bits-1)) - 1)\n            iinfo._max_vals[self.key] = val\n        return val\n\n    def __str__(self):\n        \"\"\"String representation.\"\"\"\n        fmt = (\n            'Machine parameters for %(dtype)s\\n'\n            '---------------------------------------------------------------\\n'\n            'min = %(min)s\\n'\n            'max = %(max)s\\n'\n            '---------------------------------------------------------------\\n'\n            )\n        return fmt % {'dtype': self.dtype, 'min': self.min, 'max': self.max}\n\n    def __repr__(self):\n        return \"%s(min=%s, max=%s, dtype=%s)\" % (self.__class__.__name__,\n                                    self.min, self.max, self.dtype)\n", 742], "C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py": ["'''\n# -----------------------------------------------------------------------------\n# Author: MIRKO THULKE \n# Copyright (c) 2025, MIRKO THULKE\n# All rights reserved.\n#\n# Date: 2025, VERSAILLES, FRANCE\n#\n# MIT License\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING\n# FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n#\n# -----------------------------------------------------------------------------\n'''\n\n\n'''\nimportant commands : \ncmd> python -m pip install --upgrade pip\ncmd> pip install pyaudio\ncmd> pip install numpy\ncmd> where python\ncmd> python --version\ncmd> python3 --version\ncmd> pip install --upgrade -r requirements.txt\ncmd> pip freeze > requirements.txt\ncmd> pip list --outdated\n'''\nimport wx # click button GUI\nimport pyaudio\nfrom endolith_weighting_filters import A_weight\nimport numpy as np\nimport wave\nimport matplotlib.pyplot as plt\nimport configparser\nimport multiprocessing\nimport threading\nimport subprocess\nimport os\nimport psutil\nimport time\nimport datetime\nfrom viztracer import VizTracer # visual thread debugging\n\n\n'''\nDEBUG == 0 # Default \nDEBUG == 1 # tracer logs for runtime analysis\n'''\nDEBUG   = 1\n\n# visual thead debugging\nif DEBUG == 1:\n    tracer = VizTracer()  # Start VizTracer\n    tracer.start()\n\n# open results in CMD : \"vizviewer Python_AudioLogger_JSON_LogFile.json\"\n# ZOOM into timeline by pressing CTLR + Mouse wheel\n# and check for status update and display update tasks. \n# Should be called every 20ms aprox with chunk size 1024 and 48kHz\n\n\n\n# Behringer UMC control panel settings :\n# ASIO buffer size 512   \n# Sampling rate 48kHz\n# Format : 4 Channel 16 bits  \n\n\n# Set parameters for audio input\nFORMAT = pyaudio.paInt16  # Format for the audio\nCHANNELS = 1  # Mono audio (1 channel)\nRATE = 48000  # Sampling rate (samples per second)\nCHUNK = 1024  # Number of frames per buffer (size of each audio chunk)\nDEVICE_INDEX = None  # Set to the correct device index if you have multiple devices\nCHUNK_SEC = CHUNK/RATE # Chunk duration in seconds\nWAVE_DT_SEC = 1.5 # Delta time duration before and after noise event, that will be added to wave output\nCHUNK_DNUM = int(WAVE_DT_SEC/CHUNK_SEC) # number of chunks to be added before and after noise event, that will be added to wave output\n\nREFERENCE_PRESSURE = 20e-6  # in Pa. Reference pressure in Pa (20 \u00b5Pa)\nMIC_SENSITIVITY = 15 # 15mV Sensitivity (mV / Pa) of the Behringer ECM8000 (for better understanding only)\nMIC_SPL_MAX_DB = 120   # in dB. virtual SPL max. value that the microphone can measure\nMIC_PA_MAX = 20     # in Pa. Maximum Number of Pa that the mcicrophone can measure (120dB converted to Pascal)\nMIC_MAX_MVOLT = MIC_PA_MAX * MIC_SENSITIVITY # maximum mV that the microphone can measure (corresponds to 120dB, 20Pa)\n\nPRE_AMP_GAIN_DB = 45  # in dB. Assupmption that the Gain poti on the UMC is on 3h00. Virtuel Pre-Amp Gain Factor for better understanding only\nPRE_AMP_GAIN_LIN = np.power(10, (PRE_AMP_GAIN_DB / 20) ) # Converted to linear scale.\n\nCALIB_ITERATION_LENGTH = 50 # 50 chunks are checked during calibration\nMAX_INT16 = np.iinfo(np.int16).max\n\n# dB(A) Threshold for indoor noise\n# NIGHT : 22h00 - 06h00\nSPL_MAX_DAY_DBA     = 50\nSPL_MAX_NIGH_DBA    = 35\n\n\n\n# Set parameters for audio outut\nRECORD_SECONDS = 4        # Duration of the recording in seconds\nOUTPUT_FILENAME = \"output.wav\"  # Output WAV file\nOUTPUT_NOISE_FILENAME = \"Bruit\" #Output filename prefix for logged noise events\nOUTPUT_FILE_DIRECTORY = \"audio_logfiles\"\n\n\n\n# Global Variables NOT in shared memory #######################################\n\n# To persist Settings -> Initialise a config object.\nconfig                  = None\n\n# Global variables to Initialize PyAudio in the main Init class\np                       = None\n# Open stream to read audio from the microphone\nstream                  = None\n\n\n\n# Global Funtion definitions ##########################################\ndef get_commit_version():\n    try:\n        # Run 'git rev-parse HEAD' to get the commit hash\n        commit_hash = subprocess.check_output(['git', 'rev-parse', 'HEAD']).strip().decode('utf-8')\n        return commit_hash\n    except subprocess.CalledProcessError:\n        return \"Not a git repository or error retrieving commit.\"\n \ndef func_check_devices(data_dictionary):\n    global p\n    i=0\n    \n    # List available devices\n    print(\"Available devices:\")\n    for i in range(p.get_device_count()):\n            device_info = p.get_device_info_by_index(i)\n            print(f\"Device {i}: {device_info['name']}\")\n\n\ndef func_on_button_setDevices_click(frame, data_dictionary):\n    global p\n\n    \n    data_dictionary['_device_index'] = 0\n    min_range = 0\n    max_range = 100\n\n    user_value = int(frame.text_ctrl.GetValue())\n    \n    # Check if the input is within the valid range\n    # obtain user text input for device selection\n    if min_range <= user_value  <= max_range:\n        data_dictionary['_device_index'] = user_value\n        wx.MessageBox(f\"Device {data_dictionary['_device_index']}: {p.get_device_info_by_index(data_dictionary['_device_index'])}\",\"Info\", wx.OK | wx.ICON_INFORMATION)\n    else :\n        wx.MessageBox(f\"Error: The number must be between {min_range} and {max_range}.\",\"Info\", wx.OK | wx.ICON_INFORMATION)\n\n\ndef apply_a_weighting(data_dictionary):\n    \"\"\"Apply the A-weighting filter to the signal\"\"\"\n\n    \n    # convert to float for filtering\n    float_array  = data_dictionary['audio_data'].astype(np.float32)\n    \n\n    # Apply A-weighting\n    float_array_filt = A_weight(float_array, RATE)\n    \n    #convert back to integer for further processing\n    int_array   = float_array_filt.astype(np.int16)\n    \n    #print(f'audio_data: {audio_data}')\n    #print(f'float_array: {float_array}')\n    #print(f'float_array_filt: {float_array_filt}') \n    #print(f'int_array: {int_array}')   \n    \n    return ( int_array )\n\n\ndef func_calc_SPL(data_dictionary):\n \n\n    # reset output arrays :\n    data_dictionary['a_weighted_signal']                        = np.zeros(data_dictionary['a_weighted_signal'].shape)\n    data_dictionary['audio_data_pcm_abs']                       = np.zeros(data_dictionary['audio_data_pcm_abs'].shape)\n    data_dictionary['audio_data_mV']                            = np.zeros(data_dictionary['audio_data_mV'].shape)\n    data_dictionary['audio_data_pressurePa']                    = np.zeros(data_dictionary['audio_data_pressurePa'].shape)\n    data_dictionary['audio_data_pressurePa_square']             = np.zeros(data_dictionary['audio_data_pressurePa_square'].shape)\n    # reset output variables :\n    data_dictionary['audio_data_pressurePa_squareMean']         = 0\n    data_dictionary['audio_data_pressurePa_rms']                = 0\n    data_dictionary['audio_data_pressurePa_rms_calib']          = 0\n    data_dictionary['audio_data_pressurePa_spl']                = 0\n\n    \n    # Apply A-weighting to the signal\n    # A-weighting does not have an impcat on microphone calibration at 1000Hz, because weighting is 1 at 1000Hz. \n    # Convert to float for A-weighting processing ( scipy.signal requires type 'signal', thus float32)\n    data_dictionary['a_weighted_signal'] = apply_a_weighting(data_dictionary)\n\n    # Check  the maximum absolute value\n    audio_data_max_pcm_value_new = np.max(np.abs(data_dictionary['a_weighted_signal']))\n    \n    # save if highest of all chunks\n    data_dictionary['audio_data_max_pcm_value'] = max(data_dictionary['audio_data_max_pcm_value'], audio_data_max_pcm_value_new)\n    # Example: Process the audio (e.g., calculate RMS for volume level) \n        \n    # Absolute values first      \n    data_dictionary['audio_data_pcm_abs'] = np.abs(data_dictionary['a_weighted_signal'])\n    \n    # Convert to mV using the Sensitivy value of the microphone/ Assuming that the microphone uses the full int16 signale range . \n    # Applying a preamp gain factor (only for better understanding)\n    data_dictionary['audio_data_mV'] = data_dictionary['audio_data_pcm_abs'] / PRE_AMP_GAIN_LIN\n    #print(f\"data_dictionary['audio_data_mV']: {data_dictionary['audio_data_mV']}\")\n    \n    \n    # Converting mV to Pa using the Sensitivy value\n    data_dictionary['audio_data_pressurePa'] = data_dictionary['audio_data_mV'] / MIC_SENSITIVITY\n    #print(f\"data_dictionary['audio_data_pressurePa']: {data_dictionary['audio_data_pressurePa']}\")\n    \n    # Convert to RMS - Root mean square\n    data_dictionary['audio_data_pressurePa_square'] = data_dictionary['audio_data_pressurePa'] ** 2    \n    data_dictionary['audio_data_pressurePa_squareMean'] = np.mean(data_dictionary['audio_data_pressurePa_square'])         \n    if data_dictionary['audio_data_pressurePa_squareMean']  > 0 :\n        data_dictionary['audio_data_pressurePa_rms'] = np.sqrt(data_dictionary['audio_data_pressurePa_squareMean'])\n    else :\n        data_dictionary['audio_data_pressurePa_rms'] = 0           \n   \n    data_dictionary['audio_data_pressurePa_rms_calib'] =data_dictionary['audio_data_pressurePa_rms'] * data_dictionary['system_calibration_factor_94db']\n    \n    # convert RMS to SPL (explained below)\n    # Reference pressure in air = 20 \u00b5Pa\n    if data_dictionary['audio_data_pressurePa_rms_calib'] > 0:\n        data_dictionary['audio_data_pressurePa_spl'] = 20 * np.log10(data_dictionary['audio_data_pressurePa_rms_calib'] / REFERENCE_PRESSURE)    \n    else :\n        data_dictionary['audio_data_pressurePa_spl'] = 0     \n    #print(f\"data_dictionary['audio_data_pressurePa_spl']: {data_dictionary['audio_data_pressurePa_spl']}\")      \n\n\ndef func_process_audio_input(data_dictionary, recording_status_queue, recording_dba_queue):\n\n \n    #whole process will run in high priority mode\n    p_func_process_audio_input = psutil.Process(os.getpid())\n    p_func_process_audio_input.nice(psutil.REALTIME_PRIORITY_CLASS)  \n\n    # Initialize PyAudio\n    p_loc                                  = pyaudio.PyAudio()\n    # Open stream to read audio from the microphone\n    stream_loc = p_loc.open(format=FORMAT,\n                    channels=CHANNELS,\n                    rate=RATE,\n                    input=True,\n                    input_device_index = data_dictionary['_device_index'] ,\n                    frames_per_buffer=CHUNK)\n    print(\"Audio stream opened [recording]\\n\")\n    \n    print(\"recording_process started 1/2\\n\")\n    \n    \n    #reset audio input related lists and counters\n    data_dictionary['chunk_index_i']            = 0    # counter of processed chunks\n    data_dictionary['chunk_noise_list_index']   = np.array([], dtype=int)\n    data_dictionary['chunk_noise_list_spl']     = np.array([])\n    data_dictionary['frames']                   = np.array([])\n    \n    print(f\"is_recording: {data_dictionary['is_recording']}\\n\")\n    while data_dictionary['is_recording']==True :\n        # Read a chunk of audio data\n        data = stream_loc.read(CHUNK)\n      \n        # Convert the audio data to a numpy array\n        data_dictionary['audio_data']   = np.frombuffer(data, dtype=np.int16)\n        \n        #for output wave file creation, add to a list\n        data_dictionary['frames']       =  np.append(data_dictionary['frames'], data)\n        \n        # Calculate PCM to SPl ! \n        func_calc_SPL(data_dictionary)\n        \n        #chunk counter\n        data_dictionary['chunk_index_i'] = data_dictionary['chunk_index_i']+1\n\n        recording_status_queue.put(f\"Recording running. Number of chunks processed: {data_dictionary['chunk_index_i']}\\n\")  # Send message to main process\n        print(f\"chunk_index : {data_dictionary['chunk_index_i']}\\n\")\n        \n        # Print dbA on GUI\n        recording_dba_queue.put(f\"{round(data_dictionary['audio_data_pressurePa_spl'], 2)} [dbA]\\n\")  # Send message to main process\n\n        \n        if data_dictionary['audio_data_pressurePa_spl'] > SPL_MAX_DAY_DBA :\n            data_dictionary['chunk_noise_list_index']   = np.append(data_dictionary['chunk_noise_list_index'], data_dictionary['chunk_index_i'])\n            data_dictionary['chunk_noise_list_spl']     = np.append(data_dictionary['chunk_noise_list_spl'], data_dictionary['audio_data_pressurePa_spl'])\n            print(f\"data_dictionary['chunk_noise_list_index'] : {data_dictionary['chunk_noise_list_index']}\\n\")            \n            print(f\"data_dictionary['chunk_noise_list_spl'] : {data_dictionary['chunk_noise_list_spl']}\\n\")\n            \n\n    print(\"Recording thread stopped.\\n\")\n    recording_status_queue.put(\"Recording stopped ...\\n\")  # Send message to main process\n\n\n    p_loc.terminate()\n    \ndef func_run_calibration(data_dictionary):\n    global stream\n\n  \n\n    calib_arr = np.array([])\n    i= 0 \n    data_dictionary['audio_data_max_pcm_value']  = 0\n    \n    \n    while i<CALIB_ITERATION_LENGTH :\n        \n        i=i+1\n    \n        # Read a chunk of audio data\n        data = stream.read(CHUNK)\n      \n        # Convert the audio data to a numpy array\n        data_dictionary['audio_data']   = np.frombuffer(data, dtype=np.int16)\n        \n        #for output wave file creation, add to a list\n        data_dictionary['frames']       = np.append(data_dictionary['frames'], data)\n        \n        # Calculate PCM to SPl ! \n        func_calc_SPL(data_dictionary)\n        \n        \n        if data_dictionary['audio_data_pressurePa_rms'] > 0 : \n            \n            # 94 dB != 20 log (rms /p_0) :\n            system_calibration_factor_94db_new = (REFERENCE_PRESSURE * (np.power(10, 94/20))) /data_dictionary['audio_data_pressurePa_rms']\n            print(f\"system_calibration_factor_94db_new: {system_calibration_factor_94db_new}\\n\") \n            \n            # Store new value in array \n            calib_arr   =   np.append(calib_arr, system_calibration_factor_94db_new)\n            \n        else :\n            print(\"SPL or Pa equal to zero in this chunk. Check sound input ! \\n\") \n        \n         \n    # Check if the input PCM coded signal at 94dB calibration db (which is quite loud) is using the full range of the sint16 signal range\n    # Check maximum across all chunks, see while loop\n    print(f\"Maximum PCM  amplitude: {data_dictionary['audio_data_max_pcm_value']}\\n\")\n    if data_dictionary['audio_data_max_pcm_value'] > int(MAX_INT16*0.95) :\n        wx.MessageBox(f\"Maximum PCM 16bit amplitude: {data_dictionary['audio_data_max_pcm_value']}/{MAX_INT16}. Upper threshold: {int(MAX_INT16*0.95)} . Reduce GAIN on PreAmp !\\n\",\"Info\", wx.OK | wx.ICON_INFORMATION)       \n    elif data_dictionary['audio_data_max_pcm_value'] < int(MAX_INT16*0.8) :\n        wx.MessageBox(f\"Maximum PCM 16bit amplitude: {data_dictionary['audio_data_max_pcm_value']}/{MAX_INT16}. lower threshold: {int(MAX_INT16*0.8)}  . Increase GAIN on PreAmp !\\n\",\"Info\", wx.OK | wx.ICON_INFORMATION)      \n    else :\n        wx.MessageBox(f\"Maximum PCM 16bit amplitude: {data_dictionary['audio_data_max_pcm_value']}/{MAX_INT16}. PreAmp GAIN OK !\\n\",\"Info\", wx.OK | wx.ICON_INFORMATION)\n    \n    # calculate average calibration factor across all chunks, see while loop\n    calib_average = sum(calib_arr) / len(calib_arr)\n    \n    #store average as new calibration factor\n    data_dictionary['system_calibration_factor_94db'] = calib_average\n    print(f\"Averaged data_dictionary['system_calibration_factor_94db']: {data_dictionary['system_calibration_factor_94db']}\\n\") \n       \n\n\n\ndef func_check_calibration(data_dictionary):\n    global stream\n\n\n    spl_error_arr           = np.array([])\n    spl_error_arr_square    = np.array([])\n    i = 0\n   \n    while i<CALIB_ITERATION_LENGTH :       \n        i = i+1\n        # Read a chunk of audio data\n        data = stream.read(CHUNK)\n      \n        # Convert the audio data to a numpy array\n        data_dictionary['audio_data']   = np.frombuffer(data, dtype=np.int16)\n        \n        #for output wave file creation, add to a list\n        data_dictionary['frames']       = np.append(data_dictionary['frames'], data)\n        \n        # Calculate PCM to SPl ! \n        func_calc_SPL(data_dictionary)\n        \n        \n        if data_dictionary['audio_data_pressurePa_spl'] > 0 : \n            \n            # calculate error in dB SPL\n            spl_error = 94 - data_dictionary['audio_data_pressurePa_spl']\n            print(f\"spl_error: {spl_error}\\n\")\n            \n            spl_error_square = np.power(spl_error, 2)\n                                                \n            # Store new value in array \n            spl_error_arr_square =  np.append(spl_error_arr_square, spl_error_square)\n            spl_error_arr        =  np.append(spl_error_arr, spl_error)\n            \n        else :\n            print(\"SPL or Pa equal to zero in this chunk. Check sound input !\\n \") \n\n                          \n    # calculate root mean square error \n    spl_error_average = np.sqrt(np.average(spl_error_square ))\n    print(f\"spl_error_average: {spl_error_average}\\n\")\n\n       \n\ndef func_on_button_start_click(frame, data_dictionary):\n\n    # Enable / Disable buttons\n    frame.button_start.Disable()\n    frame.button_stop.Enable()\n    \n    # Start recording process\n    wx.CallAfter(frame.update_status,  \"Start button pressed...\\n\")\n    print(f\"data_dictionary['is_recording']: {data_dictionary['is_recording']}\\n\")\n    if not data_dictionary['is_recording']:\n        data_dictionary['is_recording'] = True\n        print(f\"data_dictionary['is_recording']: {data_dictionary['is_recording']}\\n\")\n        # Create a separate processto run the audio processing task\n        # The processes are required to decouple the input stream reading from the GUI app \n        \n        print(\"recording process will be created now.\\n\")\n        if frame.recording_process is None or not frame.recording_process.is_alive():\n            try:\n                print(\"Creating and starting recording process...\\n\")\n\n                frame.recording_process         = multiprocessing.Process(target=func_process_audio_input, args=(data_dictionary,frame.recording_status_queue,frame.recording_dba_queue,))\n                print(\"recording process created\\n\")\n            \n                # Argument : frame. Required to create a process from inside the GUI that serves as longrunning\n                # background task. And must refresh the GUI (frame instance) from inside the backround task via AppendText\n       \n                frame.recording_process.start()\n                print(\"recording process started\\n\")\n            \n                # Update the status text after the task is complete (safely in the main process)  \n                wx.CallAfter(frame.update_status,  \"recording process started 2/2\\n\")\n            \n            except Exception as e:\n                print(f\"Error starting recording process : {e}\\n\")\n            \n        else:\n            wx.CallAfter(frame.update_status,  \"recording process is already running 1.\\n\")\n            print(\"recording process is already running 1.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"recording process is already running 2.\\n\")\n        print(\"recording process is already running 2.\\n\")\n\n    print(f\"logging process will be started: {data_dictionary['is_logging']}\\n\")   \n    # Start logging thread\n    if not data_dictionary['is_logging']:\n        data_dictionary['is_logging'] = True\n        print(f\"data_dictionary['is_logging']: {data_dictionary['is_logging']}\\n\")\n        # Create a separate thread to run the process\n        # The thread is required to decouple the input stream reading from the GUI app \n\n        if frame.logging_process is None or not frame.logging_process.is_alive():\n            print(\"logging process will be created now.\\n\")\n            \n            # Argument : frame. Required to create a process from inside the GUI that serves as longrunning\n            # background task. And must refresh the GUI (frame instance) from inside the backround task via callAfter\n           \n            frame.logging_process = multiprocessing.Process(target=func_saveWave_on_noise_event, args=(data_dictionary,frame.logging_status_queue,))\n            print(\"logging process created\\n\")\n \n            frame.logging_process.start()\n            print(\"logging process started 2/2\\n\")\n            \n            # Update the status text after the task is complete (safely in the main process)\n            wx.CallAfter(frame.update_status,  \"logging process started 2/2\\n\")\n        else:\n            wx.CallAfter(frame.update_status,  \"logging process is already running.\\n\")\n            print(\"logging process is already running 1.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"logging process is already running.\\n\")\n        print(\"logging Thread is already running 2.\\n\")\n\n\ndef func_on_button_stop_click(frame, data_dictionary):\n\n    \n    # Enable / Disable buttons\n    frame.button_start.Enable()\n    frame.button_stop.Disable()\n    \n    print(f\"data_dictionary['is_recording']: {data_dictionary['is_recording']}\\n\")\n    data_dictionary['is_recording'] = False\n    print(f\"data_dictionary['is_recording']: {data_dictionary['is_recording']}\\n\")\n    \n    print(f\"data_dictionary['is_logging']: {data_dictionary['is_logging']}\\n\")\n    data_dictionary['is_logging'] = False\n    print(f\"data_dictionary['is_logging']: {data_dictionary['is_logging']}\\n\")\n    \n    if frame.recording_process is not None and frame.recording_process.is_alive():\n        frame.recording_process.join()  # Wait for the process to finish gracefully\n        wx.CallAfter(frame.update_status,  \"Recording process stopped.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"No Recording process is running.\\n\")\n    \n    if frame.logging_process is not None and frame.logging_process.is_alive():\n        frame.logging_process.join()  # Wait for the process to finish gracefully\n        wx.CallAfter(frame.update_status,  \"logging process stopped.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"No logging process is running.\\n\")\n   \n\ndef func_on_button_runCalib_click(frame, data_dictionary):\n    \n    # Create a separate thread to run the process\n    # The thread is required to decouple the input stream reading from the GUI app \n    frame.runCalib_thread   =threading.Thread(target=func_run_calibration, args=(data_dictionary,))\n    frame.runCalib_thread.daemon = True\n    frame.runCalib_thread.start()\n\n       \n       \ndef func_on_button_checkCalib_click(frame, data_dictionary):\n    \n    # Create a separate thread to run the process\n    # The thread is required to decouple the input stream reading from the GUI app \n    frame.checkCalib_thread  =threading.Thread(target=func_check_calibration, args=(data_dictionary,))\n    frame.checkCalib_thread.daemon = True\n    frame.checkCalib_thread.start()\n\n\ndef func_on_button_exit_click(frame, data_dictionary):\n\n    # Close the parent application and the GUI event loop (-> indicated by self)\n    frame.Close()\n\n\n\ndef func_saveWave_on_noise_event(data_dictionary, recording_status_queue):\n\n\n    max_spl_in_chunk            = 0\n    max_spl_index_in_chunk      = 0\n    max_spl_chunk_index         = 0\n    start_chunk                 = 0\n    stop_chunk                  = 0\n    \n    noise_frames                = np.array([])\n  \n    #whole process will run in high priority mode, but lower than the Audio processing task\n    p_func_saveWave_on_noise_event = psutil.Process(os.getpid())\n    p_func_saveWave_on_noise_event.nice(psutil.HIGH_PRIORITY_CLASS)  \n  \n    print(\"logging process started 1/2\\n\")\n    \n\n    #Start with offset of wave output length\n    time.sleep(WAVE_DT_SEC)\n    \n    while data_dictionary['is_logging']:  \n        \n             \n        # check if events are detected and stored in the list\n        if data_dictionary['chunk_noise_list_index'] is not None and data_dictionary['chunk_noise_list_index'].size > 0 :\n            print(\"\\nNew Recording event: \\n\")\n            \n            #identify max spl value and repsective chunk number \n            max_spl_in_chunk = np.max(data_dictionary['chunk_noise_list_spl'])\n            max_spl_index_in_chunk = np.where(data_dictionary['chunk_noise_list_spl'] == max_spl_in_chunk)[0][0]\n \n            #index of the chunk with maximum spl \n            max_spl_chunk_index = data_dictionary['chunk_noise_list_index'][max_spl_index_in_chunk]\n        \n            #extract the relevant noise frames + some delta\n            start_chunk = max(int(max_spl_chunk_index-CHUNK_DNUM), 0)\n            stop_chunk = int(max_spl_chunk_index+CHUNK_DNUM)\n\n            \n            # Wait for minimum time CHUNK_DNUM before saveing to add delta to the wave. \n            while data_dictionary['chunk_index_i'] < stop_chunk :\n                pass  # This does nothing, just a placeholder\n            \n            print(\"Noise events will be written: \\n\")\n            print(f\"data_dictionary['chunk_noise_list_index'] : {data_dictionary['chunk_noise_list_index']}\\n\")\n            print(f\"data_dictionary['chunk_noise_list_spl'] : {data_dictionary['chunk_noise_list_spl']}\\n\")\n            print(f\"start_chunk is : {start_chunk}\\n\")\n            print(f\"stop_chunk is : {stop_chunk}\\n\")\n            \n            noise_frames = data_dictionary['frames'][start_chunk:stop_chunk]\n        \n            \n            # Get the current local time\n            current_time = datetime.datetime.now()\n            # Round to the nearest second (remove microseconds)\n            rounded_time = current_time.replace(microsecond=0)\n        \n            # construct file name with relevant data\n            noise_file_name = f\"{OUTPUT_NOISE_FILENAME}_DataID{max_spl_chunk_index}_dBA{round(max_spl_in_chunk,2)}_Date{rounded_time}.wav\"\n            # make it compatible with windows filename rules\n            noise_file_name = noise_file_name.replace(' ', '_').replace(':', '-')\n            print(noise_file_name)\n\n            # Ensure the directory exists (optional, for better handling)\n            os.makedirs(OUTPUT_FILE_DIRECTORY, exist_ok=True)\n\n            # Combine directory and file name\n            full_path = os.path.join(OUTPUT_FILE_DIRECTORY, noise_file_name)\n            print(full_path)\n                        \n            # Write the recorded data to a WAV file\n\n            with wave.open(full_path, 'wb') as wf:\n                wf.setnchannels(CHANNELS)\n                wf.setsampwidth(data_dictionary['sample_size'])\n                wf.setframerate(RATE)\n                wf.writeframes(b''.join(noise_frames))\n                print(f\"Audio saved as {noise_file_name}\\n\")\n\n\n            #erase noise event arrays\n            data_dictionary['chunk_noise_list_index']   = np.array([], dtype=int)\n            data_dictionary['chunk_noise_list_spl']     = np.array([])\n            \n            max_spl_in_chunk = 0\n            max_spl_index_in_chunk = 0\n            max_spl_chunk_index = 0\n            start_chunk = 0\n            stop_chunk = 0\n            noise_frames                                = np.array([])\n        \n            #remove chunks from wave output which are already treated. To free local resources.\n            data_dictionary['frames'] = data_dictionary['frames'][start_chunk:]\n            \n            recording_status_queue.put(f\"DataID_{max_spl_chunk_index}__dB_{max_spl_in_chunk}__Horaire:_{rounded_time}.wav\")  # Send message to main process\n\n\n\n\ndef func_on_saveWave_exit_click(data_dictionary):\n\n    # Write the recorded data to a WAV file\n    with wave.open(OUTPUT_FILENAME, 'wb') as wf:\n        wf.setnchannels(CHANNELS)\n        wf.setsampwidth(data_dictionary['sample_size'])\n        wf.setframerate(RATE)\n        wf.writeframes(b''.join(data_dictionary['frames']))\n        print(f\"Audio saved as {OUTPUT_FILENAME}\")\n\n    # open the recorded data to a WAV file\n    with wave.open(OUTPUT_FILENAME, 'rb') as wav_file:\n        sample_rate = wav_file.getframerate()  # Sample rate (samples per second)\n        num_frames = wav_file.getnframes()\n        num_channels = wav_file.getnchannels()\n        sample_width = wav_file.getsampwidth()\n        num_frames = wav_file.getnframes()\n           \n        raw_data = wav_file.readframes(num_frames)\n \n    \n    # read audio data and apply weighting filter    \n    # Convert raw byte data into a numpy array\n    # For 16-bit audio (common for WAV), use np.int16\n    data_dictionary['audio_data'] = np.frombuffer(raw_data, dtype=np.int16)\n    # A-weighted audio data\n    audio_data_weighted =   apply_a_weighting(data_dictionary)\n    # Create a time axis for plotting\n    time = np.linspace(0, num_frames / sample_rate, num_frames)\n   \n   \n   \n    # FFT  \n    # Perform FFT on the audio signal\n    fft_signal = np.fft.fft(data_dictionary['audio_data'])\n    # Perform FFT on the audio signal\n    fft_signal_weighted = np.fft.fft(audio_data_weighted)\n\n    # Compute the corresponding frequencies\n    frequencies = np.fft.fftfreq(len(fft_signal), d=1/RATE)\n    \n    # Get the magnitude of the FFT\n    fft_magnitude = np.abs(fft_signal)\n        # Get the magnitude of the FFT\n    fft_magnitude_weighted = np.abs(fft_signal_weighted)\n    \n    # We only want the positive frequencies\n    positive_frequencies = frequencies[:len(frequencies)//2]\n    positive_magnitude = fft_magnitude[:len(frequencies)//2]\n    positive_magnitude_weighted = fft_magnitude_weighted[:len(frequencies)//2]    \n \n    '''\n    # Plot the waveform\n    plt.figure(figsize=(10, 6))\n    plt.plot(time, data_dictionary['audio_data'], color='blue')\n    plt.title('Raw audio time domain')\n    plt.xlabel(\"Time [s]\")\n    plt.ylabel('PCM encoded audio [sint16]')\n    plt.grid(True)\n    plt.show()        \n    '''\n    \n    # plot frames in time domaine\n    # plot process frames in time domaine\n    # plot frames FFT\n    # plot process frames FFT\n    \n    # Create some data for plotting\n    x1 = time\n    y1 = data_dictionary['audio_data']\n\n    x2 = time\n    y2 = audio_data_weighted\n    \n    x3 = positive_frequencies\n    y3 = positive_magnitude\n    \n    x4 = positive_frequencies\n    y4 = positive_magnitude_weighted\n    \n    \n\n \n    ymin_t = MAX_INT16 = np.iinfo(np.int16).min\n    ymax_t = MAX_INT16 = np.iinfo(np.int16).max\n    \n    \n    xmin_f = 0\n    xmax_f = 16000\n    \n    ymin_f = 0\n    ymax_f = max(max(positive_magnitude_weighted),max(positive_magnitude))\n\n\n    \n    # Create a 2x2 grid of subplots (2 rows, 2 columns)\n    fig, axs = plt.subplots(2, 2, figsize=(10, 6))\n    \n    # First plot (top-left)\n    axs[0, 0].plot(x1, y1)\n    axs[0, 0].set_title('Raw audio time domain')\n    axs[0, 0].set_xlabel(\"Time [s]\")\n    axs[0, 0].set_ylabel('PCM encoded audio [sint16]')\n    axs[0, 0].set_ylim(ymin_t, ymax_t)\n    \n    # Third plot (bottom-left)\n    axs[1, 0].plot(x2, y2)\n    axs[1, 0].set_title('A-weighted audio time domain')\n    axs[1, 0].set_xlabel(\"Time [s]\")\n    axs[1, 0].set_ylabel('PCM encoded audio [sint16]')\n    axs[1, 0].set_ylim(ymin_t, ymax_t)\n    \n    # Second plot (top-right)\n    axs[0, 1].plot(x3, y3)\n    axs[0, 1].set_title('Raw audio frequency domain')\n    axs[0, 1].set_xlabel(\"Freq. [kHz]\")\n    axs[0, 1].set_ylabel('PCM encoded audio [sint16]')\n    axs[0, 1].set_xlim(xmin_f, xmax_f)\n    axs[0, 1].set_ylim(ymin_f, ymax_f)\n    \n    # Fourth plot (bottom-right) with a different x-axis range\n    axs[1, 1].plot(x4, y4)\n    axs[1, 1].set_title('A-weighted audio frequency domain')\n    axs[1, 1].set_xlabel(\"Freq. [kHz]\")\n    axs[1, 1].set_ylabel('PCM encoded audio [sint16]')\n    axs[1, 1].set_xlim(xmin_f, xmax_f)\n    axs[1, 1].set_ylim(ymin_f, ymax_f)\n    \n    # Adjust layout to prevent overlap\n    plt.tight_layout()\n    \n    # Show the plots\n    plt.show()\n    \n    \n    \n# GUI ############################################\"\n# Define the main application frame\nclass MyFrame(wx.Frame):\n    def __init__(self, parent, title):\n        super().__init__(parent, title=title, size=(350, 550))\n        \n        # Load settings from previous sessions\n        global config\n\n        global p\n        global stream\n\n        \n        print(f\"data_dictionary['_device_index'] [default]:  {data_dictionary['_device_index']}\")\n        print(f\"data_dictionary['system_calibration_factor_94db'][default]:  {data_dictionary['system_calibration_factor_94db']}\")\n        \n        \n        # To persist Settings -> Initialise a config object.\n        config  = configparser.ConfigParser()\n        # Read Settings\n        config.read('config.ini')\n        \n        # Access values from the config\n        data_dictionary['_device_index']                     = config.getint('Settings', \"_device_index\")\n        data_dictionary['system_calibration_factor_94db']    = config.getfloat('Settings', \"system_calibration_factor_94db\") \n\n        # getint is used for integers\n        print(f\"data_dictionary['_device_index'][loaded from config file]:  {data_dictionary['_device_index']}\")\n        print(f\"data_dictionary['system_calibration_factor_94db'][loaded from config file]:  {data_dictionary['system_calibration_factor_94db']}\")\n\n        # Print the commit hash\n        print(\"Commit version:\", get_commit_version())\n        \n        # Initialize PyAudio\n        p                   = pyaudio.PyAudio()\n        # Open stream to read audio from the microphone\n        stream              = p.open(format=FORMAT,\n                    channels=CHANNELS,\n                    rate=RATE,\n                    input=True,\n                    input_device_index = data_dictionary['_device_index'] ,\n                    frames_per_buffer=CHUNK)\n        data_dictionary['sample_size']     =   p.get_sample_size(FORMAT)\n        print(\"Audio stream opened [Init]\\n\")\n        \n        \n        # Create a panel inside the frame\n        panel = wx.Panel(self)\n   \n        # To store reference to the thread or process (optional choice)\n        self.recording_process          = None\n        self.recording_status_queue     = multiprocessing.Queue()\n        self.recording_dba_queue        = multiprocessing.Queue()\n\n        self.logging_process            = None  \n        self.logging_status_queue       = multiprocessing.Queue() \n        \n        # Timer to  trigger queue reading\n        self.timerDba                   = wx.Timer(self)  \n        self.timerStatus                = wx.Timer(self)  \n\n\n\n        self.runCalib_thread            = None\n        self.checkCalib_thread          = None\n            \n        # Create a text box for user input\n        self.text_ctrl   = wx.TextCtrl(panel, value=str(data_dictionary['_device_index']), pos=(290, 40), size=(30, 25))\n\n        # Create a button on the panel\n        self.button_checkDevices = wx.Button(panel, label=\"CheckDevices\", pos=(200, 10))\n\n        # Create a button on the panel\n        self.button_setDevices = wx.Button(panel, label=\"SetDevices\", pos=(200, 42))\n\n        # Create a button on the panel\n        self.button_start = wx.Button(panel, label=\"Start Measurement!\", pos=(10, 10))\n\n        # Create a button on the panel\n        self.button_stop = wx.Button(panel, label=\"Stop Measurement!\", pos=(10, 40))\n        \n        # Create a button on the panel\n        self.button_runCalib = wx.Button(panel, label=\"Calibrate!\", pos=(10, 80))\n \n        # Create a button on the panel\n        self.button_checkCalib = wx.Button(panel, label=\"Check Calibration!\", pos=(10, 110))\n\n        # Create a button on the panel\n        self.button_saveWave = wx.Button(panel, label=\"Save and Plot Wave File [check signal]\", pos=(10, 140))\n  \n  \n        # Create text output field\n        self.status_text = wx.StaticText(panel, label=\"Status:\", pos=(10, 180), size=(300, 50))\n        \n        # Create text output field\n        self.dba_display = wx.StaticText(panel, label=\"dbA:\", pos=(10, 240), size=(33, 50))\n        # Set a larger font\n        font_large = wx.Font(18, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)\n        self.dba_display.SetFont(font_large)\n        \n        # Create a button on the panel\n        self.button_exit = wx.Button(panel, label=\"Close Application\", pos=(190, 400))\n \n\n        \n        ##################################################################\n        self.Bind(wx.EVT_TIMER, self.update_dba_display, self.timerDba)\n        self.Bind(wx.EVT_TIMER, self.update_status, self.timerStatus)\n        # Check every 10ms\n        self.timerDba.Start(10)\n        self.timerStatus.Start(10)\n        \n        # Bind the button click event to an event handler function\n        self.button_checkDevices.Bind(wx.EVT_BUTTON, self.on_button_checkDevices_click)\n \n        # Bind the button click event to an event handler function\n        self.button_setDevices.Bind(wx.EVT_BUTTON, self.on_button_setDevices_click)\n        \n        # Bind the button click event to an event handler function\n        self.button_start.Bind(wx.EVT_BUTTON, self.on_button_start_click)\n        \n        # Bind the button click event to an event handler function\n        self.button_stop.Bind(wx.EVT_BUTTON, self.on_button_stop_click)\n        \n        # Bind the button click event to an event handler function\n        self.button_runCalib.Bind(wx.EVT_BUTTON, self.on_button_runCalib_click)\n \n        # Bind the button click event to an event handler function\n        self.button_checkCalib.Bind(wx.EVT_BUTTON, self.on_button_checkCalib_click)\n   \n        # Bind the button click event to an event handler function\n        self.button_exit.Bind(wx.EVT_BUTTON, self.on_button_exit_click)\n   \n        # Bind the button click event to an event handler function\n        self.button_saveWave.Bind(wx.EVT_BUTTON, self.on_button_saveWave_click)\n   \n    \n        # Show the window\n        self.Show()\n\n\n    def update_status(self, event):\n        # Safely append text to the TextCtrl\n        while not self.recording_status_queue.empty():\n            msg = self.recording_status_queue.get()\n            wx.CallAfter(self.status_text.SetLabel, msg)\n        # Safely append text to the TextCtrl\n        while not self.logging_status_queue.empty():\n            msg = self.logging_status_queue.get()\n            wx.CallAfter(self.status_text.SetLabel, msg)\n        \n    def update_dba_display(self, event):\n        # Safely append text to the TextCtrl\n        while not self.recording_dba_queue.empty():\n            msg = self.recording_dba_queue.get()\n            wx.CallAfter(self.dba_display.SetLabel, msg)\n\n\n    def on_button_checkDevices_click(self, event):\n        \"\"\"Event handler function for the button click.\"\"\"\n        wx.MessageBox(\"Check Device List in console and set device number in the text box!!\", \"Info\", wx.OK | wx.ICON_INFORMATION)\n        # Call the check device function\n        func_check_devices(data_dictionary)\n\n            \n    def on_button_setDevices_click(self, event):  \n        # Call function\n        func_on_button_setDevices_click(self, data_dictionary)\n\n\n    def on_button_start_click(self, event):\n        # Call function\n        func_on_button_start_click(self, data_dictionary)\n\n            \n    def on_button_stop_click(self, event):       \n        # Call function\n        func_on_button_stop_click(self, data_dictionary)\n\n\n    def on_button_runCalib_click(self, event):\n        # Call function\n        func_on_button_runCalib_click(self, data_dictionary)\n\n\n    def on_button_checkCalib_click(self, event):\n        # Call function\n        func_on_button_checkCalib_click(self, data_dictionary)\n        \n\n    def on_button_exit_click(self, event):\n        # Call function\n        # need self arguments to know which class instance to close\n        func_on_button_exit_click(self, data_dictionary)\n        \n        \n    def on_button_saveWave_click(self, event):\n        # Call function\n        # need self arguments to know which class instance to close\n        func_on_saveWave_exit_click(data_dictionary)\n        \n    \n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        self.frame = MyFrame(None, title=\"Task Scheduler GUI\")      \n        return True\n\n# Main GUI application loop ###################################\nif __name__ == \"__main__\":\n    \n    # required to start new process under windows systems\n    multiprocessing.set_start_method(\"spawn\", force=True)  # optional but clear\n    \n    # Defined in shared memory to allow several processes to work on the data : multiprocessing.\"\n    # values must be accessed via .value postfix ! \n    # arrays do not require to have a postfix.\n\n    # DataDictionary\n    manager = multiprocessing.Manager()\n\n    data_dictionary = manager.dict(\n        \n        # Device list user input \n        _device_index                           = 0,\n        is_recording                            = False,\n        is_logging                              = False,\n        \n        # Microphone calibration factor to obtain 94dB at 1kHz. Default value 1\n        system_calibration_factor_94db          = 1.0, \n        \n        # audio data extraceted from chunk in np format.\n        audio_data                          = np.array([]),\n        a_weighted_signal                   = np.array([]),\n        audio_data_pcm_abs                  = np.array([]),\n        audio_data_mV                       = np.array([]),\n        audio_data_mV_calib                 = np.array([]),\n        audio_data_pressurePa               = np.array([]),\n        audio_data_pressurePa_square        = np.array([]),  \n        \n        audio_data_pressurePa_squareMean    = 0.0,\n        audio_data_pressurePa_rms           = 0.0,\n        audio_data_pressurePa_rms_calib     = 0.0,\n        audio_data_pressurePa_spl           = 0.0,\n        audio_data_max_pcm_value            = 0.0,\n\n        #for output wave file creation / all chunks, complete measurement\n        frames                              = np.array([]),\n\n        chunk_index_i                       = 0,\n        chunk_noise_list_index              = np.array([], dtype=int),\n        chunk_noise_list_spl                = np.array([]),\n\n        sample_size                         = 2\n    )\n      \n\n    app = MyApp()\n\n    # Wrap the main event loop in a try-except block\n    try:\n\n        \n        app.MainLoop()\n        \n        \n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        # You can add additional cleanup or logging here if needed\n    \n    finally:\n        # Add settings to the config\n        # Add USB device index\n        # Add calibration value\n        config.set(\"Settings\",\"_device_index\", f\"{data_dictionary['_device_index']}\")\n        config.set(\"Settings\",\"system_calibration_factor_94db\", f\"{data_dictionary['system_calibration_factor_94db']}\") \n        print(f\"data_dictionary['_device_index'] [saved]:  {data_dictionary['_device_index']}\")\n        print(f\"data_dictionary['system_calibration_factor_94db'][saved]:  {data_dictionary['system_calibration_factor_94db']}\")\n    \n        # Save the program state (configuration) to a file\n        with open('config.ini', 'w') as configfile:\n            config.write(configfile)\n        \n\n    \n        # Close the stream and terminate PyAudio\n        stream.stop_stream()\n        stream.close()\n    \n        # Close audio interface\n        p.terminate()\n        data_dictionary['chunk_index_i']                        = 0    # counter of processed chunks\n        data_dictionary['chunk_noise_list_index']               = np.array([], dtype=int),\n        data_dictionary['chunk_noise_list_spl']                 = np.array([])\n        data_dictionary['frames']                               = np.array([])\n        data_dictionary['is_recording']                         = False\n        data_dictionary['is_logging']                           = False\n        data_dictionary['audio_data']                           = np.array([])\n        data_dictionary['audio_data_pcm_abs']                   = np.array([])\n        data_dictionary['audio_data_mV']                        = np.array([])\n        data_dictionary['audio_data_mV_calib']                  = np.array([])\n        data_dictionary['audio_data_pressurePa']                = np.array([])\n        data_dictionary['audio_data_pressurePa_square']         = np.array([])\n        data_dictionary['audio_data_pressurePa_squareMean']     = 0\n        data_dictionary['audio_data_pressurePa_rms']            = 0\n        data_dictionary['audio_data_pressurePa_rms_calib']      = 0\n        data_dictionary['audio_data_pressurePa_spl']            = 0\n        data_dictionary['audio_data_max_pcm_value']             = 0\n        \n        # Terminate running process, in case they are not closed already.\n        #if recording_process.is_alive() :\n        #    print(\"Timeout reached, terminating process...\")\n        #    app.recording.terminate()\n        #   app.recording.join()\n    \n        #if logging_process.is_alive() :\n        #   print(\"Timeout reached, terminating process...\")\n        #   app.logging.terminate()\n        #   app.logging.join()\n    \n        print(\"Application has finished.\")\n\n# visual thead debugging\nif DEBUG == 1:\n    tracer.stop()  # Stop VizTracer\n    tracer.save(\"Python_AudioLogger_JSON_LogFile.json\")  # Save trace data to a file\n\n##############################################################################", 1114]}, "functions": {"iinfo.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:692)": ["C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py", 692], "iinfo.max (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:716)": ["C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py", 716], "MyFrame (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:789)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 789], "MyApp (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:991)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 991]}}}