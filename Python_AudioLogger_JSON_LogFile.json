{"traceEvents": [{"ph": "M", "pid": 8952, "tid": 8952, "name": "process_name", "args": {"name": "MainProcess"}}, {"ph": "M", "pid": 8952, "tid": 3232, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 8952, "tid": 3232, "ts": 351521516476.954, "ph": "X", "dur": 8.600000003951054, "name": "iinfo.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:692)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521516488.754, "ph": "X", "dur": 1.1000000005053674, "name": "iinfo.max (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:716)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521516495.354, "ph": "X", "dur": 333755.6001533356, "name": "pyaudio._portaudio.initialize", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521516494.154, "ph": "X", "dur": 333765.3001533401, "name": "PyAudio.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:589)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850306.654, "ph": "X", "dur": 201.80000009271194, "name": "builtins.dir", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850512.054, "ph": "X", "dur": 2.6000000011945046, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850517.154, "ph": "X", "dur": 0.6000000002756549, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850518.754, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850519.454, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850520.154, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850520.754, "ph": "X", "dur": 0.5000000002297125, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850521.454, "ph": "X", "dur": 0.5000000002297125, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850522.154, "ph": "X", "dur": 0.7000000003215975, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850523.154, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850523.754, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850524.454, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850525.054, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850525.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850526.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850526.954, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850527.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850528.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850528.954, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850529.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850530.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850531.054, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850531.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850532.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850532.954, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850533.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850534.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850535.054, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850535.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850536.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850536.954, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850537.554, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850538.254, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850538.854, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850539.454, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850540.154, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850540.754, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850541.454, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850542.054, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850542.754, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850543.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850543.954, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850548.554, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850549.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850549.854, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850550.554, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850551.154, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850551.754, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850552.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850553.054, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850553.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850554.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850554.854, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850555.754, "ph": "X", "dur": 0.5000000002297125, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850556.454, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850557.154, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850557.754, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850558.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850559.054, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850559.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850560.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850560.954, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850561.554, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850562.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850562.854, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850563.554, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850564.154, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850564.854, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850565.454, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850566.154, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850566.754, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850567.454, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850568.054, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850568.654, "ph": "X", "dur": 1.8000000008269645, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850571.854, "ph": "X", "dur": 1.6000000007350799, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850573.554, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850575.554, "ph": "X", "dur": 1.5000000006891374, "name": "re.Match.group", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850578.554, "ph": "X", "dur": 0.7000000003215975, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850580.554, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850581.454, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850582.454, "ph": "X", "dur": 0.40000000018376997, "name": "re.Match.group", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850583.954, "ph": "X", "dur": 0.5000000002297125, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850584.954, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850585.754, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850586.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Match.group", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850587.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850588.154, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850588.854, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850589.554, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850593.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850593.954, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850594.554, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850595.254, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850595.854, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850596.454, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850597.154, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850597.854, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850598.454, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850599.054, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850599.754, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850600.354, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850601.054, "ph": "X", "dur": 0.30000000013782746, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850601.654, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850602.254, "ph": "X", "dur": 0.40000000018376997, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850602.954, "ph": "X", "dur": 0.5000000002297125, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850302.354, "ph": "X", "dur": 302.2000001388382, "name": "ConverterMapping.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:1339)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850637.654, "ph": "X", "dur": 0.7000000003215975, "name": "RawConfigParser.converters (C:\\Programming\\Python313\\Lib\\configparser.py:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850640.654, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.iter", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850640.054, "ph": "X", "dur": 1.3000000005972523, "name": "ConverterMapping.__iter__ (C:\\Programming\\Python313\\Lib\\configparser.py:1381)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850646.254, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850650.754, "ph": "X", "dur": 2.700000001240447, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850656.654, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850658.154, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850659.954, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850661.454, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850634.954, "ph": "X", "dur": 27.800000012772013, "name": "SectionProxy.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:1262)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850680.454, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850289.954, "ph": "X", "dur": 392.70000018041617, "name": "RawConfigParser.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:629)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850706.454, "ph": "X", "dur": 184831.80008491632, "name": "pyaudio._portaudio.open", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522035551.854, "ph": "X", "dur": 849.5000003902815, "name": "pyaudio._portaudio.start_stream", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850700.054, "ph": "X", "dur": 185703.900085317, "name": "PyAudio.Stream.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:297)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036414.854, "ph": "X", "dur": 2.3000000010566772, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351521850691.554, "ph": "X", "dur": 185726.8000853275, "name": "PyAudio.open (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:631)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036423.654, "ph": "X", "dur": 49.700000022833414, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036478.554, "ph": "X", "dur": 15.800000007258912, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036497.254, "ph": "X", "dur": 4.900000002251182, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036502.954, "ph": "X", "dur": 2.900000001332332, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036506.654, "ph": "X", "dur": 1.2000000005513098, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036508.554, "ph": "X", "dur": 1.2000000005513098, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036510.354, "ph": "X", "dur": 1.7000000007810223, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036512.754, "ph": "X", "dur": 1.3000000005972523, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036564.254, "ph": "X", "dur": 16.600000007626452, "name": "MyFrame (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:902)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036552.154, "ph": "X", "dur": 145.0000000666166, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036708.354, "ph": "X", "dur": 8.400000003859168, "name": "MyApp (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1074)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036703.554, "ph": "X", "dur": 258.90000011894506, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036991.354, "ph": "X", "dur": 0.8000000003675399, "name": "BaseContext._check_available (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:213)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036986.854, "ph": "X", "dur": 11.800000005421214, "name": "BaseContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:187)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036980.254, "ph": "X", "dur": 19.00000000872907, "name": "DefaultContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:237)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522036975.154, "ph": "X", "dur": 25.600000011761278, "name": "DefaultContext.set_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:245)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037078.354, "ph": "X", "dur": 2.4000000011026197, "name": "MyApp.IsDisplayAvailable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037082.954, "ph": "X", "dur": 7.600000003491629, "name": "MyApp.SetUseBestVisual", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037104.854, "ph": "X", "dur": 2.200000001010735, "name": "_enum_to_int (C:\\Programming\\Python313\\Lib\\signal.py:36)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037108.054, "ph": "X", "dur": 2.00000000091885, "name": "_enum_to_int (C:\\Programming\\Python313\\Lib\\signal.py:36)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037110.454, "ph": "X", "dur": 7.700000003537571, "name": "_signal.signal", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037123.154, "ph": "X", "dur": 3.600000001653929, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037122.054, "ph": "X", "dur": 5.200000002389009, "name": "_int_to_enum (C:\\Programming\\Python313\\Lib\\signal.py:24)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037100.654, "ph": "X", "dur": 27.00000001240447, "name": "signal (C:\\Programming\\Python313\\Lib\\signal.py:56)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037139.554, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037252.154, "ph": "X", "dur": 58.30000002678447, "name": "Get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037313.154, "ph": "X", "dur": 13.200000006064409, "name": "StandardPaths.SetInstallPrefix", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037359.854, "ph": "X", "dur": 91.8000000421752, "name": "SetOption", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039068.854, "ph": "X", "dur": 14.000000006431948, "name": "instance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039085.754, "ph": "X", "dur": 773.1000003551814, "name": "StockGDI.GetFont", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039866.654, "ph": "X", "dur": 3.100000001424217, "name": "Font._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039879.654, "ph": "X", "dur": 2.4000000011026197, "name": "instance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039884.554, "ph": "X", "dur": 69.50000003193003, "name": "StockGDI.GetFont", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039955.354, "ph": "X", "dur": 1.2000000005513098, "name": "Font._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039958.554, "ph": "X", "dur": 1.1000000005053674, "name": "instance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039960.554, "ph": "X", "dur": 53.600000024625174, "name": "StockGDI.GetFont", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040015.054, "ph": "X", "dur": 0.9000000004134823, "name": "Font._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040017.254, "ph": "X", "dur": 0.8000000003675399, "name": "instance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040018.854, "ph": "X", "dur": 57.800000026554756, "name": "StockGDI.GetFont", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040077.554, "ph": "X", "dur": 0.8000000003675399, "name": "Font._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040082.254, "ph": "X", "dur": 20.90000000960198, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040103.454, "ph": "X", "dur": 1.1000000005053674, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040106.854, "ph": "X", "dur": 6.300000002894377, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040113.254, "ph": "X", "dur": 0.6000000002756549, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040116.054, "ph": "X", "dur": 6.200000002848434, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040122.454, "ph": "X", "dur": 0.5000000002297125, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040124.754, "ph": "X", "dur": 6.4000000029403195, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040131.354, "ph": "X", "dur": 0.5000000002297125, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040133.454, "ph": "X", "dur": 6.200000002848434, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040139.854, "ph": "X", "dur": 0.5000000002297125, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040142.354, "ph": "X", "dur": 6.00000000275655, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040148.554, "ph": "X", "dur": 0.5000000002297125, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040150.454, "ph": "X", "dur": 61.9000000284384, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040212.654, "ph": "X", "dur": 0.7000000003215975, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040215.454, "ph": "X", "dur": 6.500000002986261, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040222.154, "ph": "X", "dur": 0.5000000002297125, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040224.254, "ph": "X", "dur": 8.600000003951054, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040233.054, "ph": "X", "dur": 0.6000000002756549, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040235.354, "ph": "X", "dur": 6.00000000275655, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040245.554, "ph": "X", "dur": 0.6000000002756549, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040247.754, "ph": "X", "dur": 6.00000000275655, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040253.854, "ph": "X", "dur": 0.5000000002297125, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040256.154, "ph": "X", "dur": 6.00000000275655, "name": "GetPen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040262.254, "ph": "X", "dur": 0.6000000002756549, "name": "Pen._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040266.454, "ph": "X", "dur": 12.200000005604982, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040278.854, "ph": "X", "dur": 1.2000000005513098, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040282.054, "ph": "X", "dur": 6.300000002894377, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040288.554, "ph": "X", "dur": 0.6000000002756549, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040290.754, "ph": "X", "dur": 6.00000000275655, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040296.954, "ph": "X", "dur": 0.5000000002297125, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040299.254, "ph": "X", "dur": 6.500000002986261, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040305.954, "ph": "X", "dur": 0.5000000002297125, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040308.054, "ph": "X", "dur": 6.300000002894377, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040314.554, "ph": "X", "dur": 0.5000000002297125, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040316.454, "ph": "X", "dur": 7.700000003537571, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040324.354, "ph": "X", "dur": 0.6000000002756549, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040326.654, "ph": "X", "dur": 6.00000000275655, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040332.754, "ph": "X", "dur": 0.5000000002297125, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040335.154, "ph": "X", "dur": 8.200000003767283, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040343.554, "ph": "X", "dur": 0.5000000002297125, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040345.454, "ph": "X", "dur": 6.00000000275655, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040351.554, "ph": "X", "dur": 0.6000000002756549, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040353.754, "ph": "X", "dur": 5.900000002710607, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040359.854, "ph": "X", "dur": 0.5000000002297125, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040361.754, "ph": "X", "dur": 5.900000002710607, "name": "GetBrush", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040367.754, "ph": "X", "dur": 0.5000000002297125, "name": "Brush._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040371.754, "ph": "X", "dur": 12.600000005788754, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040384.554, "ph": "X", "dur": 6.200000002848434, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040392.754, "ph": "X", "dur": 6.4000000029403195, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040399.354, "ph": "X", "dur": 0.8000000003675399, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040401.654, "ph": "X", "dur": 6.00000000275655, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040407.854, "ph": "X", "dur": 0.6000000002756549, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040410.354, "ph": "X", "dur": 5.900000002710607, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040416.454, "ph": "X", "dur": 0.6000000002756549, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040419.054, "ph": "X", "dur": 6.4000000029403195, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040425.554, "ph": "X", "dur": 0.7000000003215975, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040427.954, "ph": "X", "dur": 5.800000002664664, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040433.954, "ph": "X", "dur": 0.6000000002756549, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040436.154, "ph": "X", "dur": 6.00000000275655, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040442.254, "ph": "X", "dur": 0.6000000002756549, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040444.554, "ph": "X", "dur": 5.900000002710607, "name": "GetColour", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040450.554, "ph": "X", "dur": 0.7000000003215975, "name": "Colour._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040453.454, "ph": "X", "dur": 26.800000012312587, "name": "GetCursor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040480.554, "ph": "X", "dur": 0.9000000004134823, "name": "Cursor._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040487.254, "ph": "X", "dur": 12.0000000055131, "name": "GetCursor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040499.554, "ph": "X", "dur": 0.5000000002297125, "name": "Cursor._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040504.754, "ph": "X", "dur": 11.600000005329328, "name": "GetCursor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040516.654, "ph": "X", "dur": 0.5000000002297125, "name": "Cursor._copyFrom", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040518.354, "ph": "X", "dur": 4.900000002251182, "name": "_getTheFontList", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040525.054, "ph": "X", "dur": 2.00000000091885, "name": "_getThePenList", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040528.154, "ph": "X", "dur": 2.200000001010735, "name": "_getTheBrushList", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040531.354, "ph": "X", "dur": 0.7000000003215975, "name": "_getTheColourDatabase", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039058.954, "ph": "X", "dur": 1474.000000677192, "name": "_initStockObjects (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:161)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040543.254, "ph": "X", "dur": 0.9000000004134823, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040553.454, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040554.554, "ph": "X", "dur": 11.20000000514556, "name": "_locale.setlocale", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040551.754, "ph": "X", "dur": 14.300000006569775, "name": "setlocale (C:\\Programming\\Python313\\Lib\\locale.py:600)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040540.254, "ph": "X", "dur": 26.20000001203693, "name": "App.InitLocale (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2296)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522039041.654, "ph": "X", "dur": 1525.0000007006229, "name": "App.OnPreInit (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2234)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522053867.754, "ph": "X", "dur": 60.30000002770332, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522053932.854, "ph": "X", "dur": 14.90000000684543, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522053964.354, "ph": "X", "dur": 1.000000000459425, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522053968.654, "ph": "X", "dur": 0.5000000002297125, "name": "_io.text_encoding", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522055983.254, "ph": "X", "dur": 2.500000001148562, "name": "IncrementalDecoder.__init__ (C:\\Programming\\Python313\\Lib\\codecs.py:263)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522053971.754, "ph": "X", "dur": 2025.8000009307027, "name": "_io.open", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056021.354, "ph": "X", "dur": 4.800000002205239, "name": "_ReadState.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056132.954, "ph": "X", "dur": 2.500000001148562, "name": "_codecs.charmap_decode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056130.254, "ph": "X", "dur": 6.500000002986261, "name": "IncrementalDecoder.decode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:22)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056153.254, "ph": "X", "dur": 2.4000000011026197, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056148.954, "ph": "X", "dur": 7.000000003215974, "name": "_Line.__new__ (C:\\Programming\\Python313\\Lib\\configparser.py:558)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056159.454, "ph": "X", "dur": 2.6000000011945046, "name": "_Line.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:561)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056177.054, "ph": "X", "dur": 0.8000000003675399, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056185.254, "ph": "X", "dur": 1.1000000005053674, "name": "_Line.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056190.654, "ph": "X", "dur": 1.5000000006891374, "name": "builtins.any", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056182.554, "ph": "X", "dur": 10.800000004961788, "name": "_Line._strip_full (C:\\Programming\\Python313\\Lib\\configparser.py:584)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056204.954, "ph": "X", "dur": 0.6000000002756549, "name": "_Line._strip_inline.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\configparser.py:577)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056201.854, "ph": "X", "dur": 7.400000003399744, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056216.454, "ph": "X", "dur": 2.4000000011026197, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056226.854, "ph": "X", "dur": 1.000000000459425, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056228.854, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056232.454, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056231.354, "ph": "X", "dur": 1.6000000007350799, "name": "isstring (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:573)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056236.554, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056236.154, "ph": "X", "dur": 0.6000000002756549, "name": "isstring (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:573)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056253.854, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056256.954, "ph": "X", "dur": 1.3000000005972523, "name": "Tokenizer.__next (C:\\Programming\\Python313\\Lib\\re\\_parser.py:239)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056253.354, "ph": "X", "dur": 5.200000002389009, "name": "Tokenizer.__init__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:230)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056261.154, "ph": "X", "dur": 1.000000000459425, "name": "State.__init__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:76)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056272.054, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056270.854, "ph": "X", "dur": 2.4000000011026197, "name": "Tokenizer.tell (C:\\Programming\\Python313\\Lib\\re\\_parser.py:292)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056312.354, "ph": "X", "dur": 0.40000000018376997, "name": "SubPattern.__init__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:112)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056316.854, "ph": "X", "dur": 0.6000000002756549, "name": "Tokenizer.__next (C:\\Programming\\Python313\\Lib\\re\\_parser.py:239)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056316.254, "ph": "X", "dur": 5.900000002710607, "name": "Tokenizer.get (C:\\Programming\\Python313\\Lib\\re\\_parser.py:260)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056324.854, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056324.554, "ph": "X", "dur": 0.9000000004134823, "name": "Tokenizer.tell (C:\\Programming\\Python313\\Lib\\re\\_parser.py:292)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056327.154, "ph": "X", "dur": 0.40000000018376997, "name": "Tokenizer.__next (C:\\Programming\\Python313\\Lib\\re\\_parser.py:239)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056326.754, "ph": "X", "dur": 1.1000000005053674, "name": "Tokenizer.match (C:\\Programming\\Python313\\Lib\\re\\_parser.py:255)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056328.754, "ph": "X", "dur": 0.20000000009188498, "name": "Tokenizer.__next (C:\\Programming\\Python313\\Lib\\re\\_parser.py:239)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056328.454, "ph": "X", "dur": 0.7000000003215975, "name": "Tokenizer.get (C:\\Programming\\Python313\\Lib\\re\\_parser.py:260)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056331.854, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056331.554, "ph": "X", "dur": 0.6000000002756549, "name": "Tokenizer.tell (C:\\Programming\\Python313\\Lib\\re\\_parser.py:292)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056333.554, "ph": "X", "dur": 0.40000000018376997, "name": "SubPattern.__init__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:112)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056337.554, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056337.254, "ph": "X", "dur": 1.2000000005513098, "name": "SubPattern.__len__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:163)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056335.554, "ph": "X", "dur": 3.4000000015620446, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056332.754, "ph": "X", "dur": 11.000000005053673, "name": "_parse (C:\\Programming\\Python313\\Lib\\re\\_parser.py:511)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056344.454, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056345.554, "ph": "X", "dur": 0.20000000009188498, "name": "Tokenizer.match (C:\\Programming\\Python313\\Lib\\re\\_parser.py:255)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056346.354, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056330.454, "ph": "X", "dur": 16.600000007626452, "name": "_parse_sub (C:\\Programming\\Python313\\Lib\\re\\_parser.py:451)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056348.454, "ph": "X", "dur": 2.900000001332332, "name": "Tokenizer.__next (C:\\Programming\\Python313\\Lib\\re\\_parser.py:239)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056348.054, "ph": "X", "dur": 3.8000000017458144, "name": "Tokenizer.match (C:\\Programming\\Python313\\Lib\\re\\_parser.py:255)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056352.954, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056352.654, "ph": "X", "dur": 0.8000000003675399, "name": "SubPattern.__len__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:163)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056355.654, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056355.354, "ph": "X", "dur": 1.000000000459425, "name": "SubPattern.append (C:\\Programming\\Python313\\Lib\\re\\_parser.py:175)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056357.654, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056357.454, "ph": "X", "dur": 0.5000000002297125, "name": "SubPattern.__len__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:163)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056357.054, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056362.054, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056361.154, "ph": "X", "dur": 1.8000000008269645, "name": "SubPattern.__getitem__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:167)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056310.854, "ph": "X", "dur": 52.70000002421169, "name": "_parse (C:\\Programming\\Python313\\Lib\\re\\_parser.py:511)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056364.754, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056365.454, "ph": "X", "dur": 1.000000000459425, "name": "Tokenizer.match (C:\\Programming\\Python313\\Lib\\re\\_parser.py:255)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056366.754, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056268.354, "ph": "X", "dur": 98.90000004543712, "name": "_parse_sub (C:\\Programming\\Python313\\Lib\\re\\_parser.py:451)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056370.554, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056370.154, "ph": "X", "dur": 1.8000000008269645, "name": "fix_flags (C:\\Programming\\Python313\\Lib\\re\\_parser.py:954)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056240.754, "ph": "X", "dur": 132.80000006101162, "name": "parse (C:\\Programming\\Python313\\Lib\\re\\_parser.py:970)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056390.654, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.min", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056391.754, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.min", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056387.554, "ph": "X", "dur": 4.700000002159297, "name": "SubPattern.getwidth (C:\\Programming\\Python313\\Lib\\re\\_parser.py:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056393.954, "ph": "X", "dur": 0.7000000003215975, "name": "list.extend", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056381.854, "ph": "X", "dur": 13.200000006064409, "name": "_compile_info (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:514)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056419.654, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056417.354, "ph": "X", "dur": 3.100000001424217, "name": "_compile (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056426.154, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056376.054, "ph": "X", "dur": 51.000000023430665, "name": "_code (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:576)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056429.054, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056428.654, "ph": "X", "dur": 5.000000002297124, "name": "State.groups (C:\\Programming\\Python313\\Lib\\re\\_parser.py:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056435.154, "ph": "X", "dur": 0.7000000003215975, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056437.854, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056437.654, "ph": "X", "dur": 0.5000000002297125, "name": "State.groups (C:\\Programming\\Python313\\Lib\\re\\_parser.py:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056440.054, "ph": "X", "dur": 1.7000000007810223, "name": "_sre.compile", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056235.654, "ph": "X", "dur": 206.50000009487124, "name": "compile (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:743)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056450.554, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056452.954, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056449.754, "ph": "X", "dur": 3.600000001653929, "name": "Flag._get_value (C:\\Programming\\Python313\\Lib\\enum.py:1585)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056454.754, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056454.454, "ph": "X", "dur": 1.2000000005513098, "name": "Flag._get_value (C:\\Programming\\Python313\\Lib\\enum.py:1585)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056456.454, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056457.254, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056456.354, "ph": "X", "dur": 1.3000000005972523, "name": "Flag._get_value (C:\\Programming\\Python313\\Lib\\enum.py:1585)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056469.754, "ph": "X", "dur": 2.00000000091885, "name": "Enum.__new__ (C:\\Programming\\Python313\\Lib\\enum.py:1152)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056462.254, "ph": "X", "dur": 9.600000004410479, "name": "EnumType.__call__ (C:\\Programming\\Python313\\Lib\\enum.py:695)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056447.654, "ph": "X", "dur": 24.800000011393735, "name": "Flag.__and__ (C:\\Programming\\Python313\\Lib\\enum.py:1603)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056473.254, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056474.854, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.iter", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056475.454, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056477.754, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056478.354, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.iter", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056478.754, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056215.554, "ph": "X", "dur": 264.9000001217016, "name": "_compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:330)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056211.254, "ph": "X", "dur": 269.9000001239988, "name": "compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:287)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056482.954, "ph": "X", "dur": 4.100000001883641, "name": "re.Pattern.search", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056489.654, "ph": "X", "dur": 0.7000000003215975, "name": "str.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056196.054, "ph": "X", "dur": 294.60000013534653, "name": "_Line._strip_inline (C:\\Programming\\Python313\\Lib\\configparser.py:572)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056180.154, "ph": "X", "dur": 310.9000001428352, "name": "_Line.clean (C:\\Programming\\Python313\\Lib\\configparser.py:564)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056173.254, "ph": "X", "dur": 319.00000014655654, "name": "cached_property.__get__ (C:\\Programming\\Python313\\Lib\\functools.py:1026)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056495.154, "ph": "X", "dur": 2.100000000964792, "name": "re.Pattern.search", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056498.654, "ph": "X", "dur": 0.6000000002756549, "name": "re.Match.start", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056503.054, "ph": "X", "dur": 1.000000000459425, "name": "RawConfigParser._handle_continuation_line (C:\\Programming\\Python313\\Lib\\configparser.py:1083)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056508.854, "ph": "X", "dur": 1.9000000008729072, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056512.254, "ph": "X", "dur": 1.400000000643195, "name": "re.Match.group", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056526.654, "ph": "X", "dur": 0.5000000002297125, "name": "RawConfigParser.converters (C:\\Programming\\Python313\\Lib\\configparser.py:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056529.354, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.iter", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056528.154, "ph": "X", "dur": 1.8000000008269645, "name": "ConverterMapping.__iter__ (C:\\Programming\\Python313\\Lib\\configparser.py:1381)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056531.854, "ph": "X", "dur": 1.7000000007810223, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056535.454, "ph": "X", "dur": 2.200000001010735, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056538.554, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056540.354, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056542.154, "ph": "X", "dur": 1.000000000459425, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056543.754, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056524.254, "ph": "X", "dur": 20.200000009280384, "name": "SectionProxy.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:1262)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056546.654, "ph": "X", "dur": 0.7000000003215975, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056516.554, "ph": "X", "dur": 35.80000001644741, "name": "RawConfigParser._handle_header (C:\\Programming\\Python313\\Lib\\configparser.py:1107)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056506.554, "ph": "X", "dur": 46.000000021133545, "name": "RawConfigParser._handle_rest (C:\\Programming\\Python313\\Lib\\configparser.py:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056559.354, "ph": "X", "dur": 1.000000000459425, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056557.454, "ph": "X", "dur": 3.100000001424217, "name": "_Line.__new__ (C:\\Programming\\Python313\\Lib\\configparser.py:558)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056561.754, "ph": "X", "dur": 1.3000000005972523, "name": "_Line.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:561)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056566.854, "ph": "X", "dur": 0.9000000004134823, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056570.454, "ph": "X", "dur": 0.6000000002756549, "name": "_Line.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056573.454, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.any", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056569.354, "ph": "X", "dur": 5.900000002710607, "name": "_Line._strip_full (C:\\Programming\\Python313\\Lib\\configparser.py:584)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056580.354, "ph": "X", "dur": 0.5000000002297125, "name": "_Line._strip_inline.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\configparser.py:577)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056578.954, "ph": "X", "dur": 3.700000001699872, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056584.454, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056583.954, "ph": "X", "dur": 3.000000001378275, "name": "_compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:330)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056583.554, "ph": "X", "dur": 3.700000001699872, "name": "compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:287)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056587.854, "ph": "X", "dur": 1.6000000007350799, "name": "re.Pattern.search", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056590.654, "ph": "X", "dur": 0.5000000002297125, "name": "str.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056576.054, "ph": "X", "dur": 15.300000007029201, "name": "_Line._strip_inline (C:\\Programming\\Python313\\Lib\\configparser.py:572)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056568.554, "ph": "X", "dur": 23.100000010612714, "name": "_Line.clean (C:\\Programming\\Python313\\Lib\\configparser.py:564)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056565.554, "ph": "X", "dur": 26.6000000122207, "name": "cached_property.__get__ (C:\\Programming\\Python313\\Lib\\functools.py:1026)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056593.854, "ph": "X", "dur": 4.800000002205239, "name": "re.Pattern.search", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056600.454, "ph": "X", "dur": 0.30000000013782746, "name": "re.Match.start", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056602.154, "ph": "X", "dur": 1.2000000005513098, "name": "RawConfigParser._handle_continuation_line (C:\\Programming\\Python313\\Lib\\configparser.py:1083)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056605.754, "ph": "X", "dur": 0.7000000003215975, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056611.954, "ph": "X", "dur": 2.900000001332332, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056615.754, "ph": "X", "dur": 1.7000000007810223, "name": "re.Match.group", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056620.654, "ph": "X", "dur": 0.6000000002756549, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056623.254, "ph": "X", "dur": 0.5000000002297125, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056622.354, "ph": "X", "dur": 1.6000000007350799, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056625.954, "ph": "X", "dur": 0.30000000013782746, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056626.754, "ph": "X", "dur": 0.30000000013782746, "name": "str.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056610.954, "ph": "X", "dur": 17.000000007810225, "name": "RawConfigParser._handle_option (C:\\Programming\\Python313\\Lib\\configparser.py:1125)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056604.054, "ph": "X", "dur": 24.20000001111808, "name": "RawConfigParser._handle_rest (C:\\Programming\\Python313\\Lib\\configparser.py:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056631.354, "ph": "X", "dur": 0.6000000002756549, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056630.254, "ph": "X", "dur": 1.8000000008269645, "name": "_Line.__new__ (C:\\Programming\\Python313\\Lib\\configparser.py:558)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056632.854, "ph": "X", "dur": 0.5000000002297125, "name": "_Line.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:561)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056635.254, "ph": "X", "dur": 0.6000000002756549, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056637.354, "ph": "X", "dur": 0.40000000018376997, "name": "_Line.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056638.954, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.any", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056636.854, "ph": "X", "dur": 3.2000000014701597, "name": "_Line._strip_full (C:\\Programming\\Python313\\Lib\\configparser.py:584)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056642.254, "ph": "X", "dur": 0.20000000009188498, "name": "_Line._strip_inline.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\configparser.py:577)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056641.754, "ph": "X", "dur": 1.6000000007350799, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056644.854, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056644.454, "ph": "X", "dur": 1.9000000008729072, "name": "_compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:330)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056644.054, "ph": "X", "dur": 2.4000000011026197, "name": "compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:287)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056646.854, "ph": "X", "dur": 1.5000000006891374, "name": "re.Pattern.search", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056649.054, "ph": "X", "dur": 0.40000000018376997, "name": "str.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056640.654, "ph": "X", "dur": 9.000000004134822, "name": "_Line._strip_inline (C:\\Programming\\Python313\\Lib\\configparser.py:572)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056636.354, "ph": "X", "dur": 17.20000000790211, "name": "_Line.clean (C:\\Programming\\Python313\\Lib\\configparser.py:564)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056634.554, "ph": "X", "dur": 19.40000000891284, "name": "cached_property.__get__ (C:\\Programming\\Python313\\Lib\\functools.py:1026)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056654.854, "ph": "X", "dur": 1.000000000459425, "name": "re.Pattern.search", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056656.754, "ph": "X", "dur": 0.30000000013782746, "name": "re.Match.start", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056657.854, "ph": "X", "dur": 1.8000000008269645, "name": "RawConfigParser._handle_continuation_line (C:\\Programming\\Python313\\Lib\\configparser.py:1083)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056660.954, "ph": "X", "dur": 0.6000000002756549, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056663.854, "ph": "X", "dur": 2.6000000011945046, "name": "re.Pattern.match", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056667.154, "ph": "X", "dur": 0.9000000004134823, "name": "re.Match.group", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056669.954, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056671.054, "ph": "X", "dur": 0.40000000018376997, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056670.754, "ph": "X", "dur": 0.9000000004134823, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056674.054, "ph": "X", "dur": 0.30000000013782746, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056674.754, "ph": "X", "dur": 0.30000000013782746, "name": "str.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056662.854, "ph": "X", "dur": 13.100000006018465, "name": "RawConfigParser._handle_option (C:\\Programming\\Python313\\Lib\\configparser.py:1125)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056660.254, "ph": "X", "dur": 16.0000000073508, "name": "RawConfigParser._handle_rest (C:\\Programming\\Python313\\Lib\\configparser.py:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056678.554, "ph": "X", "dur": 0.7000000003215975, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056677.654, "ph": "X", "dur": 1.8000000008269645, "name": "_Line.__new__ (C:\\Programming\\Python313\\Lib\\configparser.py:558)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056680.254, "ph": "X", "dur": 0.5000000002297125, "name": "_Line.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:561)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056682.254, "ph": "X", "dur": 0.20000000009188498, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056683.654, "ph": "X", "dur": 0.40000000018376997, "name": "_Line.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056685.054, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.any", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056683.354, "ph": "X", "dur": 2.500000001148562, "name": "_Line._strip_full (C:\\Programming\\Python313\\Lib\\configparser.py:584)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056687.754, "ph": "X", "dur": 0.20000000009188498, "name": "_Line._strip_inline.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\configparser.py:577)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056687.254, "ph": "X", "dur": 1.400000000643195, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056689.754, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056689.454, "ph": "X", "dur": 1.5000000006891374, "name": "_compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:330)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056689.154, "ph": "X", "dur": 1.9000000008729072, "name": "compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:287)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056691.354, "ph": "X", "dur": 0.9000000004134823, "name": "re.Pattern.search", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056692.854, "ph": "X", "dur": 0.30000000013782746, "name": "str.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056686.354, "ph": "X", "dur": 7.000000003215974, "name": "_Line._strip_inline (C:\\Programming\\Python313\\Lib\\configparser.py:572)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056682.954, "ph": "X", "dur": 10.600000004869903, "name": "_Line.clean (C:\\Programming\\Python313\\Lib\\configparser.py:564)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056681.754, "ph": "X", "dur": 12.200000005604982, "name": "cached_property.__get__ (C:\\Programming\\Python313\\Lib\\functools.py:1026)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056696.554, "ph": "X", "dur": 0.30000000013782746, "name": "_Line.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056696.154, "ph": "X", "dur": 1.2000000005513098, "name": "_Line.has_comments (C:\\Programming\\Python313\\Lib\\configparser.py:568)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056699.354, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056739.754, "ph": "X", "dur": 1.3000000005972523, "name": "_codecs.charmap_decode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056738.754, "ph": "X", "dur": 2.80000000128639, "name": "IncrementalDecoder.decode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:22)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056017.154, "ph": "X", "dur": 726.3000003336803, "name": "RawConfigParser._read_inner (C:\\Programming\\Python313\\Lib\\configparser.py:1054)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056748.954, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.iter", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056759.754, "ph": "X", "dur": 0.5000000002297125, "name": "suppress.__init__ (C:\\Programming\\Python313\\Lib\\contextlib.py:444)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056762.454, "ph": "X", "dur": 0.10000000004594249, "name": "suppress.__enter__ (C:\\Programming\\Python313\\Lib\\contextlib.py:447)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056763.054, "ph": "X", "dur": 1.5000000006891374, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056768.754, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056767.654, "ph": "X", "dur": 2.00000000091885, "name": "suppress.__exit__ (C:\\Programming\\Python313\\Lib\\contextlib.py:450)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056748.454, "ph": "X", "dur": 22.800000010474886, "name": "ParsingError._raise_all (C:\\Programming\\Python313\\Lib\\configparser.py:327)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056778.054, "ph": "X", "dur": 0.6000000002756549, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056784.754, "ph": "X", "dur": 0.30000000013782746, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056786.954, "ph": "X", "dur": 0.20000000009188498, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056787.954, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056788.654, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056789.554, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056792.354, "ph": "X", "dur": 0.10000000004594249, "name": "Interpolation.before_read (C:\\Programming\\Python313\\Lib\\configparser.py:389)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056804.254, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056805.154, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056806.054, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056807.854, "ph": "X", "dur": 0.10000000004594249, "name": "Interpolation.before_read (C:\\Programming\\Python313\\Lib\\configparser.py:389)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056775.154, "ph": "X", "dur": 34.30000001575827, "name": "RawConfigParser._join_multiline_values (C:\\Programming\\Python313\\Lib\\configparser.py:1156)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056008.554, "ph": "X", "dur": 801.4000003681831, "name": "RawConfigParser._read (C:\\Programming\\Python313\\Lib\\configparser.py:1031)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056810.754, "ph": "X", "dur": 39.900000018331056, "name": "_io.TextIOWrapper.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056866.354, "ph": "X", "dur": 4.6000000021133545, "name": "_check_methods (C:\\Programming\\Python313\\Lib\\_collections_abc.py:108)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056863.554, "ph": "X", "dur": 7.700000003537571, "name": "PathLike.__subclasshook__ (C:\\Programming\\Python313\\Lib\\os.py:1126)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056860.854, "ph": "X", "dur": 14.600000006707603, "name": "_abc._abc_subclasscheck", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056860.654, "ph": "X", "dur": 15.100000006937314, "name": "ABCMeta.__subclasscheck__ (C:\\Programming\\Python313\\Lib\\abc.py:121)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056855.754, "ph": "X", "dur": 20.300000009326325, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056855.354, "ph": "X", "dur": 20.90000000960198, "name": "ABCMeta.__instancecheck__ (C:\\Programming\\Python313\\Lib\\abc.py:117)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056852.354, "ph": "X", "dur": 24.300000011164027, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056878.054, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522053958.354, "ph": "X", "dur": 2921.2000013420716, "name": "RawConfigParser.read (C:\\Programming\\Python313\\Lib\\configparser.py:716)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056909.554, "ph": "X", "dur": 4.0000000018377, "name": "ChainMap.__init__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1003)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056903.554, "ph": "X", "dur": 10.700000004915847, "name": "RawConfigParser._unify_values (C:\\Programming\\Python313\\Lib\\configparser.py:1174)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056915.454, "ph": "X", "dur": 0.6000000002756549, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056915.154, "ph": "X", "dur": 1.2000000005513098, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056918.954, "ph": "X", "dur": 3.700000001699872, "name": "ChainMap.__getitem__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1013)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056934.854, "ph": "X", "dur": 1.3000000005972523, "name": "ChainMap.__init__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1003)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056932.654, "ph": "X", "dur": 3.8000000017458144, "name": "RawConfigParser._unify_values (C:\\Programming\\Python313\\Lib\\configparser.py:1174)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056937.454, "ph": "X", "dur": 4.800000002205239, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056937.154, "ph": "X", "dur": 5.400000002480894, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056943.254, "ph": "X", "dur": 1.8000000008269645, "name": "ChainMap.__getitem__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1013)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056931.754, "ph": "X", "dur": 13.70000000629412, "name": "RawConfigParser.get (C:\\Programming\\Python313\\Lib\\configparser.py:794)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056947.754, "ph": "X", "dur": 0.6000000002756549, "name": "str.find", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056948.954, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056930.654, "ph": "X", "dur": 18.900000008683133, "name": "BasicInterpolation._interpolate_some (C:\\Programming\\Python313\\Lib\\configparser.py:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056950.054, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056925.454, "ph": "X", "dur": 25.100000011531563, "name": "BasicInterpolation.before_get (C:\\Programming\\Python313\\Lib\\configparser.py:413)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056900.854, "ph": "X", "dur": 50.00000002297124, "name": "RawConfigParser.get (C:\\Programming\\Python313\\Lib\\configparser.py:794)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056897.154, "ph": "X", "dur": 56.40000002591156, "name": "RawConfigParser._get (C:\\Programming\\Python313\\Lib\\configparser.py:831)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056891.854, "ph": "X", "dur": 62.40000002866811, "name": "RawConfigParser._get_conv (C:\\Programming\\Python313\\Lib\\configparser.py:834)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056887.054, "ph": "X", "dur": 68.50000003147059, "name": "RawConfigParser.getint (C:\\Programming\\Python313\\Lib\\configparser.py:845)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056963.954, "ph": "X", "dur": 0.7000000003215975, "name": "ChainMap.__init__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1003)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056962.654, "ph": "X", "dur": 2.3000000010566772, "name": "RawConfigParser._unify_values (C:\\Programming\\Python313\\Lib\\configparser.py:1174)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056965.754, "ph": "X", "dur": 0.5000000002297125, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056965.554, "ph": "X", "dur": 0.9000000004134823, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056966.754, "ph": "X", "dur": 1.3000000005972523, "name": "ChainMap.__getitem__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1013)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056975.554, "ph": "X", "dur": 0.5000000002297125, "name": "ChainMap.__init__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1003)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056974.454, "ph": "X", "dur": 1.8000000008269645, "name": "RawConfigParser._unify_values (C:\\Programming\\Python313\\Lib\\configparser.py:1174)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056976.954, "ph": "X", "dur": 0.20000000009188498, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056976.754, "ph": "X", "dur": 0.6000000002756549, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056977.654, "ph": "X", "dur": 0.8000000003675399, "name": "ChainMap.__getitem__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1013)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056974.154, "ph": "X", "dur": 4.500000002067411, "name": "RawConfigParser.get (C:\\Programming\\Python313\\Lib\\configparser.py:794)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056980.054, "ph": "X", "dur": 0.5000000002297125, "name": "str.find", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056981.054, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056973.254, "ph": "X", "dur": 8.300000003813226, "name": "BasicInterpolation._interpolate_some (C:\\Programming\\Python313\\Lib\\configparser.py:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056982.054, "ph": "X", "dur": 0.20000000009188498, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056972.654, "ph": "X", "dur": 9.800000004502364, "name": "BasicInterpolation.before_get (C:\\Programming\\Python313\\Lib\\configparser.py:413)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056962.154, "ph": "X", "dur": 20.500000009418212, "name": "RawConfigParser.get (C:\\Programming\\Python313\\Lib\\configparser.py:794)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056961.154, "ph": "X", "dur": 27.100000012450415, "name": "RawConfigParser._get (C:\\Programming\\Python313\\Lib\\configparser.py:831)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056959.454, "ph": "X", "dur": 29.400000013507093, "name": "RawConfigParser._get_conv (C:\\Programming\\Python313\\Lib\\configparser.py:834)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056957.654, "ph": "X", "dur": 31.700000014563766, "name": "RawConfigParser.getfloat (C:\\Programming\\Python313\\Lib\\configparser.py:850)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522056991.554, "ph": "X", "dur": 26.6000000122207, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057024.454, "ph": "X", "dur": 8.500000003905113, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057072.154, "ph": "X", "dur": 0.30000000013782746, "name": "_cleanup (C:\\Programming\\Python313\\Lib\\subprocess.py:265)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057076.654, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057077.654, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057102.654, "ph": "X", "dur": 1.000000000459425, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057100.554, "ph": "X", "dur": 3.8000000017458144, "name": "_GeneratorContextManagerBase.__init__ (C:\\Programming\\Python313\\Lib\\contextlib.py:108)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057095.254, "ph": "X", "dur": 9.400000004318594, "name": "contextmanager.<locals>.helper (C:\\Programming\\Python313\\Lib\\contextlib.py:303)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057113.054, "ph": "X", "dur": 0.40000000018376997, "name": "Popen._on_error_fd_closer (C:\\Programming\\Python313\\Lib\\subprocess.py:1323)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057110.454, "ph": "X", "dur": 3.100000001424217, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057106.954, "ph": "X", "dur": 6.800000003124089, "name": "_GeneratorContextManager.__enter__ (C:\\Programming\\Python313\\Lib\\contextlib.py:136)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057117.154, "ph": "X", "dur": 2.900000001332332, "name": "_winapi.GetStdHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057123.154, "ph": "X", "dur": 1.000000000459425, "name": "_winapi.GetCurrentProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057124.554, "ph": "X", "dur": 0.40000000018376997, "name": "_winapi.GetCurrentProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057125.854, "ph": "X", "dur": 7.100000003261917, "name": "_winapi.DuplicateHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057122.054, "ph": "X", "dur": 12.90000000592658, "name": "Popen._make_inheritable (C:\\Programming\\Python313\\Lib\\subprocess.py:1426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057136.654, "ph": "X", "dur": 48.900000022465875, "name": "_winapi.CreatePipe", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057191.854, "ph": "X", "dur": 1.000000000459425, "name": "list.extend", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057197.354, "ph": "X", "dur": 0.8000000003675399, "name": "_winapi.GetCurrentProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057198.654, "ph": "X", "dur": 0.20000000009188498, "name": "_winapi.GetCurrentProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057199.354, "ph": "X", "dur": 5.400000002480894, "name": "_winapi.DuplicateHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057195.454, "ph": "X", "dur": 10.700000004915847, "name": "Popen._make_inheritable (C:\\Programming\\Python313\\Lib\\subprocess.py:1426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057208.454, "ph": "X", "dur": 1.2000000005513098, "name": "_winapi.GetStdHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057211.054, "ph": "X", "dur": 0.30000000013782746, "name": "_winapi.GetCurrentProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057211.654, "ph": "X", "dur": 0.5000000002297125, "name": "_winapi.GetCurrentProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057212.554, "ph": "X", "dur": 4.800000002205239, "name": "_winapi.DuplicateHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057210.754, "ph": "X", "dur": 7.600000003491629, "name": "Popen._make_inheritable (C:\\Programming\\Python313\\Lib\\subprocess.py:1426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057227.654, "ph": "X", "dur": 0.5000000002297125, "name": "Popen._on_error_fd_closer (C:\\Programming\\Python313\\Lib\\subprocess.py:1323)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057226.154, "ph": "X", "dur": 4.40000000202147, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057225.154, "ph": "X", "dur": 9.70000000445642, "name": "_GeneratorContextManager.__exit__ (C:\\Programming\\Python313\\Lib\\contextlib.py:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057092.854, "ph": "X", "dur": 144.80000006652472, "name": "Popen._get_handles (C:\\Programming\\Python313\\Lib\\subprocess.py:1347)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057252.954, "ph": "X", "dur": 5.5000000025268365, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057248.754, "ph": "X", "dur": 10.100000004640192, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057267.454, "ph": "X", "dur": 2.80000000128639, "name": "Handle.Detach (C:\\Programming\\Python313\\Lib\\subprocess.py:229)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057270.654, "ph": "X", "dur": 8.90000000408888, "name": "msvcrt.open_osfhandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057281.554, "ph": "X", "dur": 1.5000000006891374, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057285.954, "ph": "X", "dur": 30.400000013966515, "name": "_io.open", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057328.254, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057329.654, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057339.154, "ph": "X", "dur": 3.600000001653929, "name": "_check_methods (C:\\Programming\\Python313\\Lib\\_collections_abc.py:108)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057337.654, "ph": "X", "dur": 5.400000002480894, "name": "PathLike.__subclasshook__ (C:\\Programming\\Python313\\Lib\\os.py:1126)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057336.354, "ph": "X", "dur": 11.70000000537527, "name": "_abc._abc_subclasscheck", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057336.154, "ph": "X", "dur": 12.200000005604982, "name": "ABCMeta.__subclasscheck__ (C:\\Programming\\Python313\\Lib\\abc.py:121)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057333.154, "ph": "X", "dur": 15.600000007167028, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057332.754, "ph": "X", "dur": 16.10000000739674, "name": "ABCMeta.__instancecheck__ (C:\\Programming\\Python313\\Lib\\abc.py:117)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057331.554, "ph": "X", "dur": 17.70000000813182, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057358.454, "ph": "X", "dur": 0.5000000002297125, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057359.554, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057358.154, "ph": "X", "dur": 2.00000000091885, "name": "_fscodec.<locals>.fsdecode (C:\\Programming\\Python313\\Lib\\os.py:855)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057363.454, "ph": "X", "dur": 0.8000000003675399, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057366.054, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057366.954, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057368.354, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057368.954, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057368.254, "ph": "X", "dur": 1.000000000459425, "name": "_fscodec.<locals>.fsdecode (C:\\Programming\\Python313\\Lib\\os.py:855)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057369.954, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057371.654, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057372.554, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057373.054, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057373.654, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057374.154, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057374.954, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057375.454, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057375.954, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057376.454, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057377.354, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057377.854, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057377.254, "ph": "X", "dur": 0.9000000004134823, "name": "_fscodec.<locals>.fsdecode (C:\\Programming\\Python313\\Lib\\os.py:855)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057378.654, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057379.754, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057380.354, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057380.854, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057381.654, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057383.154, "ph": "X", "dur": 1.000000000459425, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057353.754, "ph": "X", "dur": 30.700000014104344, "name": "list2cmdline (C:\\Programming\\Python313\\Lib\\subprocess.py:584)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057388.954, "ph": "X", "dur": 3.500000001607987, "name": "STARTUPINFO.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:199)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057399.854, "ph": "X", "dur": 0.7000000003215975, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057406.054, "ph": "X", "dur": 3.700000001699872, "name": "Popen._filter_handle_list (C:\\Programming\\Python313\\Lib\\subprocess.py:1435)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057418.854, "ph": "X", "dur": 0.6000000002756549, "name": "sys.audit", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057420.954, "ph": "X", "dur": 5145.800002364108, "name": "_winapi.CreateProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062584.154, "ph": "X", "dur": 2.200000001010735, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062596.554, "ph": "X", "dur": 6.4000000029403195, "name": "_BaseExitStack.__init__ (C:\\Programming\\Python313\\Lib\\contextlib.py:485)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062607.554, "ph": "X", "dur": 0.30000000013782746, "name": "ExitStack.__enter__ (C:\\Programming\\Python313\\Lib\\contextlib.py:568)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062621.454, "ph": "X", "dur": 3.500000001607987, "name": "_BaseExitStack._create_cb_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:479)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062634.554, "ph": "X", "dur": 1.400000000643195, "name": "collections.deque.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062630.754, "ph": "X", "dur": 5.900000002710607, "name": "_BaseExitStack._push_exit_callback (C:\\Programming\\Python313\\Lib\\contextlib.py:552)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062614.754, "ph": "X", "dur": 22.300000010245174, "name": "_BaseExitStack.callback (C:\\Programming\\Python313\\Lib\\contextlib.py:534)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062642.654, "ph": "X", "dur": 0.6000000002756549, "name": "_BaseExitStack._create_cb_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:479)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062646.354, "ph": "X", "dur": 0.30000000013782746, "name": "collections.deque.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062645.454, "ph": "X", "dur": 1.400000000643195, "name": "_BaseExitStack._push_exit_callback (C:\\Programming\\Python313\\Lib\\contextlib.py:552)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062639.054, "ph": "X", "dur": 7.900000003629456, "name": "_BaseExitStack.callback (C:\\Programming\\Python313\\Lib\\contextlib.py:534)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062648.754, "ph": "X", "dur": 0.5000000002297125, "name": "_BaseExitStack._create_cb_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:479)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062650.454, "ph": "X", "dur": 0.10000000004594249, "name": "collections.deque.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062649.954, "ph": "X", "dur": 0.8000000003675399, "name": "_BaseExitStack._push_exit_callback (C:\\Programming\\Python313\\Lib\\contextlib.py:552)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062647.854, "ph": "X", "dur": 3.000000001378275, "name": "_BaseExitStack.callback (C:\\Programming\\Python313\\Lib\\contextlib.py:534)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062659.054, "ph": "X", "dur": 0.7000000003215975, "name": "sys.exception", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062662.454, "ph": "X", "dur": 0.6000000002756549, "name": "collections.deque.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062669.054, "ph": "X", "dur": 8.400000003859168, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062666.754, "ph": "X", "dur": 10.90000000500773, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062665.654, "ph": "X", "dur": 12.300000005650926, "name": "_BaseExitStack._create_cb_wrapper.<locals>._exit_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:481)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062679.054, "ph": "X", "dur": 0.30000000013782746, "name": "collections.deque.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062682.854, "ph": "X", "dur": 3.2000000014701597, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062682.254, "ph": "X", "dur": 4.0000000018377, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062681.854, "ph": "X", "dur": 4.700000002159297, "name": "_BaseExitStack._create_cb_wrapper.<locals>._exit_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:481)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062687.354, "ph": "X", "dur": 0.20000000009188498, "name": "collections.deque.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062689.854, "ph": "X", "dur": 3.500000001607987, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062689.154, "ph": "X", "dur": 4.500000002067411, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062688.754, "ph": "X", "dur": 5.700000002618721, "name": "_BaseExitStack._create_cb_wrapper.<locals>._exit_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:481)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062655.854, "ph": "X", "dur": 39.500000018147276, "name": "ExitStack.__exit__ (C:\\Programming\\Python313\\Lib\\contextlib.py:571)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062581.854, "ph": "X", "dur": 116.70000005361489, "name": "Popen._close_pipe_fds (C:\\Programming\\Python313\\Lib\\subprocess.py:1294)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062708.354, "ph": "X", "dur": 4.900000002251182, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057327.354, "ph": "X", "dur": 5386.100002474508, "name": "Popen._execute_child (C:\\Programming\\Python313\\Lib\\subprocess.py:1448)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057070.454, "ph": "X", "dur": 5645.700002593775, "name": "Popen.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:816)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062717.554, "ph": "X", "dur": 0.5000000002297125, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062719.154, "ph": "X", "dur": 0.10000000004594249, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062719.754, "ph": "X", "dur": 0.20000000009188498, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062723.954, "ph": "X", "dur": 0.10000000004594249, "name": "Popen.__enter__ (C:\\Programming\\Python313\\Lib\\subprocess.py:1101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062733.154, "ph": "X", "dur": 1.3000000005972523, "name": "list.count", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062736.754, "ph": "X", "dur": 57376.50002636019, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522120117.754, "ph": "X", "dur": 19.900000009142552, "name": "_io.BufferedReader.close", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522120212.254, "ph": "X", "dur": 1113.7000005116613, "name": "_winapi.WaitForSingleObject", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121335.354, "ph": "X", "dur": 7.500000003445686, "name": "_winapi.GetExitCodeProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522120206.554, "ph": "X", "dur": 1138.4000005230093, "name": "Popen._wait (C:\\Programming\\Python313\\Lib\\subprocess.py:1592)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522120200.654, "ph": "X", "dur": 1145.2000005261332, "name": "Popen.wait (C:\\Programming\\Python313\\Lib\\subprocess.py:1271)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522062730.554, "ph": "X", "dur": 58617.10002693015, "name": "Popen.communicate (C:\\Programming\\Python313\\Lib\\subprocess.py:1177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121366.954, "ph": "X", "dur": 0.8000000003675399, "name": "Popen._internal_poll (C:\\Programming\\Python313\\Lib\\subprocess.py:1575)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121363.754, "ph": "X", "dur": 4.40000000202147, "name": "Popen.poll (C:\\Programming\\Python313\\Lib\\subprocess.py:1245)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121376.454, "ph": "X", "dur": 2.3000000010566772, "name": "_io.BufferedReader.close", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121385.854, "ph": "X", "dur": 2.3000000010566772, "name": "Popen._wait (C:\\Programming\\Python313\\Lib\\subprocess.py:1592)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121383.154, "ph": "X", "dur": 5.400000002480894, "name": "Popen.wait (C:\\Programming\\Python313\\Lib\\subprocess.py:1271)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121374.454, "ph": "X", "dur": 14.90000000684543, "name": "Popen.__exit__ (C:\\Programming\\Python313\\Lib\\subprocess.py:1104)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121396.254, "ph": "X", "dur": 3.2000000014701597, "name": "CompletedProcess.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:489)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057049.454, "ph": "X", "dur": 64351.200029564534, "name": "run (C:\\Programming\\Python313\\Lib\\subprocess.py:514)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121408.954, "ph": "X", "dur": 0.7000000003215975, "name": "Popen._internal_poll (C:\\Programming\\Python313\\Lib\\subprocess.py:1575)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121406.754, "ph": "X", "dur": 3.500000001607987, "name": "Popen.__del__ (C:\\Programming\\Python313\\Lib\\subprocess.py:1132)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121421.254, "ph": "X", "dur": 157.90000007254318, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121417.754, "ph": "X", "dur": 162.50000007465653, "name": "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057040.854, "ph": "X", "dur": 64546.10002965409, "name": "check_output (C:\\Programming\\Python313\\Lib\\subprocess.py:425)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121590.554, "ph": "X", "dur": 2.200000001010735, "name": "bytes.strip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121595.454, "ph": "X", "dur": 1.6000000007350799, "name": "bytes.decode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522057035.654, "ph": "X", "dur": 64561.800029661295, "name": "get_commit_version (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:171)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522121598.554, "ph": "X", "dur": 44.50000002044441, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522149351.954, "ph": "X", "dur": 989.0000004543712, "name": "StaticText.SetFont", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152131.854, "ph": "X", "dur": 1.6000000007350799, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152135.354, "ph": "X", "dur": 1.000000000459425, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152145.754, "ph": "X", "dur": 24.20000001111808, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152140.554, "ph": "X", "dur": 31.30000001438, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152128.354, "ph": "X", "dur": 44.20000002030658, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152181.054, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152182.954, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152186.554, "ph": "X", "dur": 5.100000002343067, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152185.254, "ph": "X", "dur": 6.800000003124089, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152177.054, "ph": "X", "dur": 15.200000006983258, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152194.954, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152195.654, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152197.254, "ph": "X", "dur": 2.900000001332332, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152196.654, "ph": "X", "dur": 3.8000000017458144, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152194.554, "ph": "X", "dur": 6.100000002802491, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152203.854, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152204.754, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152206.754, "ph": "X", "dur": 5.100000002343067, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152206.354, "ph": "X", "dur": 6.200000002848434, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152203.554, "ph": "X", "dur": 9.200000004226709, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152215.854, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152216.654, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152218.754, "ph": "X", "dur": 2.4000000011026197, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152218.054, "ph": "X", "dur": 3.4000000015620446, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152215.354, "ph": "X", "dur": 6.4000000029403195, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152223.554, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152223.954, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152226.054, "ph": "X", "dur": 5.300000002434952, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152225.254, "ph": "X", "dur": 15.500000007121086, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152223.254, "ph": "X", "dur": 17.70000000813182, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152242.954, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152243.454, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152244.854, "ph": "X", "dur": 5.60000000257278, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152244.354, "ph": "X", "dur": 6.4000000029403195, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152242.654, "ph": "X", "dur": 8.500000003905113, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152254.054, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152254.954, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152256.854, "ph": "X", "dur": 5.300000002434952, "name": "Button.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152256.354, "ph": "X", "dur": 6.100000002802491, "name": "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152253.554, "ph": "X", "dur": 9.100000004180767, "name": "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522152265.354, "ph": "X", "dur": 44994.20002067146, "name": "MyFrame.Show", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040594.454, "ph": "X", "dur": 156667.80007197708, "name": "MyFrame.__init__ (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522040582.154, "ph": "X", "dur": 156694.4000719893, "name": "MyApp.OnInit (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1075)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037457.454, "ph": "X", "dur": 159823.20007342676, "name": "MyApp._BootstrapApp", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522037013.154, "ph": "X", "dur": 160268.00007363112, "name": "App.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2151)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244350.857, "ph": "X", "dur": 35.80000001644741, "name": "TextCtrl.GetValue", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244402.757, "ph": "X", "dur": 3.4000000015620446, "name": "pyaudio._portaudio.get_device_info", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244418.957, "ph": "X", "dur": 4.900000002251182, "name": "_locale.getencoding", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244415.157, "ph": "X", "dur": 9.300000004272652, "name": "getpreferredencoding (C:\\Programming\\Python313\\Lib\\locale.py:630)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244437.857, "ph": "X", "dur": 2.80000000128639, "name": "_codecs.charmap_decode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244434.457, "ph": "X", "dur": 6.4000000029403195, "name": "Codec.decode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:14)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244426.457, "ph": "X", "dur": 16.0000000073508, "name": "bytes.decode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244408.357, "ph": "X", "dur": 39.800000018285104, "name": "PyAudio._make_device_info_dictionary (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:840)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244400.457, "ph": "X", "dur": 48.40000002223616, "name": "PyAudio.get_device_info_by_index (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:827)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244469.557, "ph": "X", "dur": 931822.4004281024, "name": "wx._core.MessageBox", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244341.557, "ph": "X", "dur": 931953.7004281627, "name": "func_on_button_setDevices_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:192)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351528244336.357, "ph": "X", "dur": 931959.9004281656, "name": "MyFrame.on_button_setDevices_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1035)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529900302.057, "ph": "X", "dur": 1671.6000007679747, "name": "Button.Disable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529901980.257, "ph": "X", "dur": 5.300000002434952, "name": "Button.Enable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902000.057, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902003.157, "ph": "X", "dur": 13.200000006064409, "name": "wx._core.GetApp", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902017.857, "ph": "X", "dur": 4.200000001929584, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902023.657, "ph": "X", "dur": 1.2000000005513098, "name": "wx._core.NewEventType", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902029.157, "ph": "X", "dur": 8.200000003767283, "name": "MyApp.Connect", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902053.957, "ph": "X", "dur": 1.3000000005972523, "name": "PyEvent.SetEventType", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902076.757, "ph": "X", "dur": 7.400000003399744, "name": "sip.wrappertype.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902072.957, "ph": "X", "dur": 23.800000010934312, "name": "_PyEvent_Clone (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1851)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902058.657, "ph": "X", "dur": 52.00000002389009, "name": "wx._core.PostEvent", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529901998.457, "ph": "X", "dur": 112.60000005173124, "name": "CallAfter (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3406)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902124.057, "ph": "X", "dur": 33.200000015252904, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902159.157, "ph": "X", "dur": 8.80000000404294, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902168.457, "ph": "X", "dur": 9.000000004134822, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902178.057, "ph": "X", "dur": 8.0000000036754, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902196.957, "ph": "X", "dur": 1.3000000005972523, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902196.057, "ph": "X", "dur": 2.900000001332332, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902214.457, "ph": "X", "dur": 0.7000000003215975, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902219.057, "ph": "X", "dur": 0.5000000002297125, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902224.857, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902236.057, "ph": "X", "dur": 0.7000000003215975, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902234.157, "ph": "X", "dur": 3.4000000015620446, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902242.157, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902224.057, "ph": "X", "dur": 18.700000008591243, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902246.557, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902248.957, "ph": "X", "dur": 0.20000000009188498, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902261.957, "ph": "X", "dur": 1.1000000005053674, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902258.557, "ph": "X", "dur": 4.800000002205239, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902264.857, "ph": "X", "dur": 2.80000000128639, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902254.057, "ph": "X", "dur": 14.700000006753546, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902269.457, "ph": "X", "dur": 0.7000000003215975, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902250.757, "ph": "X", "dur": 19.800000009096614, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902275.657, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902276.357, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902279.157, "ph": "X", "dur": 0.9000000004134823, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902278.557, "ph": "X", "dur": 1.7000000007810223, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902285.157, "ph": "X", "dur": 0.9000000004134823, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902283.757, "ph": "X", "dur": 2.500000001148562, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902246.257, "ph": "X", "dur": 41.2000000189283, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902221.457, "ph": "X", "dur": 66.30000003045987, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902288.557, "ph": "X", "dur": 0.9000000004134823, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902295.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902299.257, "ph": "X", "dur": 0.6000000002756549, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902307.757, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902307.657, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902312.957, "ph": "X", "dur": 4.200000001929584, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902312.657, "ph": "X", "dur": 4.700000002159297, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902318.657, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902318.457, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902321.157, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902321.057, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902326.257, "ph": "X", "dur": 1.1000000005053674, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902325.757, "ph": "X", "dur": 2.100000000964792, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902324.557, "ph": "X", "dur": 4.0000000018377, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902329.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902329.157, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902330.757, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902330.657, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902341.557, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902346.257, "ph": "X", "dur": 1.3000000005972523, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902354.457, "ph": "X", "dur": 10.600000004869903, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902371.357, "ph": "X", "dur": 208.70000009588196, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902369.457, "ph": "X", "dur": 211.70000009726022, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902594.057, "ph": "X", "dur": 2.80000000128639, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902605.957, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902614.257, "ph": "X", "dur": 0.9000000004134823, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902615.657, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902617.157, "ph": "X", "dur": 0.8000000003675399, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902620.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902621.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902621.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902622.957, "ph": "X", "dur": 0.9000000004134823, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902625.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902626.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902627.657, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902628.757, "ph": "X", "dur": 0.8000000003675399, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902604.357, "ph": "X", "dur": 25.80000001185316, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902634.057, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902636.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902638.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902639.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902640.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902641.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902642.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902642.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902643.357, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902644.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902644.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902645.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902646.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902636.257, "ph": "X", "dur": 10.800000004961788, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902647.957, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902649.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902651.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902651.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902652.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902653.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902654.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902654.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902655.257, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902656.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902656.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902657.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902657.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902649.157, "ph": "X", "dur": 9.500000004364535, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902659.257, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902663.157, "ph": "X", "dur": 131.3000000603225, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902662.957, "ph": "X", "dur": 132.20000006073596, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902662.457, "ph": "X", "dur": 134.30000006170076, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902661.057, "ph": "X", "dur": 137.10000006298716, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902812.757, "ph": "X", "dur": 0.6000000002756549, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902820.557, "ph": "X", "dur": 0.6000000002756549, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902824.657, "ph": "X", "dur": 2.4000000011026197, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902828.457, "ph": "X", "dur": 1.000000000459425, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902830.657, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902831.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902832.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902824.357, "ph": "X", "dur": 8.700000003996996, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902822.857, "ph": "X", "dur": 10.500000004823962, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902838.657, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902819.557, "ph": "X", "dur": 22.700000010428944, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902807.657, "ph": "X", "dur": 34.90000001603393, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902354.057, "ph": "X", "dur": 489.90000022507223, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902337.757, "ph": "X", "dur": 507.40000023311217, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902334.157, "ph": "X", "dur": 511.60000023504176, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902847.857, "ph": "X", "dur": 0.5000000002297125, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902847.257, "ph": "X", "dur": 1.3000000005972523, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902303.957, "ph": "X", "dur": 546.6000002511216, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902851.957, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902856.957, "ph": "X", "dur": 2.200000001010735, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902862.157, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902863.457, "ph": "X", "dur": 0.10000000004594249, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902864.857, "ph": "X", "dur": 4.0000000018377, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902874.957, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902875.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902877.257, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902878.957, "ph": "X", "dur": 1.1000000005053674, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902878.457, "ph": "X", "dur": 1.9000000008729072, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902881.157, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902882.857, "ph": "X", "dur": 0.10000000004594249, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902883.457, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902885.457, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902891.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902897.257, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902904.857, "ph": "X", "dur": 0.8000000003675399, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902904.457, "ph": "X", "dur": 1.6000000007350799, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902906.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902906.657, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902907.857, "ph": "X", "dur": 0.30000000013782746, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902902.857, "ph": "X", "dur": 6.4000000029403195, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902899.657, "ph": "X", "dur": 11.900000005467156, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902912.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902914.557, "ph": "X", "dur": 0.9000000004134823, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902919.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902923.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902923.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902943.657, "ph": "X", "dur": 0.6000000002756549, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902946.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902947.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902947.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902948.557, "ph": "X", "dur": 0.7000000003215975, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902950.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902950.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902951.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902951.957, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902953.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902954.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902955.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902956.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902957.057, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902918.957, "ph": "X", "dur": 39.40000001810134, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902896.957, "ph": "X", "dur": 62.30000002862217, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902889.957, "ph": "X", "dur": 69.9000000321138, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902888.057, "ph": "X", "dur": 72.20000003317048, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902961.157, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902874.057, "ph": "X", "dur": 88.10000004047532, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902861.657, "ph": "X", "dur": 101.00000004640191, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902976.757, "ph": "X", "dur": 0.10000000004594249, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902973.857, "ph": "X", "dur": 3.4000000015620446, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902979.057, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902981.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902981.557, "ph": "X", "dur": 0.9000000004134823, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902982.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902982.757, "ph": "X", "dur": 0.6000000002756549, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902983.657, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902981.157, "ph": "X", "dur": 3.2000000014701597, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902979.857, "ph": "X", "dur": 5.60000000257278, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902985.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902987.657, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902990.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902992.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902993.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902993.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902995.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902996.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902996.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902997.157, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902998.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902999.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902999.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902999.957, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903000.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903001.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903002.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903002.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903003.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902990.057, "ph": "X", "dur": 14.000000006431948, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902978.657, "ph": "X", "dur": 25.80000001185316, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903007.457, "ph": "X", "dur": 129.60000005954146, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903007.157, "ph": "X", "dur": 130.50000005995494, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903006.657, "ph": "X", "dur": 132.40000006082784, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903147.857, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903151.257, "ph": "X", "dur": 626.9000002880135, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903783.357, "ph": "X", "dur": 138.60000006367628, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903923.457, "ph": "X", "dur": 45.30000002081194, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903146.157, "ph": "X", "dur": 823.9000003785201, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903987.457, "ph": "X", "dur": 1.3000000005972523, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903992.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903994.757, "ph": "X", "dur": 0.9000000004134823, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903991.657, "ph": "X", "dur": 4.40000000202147, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529903982.257, "ph": "X", "dur": 15.500000007121086, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904008.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904009.657, "ph": "X", "dur": 0.5000000002297125, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904008.357, "ph": "X", "dur": 2.100000000964792, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904013.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904013.957, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904012.657, "ph": "X", "dur": 2.00000000091885, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904007.357, "ph": "X", "dur": 8.600000003951054, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904018.657, "ph": "X", "dur": 1.1000000005053674, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904023.457, "ph": "X", "dur": 244.00000011209966, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904268.857, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904271.857, "ph": "X", "dur": 0.6000000002756549, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904273.857, "ph": "X", "dur": 0.9000000004134823, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904022.857, "ph": "X", "dur": 252.100000115821, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902971.657, "ph": "X", "dur": 1303.6000005989063, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904307.957, "ph": "X", "dur": 0.7000000003215975, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904310.557, "ph": "X", "dur": 0.30000000013782746, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904313.657, "ph": "X", "dur": 0.5000000002297125, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904321.657, "ph": "X", "dur": 0.7000000003215975, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904319.157, "ph": "X", "dur": 3.700000001699872, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904326.057, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904313.257, "ph": "X", "dur": 13.30000000611035, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904328.157, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904329.757, "ph": "X", "dur": 0.10000000004594249, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904338.857, "ph": "X", "dur": 1.6000000007350799, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904335.357, "ph": "X", "dur": 5.400000002480894, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904341.357, "ph": "X", "dur": 2.900000001332332, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904332.057, "ph": "X", "dur": 12.90000000592658, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904345.757, "ph": "X", "dur": 0.6000000002756549, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904330.757, "ph": "X", "dur": 15.900000007304856, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904350.357, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904351.057, "ph": "X", "dur": 0.9000000004134823, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904353.357, "ph": "X", "dur": 1.000000000459425, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904352.957, "ph": "X", "dur": 1.6000000007350799, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904357.757, "ph": "X", "dur": 0.8000000003675399, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904356.357, "ph": "X", "dur": 2.3000000010566772, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904327.557, "ph": "X", "dur": 32.400000014885364, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904312.757, "ph": "X", "dur": 47.50000002182268, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904360.757, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904362.657, "ph": "X", "dur": 0.7000000003215975, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904366.957, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904366.857, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904369.257, "ph": "X", "dur": 4.0000000018377, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904368.957, "ph": "X", "dur": 4.6000000021133545, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904374.457, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904374.257, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904376.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904376.257, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904378.657, "ph": "X", "dur": 0.7000000003215975, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904378.357, "ph": "X", "dur": 1.3000000005972523, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904377.757, "ph": "X", "dur": 2.3000000010566772, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904380.857, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904380.657, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904382.057, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904381.957, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904386.157, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904387.457, "ph": "X", "dur": 1.1000000005053674, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904389.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904391.557, "ph": "X", "dur": 151.90000006978664, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904391.057, "ph": "X", "dur": 153.10000007033793, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904547.757, "ph": "X", "dur": 1.400000000643195, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904553.657, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904560.757, "ph": "X", "dur": 0.9000000004134823, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904562.157, "ph": "X", "dur": 0.9000000004134823, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904563.457, "ph": "X", "dur": 0.9000000004134823, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904567.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904567.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904568.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904569.457, "ph": "X", "dur": 0.7000000003215975, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904571.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904572.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904573.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904574.657, "ph": "X", "dur": 0.8000000003675399, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904552.757, "ph": "X", "dur": 23.500000010796484, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904578.257, "ph": "X", "dur": 0.7000000003215975, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904580.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904583.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904583.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904584.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904585.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904586.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904586.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904587.457, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904588.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904589.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904589.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904590.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904580.657, "ph": "X", "dur": 10.400000004778018, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904591.957, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904593.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904595.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904596.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904596.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904597.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904598.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904598.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904599.357, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904600.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904600.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904601.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904601.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904593.357, "ph": "X", "dur": 9.100000004180767, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904603.057, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904604.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904605.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904606.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904606.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904607.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904608.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904608.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904609.257, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904610.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904610.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904611.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904611.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904603.957, "ph": "X", "dur": 8.100000003721341, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904612.457, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904613.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904615.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904615.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904616.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904617.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904617.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904618.157, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904618.557, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904619.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904619.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904620.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904620.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904613.457, "ph": "X", "dur": 7.800000003583514, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904621.757, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904389.457, "ph": "X", "dur": 233.10000010709194, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904624.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904626.157, "ph": "X", "dur": 0.6000000002756549, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904627.657, "ph": "X", "dur": 0.6000000002756549, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904629.157, "ph": "X", "dur": 99.20000004557494, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904629.057, "ph": "X", "dur": 99.60000004575872, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904730.857, "ph": "X", "dur": 0.8000000003675399, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904734.657, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904738.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904739.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904739.757, "ph": "X", "dur": 0.6000000002756549, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904741.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904742.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904742.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904743.357, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904744.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904745.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904746.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904746.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904733.857, "ph": "X", "dur": 13.600000006248179, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904748.457, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904749.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904751.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904752.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904752.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904753.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904754.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904754.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904755.057, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904755.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904756.357, "ph": "X", "dur": 0.10000000004594249, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904756.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904757.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904749.757, "ph": "X", "dur": 8.100000003721341, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904758.357, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904759.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904761.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904761.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904761.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904763.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904763.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904763.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904764.357, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904765.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904765.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904766.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904766.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904759.357, "ph": "X", "dur": 7.800000003583514, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904767.657, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904768.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904770.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904770.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904770.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904772.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904772.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904772.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904773.457, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904774.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904774.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904775.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904775.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904768.457, "ph": "X", "dur": 7.700000003537571, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904776.657, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904777.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904779.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904779.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904780.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904781.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904781.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904782.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904782.657, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904783.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904783.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904784.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904784.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904777.457, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904785.857, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904627.457, "ph": "X", "dur": 159.00000007304854, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904787.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904789.257, "ph": "X", "dur": 0.9000000004134823, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904790.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904792.057, "ph": "X", "dur": 89.10000004093476, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904791.857, "ph": "X", "dur": 89.70000004121042, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904883.557, "ph": "X", "dur": 0.8000000003675399, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904887.157, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904890.357, "ph": "X", "dur": 0.7000000003215975, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904891.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904891.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904893.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904894.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904894.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904895.157, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904896.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904896.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904897.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904897.957, "ph": "X", "dur": 0.9000000004134823, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904886.657, "ph": "X", "dur": 12.90000000592658, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904900.457, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904901.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904903.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904904.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904904.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904905.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904906.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904906.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904907.257, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904908.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904908.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904909.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904909.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904901.857, "ph": "X", "dur": 8.300000003813226, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904910.757, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904911.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904913.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904913.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904914.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904915.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904915.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904916.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904916.857, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904917.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904918.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904918.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904918.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904911.757, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904920.257, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904921.357, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904931.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904931.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904932.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904933.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904933.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904934.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904934.857, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904935.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904936.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904936.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904937.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904921.157, "ph": "X", "dur": 16.600000007626452, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904938.257, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904939.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904940.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904941.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904941.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904943.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904943.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904943.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904944.357, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904945.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904945.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904946.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904946.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904939.357, "ph": "X", "dur": 7.600000003491629, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904947.457, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904790.657, "ph": "X", "dur": 157.50000007235943, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904949.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904950.157, "ph": "X", "dur": 1.000000000459425, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904951.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904953.057, "ph": "X", "dur": 82.6000000379485, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904952.857, "ph": "X", "dur": 83.20000003822415, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905037.757, "ph": "X", "dur": 0.6000000002756549, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905040.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905043.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905044.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905044.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905046.557, "ph": "X", "dur": 0.10000000004594249, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905046.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905047.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905047.857, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905048.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905049.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905050.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905050.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905040.457, "ph": "X", "dur": 11.000000005053673, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905052.257, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905053.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905055.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905055.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905056.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905057.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905057.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905058.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905058.857, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905059.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905060.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905060.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905060.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905053.757, "ph": "X", "dur": 7.800000003583514, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905062.057, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905063.357, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905064.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905065.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905065.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905066.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905067.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905067.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905068.157, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905068.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905069.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905069.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905070.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905063.157, "ph": "X", "dur": 7.700000003537571, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905071.457, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905074.657, "ph": "X", "dur": 88.30000004056721, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905074.257, "ph": "X", "dur": 89.10000004093476, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905073.857, "ph": "X", "dur": 91.20000004189954, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905073.257, "ph": "X", "dur": 92.40000004245086, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905168.757, "ph": "X", "dur": 0.30000000013782746, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905170.957, "ph": "X", "dur": 0.5000000002297125, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905173.257, "ph": "X", "dur": 1.6000000007350799, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905175.557, "ph": "X", "dur": 0.9000000004134823, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905177.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905178.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905178.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905172.757, "ph": "X", "dur": 6.600000003032204, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905172.257, "ph": "X", "dur": 7.3000000033538015, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905182.657, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905170.557, "ph": "X", "dur": 15.500000007121086, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905167.057, "ph": "X", "dur": 19.3000000088669, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904951.657, "ph": "X", "dur": 235.30000010810267, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904384.757, "ph": "X", "dur": 803.300000369056, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904383.557, "ph": "X", "dur": 805.1000003698829, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905190.557, "ph": "X", "dur": 0.40000000018376997, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905189.957, "ph": "X", "dur": 1.2000000005513098, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904364.557, "ph": "X", "dur": 828.4000003805876, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905195.057, "ph": "X", "dur": 1.8000000008269645, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905197.757, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905198.757, "ph": "X", "dur": 0.20000000009188498, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905199.757, "ph": "X", "dur": 3.100000001424217, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905204.457, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905205.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905206.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905208.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905208.057, "ph": "X", "dur": 1.2000000005513098, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905210.057, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905211.357, "ph": "X", "dur": 0.10000000004594249, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905211.857, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905214.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905216.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905218.557, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905224.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905223.557, "ph": "X", "dur": 1.400000000643195, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905225.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905225.357, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905226.557, "ph": "X", "dur": 0.30000000013782746, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905222.657, "ph": "X", "dur": 5.200000002389009, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905219.957, "ph": "X", "dur": 10.100000004640192, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905230.557, "ph": "X", "dur": 0.7000000003215975, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905232.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905236.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905239.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905239.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905240.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905242.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905243.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905243.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905244.257, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905245.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905246.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905246.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905247.257, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905248.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905249.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905249.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905250.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905251.157, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905236.557, "ph": "X", "dur": 15.600000007167028, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905218.357, "ph": "X", "dur": 34.30000001575827, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905215.657, "ph": "X", "dur": 37.400000017182485, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905215.057, "ph": "X", "dur": 38.30000001759597, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905253.657, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905203.957, "ph": "X", "dur": 50.500000023200954, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905197.457, "ph": "X", "dur": 57.40000002637099, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905259.557, "ph": "X", "dur": 0.10000000004594249, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905257.457, "ph": "X", "dur": 2.700000001240447, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905261.257, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905263.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905263.357, "ph": "X", "dur": 0.9000000004134823, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905264.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905264.557, "ph": "X", "dur": 0.6000000002756549, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905265.457, "ph": "X", "dur": 0.10000000004594249, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905263.157, "ph": "X", "dur": 2.80000000128639, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905262.057, "ph": "X", "dur": 4.6000000021133545, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905266.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905268.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905270.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905272.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905272.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905273.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905274.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905274.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905275.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905276.057, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905277.357, "ph": "X", "dur": 0.10000000004594249, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905277.757, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905278.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905278.557, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905279.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905279.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905280.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905281.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905281.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905270.157, "ph": "X", "dur": 12.10000000555904, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905261.057, "ph": "X", "dur": 21.50000000987763, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905284.157, "ph": "X", "dur": 86.4000000396943, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905284.057, "ph": "X", "dur": 86.90000003992402, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905283.557, "ph": "X", "dur": 88.30000004056721, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905375.757, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905377.557, "ph": "X", "dur": 587.700000270004, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905969.457, "ph": "X", "dur": 133.7000000614251, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906104.557, "ph": "X", "dur": 49.400000022695586, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905374.757, "ph": "X", "dur": 780.8000003587189, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906169.757, "ph": "X", "dur": 1.400000000643195, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906174.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906177.257, "ph": "X", "dur": 1.2000000005513098, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906173.457, "ph": "X", "dur": 5.400000002480894, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906164.557, "ph": "X", "dur": 16.90000000776428, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906195.157, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906196.957, "ph": "X", "dur": 0.5000000002297125, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906194.657, "ph": "X", "dur": 3.300000001516102, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906203.457, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906205.457, "ph": "X", "dur": 0.7000000003215975, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906202.657, "ph": "X", "dur": 4.0000000018377, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906193.357, "ph": "X", "dur": 16.90000000776428, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906213.757, "ph": "X", "dur": 3.700000001699872, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906221.557, "ph": "X", "dur": 179.80000008260458, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906800.657, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906804.257, "ph": "X", "dur": 1.3000000005972523, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906806.757, "ph": "X", "dur": 1.000000000459425, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906219.957, "ph": "X", "dur": 588.1000002701877, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905256.857, "ph": "X", "dur": 1551.7000007128895, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906835.357, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906836.557, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906834.057, "ph": "X", "dur": 4.40000000202147, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906848.057, "ph": "X", "dur": 0.8000000003675399, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906851.357, "ph": "X", "dur": 0.30000000013782746, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906854.257, "ph": "X", "dur": 0.7000000003215975, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906862.057, "ph": "X", "dur": 0.8000000003675399, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906859.557, "ph": "X", "dur": 3.900000001791757, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906866.457, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906853.957, "ph": "X", "dur": 13.000000005972522, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906868.557, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906870.357, "ph": "X", "dur": 0.10000000004594249, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906878.957, "ph": "X", "dur": 1.3000000005972523, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906876.257, "ph": "X", "dur": 4.300000001975527, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906881.157, "ph": "X", "dur": 3.2000000014701597, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906872.857, "ph": "X", "dur": 12.200000005604982, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906885.957, "ph": "X", "dur": 0.8000000003675399, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906871.457, "ph": "X", "dur": 15.500000007121086, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906890.457, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906891.157, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906893.257, "ph": "X", "dur": 1.000000000459425, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906892.857, "ph": "X", "dur": 1.7000000007810223, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906897.857, "ph": "X", "dur": 0.8000000003675399, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906896.457, "ph": "X", "dur": 2.700000001240447, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906868.257, "ph": "X", "dur": 32.0000000147016, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906853.557, "ph": "X", "dur": 46.90000002154703, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906901.157, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906902.957, "ph": "X", "dur": 0.6000000002756549, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906907.257, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906907.157, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906909.157, "ph": "X", "dur": 3.900000001791757, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906908.957, "ph": "X", "dur": 4.40000000202147, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906914.157, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906914.057, "ph": "X", "dur": 1.000000000459425, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906916.557, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906916.457, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906954.057, "ph": "X", "dur": 1.2000000005513098, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906953.457, "ph": "X", "dur": 2.3000000010566772, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906952.357, "ph": "X", "dur": 4.0000000018377, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906957.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906957.557, "ph": "X", "dur": 0.8000000003675399, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906960.557, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906960.357, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906965.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906967.757, "ph": "X", "dur": 1.3000000005972523, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906970.657, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906973.257, "ph": "X", "dur": 202.10000009284977, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906972.357, "ph": "X", "dur": 204.00000009372266, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907180.557, "ph": "X", "dur": 2.00000000091885, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907187.757, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907197.457, "ph": "X", "dur": 0.9000000004134823, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907199.057, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907200.257, "ph": "X", "dur": 1.000000000459425, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907204.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907205.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907206.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907207.857, "ph": "X", "dur": 0.9000000004134823, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907210.557, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907212.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907213.457, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907214.657, "ph": "X", "dur": 1.1000000005053674, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907186.557, "ph": "X", "dur": 30.100000013828687, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907219.057, "ph": "X", "dur": 0.8000000003675399, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907222.957, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907227.357, "ph": "X", "dur": 0.5000000002297125, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907228.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907229.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907231.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907232.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907233.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907234.957, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907236.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907237.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907239.157, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907240.157, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907222.457, "ph": "X", "dur": 19.00000000872907, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907242.957, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907245.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907249.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907250.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907251.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907254.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907255.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907255.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907257.157, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907258.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907260.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907261.257, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907262.257, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907245.257, "ph": "X", "dur": 18.400000008453418, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907264.957, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907267.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907271.557, "ph": "X", "dur": 0.5000000002297125, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907272.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907273.457, "ph": "X", "dur": 0.6000000002756549, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907276.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907277.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907278.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907279.157, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907280.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907281.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907282.957, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907283.957, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907267.457, "ph": "X", "dur": 17.900000008223707, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907286.557, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907289.157, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907293.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907294.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907295.357, "ph": "X", "dur": 0.6000000002756549, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907298.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907298.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907299.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907301.257, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907302.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907304.057, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907305.257, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907306.157, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907288.757, "ph": "X", "dur": 18.900000008683133, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907308.857, "ph": "X", "dur": 0.5000000002297125, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906970.257, "ph": "X", "dur": 340.20000015629637, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907313.157, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907315.957, "ph": "X", "dur": 1.2000000005513098, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907318.657, "ph": "X", "dur": 0.8000000003675399, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907321.157, "ph": "X", "dur": 153.7000000706136, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907320.857, "ph": "X", "dur": 155.1000000712568, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907483.257, "ph": "X", "dur": 2.3000000010566772, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907490.257, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907502.957, "ph": "X", "dur": 0.8000000003675399, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907504.357, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907505.257, "ph": "X", "dur": 0.8000000003675399, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907508.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907509.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907509.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907510.857, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907512.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907513.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907514.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907515.857, "ph": "X", "dur": 1.1000000005053674, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907489.057, "ph": "X", "dur": 28.700000013185495, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907519.457, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907522.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907524.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907525.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907525.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907527.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907527.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907528.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907528.757, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907529.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907530.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907530.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907531.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907521.757, "ph": "X", "dur": 10.400000004778018, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907532.957, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907534.357, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907536.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907536.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907537.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907538.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907538.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907539.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907539.857, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907540.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907541.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907541.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907542.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907534.057, "ph": "X", "dur": 8.700000003996996, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907543.357, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907544.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907546.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907546.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907547.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907548.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907548.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907549.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907549.757, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907550.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907550.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907551.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907551.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907544.357, "ph": "X", "dur": 8.0000000036754, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907552.857, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907553.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907555.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907556.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907556.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907557.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907558.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907558.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907559.057, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907559.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907560.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907560.757, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907561.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907553.757, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907562.157, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907318.157, "ph": "X", "dur": 244.70000011242126, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907564.957, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907566.957, "ph": "X", "dur": 1.000000000459425, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907569.157, "ph": "X", "dur": 0.6000000002756549, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907571.157, "ph": "X", "dur": 113.7000000522366, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907570.657, "ph": "X", "dur": 114.70000005269604, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907687.957, "ph": "X", "dur": 1.5000000006891374, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907692.157, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907696.457, "ph": "X", "dur": 0.6000000002756549, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907697.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907698.057, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907700.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907700.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907701.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907701.657, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907703.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907703.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907704.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907705.057, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907691.557, "ph": "X", "dur": 14.700000006753546, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907707.257, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907709.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907710.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907725.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907725.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907726.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907727.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907727.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907728.357, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907729.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907729.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907730.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907730.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907708.957, "ph": "X", "dur": 22.300000010245174, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907731.857, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907735.357, "ph": "X", "dur": 103.70000004764236, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907734.957, "ph": "X", "dur": 104.5000000480099, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907734.457, "ph": "X", "dur": 106.4000000488828, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907733.757, "ph": "X", "dur": 108.00000004961788, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907847.857, "ph": "X", "dur": 0.40000000018376997, "name": "ExtensionFileLoader.__init__ (<frozen importlib._bootstrap_external>:1307)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907850.657, "ph": "X", "dur": 0.8000000003675399, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907853.357, "ph": "X", "dur": 2.00000000091885, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907855.957, "ph": "X", "dur": 1.1000000005053674, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907857.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907858.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907859.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907852.857, "ph": "X", "dur": 7.3000000033538015, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907852.057, "ph": "X", "dur": 8.500000003905113, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907863.957, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907850.257, "ph": "X", "dur": 17.000000007810225, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907843.257, "ph": "X", "dur": 24.300000011164027, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907568.857, "ph": "X", "dur": 299.4000001375518, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906964.357, "ph": "X", "dur": 905.0000004157795, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906962.857, "ph": "X", "dur": 907.1000004167443, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907872.157, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907871.557, "ph": "X", "dur": 1.5000000006891374, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906904.757, "ph": "X", "dur": 970.200000445734, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907877.657, "ph": "X", "dur": 1.9000000008729072, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907880.457, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907884.257, "ph": "X", "dur": 918.8000004221195, "name": "_imp.create_dynamic", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907883.357, "ph": "X", "dur": 921.50000042336, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908812.157, "ph": "X", "dur": 1.6000000007350799, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907882.557, "ph": "X", "dur": 931.6000004280003, "name": "ExtensionFileLoader.create_module (<frozen importlib._bootstrap_external>:1318)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908817.757, "ph": "X", "dur": 1.5000000006891374, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908820.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908821.857, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908824.957, "ph": "X", "dur": 1.6000000007350799, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908823.457, "ph": "X", "dur": 4.100000001883641, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908828.657, "ph": "X", "dur": 1.3000000005972523, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908830.657, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908831.557, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908834.257, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908839.957, "ph": "X", "dur": 1.2000000005513098, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908843.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908836.757, "ph": "X", "dur": 7.200000003307858, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908835.357, "ph": "X", "dur": 9.200000004226709, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908816.357, "ph": "X", "dur": 28.60000001313955, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907880.057, "ph": "X", "dur": 965.4000004435287, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908884.557, "ph": "X", "dur": 83.1000000381782, "name": "_imp.exec_dynamic", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908883.457, "ph": "X", "dur": 84.5000000388214, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908970.057, "ph": "X", "dur": 0.7000000003215975, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908881.757, "ph": "X", "dur": 89.30000004102664, "name": "ExtensionFileLoader.exec_module (<frozen importlib._bootstrap_external>:1326)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908971.857, "ph": "X", "dur": 1.000000000459425, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908974.057, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529907876.657, "ph": "X", "dur": 1097.9000005044024, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906902.457, "ph": "X", "dur": 2073.1000009524337, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908982.457, "ph": "X", "dur": 1.000000000459425, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908987.757, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908989.357, "ph": "X", "dur": 0.7000000003215975, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908990.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908991.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908991.857, "ph": "X", "dur": 0.9000000004134823, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908981.757, "ph": "X", "dur": 11.400000005237443, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908978.757, "ph": "X", "dur": 14.90000000684543, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908998.457, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908999.757, "ph": "X", "dur": 0.8000000003675399, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909001.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529908997.957, "ph": "X", "dur": 3.8000000017458144, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906847.357, "ph": "X", "dur": 2157.7000009913013, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909019.657, "ph": "X", "dur": 1.400000000643195, "name": "Full (C:\\Programming\\Python313\\Lib\\queue.py:31)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909015.657, "ph": "X", "dur": 31.30000001438, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909049.457, "ph": "X", "dur": 0.8000000003675399, "name": "ShutDown (C:\\Programming\\Python313\\Lib\\queue.py:36)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909048.357, "ph": "X", "dur": 19.800000009096614, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909071.557, "ph": "X", "dur": 35.80000001644741, "name": "Queue (C:\\Programming\\Python313\\Lib\\queue.py:40)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909069.057, "ph": "X", "dur": 60.5000000277952, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909132.557, "ph": "X", "dur": 2.6000000011945046, "name": "PriorityQueue (C:\\Programming\\Python313\\Lib\\queue.py:281)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909130.757, "ph": "X", "dur": 23.500000010796484, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909156.357, "ph": "X", "dur": 2.3000000010566772, "name": "LifoQueue (C:\\Programming\\Python313\\Lib\\queue.py:300)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909154.957, "ph": "X", "dur": 22.800000010474886, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909180.757, "ph": "X", "dur": 8.300000003813226, "name": "_PySimpleQueue (C:\\Programming\\Python313\\Lib\\queue.py:316)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909179.157, "ph": "X", "dur": 24.800000011393735, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906824.357, "ph": "X", "dur": 2380.3000010935693, "name": "<module> (C:\\Programming\\Python313\\Lib\\queue.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906816.957, "ph": "X", "dur": 2388.600001097382, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529906816.157, "ph": "X", "dur": 2389.600001097842, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905256.157, "ph": "X", "dur": 3950.4000018149122, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909207.457, "ph": "X", "dur": 0.9000000004134823, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909209.957, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529905194.157, "ph": "X", "dur": 4016.5000018452797, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904362.057, "ph": "X", "dur": 4849.200002227843, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909213.857, "ph": "X", "dur": 0.30000000013782746, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909215.757, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909216.457, "ph": "X", "dur": 0.5000000002297125, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909217.257, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909217.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909218.357, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909213.357, "ph": "X", "dur": 5.700000002618721, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909212.657, "ph": "X", "dur": 6.700000003078147, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909220.957, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909221.557, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909222.457, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909220.757, "ph": "X", "dur": 2.00000000091885, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904307.057, "ph": "X", "dur": 4917.200002259084, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909229.257, "ph": "X", "dur": 0.9000000004134823, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909228.657, "ph": "X", "dur": 2.00000000091885, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909235.257, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909237.257, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909243.757, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909245.857, "ph": "X", "dur": 0.30000000013782746, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909248.457, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909254.857, "ph": "X", "dur": 4.0000000018377, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909252.957, "ph": "X", "dur": 6.4000000029403195, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909262.157, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909248.257, "ph": "X", "dur": 14.300000006569775, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909263.557, "ph": "X", "dur": 0.30000000013782746, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909264.957, "ph": "X", "dur": 0.20000000009188498, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909273.057, "ph": "X", "dur": 1.000000000459425, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909270.957, "ph": "X", "dur": 3.4000000015620446, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909275.057, "ph": "X", "dur": 2.80000000128639, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909267.357, "ph": "X", "dur": 11.20000000514556, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909279.257, "ph": "X", "dur": 0.6000000002756549, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909266.057, "ph": "X", "dur": 14.000000006431948, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909281.957, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909282.857, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909284.557, "ph": "X", "dur": 0.9000000004134823, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909284.257, "ph": "X", "dur": 1.400000000643195, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909288.057, "ph": "X", "dur": 0.8000000003675399, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909286.757, "ph": "X", "dur": 2.3000000010566772, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909263.457, "ph": "X", "dur": 26.400000012128817, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909247.757, "ph": "X", "dur": 42.40000001947961, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909290.657, "ph": "X", "dur": 0.20000000009188498, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909291.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909294.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909298.657, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909298.557, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909300.657, "ph": "X", "dur": 3.700000001699872, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909300.357, "ph": "X", "dur": 4.200000001929584, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909305.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909305.157, "ph": "X", "dur": 0.8000000003675399, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909307.457, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909307.357, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909309.757, "ph": "X", "dur": 0.8000000003675399, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909309.457, "ph": "X", "dur": 1.2000000005513098, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909308.857, "ph": "X", "dur": 2.3000000010566772, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909311.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909311.757, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909313.057, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909312.957, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909316.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909318.057, "ph": "X", "dur": 1.000000000459425, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909320.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909321.957, "ph": "X", "dur": 147.60000006781112, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909321.357, "ph": "X", "dur": 149.10000006850026, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909473.357, "ph": "X", "dur": 1.1000000005053674, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909478.357, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909485.057, "ph": "X", "dur": 1.2000000005513098, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909486.757, "ph": "X", "dur": 0.6000000002756549, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909487.757, "ph": "X", "dur": 0.9000000004134823, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909490.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909491.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909492.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909493.257, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909495.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909496.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909496.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909497.857, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909477.257, "ph": "X", "dur": 22.000000010107346, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909500.857, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909502.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909504.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909505.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909506.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909507.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909508.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909508.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909509.257, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909510.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909510.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909511.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909511.657, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909502.557, "ph": "X", "dur": 10.200000004686133, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909513.557, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909514.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909516.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909517.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909517.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909518.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909519.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909519.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909520.157, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909520.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909521.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909522.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909522.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909514.757, "ph": "X", "dur": 8.400000003859168, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909523.657, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909526.657, "ph": "X", "dur": 98.4000000452074, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909526.357, "ph": "X", "dur": 99.100000045529, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909525.957, "ph": "X", "dur": 101.30000004653974, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909525.357, "ph": "X", "dur": 102.90000004727482, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909631.057, "ph": "X", "dur": 0.20000000009188498, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909633.157, "ph": "X", "dur": 0.6000000002756549, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909635.357, "ph": "X", "dur": 2.200000001010735, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909638.157, "ph": "X", "dur": 1.000000000459425, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909639.757, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909640.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909641.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909635.057, "ph": "X", "dur": 7.000000003215974, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909634.557, "ph": "X", "dur": 7.800000003583514, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909644.957, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909632.757, "ph": "X", "dur": 15.100000006937314, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909629.557, "ph": "X", "dur": 18.600000008545305, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909319.857, "ph": "X", "dur": 328.9000001511048, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909315.457, "ph": "X", "dur": 334.90000015386136, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909314.457, "ph": "X", "dur": 336.8000001547343, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909653.557, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909652.957, "ph": "X", "dur": 1.2000000005513098, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909296.257, "ph": "X", "dur": 359.900000165347, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909657.157, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909659.757, "ph": "X", "dur": 4.40000000202147, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909666.057, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909667.657, "ph": "X", "dur": 0.5000000002297125, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909669.357, "ph": "X", "dur": 5.400000002480894, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909676.457, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909677.757, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909679.757, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909682.657, "ph": "X", "dur": 1.3000000005972523, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909681.557, "ph": "X", "dur": 3.600000001653929, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909686.457, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909688.457, "ph": "X", "dur": 0.30000000013782746, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909691.957, "ph": "X", "dur": 1.000000000459425, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909695.057, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909699.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909701.257, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909706.357, "ph": "X", "dur": 0.6000000002756549, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909705.857, "ph": "X", "dur": 1.5000000006891374, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909708.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909707.857, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909709.057, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909705.057, "ph": "X", "dur": 5.200000002389009, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909702.457, "ph": "X", "dur": 10.400000004778018, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909713.557, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909715.757, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909720.257, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909724.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909725.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909725.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909728.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909729.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909729.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909730.257, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909732.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909732.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909732.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909733.557, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909734.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909735.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909736.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909737.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909737.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909719.757, "ph": "X", "dur": 19.100000008775016, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909700.957, "ph": "X", "dur": 38.50000001768786, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909697.857, "ph": "X", "dur": 42.00000001929585, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909696.457, "ph": "X", "dur": 43.60000002003092, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909740.557, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909675.757, "ph": "X", "dur": 65.50000003009232, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909665.257, "ph": "X", "dur": 76.30000003505413, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909746.757, "ph": "X", "dur": 0.10000000004594249, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909744.657, "ph": "X", "dur": 2.6000000011945046, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909748.357, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909750.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909750.157, "ph": "X", "dur": 0.8000000003675399, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909751.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909751.157, "ph": "X", "dur": 0.8000000003675399, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909752.157, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909749.857, "ph": "X", "dur": 2.80000000128639, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909748.957, "ph": "X", "dur": 4.500000002067411, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909753.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909754.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909757.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909759.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909759.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909759.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909761.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909761.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909762.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909762.957, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909764.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909764.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909765.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909765.557, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909766.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909766.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909767.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909768.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909768.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909756.757, "ph": "X", "dur": 12.600000005788754, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909748.057, "ph": "X", "dur": 21.70000000996952, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909771.157, "ph": "X", "dur": 99.30000004562089, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909770.957, "ph": "X", "dur": 99.90000004589653, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909770.557, "ph": "X", "dur": 101.40000004658569, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909875.757, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909878.157, "ph": "X", "dur": 736.9000003385502, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910619.257, "ph": "X", "dur": 124.3000000571065, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910744.657, "ph": "X", "dur": 29.000000013323323, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909875.057, "ph": "X", "dur": 899.6000004132986, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910786.157, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910789.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910792.457, "ph": "X", "dur": 0.8000000003675399, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910789.357, "ph": "X", "dur": 4.40000000202147, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910781.557, "ph": "X", "dur": 13.800000006340062, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910803.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910804.657, "ph": "X", "dur": 0.5000000002297125, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910803.257, "ph": "X", "dur": 2.200000001010735, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910808.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910809.257, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910808.057, "ph": "X", "dur": 1.9000000008729072, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910802.357, "ph": "X", "dur": 8.500000003905113, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910813.557, "ph": "X", "dur": 1.3000000005972523, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910816.757, "ph": "X", "dur": 516.9000002374768, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911335.057, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911337.757, "ph": "X", "dur": 0.6000000002756549, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911339.257, "ph": "X", "dur": 0.9000000004134823, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529910816.157, "ph": "X", "dur": 524.2000002408305, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909743.957, "ph": "X", "dur": 1596.7000007335637, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911374.657, "ph": "X", "dur": 1.400000000643195, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911373.757, "ph": "X", "dur": 3.300000001516102, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911381.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911383.057, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911390.357, "ph": "X", "dur": 0.7000000003215975, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911393.357, "ph": "X", "dur": 0.20000000009188498, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911395.657, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911403.157, "ph": "X", "dur": 0.8000000003675399, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911401.457, "ph": "X", "dur": 3.100000001424217, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911407.557, "ph": "X", "dur": 0.5000000002297125, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911395.357, "ph": "X", "dur": 12.90000000592658, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911409.457, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911410.857, "ph": "X", "dur": 0.20000000009188498, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911419.757, "ph": "X", "dur": 1.1000000005053674, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911416.757, "ph": "X", "dur": 4.300000001975527, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911421.657, "ph": "X", "dur": 2.80000000128639, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911413.257, "ph": "X", "dur": 11.800000005421214, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911425.857, "ph": "X", "dur": 0.6000000002756549, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911411.857, "ph": "X", "dur": 14.90000000684543, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911430.157, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911430.857, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911432.957, "ph": "X", "dur": 0.9000000004134823, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911432.457, "ph": "X", "dur": 1.6000000007350799, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911437.157, "ph": "X", "dur": 0.8000000003675399, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911435.957, "ph": "X", "dur": 2.200000001010735, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911409.257, "ph": "X", "dur": 30.300000013920574, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911394.857, "ph": "X", "dur": 44.90000002062818, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911440.257, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911441.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911443.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911447.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911447.157, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911449.257, "ph": "X", "dur": 3.500000001607987, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911448.957, "ph": "X", "dur": 4.0000000018377, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911453.757, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911453.557, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911455.857, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911455.757, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911458.157, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911457.757, "ph": "X", "dur": 1.2000000005513098, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911457.157, "ph": "X", "dur": 2.3000000010566772, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911460.257, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911460.157, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911461.557, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911461.457, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911464.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911465.957, "ph": "X", "dur": 0.9000000004134823, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911467.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911469.757, "ph": "X", "dur": 147.40000006771922, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911469.257, "ph": "X", "dur": 148.40000006817866, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911620.257, "ph": "X", "dur": 1.2000000005513098, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911625.157, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911632.257, "ph": "X", "dur": 0.7000000003215975, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911633.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911634.057, "ph": "X", "dur": 1.2000000005513098, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911637.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911638.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911639.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911639.957, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911641.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911642.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911643.757, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911644.657, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911624.357, "ph": "X", "dur": 21.70000000996952, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911647.557, "ph": "X", "dur": 0.5000000002297125, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911649.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911652.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911652.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911653.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911655.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911655.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911656.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911656.857, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911657.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911658.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911658.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911659.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911649.757, "ph": "X", "dur": 10.500000004823962, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911661.157, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911662.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911664.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911664.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911665.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911666.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911667.157, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911667.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911668.057, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911668.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911669.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911669.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911670.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911662.357, "ph": "X", "dur": 8.700000003996996, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911671.557, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911674.657, "ph": "X", "dur": 93.40000004291028, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911674.357, "ph": "X", "dur": 94.10000004323187, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911673.857, "ph": "X", "dur": 95.8000000440129, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911672.957, "ph": "X", "dur": 97.50000004479392, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911772.857, "ph": "X", "dur": 0.30000000013782746, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911775.057, "ph": "X", "dur": 0.6000000002756549, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911777.157, "ph": "X", "dur": 1.8000000008269645, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911779.557, "ph": "X", "dur": 0.8000000003675399, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911780.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911781.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911782.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911776.757, "ph": "X", "dur": 6.300000002894377, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911776.257, "ph": "X", "dur": 7.100000003261917, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911785.857, "ph": "X", "dur": 0.6000000002756549, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911774.557, "ph": "X", "dur": 13.900000006386007, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911771.657, "ph": "X", "dur": 17.100000007856163, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911467.657, "ph": "X", "dur": 321.70000014779697, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911463.757, "ph": "X", "dur": 326.6000001500482, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911462.857, "ph": "X", "dur": 328.40000015087514, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911792.657, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911792.257, "ph": "X", "dur": 0.8000000003675399, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911445.157, "ph": "X", "dur": 349.3000001604771, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911795.257, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911797.057, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911799.257, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911800.157, "ph": "X", "dur": 0.20000000009188498, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911801.057, "ph": "X", "dur": 2.3000000010566772, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911804.657, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911805.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911806.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911808.157, "ph": "X", "dur": 0.6000000002756549, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911807.757, "ph": "X", "dur": 1.400000000643195, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911809.757, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911810.957, "ph": "X", "dur": 0.10000000004594249, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911811.357, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911813.157, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911815.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911817.257, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911822.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911821.357, "ph": "X", "dur": 1.7000000007810223, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911823.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911823.457, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911824.557, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911820.457, "ph": "X", "dur": 5.200000002389009, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911818.357, "ph": "X", "dur": 9.500000004364535, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911828.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911830.657, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911834.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911837.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911837.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911838.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911840.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911840.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911841.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911842.157, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911843.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911844.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911844.557, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911844.957, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911846.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911846.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911847.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911848.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911848.857, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911834.257, "ph": "X", "dur": 15.700000007212969, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911817.057, "ph": "X", "dur": 33.400000015344794, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911814.657, "ph": "X", "dur": 36.30000001667712, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911813.957, "ph": "X", "dur": 37.20000001709061, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911851.657, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911804.157, "ph": "X", "dur": 48.100000022098335, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911798.857, "ph": "X", "dur": 53.70000002467111, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911857.057, "ph": "X", "dur": 0.10000000004594249, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911855.257, "ph": "X", "dur": 2.3000000010566772, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911858.557, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911860.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911860.357, "ph": "X", "dur": 0.8000000003675399, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911861.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911861.457, "ph": "X", "dur": 0.6000000002756549, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911862.357, "ph": "X", "dur": 0.10000000004594249, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911860.157, "ph": "X", "dur": 2.80000000128639, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911859.157, "ph": "X", "dur": 4.6000000021133545, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911864.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911865.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911867.257, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911869.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911869.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911870.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911871.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911872.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911872.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911873.057, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911874.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911874.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911875.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911875.657, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911876.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911876.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911877.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911878.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911878.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911867.057, "ph": "X", "dur": 12.300000005650926, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911858.357, "ph": "X", "dur": 21.400000009831693, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911881.157, "ph": "X", "dur": 82.70000003799444, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911880.957, "ph": "X", "dur": 83.3000000382701, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911880.557, "ph": "X", "dur": 84.60000003886734, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911968.857, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911970.457, "ph": "X", "dur": 724.6000003328993, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912699.057, "ph": "X", "dur": 117.90000005416618, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912817.957, "ph": "X", "dur": 28.800000013231433, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911968.057, "ph": "X", "dur": 879.60000040411, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912858.957, "ph": "X", "dur": 1.3000000005972523, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912862.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912864.957, "ph": "X", "dur": 0.7000000003215975, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912862.257, "ph": "X", "dur": 4.0000000018377, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912854.857, "ph": "X", "dur": 12.90000000592658, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912875.757, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912876.857, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912875.457, "ph": "X", "dur": 2.200000001010735, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912880.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912881.057, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912879.857, "ph": "X", "dur": 1.9000000008729072, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912874.457, "ph": "X", "dur": 8.200000003767283, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912884.757, "ph": "X", "dur": 1.400000000643195, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912888.157, "ph": "X", "dur": 252.8000001161426, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913142.057, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913144.457, "ph": "X", "dur": 0.6000000002756549, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913145.857, "ph": "X", "dur": 0.9000000004134823, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529912887.557, "ph": "X", "dur": 259.5000001192208, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911854.557, "ph": "X", "dur": 1292.8000005939446, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913175.157, "ph": "X", "dur": 1.3000000005972523, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913174.257, "ph": "X", "dur": 2.80000000128639, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913181.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913182.657, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913180.557, "ph": "X", "dur": 3.2000000014701597, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913191.557, "ph": "X", "dur": 1.400000000643195, "name": "_platform_supports_abstract_sockets (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:104)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913206.357, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913209.357, "ph": "X", "dur": 0.6000000002756549, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913211.657, "ph": "X", "dur": 0.30000000013782746, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913205.557, "ph": "X", "dur": 6.900000003170031, "name": "WeakValueDictionary.update (C:\\Programming\\Python313\\Lib\\weakref.py:289)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913198.157, "ph": "X", "dur": 15.300000007029201, "name": "WeakValueDictionary.__init__ (C:\\Programming\\Python313\\Lib\\weakref.py:104)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913222.557, "ph": "X", "dur": 7.600000003491629, "name": "Finalize (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:174)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913219.257, "ph": "X", "dur": 36.70000001686089, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913259.357, "ph": "X", "dur": 1.400000000643195, "name": "atexit.register", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913262.757, "ph": "X", "dur": 1.6000000007350799, "name": "ForkAwareThreadLock (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:360)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913261.357, "ph": "X", "dur": 17.80000000817776, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913281.657, "ph": "X", "dur": 1.2000000005513098, "name": "ForkAwareLocal (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:377)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913280.357, "ph": "X", "dur": 21.000000009647923, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913308.257, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913160.957, "ph": "X", "dur": 154.70000007107305, "name": "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913153.157, "ph": "X", "dur": 163.40000007507, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913152.257, "ph": "X", "dur": 164.60000007562132, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911853.957, "ph": "X", "dur": 1463.3000006722764, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913318.257, "ph": "X", "dur": 1.1000000005053674, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913320.657, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911796.457, "ph": "X", "dur": 1524.900000700577, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913322.057, "ph": "X", "dur": 0.7000000003215975, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913323.957, "ph": "X", "dur": 1.7000000007810223, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911441.457, "ph": "X", "dur": 1884.4000008657401, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913328.957, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913332.557, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913333.457, "ph": "X", "dur": 0.5000000002297125, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913334.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913335.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913335.557, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913328.457, "ph": "X", "dur": 8.100000003721341, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913327.757, "ph": "X", "dur": 9.000000004134822, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913339.457, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913340.257, "ph": "X", "dur": 0.6000000002756549, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913341.857, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913339.157, "ph": "X", "dur": 3.100000001424217, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911389.757, "ph": "X", "dur": 1954.300000897854, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911386.257, "ph": "X", "dur": 1960.3000009006105, "name": "builtins.__import__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911385.857, "ph": "X", "dur": 1960.9000009008862, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911380.957, "ph": "X", "dur": 1966.500000903459, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913350.057, "ph": "X", "dur": 0.8000000003675399, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913349.657, "ph": "X", "dur": 1.6000000007350799, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913353.357, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913354.257, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913355.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913356.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913352.557, "ph": "X", "dur": 4.100000001883641, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913357.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913357.757, "ph": "X", "dur": 0.8000000003675399, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913366.357, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913368.357, "ph": "X", "dur": 0.30000000013782746, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913370.757, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913375.257, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913373.757, "ph": "X", "dur": 2.6000000011945046, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913378.757, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913370.557, "ph": "X", "dur": 8.600000003951054, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913380.057, "ph": "X", "dur": 0.30000000013782746, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913381.257, "ph": "X", "dur": 0.20000000009188498, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913388.857, "ph": "X", "dur": 1.000000000459425, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913386.757, "ph": "X", "dur": 3.4000000015620446, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913390.657, "ph": "X", "dur": 2.900000001332332, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913383.757, "ph": "X", "dur": 10.800000004961788, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913395.157, "ph": "X", "dur": 0.6000000002756549, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913382.357, "ph": "X", "dur": 13.600000006248179, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913397.957, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913398.557, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913400.257, "ph": "X", "dur": 1.000000000459425, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913399.857, "ph": "X", "dur": 1.6000000007350799, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913403.657, "ph": "X", "dur": 0.7000000003215975, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913402.457, "ph": "X", "dur": 2.00000000091885, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913379.957, "ph": "X", "dur": 25.40000001166939, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913369.957, "ph": "X", "dur": 35.70000001640146, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913406.257, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913407.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913411.257, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913411.157, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913413.157, "ph": "X", "dur": 3.700000001699872, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913412.957, "ph": "X", "dur": 4.200000001929584, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913417.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913417.757, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913419.557, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913419.457, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913421.857, "ph": "X", "dur": 0.8000000003675399, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913421.457, "ph": "X", "dur": 1.3000000005972523, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913420.957, "ph": "X", "dur": 2.200000001010735, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913423.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913423.757, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913425.257, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913425.157, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913428.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913429.457, "ph": "X", "dur": 0.9000000004134823, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913431.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913432.857, "ph": "X", "dur": 147.50000006776514, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913432.357, "ph": "X", "dur": 148.90000006840836, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913583.757, "ph": "X", "dur": 1.1000000005053674, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913588.257, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913595.057, "ph": "X", "dur": 1.000000000459425, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913596.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913597.457, "ph": "X", "dur": 1.000000000459425, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913601.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913601.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913602.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913603.257, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913605.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913606.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913606.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913607.757, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913587.257, "ph": "X", "dur": 21.900000010061405, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913610.657, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913613.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913615.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913615.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913616.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913618.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913618.857, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913619.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913619.957, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913620.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913621.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913622.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913622.557, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913612.757, "ph": "X", "dur": 10.90000000500773, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913624.357, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913625.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913627.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913628.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913628.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913630.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913630.557, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913630.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913631.457, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913632.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913632.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913633.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913633.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913625.657, "ph": "X", "dur": 8.700000003996996, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913634.757, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913635.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913637.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913638.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913638.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913639.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913640.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913640.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913641.057, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913641.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913642.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913642.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913643.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913635.757, "ph": "X", "dur": 8.100000003721341, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913644.357, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913645.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913647.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913647.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913648.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913649.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913649.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913650.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913650.657, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913651.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913651.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913652.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913652.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913645.257, "ph": "X", "dur": 8.200000003767283, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913653.957, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913431.057, "ph": "X", "dur": 223.50000010268147, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913655.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913657.457, "ph": "X", "dur": 0.6000000002756549, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913659.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913660.557, "ph": "X", "dur": 83.20000003822415, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913660.357, "ph": "X", "dur": 83.8000000384998, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913745.957, "ph": "X", "dur": 0.8000000003675399, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913748.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913752.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913752.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913753.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913755.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913755.757, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913756.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913756.657, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913757.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913758.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913759.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913759.557, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913748.157, "ph": "X", "dur": 12.50000000574281, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913761.557, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913762.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913787.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913787.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913788.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913789.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913789.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913790.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913790.857, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913791.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913792.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913792.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913793.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913762.657, "ph": "X", "dur": 31.30000001438, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913794.457, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913795.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913797.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913797.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913797.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913799.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913799.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913800.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913800.557, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913801.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913801.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913802.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913802.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913795.357, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913803.757, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913804.757, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913806.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913806.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913807.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913808.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913808.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913809.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913809.757, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913810.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913810.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913811.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913811.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913804.657, "ph": "X", "dur": 7.800000003583514, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913812.857, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913813.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913815.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913815.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913816.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913817.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913817.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913818.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913818.757, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913819.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913819.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913820.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913820.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913813.757, "ph": "X", "dur": 7.700000003537571, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913821.957, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913658.857, "ph": "X", "dur": 163.6000000751619, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913823.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913824.857, "ph": "X", "dur": 0.6000000002756549, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913826.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913827.257, "ph": "X", "dur": 82.30000003781066, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913827.157, "ph": "X", "dur": 82.80000003804038, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913911.557, "ph": "X", "dur": 0.7000000003215975, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913914.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913917.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913917.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913918.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913920.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913920.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913920.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913921.657, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913922.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913923.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913923.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913924.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913913.757, "ph": "X", "dur": 11.500000005283386, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913926.057, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913927.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913928.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913929.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913929.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913931.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913931.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913931.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913932.457, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913933.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913933.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913934.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913934.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913927.157, "ph": "X", "dur": 8.100000003721341, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913935.757, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913938.257, "ph": "X", "dur": 85.90000003946459, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913938.057, "ph": "X", "dur": 86.50000003974024, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913937.657, "ph": "X", "dur": 88.00000004042938, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913937.157, "ph": "X", "dur": 89.30000004102664, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914029.457, "ph": "X", "dur": 0.30000000013782746, "name": "ExtensionFileLoader.__init__ (<frozen importlib._bootstrap_external>:1307)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914031.657, "ph": "X", "dur": 0.6000000002756549, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914033.457, "ph": "X", "dur": 1.8000000008269645, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914035.857, "ph": "X", "dur": 0.9000000004134823, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914037.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914038.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914038.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914033.157, "ph": "X", "dur": 6.200000002848434, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914032.757, "ph": "X", "dur": 6.900000003170031, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914042.557, "ph": "X", "dur": 0.5000000002297125, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914031.257, "ph": "X", "dur": 14.10000000647789, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914027.857, "ph": "X", "dur": 17.80000000817776, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913825.957, "ph": "X", "dur": 220.20000010116536, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913427.357, "ph": "X", "dur": 619.6000002846597, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913426.457, "ph": "X", "dur": 621.0000002853029, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914048.957, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914048.457, "ph": "X", "dur": 1.3000000005972523, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913409.057, "ph": "X", "dur": 642.0000002949508, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914052.957, "ph": "X", "dur": 1.000000000459425, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914054.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914057.357, "ph": "X", "dur": 1087.1000004994407, "name": "_imp.create_dynamic", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914056.957, "ph": "X", "dur": 1090.4000005009568, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915154.057, "ph": "X", "dur": 1.400000000643195, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914056.057, "ph": "X", "dur": 1099.9000005053215, "name": "ExtensionFileLoader.create_module (<frozen importlib._bootstrap_external>:1318)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915160.157, "ph": "X", "dur": 1.5000000006891374, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915162.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915163.657, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915166.057, "ph": "X", "dur": 1.2000000005513098, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915165.057, "ph": "X", "dur": 3.500000001607987, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915169.357, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915170.457, "ph": "X", "dur": 0.10000000004594249, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915170.957, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915172.057, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915176.457, "ph": "X", "dur": 1.1000000005053674, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915178.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915173.957, "ph": "X", "dur": 5.400000002480894, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915172.957, "ph": "X", "dur": 6.900000003170031, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915158.257, "ph": "X", "dur": 21.80000001001546, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914054.557, "ph": "X", "dur": 1125.9000005172663, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915185.257, "ph": "X", "dur": 41.000000018836424, "name": "_imp.exec_dynamic", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915184.557, "ph": "X", "dur": 41.9000000192499, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915228.057, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915183.157, "ph": "X", "dur": 45.50000002090383, "name": "ExtensionFileLoader.exec_module (<frozen importlib._bootstrap_external>:1326)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915229.657, "ph": "X", "dur": 1.2000000005513098, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915232.057, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529914052.357, "ph": "X", "dur": 1180.4000005423052, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913407.457, "ph": "X", "dur": 1826.3000008390477, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915237.657, "ph": "X", "dur": 0.8000000003675399, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915241.757, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915243.257, "ph": "X", "dur": 0.9000000004134823, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915244.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915245.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915245.957, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915236.657, "ph": "X", "dur": 10.300000004732075, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915235.757, "ph": "X", "dur": 11.500000005283386, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915250.257, "ph": "X", "dur": 0.5000000002297125, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915251.257, "ph": "X", "dur": 0.5000000002297125, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915253.257, "ph": "X", "dur": 0.40000000018376997, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915249.957, "ph": "X", "dur": 3.8000000017458144, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529913366.057, "ph": "X", "dur": 1890.8000008686804, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915270.357, "ph": "X", "dur": 1.6000000007350799, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915286.157, "ph": "X", "dur": 19.500000008958786, "name": "_ConnectionBase (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:115)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915280.057, "ph": "X", "dur": 53.400000024533284, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915337.457, "ph": "X", "dur": 4.300000001975527, "name": "PipeConnection (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:268)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915334.957, "ph": "X", "dur": 30.500000014012457, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915368.357, "ph": "X", "dur": 4.900000002251182, "name": "Connection (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:364)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915366.257, "ph": "X", "dur": 26.400000012128817, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915395.857, "ph": "X", "dur": 8.0000000036754, "name": "Listener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:448)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915394.057, "ph": "X", "dur": 25.70000001180722, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915425.157, "ph": "X", "dur": 1.7000000007810223, "name": "SocketListener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:596)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915423.657, "ph": "X", "dur": 18.800000008637188, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915445.357, "ph": "X", "dur": 6.600000003032204, "name": "PipeListener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:656)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915444.057, "ph": "X", "dur": 20.90000000960198, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915474.657, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915474.057, "ph": "X", "dur": 1.400000000643195, "name": "<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:838)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915476.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915475.957, "ph": "X", "dur": 1.3000000005972523, "name": "<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:838)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915477.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915477.657, "ph": "X", "dur": 0.5000000002297125, "name": "<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:838)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915478.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915478.357, "ph": "X", "dur": 0.40000000018376997, "name": "<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:838)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915479.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915478.957, "ph": "X", "dur": 0.40000000018376997, "name": "<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:838)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915479.657, "ph": "X", "dur": 0.40000000018376997, "name": "<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:838)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915472.057, "ph": "X", "dur": 8.80000000404294, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915486.057, "ph": "X", "dur": 1.7000000007810223, "name": "ConnectionWrapper (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:970)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915484.757, "ph": "X", "dur": 17.100000007856163, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915508.257, "ph": "X", "dur": 0.8000000003675399, "name": "XmlListener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:992)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915507.157, "ph": "X", "dur": 17.80000000817776, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915531.357, "ph": "X", "dur": 1.5000000006891374, "name": "ForkingPickler.register (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:43)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915534.257, "ph": "X", "dur": 0.30000000013782746, "name": "ForkingPickler.register (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:43)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911358.757, "ph": "X", "dur": 4176.000001918558, "name": "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911347.257, "ph": "X", "dur": 4188.500001924301, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529911346.557, "ph": "X", "dur": 4189.600001924806, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909743.157, "ph": "X", "dur": 5793.600002661724, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915537.557, "ph": "X", "dur": 0.8000000003675399, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915539.757, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909658.657, "ph": "X", "dur": 5881.800002702245, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915541.257, "ph": "X", "dur": 0.8000000003675399, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915543.657, "ph": "X", "dur": 2.6000000011945046, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909291.557, "ph": "X", "dur": 6255.000002873703, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915549.157, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915551.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915551.957, "ph": "X", "dur": 0.5000000002297125, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915552.757, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915553.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915553.957, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915548.757, "ph": "X", "dur": 6.100000002802491, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915548.257, "ph": "X", "dur": 6.800000003124089, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915556.857, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915557.557, "ph": "X", "dur": 0.5000000002297125, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915558.757, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915556.657, "ph": "X", "dur": 2.500000001148562, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909243.357, "ph": "X", "dur": 6317.400002902371, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909240.257, "ph": "X", "dur": 6322.800002904852, "name": "builtins.__import__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909239.857, "ph": "X", "dur": 6323.5000029051735, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529909233.957, "ph": "X", "dur": 6330.300002908297, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915567.757, "ph": "X", "dur": 1.000000000459425, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915567.257, "ph": "X", "dur": 2.100000000964792, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915572.057, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915573.857, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915571.057, "ph": "X", "dur": 3.700000001699872, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915577.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915577.457, "ph": "X", "dur": 0.8000000003675399, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915592.757, "ph": "X", "dur": 32.60000001497725, "name": "Queue (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:33)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915584.957, "ph": "X", "dur": 57.000000026187216, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915646.057, "ph": "X", "dur": 3.000000001378275, "name": "JoinableQueue (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:314)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915644.057, "ph": "X", "dur": 20.800000009556037, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915667.357, "ph": "X", "dur": 6.800000003124089, "name": "SimpleQueue (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:357)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915665.757, "ph": "X", "dur": 21.400000009831693, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904287.957, "ph": "X", "dur": 11399.700005237306, "name": "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904282.557, "ph": "X", "dur": 11405.700005240062, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529904281.757, "ph": "X", "dur": 11406.700005240522, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902965.157, "ph": "X", "dur": 12723.800005845631, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915689.657, "ph": "X", "dur": 1.000000000459425, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915691.957, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902856.057, "ph": "X", "dur": 12836.500005897407, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915693.157, "ph": "X", "dur": 0.7000000003215975, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915694.657, "ph": "X", "dur": 1.3000000005972523, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902294.557, "ph": "X", "dur": 13401.700006157074, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915698.257, "ph": "X", "dur": 0.30000000013782746, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915699.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915700.157, "ph": "X", "dur": 5.400000002480894, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915706.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915706.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915707.257, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915697.657, "ph": "X", "dur": 10.300000004732075, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915697.257, "ph": "X", "dur": 10.90000000500773, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915709.757, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915710.257, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915711.057, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915709.557, "ph": "X", "dur": 1.9000000008729072, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902213.857, "ph": "X", "dur": 13498.900006201731, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915715.557, "ph": "X", "dur": 0.7000000003215975, "name": "DefaultContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:237)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915722.557, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915722.157, "ph": "X", "dur": 1.3000000005972523, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915727.257, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915729.057, "ph": "X", "dur": 0.30000000013782746, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915731.457, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915737.357, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915735.557, "ph": "X", "dur": 2.900000001332332, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915740.457, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915731.257, "ph": "X", "dur": 9.600000004410479, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915741.857, "ph": "X", "dur": 0.30000000013782746, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915743.157, "ph": "X", "dur": 0.20000000009188498, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915750.657, "ph": "X", "dur": 0.9000000004134823, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915748.657, "ph": "X", "dur": 3.2000000014701597, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915752.457, "ph": "X", "dur": 2.500000001148562, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915745.757, "ph": "X", "dur": 9.900000004548307, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915756.257, "ph": "X", "dur": 0.6000000002756549, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915744.157, "ph": "X", "dur": 12.90000000592658, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915758.857, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915759.557, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915761.357, "ph": "X", "dur": 0.9000000004134823, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915760.957, "ph": "X", "dur": 1.5000000006891374, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915764.857, "ph": "X", "dur": 0.7000000003215975, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915763.457, "ph": "X", "dur": 2.3000000010566772, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915741.757, "ph": "X", "dur": 24.800000011393735, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915730.757, "ph": "X", "dur": 36.10000001658524, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915767.357, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915768.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915771.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915774.757, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915774.657, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915776.857, "ph": "X", "dur": 3.300000001516102, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915776.557, "ph": "X", "dur": 3.8000000017458144, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915781.057, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915780.957, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915782.757, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915782.657, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915785.357, "ph": "X", "dur": 0.7000000003215975, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915784.957, "ph": "X", "dur": 1.3000000005972523, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915784.357, "ph": "X", "dur": 2.3000000010566772, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915787.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915787.257, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915788.757, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915788.657, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915792.157, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915793.457, "ph": "X", "dur": 0.9000000004134823, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915795.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915797.057, "ph": "X", "dur": 136.40000006266555, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915796.557, "ph": "X", "dur": 137.400000063125, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915936.457, "ph": "X", "dur": 1.000000000459425, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915940.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915947.157, "ph": "X", "dur": 0.7000000003215975, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915948.257, "ph": "X", "dur": 0.6000000002756549, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915949.357, "ph": "X", "dur": 0.9000000004134823, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915952.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915953.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915953.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915954.957, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915957.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915957.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915958.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915959.657, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915940.257, "ph": "X", "dur": 20.90000000960198, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915962.657, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915964.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915967.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915967.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915968.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915969.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915970.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915970.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915971.657, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915972.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915973.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915973.757, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915974.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915964.757, "ph": "X", "dur": 10.100000004640192, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915975.657, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915977.057, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915978.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915979.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915979.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915981.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915981.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915982.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915982.557, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915983.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915983.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915984.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915984.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915976.857, "ph": "X", "dur": 8.600000003951054, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915986.057, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915988.957, "ph": "X", "dur": 95.30000004378319, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915988.757, "ph": "X", "dur": 96.0000000441048, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915988.357, "ph": "X", "dur": 97.7000000448858, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915987.757, "ph": "X", "dur": 99.100000045529, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916089.757, "ph": "X", "dur": 0.20000000009188498, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916091.757, "ph": "X", "dur": 0.5000000002297125, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916093.557, "ph": "X", "dur": 2.00000000091885, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916096.057, "ph": "X", "dur": 1.1000000005053674, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916097.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916098.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916099.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916093.257, "ph": "X", "dur": 6.700000003078147, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916092.857, "ph": "X", "dur": 7.3000000033538015, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916102.557, "ph": "X", "dur": 0.6000000002756549, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916091.457, "ph": "X", "dur": 13.800000006340062, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916088.057, "ph": "X", "dur": 17.500000008039933, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915795.057, "ph": "X", "dur": 311.0000001428811, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915790.857, "ph": "X", "dur": 316.0000001451782, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915789.857, "ph": "X", "dur": 317.6000001459133, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916108.757, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916108.557, "ph": "X", "dur": 0.7000000003215975, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915772.557, "ph": "X", "dur": 337.80000015519374, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916111.057, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916113.357, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916115.157, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916116.157, "ph": "X", "dur": 0.20000000009188498, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916117.057, "ph": "X", "dur": 2.500000001148562, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916120.857, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916121.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916122.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916123.957, "ph": "X", "dur": 0.8000000003675399, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916123.657, "ph": "X", "dur": 1.400000000643195, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916125.657, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916126.657, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916127.157, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916128.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916130.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916132.557, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916136.657, "ph": "X", "dur": 0.7000000003215975, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916136.157, "ph": "X", "dur": 1.400000000643195, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916138.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916137.957, "ph": "X", "dur": 0.8000000003675399, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916139.157, "ph": "X", "dur": 0.30000000013782746, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916135.457, "ph": "X", "dur": 4.700000002159297, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916133.557, "ph": "X", "dur": 8.700000003996996, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916142.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916144.757, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916148.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916151.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916151.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916152.357, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916154.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916155.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916155.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916156.357, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916158.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916158.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916158.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916159.457, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916160.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916161.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916161.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916162.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916163.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916148.357, "ph": "X", "dur": 15.800000007258912, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916132.357, "ph": "X", "dur": 32.30000001483942, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916129.957, "ph": "X", "dur": 35.10000001612581, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916129.257, "ph": "X", "dur": 36.10000001658524, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916165.757, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916120.457, "ph": "X", "dur": 45.9000000210876, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916114.757, "ph": "X", "dur": 51.90000002384415, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916171.057, "ph": "X", "dur": 0.20000000009188498, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916169.257, "ph": "X", "dur": 2.4000000011026197, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916172.557, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916174.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916174.157, "ph": "X", "dur": 0.8000000003675399, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916175.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916175.157, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916176.057, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916173.957, "ph": "X", "dur": 2.700000001240447, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916173.157, "ph": "X", "dur": 4.100000001883641, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916177.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916178.757, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916180.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916182.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916183.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916183.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916185.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916185.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916186.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916186.657, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916188.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916188.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916188.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916189.357, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916190.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916190.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916191.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916191.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916192.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916180.757, "ph": "X", "dur": 12.400000005696867, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916172.357, "ph": "X", "dur": 21.100000009693865, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916194.957, "ph": "X", "dur": 83.90000003854574, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916194.857, "ph": "X", "dur": 84.30000003872952, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916194.457, "ph": "X", "dur": 85.70000003937271, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916283.657, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916285.757, "ph": "X", "dur": 786.8000003614756, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917076.457, "ph": "X", "dur": 119.20000005476344, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917196.757, "ph": "X", "dur": 27.100000012450415, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916282.757, "ph": "X", "dur": 941.9000004327323, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917235.157, "ph": "X", "dur": 1.000000000459425, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917238.357, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917240.057, "ph": "X", "dur": 0.7000000003215975, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917238.057, "ph": "X", "dur": 3.100000001424217, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917230.757, "ph": "X", "dur": 11.800000005421214, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917249.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917249.957, "ph": "X", "dur": 0.30000000013782746, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917249.057, "ph": "X", "dur": 1.400000000643195, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917252.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917252.657, "ph": "X", "dur": 0.30000000013782746, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917251.957, "ph": "X", "dur": 1.2000000005513098, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917248.457, "ph": "X", "dur": 5.200000002389009, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917255.557, "ph": "X", "dur": 1.000000000459425, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917258.357, "ph": "X", "dur": 253.10000011628043, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917512.657, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917515.257, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917516.557, "ph": "X", "dur": 0.8000000003675399, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917257.857, "ph": "X", "dur": 259.8000001193586, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916168.657, "ph": "X", "dur": 1349.300000619902, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917542.857, "ph": "X", "dur": 1.400000000643195, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917541.657, "ph": "X", "dur": 3.2000000014701597, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917549.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917550.857, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917548.757, "ph": "X", "dur": 3.2000000014701597, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917553.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917553.257, "ph": "X", "dur": 1.000000000459425, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917555.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917555.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917555.057, "ph": "X", "dur": 1.400000000643195, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917557.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917557.257, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917558.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917559.257, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917558.557, "ph": "X", "dur": 1.3000000005972523, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917572.957, "ph": "X", "dur": 11.800000005421214, "name": "SemLock (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:46)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917569.557, "ph": "X", "dur": 43.20000001984715, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917615.657, "ph": "X", "dur": 2.00000000091885, "name": "Semaphore (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:130)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917614.057, "ph": "X", "dur": 22.800000010474886, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917638.957, "ph": "X", "dur": 1.000000000459425, "name": "BoundedSemaphore (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:149)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917637.757, "ph": "X", "dur": 19.200000008820957, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917658.857, "ph": "X", "dur": 1.000000000459425, "name": "Lock (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:166)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917657.657, "ph": "X", "dur": 21.400000009831693, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917680.957, "ph": "X", "dur": 0.8000000003675399, "name": "RLock (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:191)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917679.657, "ph": "X", "dur": 179.90000008265054, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917862.457, "ph": "X", "dur": 7.3000000033538015, "name": "Condition (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:217)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917860.557, "ph": "X", "dur": 24.800000011393735, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917887.757, "ph": "X", "dur": 2.00000000091885, "name": "Event (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:328)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917886.457, "ph": "X", "dur": 17.20000000790211, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917910.257, "ph": "X", "dur": 1.400000000643195, "name": "property.setter", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917913.357, "ph": "X", "dur": 0.6000000002756549, "name": "property.setter", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917906.857, "ph": "X", "dur": 7.500000003445686, "name": "Barrier (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:370)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917905.157, "ph": "X", "dur": 28.700000013185495, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917530.857, "ph": "X", "dur": 403.400000185332, "name": "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917524.157, "ph": "X", "dur": 410.9000001887777, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917523.557, "ph": "X", "dur": 411.9000001892371, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916167.957, "ph": "X", "dur": 1768.1000008123092, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917937.157, "ph": "X", "dur": 1.000000000459425, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917939.957, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529916112.557, "ph": "X", "dur": 1828.4000008400124, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917941.757, "ph": "X", "dur": 0.6000000002756549, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917943.457, "ph": "X", "dur": 1.6000000007350799, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915768.657, "ph": "X", "dur": 2176.70000100003, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917948.957, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917952.657, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917953.757, "ph": "X", "dur": 0.40000000018376997, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917954.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917955.357, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917955.757, "ph": "X", "dur": 0.9000000004134823, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917948.057, "ph": "X", "dur": 8.90000000408888, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917947.157, "ph": "X", "dur": 10.100000004640192, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917959.657, "ph": "X", "dur": 0.40000000018376997, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917960.457, "ph": "X", "dur": 0.6000000002756549, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917961.957, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917959.257, "ph": "X", "dur": 3.100000001424217, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915727.057, "ph": "X", "dur": 2237.400001027917, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917977.557, "ph": "X", "dur": 8.300000003813226, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917986.457, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917996.657, "ph": "X", "dur": 0.7000000003215975, "name": "_thread.lock.acquire", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917999.357, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.lock.release", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917995.357, "ph": "X", "dur": 4.800000002205239, "name": "_get_candidate_names (C:\\Programming\\Python313\\Lib\\tempfile.py:229)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918007.157, "ph": "X", "dur": 0.20000000009188498, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918007.957, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918020.057, "ph": "X", "dur": 1.400000000643195, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918023.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918025.857, "ph": "X", "dur": 15.500000007121086, "name": "Random.seed", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918018.257, "ph": "X", "dur": 25.300000011623446, "name": "Random.seed (C:\\Programming\\Python313\\Lib\\random.py:128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918013.257, "ph": "X", "dur": 30.900000014196227, "name": "Random.__init__ (C:\\Programming\\Python313\\Lib\\random.py:119)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918006.557, "ph": "X", "dur": 38.900000017871626, "name": "_RandomNameSequence.rng (C:\\Programming\\Python313\\Lib\\tempfile.py:142)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918052.757, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918056.657, "ph": "X", "dur": 1.5000000006891374, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918058.757, "ph": "X", "dur": 0.6000000002756549, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918061.057, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918061.557, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918062.357, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918062.657, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918063.057, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918063.357, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918063.657, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918063.957, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918064.457, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918064.657, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918065.057, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918065.257, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918065.557, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918065.757, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918051.557, "ph": "X", "dur": 14.800000006799488, "name": "Random.choices (C:\\Programming\\Python313\\Lib\\random.py:458)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918066.857, "ph": "X", "dur": 1.000000000459425, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918004.257, "ph": "X", "dur": 64.0000000294032, "name": "_RandomNameSequence.__next__ (C:\\Programming\\Python313\\Lib\\tempfile.py:153)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918002.157, "ph": "X", "dur": 66.50000003055175, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918076.057, "ph": "X", "dur": 0.40000000018376997, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918077.157, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918078.157, "ph": "X", "dur": 1.000000000459425, "name": "nt._path_splitroot_ex", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918079.857, "ph": "X", "dur": 0.9000000004134823, "name": "nt._path_splitroot_ex", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918075.557, "ph": "X", "dur": 6.800000003124089, "name": "join (C:\\Programming\\Python313\\Lib\\ntpath.py:99)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918085.157, "ph": "X", "dur": 60.80000002793303, "name": "nt.lstat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918084.357, "ph": "X", "dur": 64.40000002958696, "name": "_exists (C:\\Programming\\Python313\\Lib\\tempfile.py:76)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917993.257, "ph": "X", "dur": 156.3000000718081, "name": "mktemp (C:\\Programming\\Python313\\Lib\\tempfile.py:400)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917974.857, "ph": "X", "dur": 175.10000008044528, "name": "arbitrary_address (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:70)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918157.357, "ph": "X", "dur": 55.8000000256359, "name": "_winapi.CreateNamedPipe", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918215.457, "ph": "X", "dur": 20.200000009280384, "name": "_winapi.CreateFile", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918236.757, "ph": "X", "dur": 10.800000004961788, "name": "_winapi.SetNamedPipeHandleState", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918248.357, "ph": "X", "dur": 29.70000001364492, "name": "_winapi.ConnectNamedPipe", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918279.957, "ph": "X", "dur": 4.800000002205239, "name": "_winapi.Overlapped.GetOverlappedResult", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918291.257, "ph": "X", "dur": 4.500000002067411, "name": "_ConnectionBase.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:118)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918298.257, "ph": "X", "dur": 2.4000000011026197, "name": "_ConnectionBase.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:118)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529917972.357, "ph": "X", "dur": 329.0000001511508, "name": "Pipe (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:552)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918313.057, "ph": "X", "dur": 0.8000000003675399, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918312.457, "ph": "X", "dur": 1.9000000008729072, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918319.657, "ph": "X", "dur": 0.20000000009188498, "name": "BaseContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:187)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918328.557, "ph": "X", "dur": 0.5000000002297125, "name": "BaseContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:197)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918336.057, "ph": "X", "dur": 0.40000000018376997, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918341.957, "ph": "X", "dur": 0.5000000002297125, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918342.857, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918347.657, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918350.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918352.057, "ph": "X", "dur": 12.90000000592658, "name": "Random.seed", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918346.457, "ph": "X", "dur": 19.70000000905067, "name": "Random.seed (C:\\Programming\\Python313\\Lib\\random.py:128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918345.757, "ph": "X", "dur": 20.800000009556037, "name": "Random.__init__ (C:\\Programming\\Python313\\Lib\\random.py:119)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918341.157, "ph": "X", "dur": 26.50000001217476, "name": "_RandomNameSequence.rng (C:\\Programming\\Python313\\Lib\\tempfile.py:142)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918370.357, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918373.457, "ph": "X", "dur": 1.3000000005972523, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918375.057, "ph": "X", "dur": 0.30000000013782746, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918375.757, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918376.057, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918376.457, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918376.757, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918376.957, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918377.257, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918377.457, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918377.757, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918378.157, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918378.457, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918378.757, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918378.957, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918379.257, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918379.457, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918369.257, "ph": "X", "dur": 10.800000004961788, "name": "Random.choices (C:\\Programming\\Python313\\Lib\\random.py:458)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918380.557, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918339.957, "ph": "X", "dur": 41.60000001911207, "name": "_RandomNameSequence.__next__ (C:\\Programming\\Python313\\Lib\\tempfile.py:153)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918338.757, "ph": "X", "dur": 43.00000001975526, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918334.557, "ph": "X", "dur": 47.80000002196051, "name": "SemLock._make_name (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:121)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918394.257, "ph": "X", "dur": 0.6000000002756549, "name": "debug (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918396.357, "ph": "X", "dur": 1.6000000007350799, "name": "SemLock._make_methods (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:90)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918327.357, "ph": "X", "dur": 71.70000003294076, "name": "SemLock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:50)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918322.357, "ph": "X", "dur": 77.10000003542166, "name": "Lock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:168)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918310.257, "ph": "X", "dur": 89.90000004130229, "name": "BaseContext.Lock (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:65)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918401.257, "ph": "X", "dur": 0.20000000009188498, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918405.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918405.057, "ph": "X", "dur": 1.3000000005972523, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918409.057, "ph": "X", "dur": 0.10000000004594249, "name": "BaseContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:187)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918412.957, "ph": "X", "dur": 0.40000000018376997, "name": "BaseContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:197)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918418.757, "ph": "X", "dur": 0.30000000013782746, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918421.657, "ph": "X", "dur": 0.20000000009188498, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918422.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918421.357, "ph": "X", "dur": 1.5000000006891374, "name": "_RandomNameSequence.rng (C:\\Programming\\Python313\\Lib\\tempfile.py:142)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918424.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918425.757, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918426.057, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918426.557, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918426.857, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918427.157, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918427.357, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918427.657, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918427.857, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918428.157, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918428.357, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918428.857, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918429.157, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918429.357, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918429.657, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918429.857, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918430.157, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918423.757, "ph": "X", "dur": 6.800000003124089, "name": "Random.choices (C:\\Programming\\Python313\\Lib\\random.py:458)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918430.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918421.057, "ph": "X", "dur": 10.600000004869903, "name": "_RandomNameSequence.__next__ (C:\\Programming\\Python313\\Lib\\tempfile.py:153)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918420.457, "ph": "X", "dur": 11.300000005191501, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918418.057, "ph": "X", "dur": 14.10000000647789, "name": "SemLock._make_name (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:121)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918438.957, "ph": "X", "dur": 0.40000000018376997, "name": "debug (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918440.257, "ph": "X", "dur": 1.5000000006891374, "name": "SemLock._make_methods (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:90)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918412.357, "ph": "X", "dur": 30.100000013828687, "name": "SemLock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:50)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918411.457, "ph": "X", "dur": 31.30000001438, "name": "BoundedSemaphore.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:151)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918404.257, "ph": "X", "dur": 39.10000001796351, "name": "BaseContext.BoundedSemaphore (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:85)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918454.257, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918455.457, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918456.157, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918451.757, "ph": "X", "dur": 7.900000003629456, "name": "Condition.__init__ (C:\\Programming\\Python313\\Lib\\threading.py:281)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918446.557, "ph": "X", "dur": 19.800000009096614, "name": "Queue._reset (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:69)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529915720.757, "ph": "X", "dur": 2746.2000012616727, "name": "Queue.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:35)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529902190.957, "ph": "X", "dur": 16277.100007478104, "name": "BaseContext.Queue (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:100)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918475.957, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918478.557, "ph": "X", "dur": 0.9000000004134823, "name": "dict.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918480.357, "ph": "X", "dur": 0.20000000009188498, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918481.857, "ph": "X", "dur": 0.40000000018376997, "name": "BaseProcess.name (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:189)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918491.357, "ph": "X", "dur": 1.400000000643195, "name": "BaseProcess.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:94)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918493.157, "ph": "X", "dur": 0.30000000013782746, "name": "BaseProcess.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:94)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918489.557, "ph": "X", "dur": 5.100000002343067, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918502.057, "ph": "X", "dur": 0.8000000003675399, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918498.457, "ph": "X", "dur": 5.000000002297124, "name": "WeakSet.add (C:\\Programming\\Python313\\Lib\\_weakrefset.py:85)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918475.257, "ph": "X", "dur": 28.500000013093608, "name": "BaseProcess.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:80)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918505.057, "ph": "X", "dur": 30.600000014058402, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918540.457, "ph": "X", "dur": 0.30000000013782746, "name": "BaseProcess._check_closed (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:99)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918541.557, "ph": "X", "dur": 0.30000000013782746, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918542.957, "ph": "X", "dur": 0.6000000002756549, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918545.357, "ph": "X", "dur": 1.9000000008729072, "name": "_cleanup (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:61)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918550.157, "ph": "X", "dur": 0.5000000002297125, "name": "DefaultContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:237)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918554.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918554.057, "ph": "X", "dur": 1.3000000005972523, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918560.857, "ph": "X", "dur": 0.40000000018376997, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918562.857, "ph": "X", "dur": 0.20000000009188498, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918565.257, "ph": "X", "dur": 0.40000000018376997, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918571.457, "ph": "X", "dur": 0.30000000013782746, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918569.457, "ph": "X", "dur": 2.80000000128639, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918574.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918564.857, "ph": "X", "dur": 9.900000004548307, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918575.957, "ph": "X", "dur": 0.30000000013782746, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918577.457, "ph": "X", "dur": 0.20000000009188498, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918585.057, "ph": "X", "dur": 1.000000000459425, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918583.157, "ph": "X", "dur": 3.2000000014701597, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918586.957, "ph": "X", "dur": 2.4000000011026197, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918579.857, "ph": "X", "dur": 10.100000004640192, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918590.657, "ph": "X", "dur": 0.5000000002297125, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918578.557, "ph": "X", "dur": 12.800000005880639, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918593.757, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918594.257, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918596.257, "ph": "X", "dur": 0.9000000004134823, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918595.857, "ph": "X", "dur": 1.5000000006891374, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918600.257, "ph": "X", "dur": 0.8000000003675399, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918598.757, "ph": "X", "dur": 2.4000000011026197, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918575.757, "ph": "X", "dur": 26.50000001217476, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918564.357, "ph": "X", "dur": 38.20000001755003, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918602.957, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918604.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918607.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918610.757, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918610.657, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918613.057, "ph": "X", "dur": 3.8000000017458144, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918612.557, "ph": "X", "dur": 4.6000000021133545, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918617.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918617.757, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918619.657, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918619.557, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918622.157, "ph": "X", "dur": 0.8000000003675399, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918621.757, "ph": "X", "dur": 1.5000000006891374, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918621.057, "ph": "X", "dur": 2.6000000011945046, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918624.357, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918624.257, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918625.657, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918625.457, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918630.357, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918632.057, "ph": "X", "dur": 1.1000000005053674, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918634.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918636.357, "ph": "X", "dur": 184.20000008462605, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918635.757, "ph": "X", "dur": 186.10000008549898, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918826.257, "ph": "X", "dur": 1.6000000007350799, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918831.757, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918839.357, "ph": "X", "dur": 1.3000000005972523, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918841.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918842.057, "ph": "X", "dur": 1.000000000459425, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918845.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918846.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918847.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918848.157, "ph": "X", "dur": 0.8000000003675399, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918850.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918851.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918852.157, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918852.957, "ph": "X", "dur": 0.8000000003675399, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918830.957, "ph": "X", "dur": 23.500000010796484, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918856.857, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918859.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918861.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918861.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918862.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918863.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918864.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918864.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918881.057, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918882.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918882.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918883.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918883.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918858.957, "ph": "X", "dur": 25.900000011899106, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918885.857, "ph": "X", "dur": 0.6000000002756549, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918887.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918889.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918890.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918890.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918892.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918892.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918893.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918893.657, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918894.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918895.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918895.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918896.057, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918887.457, "ph": "X", "dur": 9.400000004318594, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918897.357, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918900.157, "ph": "X", "dur": 146.40000006725978, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918900.057, "ph": "X", "dur": 147.50000006776514, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918899.557, "ph": "X", "dur": 149.90000006886777, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918898.957, "ph": "X", "dur": 154.4000000709352, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919060.257, "ph": "X", "dur": 0.5000000002297125, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919064.457, "ph": "X", "dur": 0.7000000003215975, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919067.457, "ph": "X", "dur": 5.60000000257278, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919074.057, "ph": "X", "dur": 1.1000000005053674, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919076.857, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919078.857, "ph": "X", "dur": 0.8000000003675399, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919080.157, "ph": "X", "dur": 0.6000000002756549, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919066.857, "ph": "X", "dur": 14.300000006569775, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919066.057, "ph": "X", "dur": 15.400000007075143, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919085.957, "ph": "X", "dur": 0.9000000004134823, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919063.657, "ph": "X", "dur": 27.40000001258824, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919056.857, "ph": "X", "dur": 34.700000015942045, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918633.957, "ph": "X", "dur": 458.40000021060035, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918629.057, "ph": "X", "dur": 464.7000002134948, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918627.657, "ph": "X", "dur": 467.0000002145514, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919097.757, "ph": "X", "dur": 0.7000000003215975, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919096.757, "ph": "X", "dur": 2.100000000964792, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918608.557, "ph": "X", "dur": 493.2000002265883, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919103.057, "ph": "X", "dur": 0.9000000004134823, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919106.957, "ph": "X", "dur": 1.400000000643195, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919109.957, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919111.557, "ph": "X", "dur": 0.20000000009188498, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919113.457, "ph": "X", "dur": 4.0000000018377, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919119.457, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919120.857, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919123.257, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919125.457, "ph": "X", "dur": 1.5000000006891374, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919124.757, "ph": "X", "dur": 2.80000000128639, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919128.657, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919130.357, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919131.157, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919134.357, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919138.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919141.457, "ph": "X", "dur": 0.40000000018376997, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919149.457, "ph": "X", "dur": 0.9000000004134823, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919148.757, "ph": "X", "dur": 2.100000000964792, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919152.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919151.357, "ph": "X", "dur": 1.5000000006891374, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919153.557, "ph": "X", "dur": 0.40000000018376997, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919147.557, "ph": "X", "dur": 7.700000003537571, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919143.257, "ph": "X", "dur": 15.500000007121086, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919159.657, "ph": "X", "dur": 0.9000000004134823, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919162.657, "ph": "X", "dur": 1.000000000459425, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919170.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919175.557, "ph": "X", "dur": 0.7000000003215975, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919176.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919177.757, "ph": "X", "dur": 1.000000000459425, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919181.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919182.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919183.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919185.057, "ph": "X", "dur": 0.7000000003215975, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919187.557, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919188.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919189.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919190.157, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919192.357, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919193.757, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919194.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919196.157, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919197.157, "ph": "X", "dur": 0.8000000003675399, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919169.457, "ph": "X", "dur": 29.600000013598976, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919140.957, "ph": "X", "dur": 59.100000027152014, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919136.757, "ph": "X", "dur": 64.10000002944913, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919135.657, "ph": "X", "dur": 65.60000003013826, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919201.957, "ph": "X", "dur": 0.30000000013782746, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919118.757, "ph": "X", "dur": 84.30000003872952, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919109.357, "ph": "X", "dur": 94.30000004332376, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919211.257, "ph": "X", "dur": 0.20000000009188498, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919208.157, "ph": "X", "dur": 3.8000000017458144, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919213.757, "ph": "X", "dur": 0.5000000002297125, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919218.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919217.757, "ph": "X", "dur": 1.5000000006891374, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919220.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919219.757, "ph": "X", "dur": 1.2000000005513098, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919221.557, "ph": "X", "dur": 0.40000000018376997, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919217.157, "ph": "X", "dur": 6.100000002802491, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919215.057, "ph": "X", "dur": 9.900000004548307, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919225.757, "ph": "X", "dur": 0.7000000003215975, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919228.557, "ph": "X", "dur": 1.000000000459425, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919233.657, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919237.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919239.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919239.857, "ph": "X", "dur": 0.6000000002756549, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919242.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919243.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919244.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919245.557, "ph": "X", "dur": 0.7000000003215975, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919247.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919248.857, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919249.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919250.857, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919252.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919253.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919255.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919256.257, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919257.057, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919233.257, "ph": "X", "dur": 25.200000011577508, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919213.357, "ph": "X", "dur": 45.70000002099572, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919262.457, "ph": "X", "dur": 178.4000000819614, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919261.957, "ph": "X", "dur": 179.90000008265054, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919260.957, "ph": "X", "dur": 182.500000083845, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919450.157, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919453.057, "ph": "X", "dur": 592.800000272347, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920051.357, "ph": "X", "dur": 133.80000006147105, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920186.257, "ph": "X", "dur": 31.30000001438, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919448.357, "ph": "X", "dur": 770.2000003538491, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920232.557, "ph": "X", "dur": 1.9000000008729072, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920237.157, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920240.157, "ph": "X", "dur": 1.000000000459425, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920236.657, "ph": "X", "dur": 4.900000002251182, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920227.357, "ph": "X", "dur": 16.10000000739674, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920252.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920253.157, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920251.657, "ph": "X", "dur": 2.200000001010735, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920256.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920256.957, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920255.857, "ph": "X", "dur": 1.7000000007810223, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920250.857, "ph": "X", "dur": 7.500000003445686, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920261.057, "ph": "X", "dur": 1.2000000005513098, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920265.057, "ph": "X", "dur": 134.40000006174668, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920400.757, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920403.457, "ph": "X", "dur": 0.6000000002756549, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920404.957, "ph": "X", "dur": 0.8000000003675399, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920264.557, "ph": "X", "dur": 141.40000006496265, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919206.857, "ph": "X", "dur": 1199.4000005510343, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920433.957, "ph": "X", "dur": 1.400000000643195, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920432.757, "ph": "X", "dur": 3.2000000014701597, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920443.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920442.757, "ph": "X", "dur": 1.000000000459425, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920448.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920449.757, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920460.357, "ph": "X", "dur": 0.5000000002297125, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920463.057, "ph": "X", "dur": 0.20000000009188498, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920465.657, "ph": "X", "dur": 0.6000000002756549, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920474.057, "ph": "X", "dur": 0.7000000003215975, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920471.657, "ph": "X", "dur": 3.700000001699872, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920478.557, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920465.357, "ph": "X", "dur": 13.600000006248179, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920481.057, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920482.857, "ph": "X", "dur": 0.10000000004594249, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920491.857, "ph": "X", "dur": 1.3000000005972523, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920488.357, "ph": "X", "dur": 5.100000002343067, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920494.057, "ph": "X", "dur": 3.000000001378275, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920485.057, "ph": "X", "dur": 12.600000005788754, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920498.557, "ph": "X", "dur": 0.6000000002756549, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920483.857, "ph": "X", "dur": 15.600000007167028, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920502.857, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920503.557, "ph": "X", "dur": 1.000000000459425, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920506.057, "ph": "X", "dur": 1.1000000005053674, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920505.557, "ph": "X", "dur": 1.9000000008729072, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920510.557, "ph": "X", "dur": 0.9000000004134823, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920509.257, "ph": "X", "dur": 2.6000000011945046, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920480.157, "ph": "X", "dur": 32.70000001502319, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920464.657, "ph": "X", "dur": 48.40000002223616, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920513.857, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920515.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920518.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920522.057, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920521.857, "ph": "X", "dur": 0.7000000003215975, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920524.157, "ph": "X", "dur": 3.500000001607987, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920523.857, "ph": "X", "dur": 4.100000001883641, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920528.757, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920528.557, "ph": "X", "dur": 0.7000000003215975, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920530.857, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920530.657, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920533.157, "ph": "X", "dur": 0.8000000003675399, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920532.857, "ph": "X", "dur": 1.3000000005972523, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920532.257, "ph": "X", "dur": 2.4000000011026197, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920535.357, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920535.157, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920536.657, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920536.457, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920540.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920541.257, "ph": "X", "dur": 1.400000000643195, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920544.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920545.957, "ph": "X", "dur": 195.50000008981758, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920545.457, "ph": "X", "dur": 197.0000000905067, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920746.057, "ph": "X", "dur": 2.00000000091885, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920752.357, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920759.757, "ph": "X", "dur": 0.9000000004134823, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920761.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920762.257, "ph": "X", "dur": 0.9000000004134823, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920766.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920767.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920767.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920768.757, "ph": "X", "dur": 0.8000000003675399, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920771.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920772.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920773.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920773.957, "ph": "X", "dur": 0.8000000003675399, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920751.557, "ph": "X", "dur": 24.0000000110262, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920777.557, "ph": "X", "dur": 0.5000000002297125, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920780.057, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920782.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920782.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920783.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920785.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920785.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920786.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920786.857, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920787.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920788.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920788.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920789.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920779.757, "ph": "X", "dur": 10.300000004732075, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920790.857, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920792.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920794.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920794.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920795.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920796.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920796.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920797.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920797.857, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920798.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920799.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920799.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920799.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920792.157, "ph": "X", "dur": 8.400000003859168, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920801.157, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920803.857, "ph": "X", "dur": 116.500000053523, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920803.657, "ph": "X", "dur": 117.30000005389053, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920803.157, "ph": "X", "dur": 119.30000005480939, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920802.457, "ph": "X", "dur": 121.10000005563636, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920927.157, "ph": "X", "dur": 0.30000000013782746, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920929.657, "ph": "X", "dur": 0.5000000002297125, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920931.657, "ph": "X", "dur": 2.100000000964792, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920934.657, "ph": "X", "dur": 1.1000000005053674, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920936.757, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920937.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920938.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920931.357, "ph": "X", "dur": 7.900000003629456, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920930.957, "ph": "X", "dur": 8.500000003905113, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920942.857, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920929.157, "ph": "X", "dur": 16.90000000776428, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920925.057, "ph": "X", "dur": 21.400000009831693, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920543.857, "ph": "X", "dur": 403.2000001852401, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920538.757, "ph": "X", "dur": 409.4000001880885, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920537.757, "ph": "X", "dur": 411.10000018886956, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920951.157, "ph": "X", "dur": 0.40000000018376997, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920950.657, "ph": "X", "dur": 1.2000000005513098, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920519.557, "ph": "X", "dur": 433.9000001993444, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920954.357, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920956.457, "ph": "X", "dur": 1.400000000643195, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920958.957, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920960.057, "ph": "X", "dur": 0.20000000009188498, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920960.957, "ph": "X", "dur": 3.000000001378275, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920965.557, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920966.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920967.857, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920969.257, "ph": "X", "dur": 1.000000000459425, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920968.857, "ph": "X", "dur": 1.7000000007810223, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920971.357, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920972.457, "ph": "X", "dur": 0.10000000004594249, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920972.957, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920974.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920977.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920979.057, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920984.757, "ph": "X", "dur": 0.7000000003215975, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920984.357, "ph": "X", "dur": 1.400000000643195, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920986.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920986.257, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920987.357, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920983.457, "ph": "X", "dur": 5.100000002343067, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920980.557, "ph": "X", "dur": 10.200000004686133, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920991.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920993.357, "ph": "X", "dur": 0.6000000002756549, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920997.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921000.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921001.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921001.657, "ph": "X", "dur": 0.6000000002756549, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921004.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921004.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921005.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921005.857, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921007.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921008.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921008.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921009.257, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921010.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921011.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921011.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921012.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921013.257, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920997.357, "ph": "X", "dur": 17.20000000790211, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920978.857, "ph": "X", "dur": 36.20000001663118, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920976.257, "ph": "X", "dur": 39.40000001810134, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920975.657, "ph": "X", "dur": 40.30000001851482, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921016.357, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920964.757, "ph": "X", "dur": 52.300000024027916, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920958.457, "ph": "X", "dur": 58.90000002706012, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921022.857, "ph": "X", "dur": 0.10000000004594249, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921020.557, "ph": "X", "dur": 2.900000001332332, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921024.357, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921026.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921026.357, "ph": "X", "dur": 0.9000000004134823, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921027.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921027.457, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921028.357, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921026.057, "ph": "X", "dur": 2.900000001332332, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921025.057, "ph": "X", "dur": 4.700000002159297, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921030.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921031.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921033.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921035.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921036.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921036.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921038.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921038.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921039.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921039.757, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921041.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921041.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921041.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921042.357, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921043.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921043.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921044.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921044.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921045.357, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921033.357, "ph": "X", "dur": 12.90000000592658, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921024.157, "ph": "X", "dur": 22.40000001029112, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921048.057, "ph": "X", "dur": 103.40000004750452, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921047.857, "ph": "X", "dur": 103.90000004773424, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921047.357, "ph": "X", "dur": 105.70000004856121, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921157.457, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921159.557, "ph": "X", "dur": 738.7000003393771, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921902.157, "ph": "X", "dur": 117.50000005398242, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922020.957, "ph": "X", "dur": 29.200000013415206, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921156.457, "ph": "X", "dur": 894.7000004110473, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922063.157, "ph": "X", "dur": 1.3000000005972523, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922067.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922069.457, "ph": "X", "dur": 0.9000000004134823, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922066.457, "ph": "X", "dur": 4.40000000202147, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922058.557, "ph": "X", "dur": 14.000000006431948, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922081.157, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922082.257, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922080.757, "ph": "X", "dur": 2.200000001010735, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922085.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922086.457, "ph": "X", "dur": 0.5000000002297125, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922085.257, "ph": "X", "dur": 2.00000000091885, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922079.857, "ph": "X", "dur": 8.200000003767283, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922090.757, "ph": "X", "dur": 1.000000000459425, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922093.457, "ph": "X", "dur": 173.60000007975617, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922268.257, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922270.257, "ph": "X", "dur": 0.5000000002297125, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922271.557, "ph": "X", "dur": 0.9000000004134823, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922092.957, "ph": "X", "dur": 179.80000008260458, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921019.357, "ph": "X", "dur": 1253.7000005759808, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922295.257, "ph": "X", "dur": 0.9000000004134823, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922298.057, "ph": "X", "dur": 0.30000000013782746, "name": "_ModuleLockManager.__init__ (<frozen importlib._bootstrap>:412)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922300.557, "ph": "X", "dur": 0.5000000002297125, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922307.957, "ph": "X", "dur": 0.8000000003675399, "name": "_thread.allocate_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922306.057, "ph": "X", "dur": 3.500000001607987, "name": "_ModuleLock.__init__ (<frozen importlib._bootstrap>:232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922312.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922300.257, "ph": "X", "dur": 13.000000005972522, "name": "_get_module_lock (<frozen importlib._bootstrap>:426)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922314.457, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922316.057, "ph": "X", "dur": 0.10000000004594249, "name": "_BlockingOnManager.__init__ (<frozen importlib._bootstrap>:158)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922325.957, "ph": "X", "dur": 1.1000000005053674, "name": "type.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922322.357, "ph": "X", "dur": 5.000000002297124, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__new__ (<frozen importlib._bootstrap>:74)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922327.857, "ph": "X", "dur": 2.80000000128639, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.__init__ (<frozen importlib._bootstrap>:79)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922318.757, "ph": "X", "dur": 12.50000000574281, "name": "_WeakValueDictionary.setdefault (<frozen importlib._bootstrap>:124)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922331.957, "ph": "X", "dur": 1.000000000459425, "name": "_List.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922317.357, "ph": "X", "dur": 15.800000007258912, "name": "_BlockingOnManager.__enter__ (<frozen importlib._bootstrap>:162)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922336.657, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922337.357, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922339.357, "ph": "X", "dur": 1.1000000005053674, "name": "_List.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922338.857, "ph": "X", "dur": 1.8000000008269645, "name": "_BlockingOnManager.__exit__ (<frozen importlib._bootstrap>:173)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922344.057, "ph": "X", "dur": 0.7000000003215975, "name": "_weakref._remove_dead_weakref", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922342.657, "ph": "X", "dur": 2.3000000010566772, "name": "_WeakValueDictionary.__init__.<locals>.KeyedRef.remove (<frozen importlib._bootstrap>:82)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922314.257, "ph": "X", "dur": 31.700000014563766, "name": "_ModuleLock.acquire (<frozen importlib._bootstrap>:304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922299.757, "ph": "X", "dur": 46.500000021363256, "name": "_ModuleLockManager.__enter__ (<frozen importlib._bootstrap>:416)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922346.757, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922348.557, "ph": "X", "dur": 0.6000000002756549, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922352.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922352.657, "ph": "X", "dur": 0.6000000002756549, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922354.957, "ph": "X", "dur": 4.0000000018377, "name": "_imp.is_builtin", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922354.657, "ph": "X", "dur": 4.500000002067411, "name": "BuiltinImporter.find_spec (<frozen importlib._bootstrap>:982)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922360.057, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922359.957, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922361.957, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922361.857, "ph": "X", "dur": 0.40000000018376997, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922364.057, "ph": "X", "dur": 0.8000000003675399, "name": "_imp.find_frozen", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922363.757, "ph": "X", "dur": 1.3000000005972523, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922363.257, "ph": "X", "dur": 2.3000000010566772, "name": "FrozenImporter.find_spec (<frozen importlib._bootstrap>:1128)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922366.257, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922366.157, "ph": "X", "dur": 0.30000000013782746, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922371.257, "ph": "X", "dur": 0.10000000004594249, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922371.057, "ph": "X", "dur": 0.5000000002297125, "name": "_ImportLockContext.__enter__ (<frozen importlib._bootstrap>:1222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922374.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922375.957, "ph": "X", "dur": 1.1000000005053674, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922378.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922379.857, "ph": "X", "dur": 136.60000006275743, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922379.257, "ph": "X", "dur": 137.7000000632628, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922519.957, "ph": "X", "dur": 1.2000000005513098, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922524.557, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922531.357, "ph": "X", "dur": 0.7000000003215975, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922532.557, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922533.457, "ph": "X", "dur": 0.9000000004134823, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922537.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922538.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922538.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922539.557, "ph": "X", "dur": 0.6000000002756549, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922541.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922542.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922543.257, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922544.157, "ph": "X", "dur": 0.7000000003215975, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922524.057, "ph": "X", "dur": 21.50000000987763, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922547.057, "ph": "X", "dur": 0.40000000018376997, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922549.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922551.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922552.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922552.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922554.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922554.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922555.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922556.057, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922557.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922557.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922558.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922558.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922548.957, "ph": "X", "dur": 10.600000004869903, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922560.457, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922561.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922563.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922564.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922564.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922566.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922566.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922567.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922567.657, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922568.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922569.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922569.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922569.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922561.657, "ph": "X", "dur": 9.000000004134822, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922571.157, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922572.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922573.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922574.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922574.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922575.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922576.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922576.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922577.257, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922577.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922578.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922578.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922579.357, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922571.957, "ph": "X", "dur": 8.0000000036754, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922580.457, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922581.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922583.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922583.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922584.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922585.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922585.757, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922586.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922586.657, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922587.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922587.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922588.357, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922588.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922581.357, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922589.857, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922377.857, "ph": "X", "dur": 212.60000009767373, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922591.957, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922593.457, "ph": "X", "dur": 0.7000000003215975, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922595.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922596.357, "ph": "X", "dur": 109.30000005021513, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922596.157, "ph": "X", "dur": 110.00000005053674, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922708.257, "ph": "X", "dur": 0.8000000003675399, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922711.457, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922715.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922716.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922716.757, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922719.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922719.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922720.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922720.557, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922721.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922722.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922723.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922723.757, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922710.957, "ph": "X", "dur": 13.800000006340062, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922725.857, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922727.257, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922728.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922729.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922729.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922731.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922731.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922732.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922732.557, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922733.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922733.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922734.357, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922734.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922727.057, "ph": "X", "dur": 8.200000003767283, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922735.857, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922736.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922738.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922738.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922739.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922740.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922741.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922741.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922741.957, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922742.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922743.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922743.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922744.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922736.757, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922745.157, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922746.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922747.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922748.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922748.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922749.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922750.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922750.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922751.157, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922751.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922752.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922752.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922753.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922745.957, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922754.357, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922755.257, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922756.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922757.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922757.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922758.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922759.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922759.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922760.257, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922760.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922761.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922761.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922762.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922755.157, "ph": "X", "dur": 7.800000003583514, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922763.457, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922594.757, "ph": "X", "dur": 169.20000007773467, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922765.357, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922766.857, "ph": "X", "dur": 0.6000000002756549, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922768.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922769.357, "ph": "X", "dur": 84.70000003891329, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922769.257, "ph": "X", "dur": 85.20000003914299, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922856.357, "ph": "X", "dur": 0.7000000003215975, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922859.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922861.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922862.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922863.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922865.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922865.657, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922866.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922866.657, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922867.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922868.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922868.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922869.457, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922858.757, "ph": "X", "dur": 11.600000005329328, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922871.157, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922872.457, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922874.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922874.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922874.957, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922876.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922876.657, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922877.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922877.457, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922878.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922878.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922879.257, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922879.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922872.257, "ph": "X", "dur": 8.100000003721341, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922880.857, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922881.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922883.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922883.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922884.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922885.557, "ph": "X", "dur": 0.10000000004594249, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922885.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922886.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922886.857, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922887.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922888.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922888.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922888.957, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922881.757, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922890.157, "ph": "X", "dur": 0.10000000004594249, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922891.157, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922892.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922892.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922893.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922894.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922894.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922895.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922895.957, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922896.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922897.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922897.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922898.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922890.957, "ph": "X", "dur": 7.600000003491629, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922899.057, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922900.057, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922901.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922901.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922902.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922903.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922903.957, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922904.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922904.857, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922905.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922906.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922906.557, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922906.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922899.857, "ph": "X", "dur": 7.600000003491629, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922907.857, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922767.957, "ph": "X", "dur": 140.50000006454917, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922909.257, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922910.257, "ph": "X", "dur": 0.7000000003215975, "name": "PathFinder._path_importer_cache (<frozen importlib._bootstrap_external>:1500)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922911.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922912.557, "ph": "X", "dur": 74.50000003422716, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922912.457, "ph": "X", "dur": 74.90000003441092, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922989.057, "ph": "X", "dur": 0.6000000002756549, "name": "_make_relax_case.<locals>._relax_case (<frozen importlib._bootstrap_external>:67)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922991.457, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922994.257, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922994.857, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922995.357, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922997.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922997.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922997.957, "ph": "X", "dur": 0.10000000004594249, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922998.457, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922999.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923000.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923000.557, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923000.957, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922991.157, "ph": "X", "dur": 10.700000004915847, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923002.657, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923003.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923005.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923005.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923006.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923007.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923008.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923008.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923008.957, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923009.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923010.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923010.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923011.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923003.657, "ph": "X", "dur": 7.900000003629456, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923012.057, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923013.257, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923014.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923015.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923015.557, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923016.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923017.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923017.657, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923018.157, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923018.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923019.357, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923019.857, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923020.157, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923013.057, "ph": "X", "dur": 7.800000003583514, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923021.257, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923023.857, "ph": "X", "dur": 84.80000003895923, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923023.657, "ph": "X", "dur": 85.40000003923488, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923023.257, "ph": "X", "dur": 86.90000003992402, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:155)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923022.657, "ph": "X", "dur": 88.20000004052127, "name": "_path_isfile (<frozen importlib._bootstrap_external>:164)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923114.157, "ph": "X", "dur": 0.10000000004594249, "name": "FileLoader.__init__ (<frozen importlib._bootstrap_external>:1184)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923116.257, "ph": "X", "dur": 0.6000000002756549, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923118.257, "ph": "X", "dur": 1.6000000007350799, "name": "nt._path_splitroot", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923120.557, "ph": "X", "dur": 0.9000000004134823, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923122.257, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923123.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923123.857, "ph": "X", "dur": 0.40000000018376997, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923117.957, "ph": "X", "dur": 6.500000002986261, "name": "_path_isabs (<frozen importlib._bootstrap_external>:177)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923117.457, "ph": "X", "dur": 7.200000003307858, "name": "_path_abspath (<frozen importlib._bootstrap_external>:190)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923127.757, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.__init__ (<frozen importlib._bootstrap>:599)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923115.857, "ph": "X", "dur": 15.000000006891373, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:833)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923112.157, "ph": "X", "dur": 18.900000008683133, "name": "FileFinder._get_spec (<frozen importlib._bootstrap_external>:1619)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922911.357, "ph": "X", "dur": 220.3000001012113, "name": "FileFinder.find_spec (<frozen importlib._bootstrap_external>:1624)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922373.457, "ph": "X", "dur": 759.0000003487035, "name": "PathFinder._get_spec (<frozen importlib._bootstrap_external>:1522)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922372.357, "ph": "X", "dur": 760.8000003495305, "name": "PathFinder.find_spec (<frozen importlib._bootstrap_external>:1551)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923134.657, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923134.157, "ph": "X", "dur": 1.1000000005053674, "name": "_ImportLockContext.__exit__ (<frozen importlib._bootstrap>:1226)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922350.357, "ph": "X", "dur": 786.7000003614295, "name": "_find_spec (<frozen importlib._bootstrap>:1240)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923139.057, "ph": "X", "dur": 1.000000000459425, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923141.057, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923142.057, "ph": "X", "dur": 0.20000000009188498, "name": "_LoaderBasics.create_module (<frozen importlib._bootstrap_external>:1017)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923142.957, "ph": "X", "dur": 2.80000000128639, "name": "_new_module (<frozen importlib._bootstrap>:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923147.257, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923148.257, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923149.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923151.057, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923150.657, "ph": "X", "dur": 1.1000000005053674, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923152.457, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923153.557, "ph": "X", "dur": 0.10000000004594249, "name": "ModuleSpec.has_location (<frozen importlib._bootstrap>:653)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923153.957, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923155.957, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923158.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923159.857, "ph": "X", "dur": 0.40000000018376997, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923165.257, "ph": "X", "dur": 0.5000000002297125, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923164.757, "ph": "X", "dur": 1.3000000005972523, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923166.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923166.457, "ph": "X", "dur": 0.7000000003215975, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923167.557, "ph": "X", "dur": 0.20000000009188498, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923163.957, "ph": "X", "dur": 4.900000002251182, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923161.557, "ph": "X", "dur": 9.600000004410479, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923171.657, "ph": "X", "dur": 0.7000000003215975, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923174.057, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923177.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923180.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923180.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923181.057, "ph": "X", "dur": 0.5000000002297125, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923183.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923183.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923198.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923199.257, "ph": "X", "dur": 0.5000000002297125, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923201.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923201.457, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923201.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923202.357, "ph": "X", "dur": 0.30000000013782746, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923203.357, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923204.157, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923204.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923205.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923206.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923177.557, "ph": "X", "dur": 29.600000013598976, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923159.657, "ph": "X", "dur": 48.0000000220524, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923157.457, "ph": "X", "dur": 50.700000023292844, "name": "_get_cached (<frozen importlib._bootstrap_external>:642)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923156.757, "ph": "X", "dur": 51.70000002375226, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923208.957, "ph": "X", "dur": 0.20000000009188498, "name": "ModuleSpec.cached (<frozen importlib._bootstrap>:632)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923146.657, "ph": "X", "dur": 63.00000002894377, "name": "_init_module_attrs (<frozen importlib._bootstrap>:733)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923140.657, "ph": "X", "dur": 69.40000003188409, "name": "module_from_spec (<frozen importlib._bootstrap>:806)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923214.657, "ph": "X", "dur": 0.20000000009188498, "name": "FileLoader.get_filename (<frozen importlib._bootstrap_external>:1209)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923212.657, "ph": "X", "dur": 3.100000001424217, "name": "_check_name.<locals>._check_name_wrapper (<frozen importlib._bootstrap_external>:674)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923216.857, "ph": "X", "dur": 0.20000000009188498, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923219.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923218.757, "ph": "X", "dur": 0.9000000004134823, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923220.057, "ph": "X", "dur": 0.30000000013782746, "name": "str.rfind", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923219.857, "ph": "X", "dur": 0.6000000002756549, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923220.757, "ph": "X", "dur": 0.10000000004594249, "name": "_path_split.<locals>.<genexpr> (<frozen importlib._bootstrap_external>:139)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923218.457, "ph": "X", "dur": 2.80000000128639, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923217.557, "ph": "X", "dur": 4.6000000021133545, "name": "_path_split (<frozen importlib._bootstrap_external>:137)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923222.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923223.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923225.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923227.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923228.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923228.657, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923230.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923230.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923231.057, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923231.557, "ph": "X", "dur": 0.40000000018376997, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923232.857, "ph": "X", "dur": 0.20000000009188498, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923233.257, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923233.757, "ph": "X", "dur": 0.20000000009188498, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923234.257, "ph": "X", "dur": 0.20000000009188498, "name": "list.append", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923234.957, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923235.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923236.157, "ph": "X", "dur": 0.20000000009188498, "name": "str.rstrip", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923236.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923237.257, "ph": "X", "dur": 0.40000000018376997, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923225.657, "ph": "X", "dur": 12.300000005650926, "name": "_path_join (<frozen importlib._bootstrap_external>:101)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923216.657, "ph": "X", "dur": 21.600000009923576, "name": "cache_from_source (<frozen importlib._bootstrap_external>:513)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923239.957, "ph": "X", "dur": 82.30000003781066, "name": "nt.stat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923239.857, "ph": "X", "dur": 82.80000003804038, "name": "_path_stat (<frozen importlib._bootstrap_external>:145)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923239.457, "ph": "X", "dur": 84.10000003863763, "name": "SourceFileLoader.path_stats (<frozen importlib._bootstrap_external>:1233)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923327.557, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923329.357, "ph": "X", "dur": 570.4000002620559, "name": "_io.open_code", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923903.757, "ph": "X", "dur": 117.30000005389053, "name": "_io.BufferedReader.read", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924021.957, "ph": "X", "dur": 26.50000001217476, "name": "_io.BufferedReader.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923326.757, "ph": "X", "dur": 722.6000003319804, "name": "FileLoader.get_data (<frozen importlib._bootstrap_external>:1214)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924060.957, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924064.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924066.857, "ph": "X", "dur": 1.2000000005513098, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924064.157, "ph": "X", "dur": 4.300000001975527, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924056.457, "ph": "X", "dur": 13.500000006202235, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:697)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924078.757, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924079.857, "ph": "X", "dur": 0.40000000018376997, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924078.457, "ph": "X", "dur": 2.100000000964792, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924082.957, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924083.857, "ph": "X", "dur": 0.30000000013782746, "name": "type.from_bytes", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924082.657, "ph": "X", "dur": 1.8000000008269645, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:89)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924077.557, "ph": "X", "dur": 7.700000003537571, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:730)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924087.457, "ph": "X", "dur": 1.1000000005053674, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924090.857, "ph": "X", "dur": 155.40000007139463, "name": "marshal.loads", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924247.557, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924249.657, "ph": "X", "dur": 0.5000000002297125, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924251.057, "ph": "X", "dur": 0.8000000003675399, "name": "_imp._fix_co_filename", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924090.257, "ph": "X", "dur": 161.9000000743809, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:782)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923211.957, "ph": "X", "dur": 1040.5000004780316, "name": "SourceLoader.get_code (<frozen importlib._bootstrap_external>:1093)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924285.657, "ph": "X", "dur": 2.4000000011026197, "name": "_TempModule (C:\\Programming\\Python313\\Lib\\runpy.py:26)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924282.857, "ph": "X", "dur": 34.30000001575827, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924320.157, "ph": "X", "dur": 1.400000000643195, "name": "_ModifiedArgv0 (C:\\Programming\\Python313\\Lib\\runpy.py:49)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924318.757, "ph": "X", "dur": 21.400000009831693, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924344.057, "ph": "X", "dur": 0.7000000003215975, "name": "_Error (C:\\Programming\\Python313\\Lib\\runpy.py:166)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924342.957, "ph": "X", "dur": 22.800000010474886, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924269.757, "ph": "X", "dur": 99.20000004557494, "name": "<module> (C:\\Programming\\Python313\\Lib\\runpy.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924258.857, "ph": "X", "dur": 110.90000005095021, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924258.157, "ph": "X", "dur": 111.90000005140965, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923211.157, "ph": "X", "dur": 1159.400000532657, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924371.857, "ph": "X", "dur": 4.200000001929584, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924377.757, "ph": "X", "dur": 0.30000000013782746, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529923138.257, "ph": "X", "dur": 1240.3000005698245, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922347.957, "ph": "X", "dur": 2031.200000933184, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924382.457, "ph": "X", "dur": 0.7000000003215975, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924386.057, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924387.157, "ph": "X", "dur": 1.000000000459425, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924388.657, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924389.457, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924389.957, "ph": "X", "dur": 0.6000000002756549, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924381.957, "ph": "X", "dur": 9.000000004134822, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924381.057, "ph": "X", "dur": 10.100000004640192, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924393.857, "ph": "X", "dur": 0.40000000018376997, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924394.757, "ph": "X", "dur": 0.6000000002756549, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924396.157, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924393.557, "ph": "X", "dur": 3.000000001378275, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922294.457, "ph": "X", "dur": 2104.100000966676, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924403.757, "ph": "X", "dur": 1.1000000005053674, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924402.857, "ph": "X", "dur": 2.500000001148562, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924409.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924411.157, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924412.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924413.057, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924408.457, "ph": "X", "dur": 5.5000000025268365, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924415.657, "ph": "X", "dur": 0.40000000018376997, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924415.357, "ph": "X", "dur": 0.9000000004134823, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924417.657, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924417.957, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924417.157, "ph": "X", "dur": 1.5000000006891374, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924419.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924419.557, "ph": "X", "dur": 0.7000000003215975, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924424.457, "ph": "X", "dur": 0.30000000013782746, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924424.357, "ph": "X", "dur": 0.6000000002756549, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924425.957, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924426.257, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924425.657, "ph": "X", "dur": 1.6000000007350799, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924429.257, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924431.457, "ph": "X", "dur": 0.7000000003215975, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924433.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924440.557, "ph": "X", "dur": 0.5000000002297125, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924442.257, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924440.257, "ph": "X", "dur": 2.900000001332332, "name": "_fscodec.<locals>.fsdecode (C:\\Programming\\Python313\\Lib\\os.py:855)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924437.657, "ph": "X", "dur": 5.900000002710607, "name": "set_executable (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:36)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922286.757, "ph": "X", "dur": 2164.4000009943793, "name": "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922280.057, "ph": "X", "dur": 2171.700000997733, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529922279.357, "ph": "X", "dur": 2172.6000009981462, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529921018.757, "ph": "X", "dur": 3433.600001577481, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924452.957, "ph": "X", "dur": 0.5000000002297125, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924454.457, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920955.557, "ph": "X", "dur": 3499.4000016077116, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924455.657, "ph": "X", "dur": 0.5000000002297125, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924457.357, "ph": "X", "dur": 1.9000000008729072, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920515.057, "ph": "X", "dur": 3944.4000018121556, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924461.257, "ph": "X", "dur": 0.20000000009188498, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924462.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924463.157, "ph": "X", "dur": 0.40000000018376997, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924463.857, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924464.657, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924465.057, "ph": "X", "dur": 0.5000000002297125, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924460.957, "ph": "X", "dur": 4.900000002251182, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924460.657, "ph": "X", "dur": 5.400000002480894, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924467.457, "ph": "X", "dur": 0.30000000013782746, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924467.957, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924468.857, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924467.257, "ph": "X", "dur": 1.9000000008729072, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920459.757, "ph": "X", "dur": 4010.8000018426615, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920452.857, "ph": "X", "dur": 4019.3000018465664, "name": "builtins.__import__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920452.457, "ph": "X", "dur": 4019.900001846842, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920446.757, "ph": "X", "dur": 4026.1000018496907, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924475.157, "ph": "X", "dur": 0.5000000002297125, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924474.757, "ph": "X", "dur": 1.3000000005972523, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924477.357, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924477.857, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924476.957, "ph": "X", "dur": 1.400000000643195, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1390)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924480.757, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924481.757, "ph": "X", "dur": 0.30000000013782746, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924482.557, "ph": "X", "dur": 0.30000000013782746, "name": "str.endswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924485.657, "ph": "X", "dur": 0.40000000018376997, "name": "_path_eq (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:24)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924488.957, "ph": "X", "dur": 4.200000001929584, "name": "Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:40)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924487.357, "ph": "X", "dur": 23.000000010566772, "name": "builtins.__build_class__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920419.357, "ph": "X", "dur": 4091.500001879737, "name": "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:1)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920413.057, "ph": "X", "dur": 4098.300001882861, "name": "builtins.exec", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529920412.257, "ph": "X", "dur": 4099.400001883366, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:480)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919205.857, "ph": "X", "dur": 5306.1000024377545, "name": "_LoaderBasics.exec_module (<frozen importlib._bootstrap_external>:1020)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924512.757, "ph": "X", "dur": 0.7000000003215975, "name": "dict.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924514.357, "ph": "X", "dur": 0.20000000009188498, "name": "_verbose_message (<frozen importlib._bootstrap>:491)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529919105.357, "ph": "X", "dur": 5409.500002485259, "name": "_load_unlocked (<frozen importlib._bootstrap>:911)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924515.357, "ph": "X", "dur": 0.40000000018376997, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924516.557, "ph": "X", "dur": 1.6000000007350799, "name": "builtins.setattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918604.257, "ph": "X", "dur": 5914.200002717131, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:1304)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924520.057, "ph": "X", "dur": 0.20000000009188498, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924521.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924521.657, "ph": "X", "dur": 0.20000000009188498, "name": "list.pop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924522.157, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924522.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924523.157, "ph": "X", "dur": 0.40000000018376997, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924519.857, "ph": "X", "dur": 3.900000001791757, "name": "_ModuleLock.release (<frozen importlib._bootstrap>:372)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924519.457, "ph": "X", "dur": 4.500000002067411, "name": "_ModuleLockManager.__exit__ (<frozen importlib._bootstrap>:420)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924525.057, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.acquire_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924525.557, "ph": "X", "dur": 0.30000000013782746, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924526.157, "ph": "X", "dur": 0.20000000009188498, "name": "_imp.release_lock", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924524.857, "ph": "X", "dur": 1.6000000007350799, "name": "_get_module_lock.<locals>.cb (<frozen importlib._bootstrap>:445)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918560.357, "ph": "X", "dur": 5967.3000027415255, "name": "_find_and_load (<frozen importlib._bootstrap>:1349)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924543.457, "ph": "X", "dur": 0.20000000009188498, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924544.157, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924542.157, "ph": "X", "dur": 3.300000001516102, "name": "_check_not_importing_main (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:138)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924547.057, "ph": "X", "dur": 0.10000000004594249, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924548.457, "ph": "X", "dur": 0.9000000004134823, "name": "BaseProcess.authkey (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:213)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924552.757, "ph": "X", "dur": 1.2000000005513098, "name": "list.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924554.757, "ph": "X", "dur": 3.000000001378275, "name": "list.index", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924562.857, "ph": "X", "dur": 3.900000001791757, "name": "nt.getcwd", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924568.657, "ph": "X", "dur": 1.000000000459425, "name": "DefaultContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:253)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924570.157, "ph": "X", "dur": 2.80000000128639, "name": "dict.update", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924574.657, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924576.857, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924580.957, "ph": "X", "dur": 0.30000000013782746, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924581.957, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924584.157, "ph": "X", "dur": 0.9000000004134823, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924585.457, "ph": "X", "dur": 0.40000000018376997, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924580.757, "ph": "X", "dur": 5.400000002480894, "name": "isabs (C:\\Programming\\Python313\\Lib\\ntpath.py:80)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924587.357, "ph": "X", "dur": 2.200000001010735, "name": "nt._path_normpath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924541.057, "ph": "X", "dur": 49.10000002255776, "name": "get_preparation_data (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:160)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924591.657, "ph": "X", "dur": 40.500000018606706, "name": "_winapi.CreatePipe", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924634.357, "ph": "X", "dur": 4.0000000018377, "name": "msvcrt.open_osfhandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924639.557, "ph": "X", "dur": 0.8000000003675399, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924644.157, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924646.357, "ph": "X", "dur": 0.6000000002756549, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924650.157, "ph": "X", "dur": 3.4000000015620446, "name": "get_command_line.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:92)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924653.957, "ph": "X", "dur": 1.2000000005513098, "name": "get_command_line.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:92)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924655.357, "ph": "X", "dur": 0.20000000009188498, "name": "get_command_line.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:92)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924648.357, "ph": "X", "dur": 9.000000004134822, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924667.557, "ph": "X", "dur": 1.9000000008729072, "name": "_optim_args_from_interpreter_flags (C:\\Programming\\Python313\\Lib\\subprocess.py:296)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924669.857, "ph": "X", "dur": 0.30000000013782746, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924671.257, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924673.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924674.457, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924675.057, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924675.557, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924676.057, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924679.457, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924685.257, "ph": "X", "dur": 0.7000000003215975, "name": "list.extend", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924664.757, "ph": "X", "dur": 22.000000010107346, "name": "_args_from_interpreter_flags (C:\\Programming\\Python313\\Lib\\subprocess.py:306)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924688.157, "ph": "X", "dur": 0.30000000013782746, "name": "get_executable (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:45)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924643.757, "ph": "X", "dur": 46.500000021363256, "name": "get_command_line (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:83)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924691.357, "ph": "X", "dur": 0.30000000013782746, "name": "get_executable (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:45)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924694.057, "ph": "X", "dur": 1.000000000459425, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924695.257, "ph": "X", "dur": 0.8000000003675399, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924696.257, "ph": "X", "dur": 0.5000000002297125, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924696.957, "ph": "X", "dur": 0.5000000002297125, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924697.657, "ph": "X", "dur": 0.5000000002297125, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924698.357, "ph": "X", "dur": 0.5000000002297125, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924699.057, "ph": "X", "dur": 0.10000000004594249, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924692.957, "ph": "X", "dur": 7.600000003491629, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924701.857, "ph": "X", "dur": 28.000000012863897, "name": "_io.open", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924737.557, "ph": "X", "dur": 3.100000001424217, "name": "STARTUPINFO.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:199)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924741.657, "ph": "X", "dur": 20613.70000947045, "name": "_winapi.CreateProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945365.757, "ph": "X", "dur": 6.600000003032204, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945406.157, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945410.157, "ph": "X", "dur": 1.6000000007350799, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945396.557, "ph": "X", "dur": 19.100000008775016, "name": "Finalize.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:178)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945419.957, "ph": "X", "dur": 4.300000001975527, "name": "set_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:369)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945458.357, "ph": "X", "dur": 4.100000001883641, "name": "dict.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945465.257, "ph": "X", "dur": 4.100000001883641, "name": "dict.update", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945432.757, "ph": "X", "dur": 37.30000001713655, "name": "ForkingPickler.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:38)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945513.257, "ph": "X", "dur": 2.3000000010566772, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945511.857, "ph": "X", "dur": 4.6000000021133545, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945526.057, "ph": "X", "dur": 1.5000000006891374, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945525.157, "ph": "X", "dur": 2.900000001332332, "name": "get_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:366)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945507.257, "ph": "X", "dur": 25.100000011531563, "name": "AuthenticationString.__reduce__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:347)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945473.457, "ph": "X", "dur": 92.20000004235897, "name": "ForkingPickler.dump", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945428.157, "ph": "X", "dur": 154.10000007079736, "name": "dump (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:58)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945603.757, "ph": "X", "dur": 2.200000001010735, "name": "dict.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945608.657, "ph": "X", "dur": 2.6000000011945046, "name": "dict.update", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945588.857, "ph": "X", "dur": 22.800000010474886, "name": "ForkingPickler.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:38)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945637.457, "ph": "X", "dur": 2.3000000010566772, "name": "mappingproxy.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945642.057, "ph": "X", "dur": 1.9000000008729072, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945635.757, "ph": "X", "dur": 11.300000005191501, "name": "_slotnames (C:\\Programming\\Python313\\Lib\\copyreg.py:107)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945666.057, "ph": "X", "dur": 1.1000000005053674, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945665.357, "ph": "X", "dur": 2.700000001240447, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945673.357, "ph": "X", "dur": 1.400000000643195, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945672.357, "ph": "X", "dur": 2.6000000011945046, "name": "get_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:366)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945663.657, "ph": "X", "dur": 13.500000006202235, "name": "AuthenticationString.__reduce__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:347)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945613.357, "ph": "X", "dur": 86.30000003964837, "name": "ForkingPickler.dump", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945586.057, "ph": "X", "dur": 117.30000005389053, "name": "dump (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:58)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945704.957, "ph": "X", "dur": 1.7000000007810223, "name": "set_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:369)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945707.257, "ph": "X", "dur": 46.20000002122543, "name": "_io.BufferedWriter.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529924536.157, "ph": "X", "dur": 21218.40000974826, "name": "Popen.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:46)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918552.957, "ph": "X", "dur": 27208.20001250012, "name": "SpawnProcess._Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:334)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918548.557, "ph": "X", "dur": 27213.300012502466, "name": "Process._Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945770.657, "ph": "X", "dur": 1.400000000643195, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529918539.057, "ph": "X", "dur": 27233.600012511793, "name": "BaseProcess.start (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:110)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945774.457, "ph": "X", "dur": 61.700000028346516, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945844.057, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945848.257, "ph": "X", "dur": 6.100000002802491, "name": "wx._core.GetApp", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945855.557, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945872.057, "ph": "X", "dur": 2.3000000010566772, "name": "PyEvent.SetEventType", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945891.757, "ph": "X", "dur": 1.7000000007810223, "name": "sip.wrappertype.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945887.957, "ph": "X", "dur": 20.800000009556037, "name": "_PyEvent_Clone (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1851)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945879.457, "ph": "X", "dur": 41.40000001902019, "name": "wx._core.PostEvent", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945843.057, "ph": "X", "dur": 78.40000003601891, "name": "CallAfter (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3406)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945933.057, "ph": "X", "dur": 20.200000009280384, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945956.757, "ph": "X", "dur": 14.000000006431948, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945971.957, "ph": "X", "dur": 11.800000005421214, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945991.257, "ph": "X", "dur": 1.000000000459425, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945990.257, "ph": "X", "dur": 2.80000000128639, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946004.257, "ph": "X", "dur": 0.6000000002756549, "name": "DefaultContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:237)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946012.457, "ph": "X", "dur": 1.000000000459425, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946011.957, "ph": "X", "dur": 2.100000000964792, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946029.957, "ph": "X", "dur": 1.9000000008729072, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946033.257, "ph": "X", "dur": 1.3000000005972523, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946043.857, "ph": "X", "dur": 0.5000000002297125, "name": "_get_candidate_names (C:\\Programming\\Python313\\Lib\\tempfile.py:229)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946053.157, "ph": "X", "dur": 0.6000000002756549, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946054.957, "ph": "X", "dur": 1.000000000459425, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946052.757, "ph": "X", "dur": 4.6000000021133545, "name": "_RandomNameSequence.rng (C:\\Programming\\Python313\\Lib\\tempfile.py:142)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946062.557, "ph": "X", "dur": 1.1000000005053674, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946070.957, "ph": "X", "dur": 1.1000000005053674, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946072.457, "ph": "X", "dur": 0.8000000003675399, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946074.357, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946075.057, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946075.557, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946075.957, "ph": "X", "dur": 0.5000000002297125, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946076.757, "ph": "X", "dur": 0.30000000013782746, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946077.257, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946077.757, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946078.157, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946079.057, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946079.457, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946079.957, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946080.357, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946081.157, "ph": "X", "dur": 0.10000000004594249, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946081.557, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946060.757, "ph": "X", "dur": 22.000000010107346, "name": "Random.choices (C:\\Programming\\Python313\\Lib\\random.py:458)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946083.657, "ph": "X", "dur": 1.3000000005972523, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946051.957, "ph": "X", "dur": 33.70000001548262, "name": "_RandomNameSequence.__next__ (C:\\Programming\\Python313\\Lib\\tempfile.py:153)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946049.557, "ph": "X", "dur": 36.600000016814946, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946091.457, "ph": "X", "dur": 0.7000000003215975, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946093.657, "ph": "X", "dur": 1.3000000005972523, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946096.157, "ph": "X", "dur": 1.5000000006891374, "name": "nt._path_splitroot_ex", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946098.757, "ph": "X", "dur": 1.5000000006891374, "name": "nt._path_splitroot_ex", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946090.957, "ph": "X", "dur": 11.600000005329328, "name": "join (C:\\Programming\\Python313\\Lib\\ntpath.py:99)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946105.257, "ph": "X", "dur": 72.90000003349208, "name": "nt.lstat", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946104.457, "ph": "X", "dur": 78.6000000361108, "name": "_exists (C:\\Programming\\Python313\\Lib\\tempfile.py:76)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946042.457, "ph": "X", "dur": 142.10000006528426, "name": "mktemp (C:\\Programming\\Python313\\Lib\\tempfile.py:400)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946024.657, "ph": "X", "dur": 160.90000007392146, "name": "arbitrary_address (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:70)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946195.557, "ph": "X", "dur": 60.00000002756549, "name": "_winapi.CreateNamedPipe", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946259.657, "ph": "X", "dur": 25.80000001185316, "name": "_winapi.CreateFile", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946287.357, "ph": "X", "dur": 11.900000005467156, "name": "_winapi.SetNamedPipeHandleState", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946300.657, "ph": "X", "dur": 19.800000009096614, "name": "_winapi.ConnectNamedPipe", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946323.757, "ph": "X", "dur": 7.100000003261917, "name": "_winapi.Overlapped.GetOverlappedResult", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946339.857, "ph": "X", "dur": 5.200000002389009, "name": "_ConnectionBase.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:118)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946349.957, "ph": "X", "dur": 1.9000000008729072, "name": "_ConnectionBase.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:118)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946022.857, "ph": "X", "dur": 330.5000001518399, "name": "Pipe (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:552)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946369.257, "ph": "X", "dur": 1.8000000008269645, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946367.657, "ph": "X", "dur": 4.200000001929584, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946381.257, "ph": "X", "dur": 0.30000000013782746, "name": "BaseContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:187)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946401.357, "ph": "X", "dur": 0.6000000002756549, "name": "BaseContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:197)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946411.557, "ph": "X", "dur": 0.5000000002297125, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946418.857, "ph": "X", "dur": 1.000000000459425, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946420.957, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946418.057, "ph": "X", "dur": 4.800000002205239, "name": "_RandomNameSequence.rng (C:\\Programming\\Python313\\Lib\\tempfile.py:142)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946428.657, "ph": "X", "dur": 1.000000000459425, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946436.257, "ph": "X", "dur": 0.9000000004134823, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946437.657, "ph": "X", "dur": 0.6000000002756549, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946439.257, "ph": "X", "dur": 0.40000000018376997, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946439.957, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946441.157, "ph": "X", "dur": 0.30000000013782746, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946441.857, "ph": "X", "dur": 0.30000000013782746, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946442.757, "ph": "X", "dur": 0.30000000013782746, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946443.357, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946444.357, "ph": "X", "dur": 0.40000000018376997, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946445.057, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946446.357, "ph": "X", "dur": 0.40000000018376997, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946447.057, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946448.057, "ph": "X", "dur": 0.9000000004134823, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946449.157, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946449.957, "ph": "X", "dur": 0.40000000018376997, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946450.557, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946426.557, "ph": "X", "dur": 25.80000001185316, "name": "Random.choices (C:\\Programming\\Python313\\Lib\\random.py:458)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946453.457, "ph": "X", "dur": 2.200000001010735, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946417.257, "ph": "X", "dur": 39.800000018285104, "name": "_RandomNameSequence.__next__ (C:\\Programming\\Python313\\Lib\\tempfile.py:153)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946415.157, "ph": "X", "dur": 42.600000019571496, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946410.457, "ph": "X", "dur": 48.40000002223616, "name": "SemLock._make_name (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:121)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946473.957, "ph": "X", "dur": 0.6000000002756549, "name": "debug (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946476.657, "ph": "X", "dur": 2.200000001010735, "name": "SemLock._make_methods (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:90)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946399.557, "ph": "X", "dur": 81.50000003744313, "name": "SemLock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:50)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946396.157, "ph": "X", "dur": 85.80000003941865, "name": "Lock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:168)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946363.857, "ph": "X", "dur": 119.80000005503909, "name": "BaseContext.Lock (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:65)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946486.257, "ph": "X", "dur": 0.7000000003215975, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946493.857, "ph": "X", "dur": 1.400000000643195, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946493.057, "ph": "X", "dur": 3.000000001378275, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946501.657, "ph": "X", "dur": 0.30000000013782746, "name": "BaseContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:187)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946508.957, "ph": "X", "dur": 0.30000000013782746, "name": "BaseContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:197)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946515.257, "ph": "X", "dur": 0.30000000013782746, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946519.357, "ph": "X", "dur": 0.8000000003675399, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946520.557, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946518.957, "ph": "X", "dur": 2.700000001240447, "name": "_RandomNameSequence.rng (C:\\Programming\\Python313\\Lib\\tempfile.py:142)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946524.757, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.len", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946528.957, "ph": "X", "dur": 0.40000000018376997, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946529.857, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946531.057, "ph": "X", "dur": 0.30000000013782746, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946531.757, "ph": "X", "dur": 0.9000000004134823, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946533.357, "ph": "X", "dur": 0.40000000018376997, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946534.057, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946534.957, "ph": "X", "dur": 0.30000000013782746, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946535.557, "ph": "X", "dur": 0.5000000002297125, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946536.557, "ph": "X", "dur": 0.30000000013782746, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946537.157, "ph": "X", "dur": 0.40000000018376997, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946538.657, "ph": "X", "dur": 0.30000000013782746, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946539.357, "ph": "X", "dur": 0.5000000002297125, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946540.057, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946540.457, "ph": "X", "dur": 0.10000000004594249, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946540.757, "ph": "X", "dur": 0.20000000009188498, "name": "Random.random", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946541.157, "ph": "X", "dur": 0.20000000009188498, "name": "math.floor", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946523.457, "ph": "X", "dur": 18.50000000849936, "name": "Random.choices (C:\\Programming\\Python313\\Lib\\random.py:458)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946542.557, "ph": "X", "dur": 1.000000000459425, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946518.257, "ph": "X", "dur": 26.10000001199099, "name": "_RandomNameSequence.__next__ (C:\\Programming\\Python313\\Lib\\tempfile.py:153)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946517.157, "ph": "X", "dur": 27.70000001272607, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946514.157, "ph": "X", "dur": 31.700000014563766, "name": "SemLock._make_name (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:121)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946559.557, "ph": "X", "dur": 0.7000000003215975, "name": "debug (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:48)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946561.657, "ph": "X", "dur": 1.7000000007810223, "name": "SemLock._make_methods (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:90)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946507.757, "ph": "X", "dur": 57.10000002623316, "name": "SemLock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:50)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946505.657, "ph": "X", "dur": 59.80000002747361, "name": "BoundedSemaphore.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:151)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946490.757, "ph": "X", "dur": 76.40000003510006, "name": "BaseContext.BoundedSemaphore (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:85)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946584.457, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946586.057, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946587.257, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946582.157, "ph": "X", "dur": 10.400000004778018, "name": "Condition.__init__ (C:\\Programming\\Python313\\Lib\\threading.py:281)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946570.557, "ph": "X", "dur": 33.60000001543667, "name": "Queue._reset (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:69)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946010.257, "ph": "X", "dur": 595.4000002735415, "name": "Queue.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:35)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529945987.257, "ph": "X", "dur": 620.500000285073, "name": "BaseContext.Queue (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:100)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946618.557, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946624.757, "ph": "X", "dur": 2.00000000091885, "name": "dict.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946628.757, "ph": "X", "dur": 0.7000000003215975, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946632.157, "ph": "X", "dur": 1.1000000005053674, "name": "BaseProcess.name (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:189)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946652.457, "ph": "X", "dur": 3.4000000015620446, "name": "BaseProcess.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:94)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946656.357, "ph": "X", "dur": 0.30000000013782746, "name": "BaseProcess.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:94)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946649.357, "ph": "X", "dur": 10.100000004640192, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946668.557, "ph": "X", "dur": 2.3000000010566772, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946664.957, "ph": "X", "dur": 6.600000003032204, "name": "WeakSet.add (C:\\Programming\\Python313\\Lib\\_weakrefset.py:85)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946616.957, "ph": "X", "dur": 55.10000002531431, "name": "BaseProcess.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:80)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946675.257, "ph": "X", "dur": 43.700000020076864, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946723.857, "ph": "X", "dur": 0.9000000004134823, "name": "BaseProcess._check_closed (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:99)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946726.257, "ph": "X", "dur": 0.6000000002756549, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946728.857, "ph": "X", "dur": 1.1000000005053674, "name": "dict.get", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946748.257, "ph": "X", "dur": 1.2000000005513098, "name": "builtins.max", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946751.957, "ph": "X", "dur": 5.60000000257278, "name": "_winapi.WaitForSingleObject", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946744.557, "ph": "X", "dur": 14.700000006753546, "name": "Popen.wait (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:105)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946740.057, "ph": "X", "dur": 19.800000009096614, "name": "Popen.poll (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:123)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946731.757, "ph": "X", "dur": 29.200000013415206, "name": "_cleanup (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:61)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946765.657, "ph": "X", "dur": 0.5000000002297125, "name": "DefaultContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:237)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946772.057, "ph": "X", "dur": 1.400000000643195, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946771.257, "ph": "X", "dur": 3.000000001378275, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946788.857, "ph": "X", "dur": 0.30000000013782746, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946789.557, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946786.457, "ph": "X", "dur": 4.40000000202147, "name": "_check_not_importing_main (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:138)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946793.457, "ph": "X", "dur": 0.30000000013782746, "name": "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946795.057, "ph": "X", "dur": 1.000000000459425, "name": "BaseProcess.authkey (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:213)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946802.157, "ph": "X", "dur": 1.3000000005972523, "name": "list.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946805.257, "ph": "X", "dur": 4.6000000021133545, "name": "list.index", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946817.057, "ph": "X", "dur": 4.300000001975527, "name": "nt.getcwd", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946823.857, "ph": "X", "dur": 1.8000000008269645, "name": "DefaultContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:253)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946826.557, "ph": "X", "dur": 6.700000003078147, "name": "dict.update", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946836.757, "ph": "X", "dur": 1.8000000008269645, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946841.157, "ph": "X", "dur": 1.6000000007350799, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946847.257, "ph": "X", "dur": 0.9000000004134823, "name": "nt.fspath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946849.957, "ph": "X", "dur": 1.400000000643195, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946854.757, "ph": "X", "dur": 1.3000000005972523, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946857.057, "ph": "X", "dur": 1.000000000459425, "name": "str.startswith", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946846.757, "ph": "X", "dur": 11.800000005421214, "name": "isabs (C:\\Programming\\Python313\\Lib\\ntpath.py:80)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946860.757, "ph": "X", "dur": 3.700000001699872, "name": "nt._path_normpath", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946785.257, "ph": "X", "dur": 80.20000003684586, "name": "get_preparation_data (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:160)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946867.457, "ph": "X", "dur": 51.200000023522556, "name": "_winapi.CreatePipe", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946921.657, "ph": "X", "dur": 4.900000002251182, "name": "msvcrt.open_osfhandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946927.757, "ph": "X", "dur": 0.40000000018376997, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946931.957, "ph": "X", "dur": 1.000000000459425, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946935.357, "ph": "X", "dur": 0.9000000004134823, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946939.757, "ph": "X", "dur": 3.4000000015620446, "name": "get_command_line.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:92)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946943.757, "ph": "X", "dur": 1.5000000006891374, "name": "get_command_line.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:92)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946945.657, "ph": "X", "dur": 0.40000000018376997, "name": "get_command_line.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:92)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946938.257, "ph": "X", "dur": 10.400000004778018, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946956.957, "ph": "X", "dur": 1.9000000008729072, "name": "_optim_args_from_interpreter_flags (C:\\Programming\\Python313\\Lib\\subprocess.py:296)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946959.557, "ph": "X", "dur": 0.5000000002297125, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946960.957, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946962.257, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946963.257, "ph": "X", "dur": 0.5000000002297125, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946964.157, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946964.957, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946965.757, "ph": "X", "dur": 0.20000000009188498, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946970.657, "ph": "X", "dur": 0.7000000003215975, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946979.257, "ph": "X", "dur": 1.6000000007350799, "name": "list.extend", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946953.357, "ph": "X", "dur": 29.100000013369264, "name": "_args_from_interpreter_flags (C:\\Programming\\Python313\\Lib\\subprocess.py:306)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946984.257, "ph": "X", "dur": 0.40000000018376997, "name": "get_executable (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:45)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946930.457, "ph": "X", "dur": 57.70000002650882, "name": "get_command_line (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:83)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946989.557, "ph": "X", "dur": 0.20000000009188498, "name": "get_executable (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:45)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946992.257, "ph": "X", "dur": 1.400000000643195, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946993.957, "ph": "X", "dur": 1.1000000005053674, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946995.357, "ph": "X", "dur": 0.8000000003675399, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946996.457, "ph": "X", "dur": 7.3000000033538015, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529947004.157, "ph": "X", "dur": 0.7000000003215975, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529947005.257, "ph": "X", "dur": 0.8000000003675399, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529947006.457, "ph": "X", "dur": 0.20000000009188498, "name": "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946991.557, "ph": "X", "dur": 17.40000000799399, "name": "str.join", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529947010.657, "ph": "X", "dur": 40.90000001879047, "name": "_io.open", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529947060.857, "ph": "X", "dur": 1.1000000005053674, "name": "STARTUPINFO.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:199)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529947063.257, "ph": "X", "dur": 8223.00000377785, "name": "_winapi.CreateProcess", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955296.057, "ph": "X", "dur": 7.100000003261917, "name": "_winapi.CloseHandle", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955324.257, "ph": "X", "dur": 0.9000000004134823, "name": "builtins.next", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955327.257, "ph": "X", "dur": 1.3000000005972523, "name": "nt.getpid", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955317.057, "ph": "X", "dur": 14.700000006753546, "name": "Finalize.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:178)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955335.657, "ph": "X", "dur": 4.300000001975527, "name": "set_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:369)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955367.957, "ph": "X", "dur": 3.700000001699872, "name": "dict.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955373.757, "ph": "X", "dur": 4.0000000018377, "name": "dict.update", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955345.457, "ph": "X", "dur": 32.80000001506913, "name": "ForkingPickler.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:38)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955400.857, "ph": "X", "dur": 1.9000000008729072, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955399.757, "ph": "X", "dur": 4.0000000018377, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955411.357, "ph": "X", "dur": 1.400000000643195, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955410.857, "ph": "X", "dur": 2.3000000010566772, "name": "get_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:366)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955395.957, "ph": "X", "dur": 20.200000009280384, "name": "AuthenticationString.__reduce__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:347)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955380.657, "ph": "X", "dur": 66.6000000305977, "name": "ForkingPickler.dump", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955342.657, "ph": "X", "dur": 109.40000005026108, "name": "dump (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:58)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955465.157, "ph": "X", "dur": 1.3000000005972523, "name": "dict.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955467.957, "ph": "X", "dur": 1.9000000008729072, "name": "dict.update", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955455.957, "ph": "X", "dur": 14.400000006615716, "name": "ForkingPickler.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:38)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955504.557, "ph": "X", "dur": 1.2000000005513098, "name": "str.rpartition", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955503.757, "ph": "X", "dur": 2.80000000128639, "name": "ModuleSpec.parent (<frozen importlib._bootstrap>:645)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955510.957, "ph": "X", "dur": 1.400000000643195, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955510.557, "ph": "X", "dur": 2.100000000964792, "name": "get_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:366)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955501.757, "ph": "X", "dur": 12.800000005880639, "name": "AuthenticationString.__reduce__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:347)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955471.457, "ph": "X", "dur": 64.30000002954102, "name": "ForkingPickler.dump", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955454.457, "ph": "X", "dur": 85.20000003914299, "name": "dump (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:58)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955541.457, "ph": "X", "dur": 1.1000000005053674, "name": "set_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:369)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955542.957, "ph": "X", "dur": 50.80000002333878, "name": "_io.BufferedWriter.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946782.557, "ph": "X", "dur": 8812.200004048544, "name": "Popen.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:46)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946769.157, "ph": "X", "dur": 8831.50000405741, "name": "SpawnProcess._Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:334)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946763.157, "ph": "X", "dur": 8838.40000406058, "name": "Process._Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:222)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955609.457, "ph": "X", "dur": 1.000000000459425, "name": "set.add", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529946722.357, "ph": "X", "dur": 8888.800004083736, "name": "BaseProcess.start (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:110)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955613.957, "ph": "X", "dur": 30.600000014058402, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955652.157, "ph": "X", "dur": 0.6000000002756549, "name": "builtins.callable", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955654.257, "ph": "X", "dur": 7.100000003261917, "name": "wx._core.GetApp", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955662.457, "ph": "X", "dur": 1.8000000008269645, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955678.057, "ph": "X", "dur": 2.4000000011026197, "name": "PyEvent.SetEventType", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955693.957, "ph": "X", "dur": 1.2000000005513098, "name": "sip.wrappertype.__new__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955692.857, "ph": "X", "dur": 14.500000006661661, "name": "_PyEvent_Clone (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1851)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955684.357, "ph": "X", "dur": 34.20000001571233, "name": "wx._core.PostEvent", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955651.657, "ph": "X", "dur": 67.30000003091929, "name": "CallAfter (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3406)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529900296.857, "ph": "X", "dur": 55428.10002546505, "name": "func_on_button_start_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:527)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529900288.457, "ph": "X", "dur": 55437.40002546932, "name": "MyFrame.on_button_start_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1040)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955898.457, "ph": "X", "dur": 927.8000004262543, "name": "StaticText.SetLabel", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955895.357, "ph": "X", "dur": 933.5000004288731, "name": "MyFrame.update_status (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1019)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529955879.957, "ph": "X", "dur": 951.3000004370508, "name": "CallAfter.<locals>.<lambda> (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3427)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529956885.757, "ph": "X", "dur": 686.5000003153951, "name": "StaticText.SetLabel", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529956882.857, "ph": "X", "dur": 692.000000317922, "name": "MyFrame.update_status (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1019)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529956868.357, "ph": "X", "dur": 709.500000325962, "name": "CallAfter.<locals>.<lambda> (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3427)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529957636.457, "ph": "X", "dur": 701.3000003221947, "name": "StaticText.SetLabel", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529957633.957, "ph": "X", "dur": 706.6000003246296, "name": "MyFrame.update_status (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1019)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351529957622.457, "ph": "X", "dur": 720.6000003310616, "name": "CallAfter.<locals>.<lambda> (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3427)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522197296.254, "ph": "X", "dur": 216962665.79967803, "name": "MainLoop", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739159975.954, "ph": "X", "dur": 10.200000004686133, "name": "App.RestoreStdio (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2276)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351522197289.854, "ph": "X", "dur": 216962697.09967807, "name": "App.MainLoop (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2258)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160003.054, "ph": "X", "dur": 1.5000000006891374, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160005.654, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160007.154, "ph": "X", "dur": 0.30000000013782746, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160001.254, "ph": "X", "dur": 6.600000003032204, "name": "RawConfigParser._validate_value_types (C:\\Programming\\Python313\\Lib\\configparser.py:1201)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160021.754, "ph": "X", "dur": 1.2000000005513098, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160028.654, "ph": "X", "dur": 5.100000002343067, "name": "re.Pattern.sub", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160020.454, "ph": "X", "dur": 15.100000006937314, "name": "BasicInterpolation.before_set (C:\\Programming\\Python313\\Lib\\configparser.py:418)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160041.154, "ph": "X", "dur": 0.8000000003675399, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160040.554, "ph": "X", "dur": 1.9000000008729072, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160016.054, "ph": "X", "dur": 28.500000013093608, "name": "RawConfigParser.set (C:\\Programming\\Python313\\Lib\\configparser.py:920)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739159996.454, "ph": "X", "dur": 48.40000002223616, "name": "ConfigParser.set (C:\\Programming\\Python313\\Lib\\configparser.py:1232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160057.854, "ph": "X", "dur": 0.40000000018376997, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160059.154, "ph": "X", "dur": 0.10000000004594249, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160063.154, "ph": "X", "dur": 0.8000000003675399, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160056.554, "ph": "X", "dur": 8.0000000036754, "name": "RawConfigParser._validate_value_types (C:\\Programming\\Python313\\Lib\\configparser.py:1201)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160071.954, "ph": "X", "dur": 1.000000000459425, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160075.254, "ph": "X", "dur": 2.80000000128639, "name": "re.Pattern.sub", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160071.054, "ph": "X", "dur": 8.200000003767283, "name": "BasicInterpolation.before_set (C:\\Programming\\Python313\\Lib\\configparser.py:418)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160098.554, "ph": "X", "dur": 2.80000000128639, "name": "str.lower", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160084.254, "ph": "X", "dur": 17.80000000817776, "name": "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160068.954, "ph": "X", "dur": 35.500000016309585, "name": "RawConfigParser.set (C:\\Programming\\Python313\\Lib\\configparser.py:920)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160054.254, "ph": "X", "dur": 50.700000023292844, "name": "ConfigParser.set (C:\\Programming\\Python313\\Lib\\configparser.py:1232)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160109.254, "ph": "X", "dur": 383.8000001763272, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160508.054, "ph": "X", "dur": 25.70000001180722, "name": "builtins.print", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161138.754, "ph": "X", "dur": 3.300000001516102, "name": "IncrementalEncoder.__init__ (C:\\Programming\\Python313\\Lib\\codecs.py:189)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739160535.954, "ph": "X", "dur": 643.4000002955939, "name": "_io.open", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161201.254, "ph": "X", "dur": 4.300000001975527, "name": "str.format", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161218.654, "ph": "X", "dur": 1.400000000643195, "name": "dict.items", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161226.654, "ph": "X", "dur": 2.100000000964792, "name": "str.format", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161242.754, "ph": "X", "dur": 2.900000001332332, "name": "_codecs.charmap_encode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161238.154, "ph": "X", "dur": 8.80000000404294, "name": "IncrementalEncoder.encode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:18)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161229.454, "ph": "X", "dur": 18.700000008591243, "name": "_io.TextIOWrapper.write", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161254.554, "ph": "X", "dur": 0.30000000013782746, "name": "Interpolation.before_write (C:\\Programming\\Python313\\Lib\\configparser.py:392)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161257.754, "ph": "X", "dur": 0.9000000004134823, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161260.654, "ph": "X", "dur": 2.3000000010566772, "name": "str.format", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161269.954, "ph": "X", "dur": 1.6000000007350799, "name": "_codecs.charmap_encode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161266.654, "ph": "X", "dur": 6.200000002848434, "name": "IncrementalEncoder.encode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:18)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161263.654, "ph": "X", "dur": 10.700000004915847, "name": "_io.TextIOWrapper.write", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161277.954, "ph": "X", "dur": 0.30000000013782746, "name": "Interpolation.before_write (C:\\Programming\\Python313\\Lib\\configparser.py:392)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161280.354, "ph": "X", "dur": 0.6000000002756549, "name": "str.replace", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161283.054, "ph": "X", "dur": 2.00000000091885, "name": "str.format", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161289.054, "ph": "X", "dur": 2.500000001148562, "name": "_codecs.charmap_encode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161288.354, "ph": "X", "dur": 3.8000000017458144, "name": "IncrementalEncoder.encode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:18)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161285.854, "ph": "X", "dur": 7.500000003445686, "name": "_io.TextIOWrapper.write", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161297.554, "ph": "X", "dur": 0.9000000004134823, "name": "_codecs.charmap_encode", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161297.054, "ph": "X", "dur": 1.9000000008729072, "name": "IncrementalEncoder.encode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:18)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161294.954, "ph": "X", "dur": 4.700000002159297, "name": "_io.TextIOWrapper.write", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161225.354, "ph": "X", "dur": 74.90000003441092, "name": "RawConfigParser._write_section (C:\\Programming\\Python313\\Lib\\configparser.py:959)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161197.454, "ph": "X", "dur": 104.80000004814772, "name": "RawConfigParser.write (C:\\Programming\\Python313\\Lib\\configparser.py:934)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161303.254, "ph": "X", "dur": 343.00000015758275, "name": "_io.TextIOWrapper.__exit__", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161667.754, "ph": "X", "dur": 325.90000014972657, "name": "pyaudio._portaudio.stop_stream", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739161659.354, "ph": "X", "dur": 337.80000015519374, "name": "PyAudio.Stream.stop_stream (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:495)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739162011.654, "ph": "X", "dur": 8765.400004027042, "name": "pyaudio._portaudio.close", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170795.154, "ph": "X", "dur": 1.5000000006891374, "name": "set.remove", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170791.554, "ph": "X", "dur": 6.4000000029403195, "name": "PyAudio._remove_stream (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:654)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739162007.754, "ph": "X", "dur": 8790.700004038665, "name": "PyAudio.Stream.close (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:449)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170805.154, "ph": "X", "dur": 2.500000001148562, "name": "set.copy", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170814.154, "ph": "X", "dur": 123.30000005664708, "name": "pyaudio._portaudio.terminate", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170803.554, "ph": "X", "dur": 135.00000006202237, "name": "PyAudio.terminate (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:594)", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170947.954, "ph": "X", "dur": 16.10000000739674, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170967.054, "ph": "X", "dur": 1.7000000007810223, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170970.054, "ph": "X", "dur": 1.2000000005513098, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170972.154, "ph": "X", "dur": 1.1000000005053674, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170974.254, "ph": "X", "dur": 1.000000000459425, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170976.454, "ph": "X", "dur": 1.000000000459425, "name": "numpy.array", "cat": "FEE"}, {"pid": 8952, "tid": 3232, "ts": 351739170981.754, "ph": "X", "dur": 39.200000018009455, "name": "builtins.print", "cat": "FEE"}], "viztracer_metadata": {"version": "1.0.3", "overflow": false, "baseTimeNanoseconds": 1745300833843432000}, "file_info": {"files": {"C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py": ["\"\"\"Machine limits for Float32 and Float64 and (long double) if available...\n\n\"\"\"\n__all__ = ['finfo', 'iinfo']\n\nimport warnings\n\nfrom .._utils import set_module\nfrom ._machar import MachAr\nfrom . import numeric\nfrom . import numerictypes as ntypes\nfrom .numeric import array, inf, nan\nfrom .umath import log10, exp2, nextafter, isnan\n\n\ndef _fr0(a):\n    \"\"\"fix rank-0 --> rank-1\"\"\"\n    if a.ndim == 0:\n        a = a.copy()\n        a.shape = (1,)\n    return a\n\n\ndef _fr1(a):\n    \"\"\"fix rank > 0 --> rank-0\"\"\"\n    if a.size == 1:\n        a = a.copy()\n        a.shape = ()\n    return a\n\n\nclass MachArLike:\n    \"\"\" Object to simulate MachAr instance \"\"\"\n    def __init__(self, ftype, *, eps, epsneg, huge, tiny,\n                 ibeta, smallest_subnormal=None, **kwargs):\n        self.params = _MACHAR_PARAMS[ftype]\n        self.ftype = ftype\n        self.title = self.params['title']\n        # Parameter types same as for discovered MachAr object.\n        if not smallest_subnormal:\n            self._smallest_subnormal = nextafter(\n                self.ftype(0), self.ftype(1), dtype=self.ftype)\n        else:\n            self._smallest_subnormal = smallest_subnormal\n        self.epsilon = self.eps = self._float_to_float(eps)\n        self.epsneg = self._float_to_float(epsneg)\n        self.xmax = self.huge = self._float_to_float(huge)\n        self.xmin = self._float_to_float(tiny)\n        self.smallest_normal = self.tiny = self._float_to_float(tiny)\n        self.ibeta = self.params['itype'](ibeta)\n        self.__dict__.update(kwargs)\n        self.precision = int(-log10(self.eps))\n        self.resolution = self._float_to_float(\n            self._float_conv(10) ** (-self.precision))\n        self._str_eps = self._float_to_str(self.eps)\n        self._str_epsneg = self._float_to_str(self.epsneg)\n        self._str_xmin = self._float_to_str(self.xmin)\n        self._str_xmax = self._float_to_str(self.xmax)\n        self._str_resolution = self._float_to_str(self.resolution)\n        self._str_smallest_normal = self._float_to_str(self.xmin)\n\n    @property\n    def smallest_subnormal(self):\n        \"\"\"Return the value for the smallest subnormal.\n\n        Returns\n        -------\n        smallest_subnormal : float\n            value for the smallest subnormal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest subnormal is zero.\n        \"\"\"\n        # Check that the calculated value is not zero, in case it raises a\n        # warning.\n        value = self._smallest_subnormal\n        if self.ftype(0) == value:\n            warnings.warn(\n                'The value of the smallest subnormal for {} type '\n                'is zero.'.format(self.ftype), UserWarning, stacklevel=2)\n\n        return self._float_to_float(value)\n\n    @property\n    def _str_smallest_subnormal(self):\n        \"\"\"Return the string representation of the smallest subnormal.\"\"\"\n        return self._float_to_str(self.smallest_subnormal)\n\n    def _float_to_float(self, value):\n        \"\"\"Converts float to float.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return _fr1(self._float_conv(value))\n\n    def _float_conv(self, value):\n        \"\"\"Converts float to conv.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return array([value], self.ftype)\n\n    def _float_to_str(self, value):\n        \"\"\"Converts float to str.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return self.params['fmt'] % array(_fr0(value)[0], self.ftype)\n\n\n_convert_to_float = {\n    ntypes.csingle: ntypes.single,\n    ntypes.complex128: ntypes.float64,\n    ntypes.clongdouble: ntypes.longdouble\n    }\n\n# Parameters for creating MachAr / MachAr-like objects\n_title_fmt = 'numpy {} precision floating point number'\n_MACHAR_PARAMS = {\n    ntypes.double: dict(\n        itype = ntypes.int64,\n        fmt = '%24.16e',\n        title = _title_fmt.format('double')),\n    ntypes.single: dict(\n        itype = ntypes.int32,\n        fmt = '%15.7e',\n        title = _title_fmt.format('single')),\n    ntypes.longdouble: dict(\n        itype = ntypes.longlong,\n        fmt = '%s',\n        title = _title_fmt.format('long double')),\n    ntypes.half: dict(\n        itype = ntypes.int16,\n        fmt = '%12.5e',\n        title = _title_fmt.format('half'))}\n\n# Key to identify the floating point type.  Key is result of\n#\n#    ftype = np.longdouble        # or float64, float32, etc.\n#    v = (ftype(-1.0) / ftype(10.0))\n#    v.view(v.dtype.newbyteorder('<')).tobytes()\n#\n# Uses division to work around deficiencies in strtold on some platforms.\n# See:\n# https://perl5.git.perl.org/perl.git/blob/3118d7d684b56cbeb702af874f4326683c45f045:/Configure\n\n_KNOWN_TYPES = {}\ndef _register_type(machar, bytepat):\n    _KNOWN_TYPES[bytepat] = machar\n\n\n_float_ma = {}\n\n\ndef _register_known_types():\n    # Known parameters for float16\n    # See docstring of MachAr class for description of parameters.\n    f16 = ntypes.float16\n    float16_ma = MachArLike(f16,\n                            machep=-10,\n                            negep=-11,\n                            minexp=-14,\n                            maxexp=16,\n                            it=10,\n                            iexp=5,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(f16(-10)),\n                            epsneg=exp2(f16(-11)),\n                            huge=f16(65504),\n                            tiny=f16(2 ** -14))\n    _register_type(float16_ma, b'f\\xae')\n    _float_ma[16] = float16_ma\n\n    # Known parameters for float32\n    f32 = ntypes.float32\n    float32_ma = MachArLike(f32,\n                            machep=-23,\n                            negep=-24,\n                            minexp=-126,\n                            maxexp=128,\n                            it=23,\n                            iexp=8,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(f32(-23)),\n                            epsneg=exp2(f32(-24)),\n                            huge=f32((1 - 2 ** -24) * 2**128),\n                            tiny=exp2(f32(-126)))\n    _register_type(float32_ma, b'\\xcd\\xcc\\xcc\\xbd')\n    _float_ma[32] = float32_ma\n\n    # Known parameters for float64\n    f64 = ntypes.float64\n    epsneg_f64 = 2.0 ** -53.0\n    tiny_f64 = 2.0 ** -1022.0\n    float64_ma = MachArLike(f64,\n                            machep=-52,\n                            negep=-53,\n                            minexp=-1022,\n                            maxexp=1024,\n                            it=52,\n                            iexp=11,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=2.0 ** -52.0,\n                            epsneg=epsneg_f64,\n                            huge=(1.0 - epsneg_f64) / tiny_f64 * f64(4),\n                            tiny=tiny_f64)\n    _register_type(float64_ma, b'\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf')\n    _float_ma[64] = float64_ma\n\n    # Known parameters for IEEE 754 128-bit binary float\n    ld = ntypes.longdouble\n    epsneg_f128 = exp2(ld(-113))\n    tiny_f128 = exp2(ld(-16382))\n    # Ignore runtime error when this is not f128\n    with numeric.errstate(all='ignore'):\n        huge_f128 = (ld(1) - epsneg_f128) / tiny_f128 * ld(4)\n    float128_ma = MachArLike(ld,\n                             machep=-112,\n                             negep=-113,\n                             minexp=-16382,\n                             maxexp=16384,\n                             it=112,\n                             iexp=15,\n                             ibeta=2,\n                             irnd=5,\n                             ngrd=0,\n                             eps=exp2(ld(-112)),\n                             epsneg=epsneg_f128,\n                             huge=huge_f128,\n                             tiny=tiny_f128)\n    # IEEE 754 128-bit binary float\n    _register_type(float128_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\xfb\\xbf')\n    _float_ma[128] = float128_ma\n\n    # Known parameters for float80 (Intel 80-bit extended precision)\n    epsneg_f80 = exp2(ld(-64))\n    tiny_f80 = exp2(ld(-16382))\n    # Ignore runtime error when this is not f80\n    with numeric.errstate(all='ignore'):\n        huge_f80 = (ld(1) - epsneg_f80) / tiny_f80 * ld(4)\n    float80_ma = MachArLike(ld,\n                            machep=-63,\n                            negep=-64,\n                            minexp=-16382,\n                            maxexp=16384,\n                            it=63,\n                            iexp=15,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(ld(-63)),\n                            epsneg=epsneg_f80,\n                            huge=huge_f80,\n                            tiny=tiny_f80)\n    # float80, first 10 bytes containing actual storage\n    _register_type(float80_ma, b'\\xcd\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xfb\\xbf')\n    _float_ma[80] = float80_ma\n\n    # Guessed / known parameters for double double; see:\n    # https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic\n    # These numbers have the same exponent range as float64, but extended\n    # number of digits in the significand.\n    huge_dd = nextafter(ld(inf), ld(0), dtype=ld)\n    # As the smallest_normal in double double is so hard to calculate we set\n    # it to NaN.\n    smallest_normal_dd = nan\n    # Leave the same value for the smallest subnormal as double\n    smallest_subnormal_dd = ld(nextafter(0., 1.))\n    float_dd_ma = MachArLike(ld,\n                             machep=-105,\n                             negep=-106,\n                             minexp=-1022,\n                             maxexp=1024,\n                             it=105,\n                             iexp=11,\n                             ibeta=2,\n                             irnd=5,\n                             ngrd=0,\n                             eps=exp2(ld(-105)),\n                             epsneg=exp2(ld(-106)),\n                             huge=huge_dd,\n                             tiny=smallest_normal_dd,\n                             smallest_subnormal=smallest_subnormal_dd)\n    # double double; low, high order (e.g. PPC 64)\n    _register_type(float_dd_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99Y<\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf')\n    # double double; high, low order (e.g. PPC 64 le)\n    _register_type(float_dd_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf\\x9a\\x99\\x99\\x99\\x99\\x99Y<')\n    _float_ma['dd'] = float_dd_ma\n\n\ndef _get_machar(ftype):\n    \"\"\" Get MachAr instance or MachAr-like instance\n\n    Get parameters for floating point type, by first trying signatures of\n    various known floating point types, then, if none match, attempting to\n    identify parameters by analysis.\n\n    Parameters\n    ----------\n    ftype : class\n        Numpy floating point type class (e.g. ``np.float64``)\n\n    Returns\n    -------\n    ma_like : instance of :class:`MachAr` or :class:`MachArLike`\n        Object giving floating point parameters for `ftype`.\n\n    Warns\n    -----\n    UserWarning\n        If the binary signature of the float type is not in the dictionary of\n        known float types.\n    \"\"\"\n    params = _MACHAR_PARAMS.get(ftype)\n    if params is None:\n        raise ValueError(repr(ftype))\n    # Detect known / suspected types\n    # ftype(-1.0) / ftype(10.0) is better than ftype('-0.1') because stold\n    # may be deficient\n    key = (ftype(-1.0) / ftype(10.))\n    key = key.view(key.dtype.newbyteorder(\"<\")).tobytes()\n    ma_like = None\n    if ftype == ntypes.longdouble:\n        # Could be 80 bit == 10 byte extended precision, where last bytes can\n        # be random garbage.\n        # Comparing first 10 bytes to pattern first to avoid branching on the\n        # random garbage.\n        ma_like = _KNOWN_TYPES.get(key[:10])\n    if ma_like is None:\n        # see if the full key is known.\n        ma_like = _KNOWN_TYPES.get(key)\n    if ma_like is None and len(key) == 16:\n        # machine limits could be f80 masquerading as np.float128,\n        # find all keys with length 16 and make new dict, but make the keys\n        # only 10 bytes long, the last bytes can be random garbage\n        _kt = {k[:10]: v for k, v in _KNOWN_TYPES.items() if len(k) == 16}\n        ma_like = _kt.get(key[:10])\n    if ma_like is not None:\n        return ma_like\n    # Fall back to parameter discovery\n    warnings.warn(\n        f'Signature {key} for {ftype} does not match any known type: '\n        'falling back to type probe function.\\n'\n        'This warnings indicates broken support for the dtype!',\n        UserWarning, stacklevel=2)\n    return _discovered_machar(ftype)\n\n\ndef _discovered_machar(ftype):\n    \"\"\" Create MachAr instance with found information on float types\n\n    TODO: MachAr should be retired completely ideally.  We currently only\n          ever use it system with broken longdouble (valgrind, WSL).\n    \"\"\"\n    params = _MACHAR_PARAMS[ftype]\n    return MachAr(lambda v: array([v], ftype),\n                  lambda v: _fr0(v.astype(params['itype']))[0],\n                  lambda v: array(_fr0(v)[0], ftype),\n                  lambda v: params['fmt'] % array(_fr0(v)[0], ftype),\n                  params['title'])\n\n\n@set_module('numpy')\nclass finfo:\n    \"\"\"\n    finfo(dtype)\n\n    Machine limits for floating point types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    dtype : dtype\n        Returns the dtype for which `finfo` returns information. For complex\n        input, the returned dtype is the associated ``float*`` dtype for its\n        real and complex components.\n    eps : float\n        The difference between 1.0 and the next smallest representable float\n        larger than 1.0. For example, for 64-bit binary floats in the IEEE-754\n        standard, ``eps = 2**-52``, approximately 2.22e-16.\n    epsneg : float\n        The difference between 1.0 and the next smallest representable float\n        less than 1.0. For example, for 64-bit binary floats in the IEEE-754\n        standard, ``epsneg = 2**-53``, approximately 1.11e-16.\n    iexp : int\n        The number of bits in the exponent portion of the floating point\n        representation.\n    machep : int\n        The exponent that yields `eps`.\n    max : floating point number of the appropriate type\n        The largest representable number.\n    maxexp : int\n        The smallest positive power of the base (2) that causes overflow.\n    min : floating point number of the appropriate type\n        The smallest representable number, typically ``-max``.\n    minexp : int\n        The most negative power of the base (2) consistent with there\n        being no leading 0's in the mantissa.\n    negep : int\n        The exponent that yields `epsneg`.\n    nexp : int\n        The number of bits in the exponent including its sign and bias.\n    nmant : int\n        The number of bits in the mantissa.\n    precision : int\n        The approximate number of decimal digits to which this kind of\n        float is precise.\n    resolution : floating point number of the appropriate type\n        The approximate decimal resolution of this type, i.e.,\n        ``10**-precision``.\n    tiny : float\n        An alias for `smallest_normal`, kept for backwards compatibility.\n    smallest_normal : float\n        The smallest positive floating point number with 1 as leading bit in\n        the mantissa following IEEE-754 (see Notes).\n    smallest_subnormal : float\n        The smallest positive floating point number with 0 as leading bit in\n        the mantissa following IEEE-754.\n\n    Parameters\n    ----------\n    dtype : float, dtype, or instance\n        Kind of floating point or complex floating point\n        data-type about which to get information.\n\n    See Also\n    --------\n    iinfo : The equivalent for integer data types.\n    spacing : The distance between a value and the nearest adjacent number\n    nextafter : The next floating point value after x1 towards x2\n\n    Notes\n    -----\n    For developers of NumPy: do not instantiate this at the module level.\n    The initial calculation of these parameters is expensive and negatively\n    impacts import times.  These objects are cached, so calling ``finfo()``\n    repeatedly inside your functions is not a problem.\n\n    Note that ``smallest_normal`` is not actually the smallest positive\n    representable value in a NumPy floating point type. As in the IEEE-754\n    standard [1]_, NumPy floating point types make use of subnormal numbers to\n    fill the gap between 0 and ``smallest_normal``. However, subnormal numbers\n    may have significantly reduced precision [2]_.\n\n    This function can also be used for complex data types as well. If used,\n    the output will be the same as the corresponding real float type\n    (e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).\n    However, the output is true for the real and imaginary components.\n\n    References\n    ----------\n    .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,\n           pp.1-70, 2008, https://doi.org/10.1109/IEEESTD.2008.4610935\n    .. [2] Wikipedia, \"Denormal Numbers\",\n           https://en.wikipedia.org/wiki/Denormal_number\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.finfo(np.float64).dtype\n    dtype('float64')\n    >>> np.finfo(np.complex64).dtype\n    dtype('float32')\n\n    \"\"\"\n\n    _finfo_cache = {}\n\n    def __new__(cls, dtype):\n        try:\n            obj = cls._finfo_cache.get(dtype)  # most common path\n            if obj is not None:\n                return obj\n        except TypeError:\n            pass\n\n        if dtype is None:\n            # Deprecated in NumPy 1.25, 2023-01-16\n            warnings.warn(\n                \"finfo() dtype cannot be None. This behavior will \"\n                \"raise an error in the future. (Deprecated in NumPy 1.25)\",\n                DeprecationWarning,\n                stacklevel=2\n            )\n\n        try:\n            dtype = numeric.dtype(dtype)\n        except TypeError:\n            # In case a float instance was given\n            dtype = numeric.dtype(type(dtype))\n\n        obj = cls._finfo_cache.get(dtype)\n        if obj is not None:\n            return obj\n        dtypes = [dtype]\n        newdtype = ntypes.obj2sctype(dtype)\n        if newdtype is not dtype:\n            dtypes.append(newdtype)\n            dtype = newdtype\n        if not issubclass(dtype, numeric.inexact):\n            raise ValueError(\"data type %r not inexact\" % (dtype))\n        obj = cls._finfo_cache.get(dtype)\n        if obj is not None:\n            return obj\n        if not issubclass(dtype, numeric.floating):\n            newdtype = _convert_to_float[dtype]\n            if newdtype is not dtype:\n                # dtype changed, for example from complex128 to float64\n                dtypes.append(newdtype)\n                dtype = newdtype\n\n                obj = cls._finfo_cache.get(dtype, None)\n                if obj is not None:\n                    # the original dtype was not in the cache, but the new\n                    # dtype is in the cache. we add the original dtypes to\n                    # the cache and return the result\n                    for dt in dtypes:\n                        cls._finfo_cache[dt] = obj\n                    return obj\n        obj = object.__new__(cls)._init(dtype)\n        for dt in dtypes:\n            cls._finfo_cache[dt] = obj\n        return obj\n\n    def _init(self, dtype):\n        self.dtype = numeric.dtype(dtype)\n        machar = _get_machar(dtype)\n\n        for word in ['precision', 'iexp',\n                     'maxexp', 'minexp', 'negep',\n                     'machep']:\n            setattr(self, word, getattr(machar, word))\n        for word in ['resolution', 'epsneg', 'smallest_subnormal']:\n            setattr(self, word, getattr(machar, word).flat[0])\n        self.bits = self.dtype.itemsize * 8\n        self.max = machar.huge.flat[0]\n        self.min = -self.max\n        self.eps = machar.eps.flat[0]\n        self.nexp = machar.iexp\n        self.nmant = machar.it\n        self._machar = machar\n        self._str_tiny = machar._str_xmin.strip()\n        self._str_max = machar._str_xmax.strip()\n        self._str_epsneg = machar._str_epsneg.strip()\n        self._str_eps = machar._str_eps.strip()\n        self._str_resolution = machar._str_resolution.strip()\n        self._str_smallest_normal = machar._str_smallest_normal.strip()\n        self._str_smallest_subnormal = machar._str_smallest_subnormal.strip()\n        return self\n\n    def __str__(self):\n        fmt = (\n            'Machine parameters for %(dtype)s\\n'\n            '---------------------------------------------------------------\\n'\n            'precision = %(precision)3s   resolution = %(_str_resolution)s\\n'\n            'machep = %(machep)6s   eps =        %(_str_eps)s\\n'\n            'negep =  %(negep)6s   epsneg =     %(_str_epsneg)s\\n'\n            'minexp = %(minexp)6s   tiny =       %(_str_tiny)s\\n'\n            'maxexp = %(maxexp)6s   max =        %(_str_max)s\\n'\n            'nexp =   %(nexp)6s   min =        -max\\n'\n            'smallest_normal = %(_str_smallest_normal)s   '\n            'smallest_subnormal = %(_str_smallest_subnormal)s\\n'\n            '---------------------------------------------------------------\\n'\n            )\n        return fmt % self.__dict__\n\n    def __repr__(self):\n        c = self.__class__.__name__\n        d = self.__dict__.copy()\n        d['klass'] = c\n        return ((\"%(klass)s(resolution=%(resolution)s, min=-%(_str_max)s,\"\n                 \" max=%(_str_max)s, dtype=%(dtype)s)\") % d)\n\n    @property\n    def smallest_normal(self):\n        \"\"\"Return the value for the smallest normal.\n\n        Returns\n        -------\n        smallest_normal : float\n            Value for the smallest normal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest normal is requested for\n            double-double.\n        \"\"\"\n        # This check is necessary because the value for smallest_normal is\n        # platform dependent for longdouble types.\n        if isnan(self._machar.smallest_normal.flat[0]):\n            warnings.warn(\n                'The value of smallest normal is undefined for double double',\n                UserWarning, stacklevel=2)\n        return self._machar.smallest_normal.flat[0]\n\n    @property\n    def tiny(self):\n        \"\"\"Return the value for tiny, alias of smallest_normal.\n\n        Returns\n        -------\n        tiny : float\n            Value for the smallest normal, alias of smallest_normal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest normal is requested for\n            double-double.\n        \"\"\"\n        return self.smallest_normal\n\n\n@set_module('numpy')\nclass iinfo:\n    \"\"\"\n    iinfo(type)\n\n    Machine limits for integer types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    dtype : dtype\n        Returns the dtype for which `iinfo` returns information.\n    min : int\n        The smallest integer expressible by the type.\n    max : int\n        The largest integer expressible by the type.\n\n    Parameters\n    ----------\n    int_type : integer type, dtype, or instance\n        The kind of integer data type to get information about.\n\n    See Also\n    --------\n    finfo : The equivalent for floating point data types.\n\n    Examples\n    --------\n    With types:\n\n    >>> import numpy as np\n    >>> ii16 = np.iinfo(np.int16)\n    >>> ii16.min\n    -32768\n    >>> ii16.max\n    32767\n    >>> ii32 = np.iinfo(np.int32)\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    With instances:\n\n    >>> ii32 = np.iinfo(np.int32(10))\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    \"\"\"\n\n    _min_vals = {}\n    _max_vals = {}\n\n    def __init__(self, int_type):\n        try:\n            self.dtype = numeric.dtype(int_type)\n        except TypeError:\n            self.dtype = numeric.dtype(type(int_type))\n        self.kind = self.dtype.kind\n        self.bits = self.dtype.itemsize * 8\n        self.key = \"%s%d\" % (self.kind, self.bits)\n        if self.kind not in 'iu':\n            raise ValueError(\"Invalid integer data type %r.\" % (self.kind,))\n\n    @property\n    def min(self):\n        \"\"\"Minimum value of given dtype.\"\"\"\n        if self.kind == 'u':\n            return 0\n        else:\n            try:\n                val = iinfo._min_vals[self.key]\n            except KeyError:\n                val = int(-(1 << (self.bits-1)))\n                iinfo._min_vals[self.key] = val\n            return val\n\n    @property\n    def max(self):\n        \"\"\"Maximum value of given dtype.\"\"\"\n        try:\n            val = iinfo._max_vals[self.key]\n        except KeyError:\n            if self.kind == 'u':\n                val = int((1 << self.bits) - 1)\n            else:\n                val = int((1 << (self.bits-1)) - 1)\n            iinfo._max_vals[self.key] = val\n        return val\n\n    def __str__(self):\n        \"\"\"String representation.\"\"\"\n        fmt = (\n            'Machine parameters for %(dtype)s\\n'\n            '---------------------------------------------------------------\\n'\n            'min = %(min)s\\n'\n            'max = %(max)s\\n'\n            '---------------------------------------------------------------\\n'\n            )\n        return fmt % {'dtype': self.dtype, 'min': self.min, 'max': self.max}\n\n    def __repr__(self):\n        return \"%s(min=%s, max=%s, dtype=%s)\" % (self.__class__.__name__,\n                                    self.min, self.max, self.dtype)\n", 742], "C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py": ["# PyAudio : Python Bindings for PortAudio.\n#\n# Copyright (c) 2006 Hubert Pham\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\"\"\"\nPyAudio provides Python bindings for PortAudio, the cross-platform\naudio I/O library. With PyAudio, you can easily use Python to play and\nrecord audio on a variety of platforms.\n\n.. include:: ../sphinx/examples.rst\n\nOverview\n--------\n\n**Classes**\n  :py:class:`PyAudio`, :py:class:`PyAudio.Stream`\n\n.. only:: pamac\n\n   **Host Specific Classes**\n     :py:class:`PaMacCoreStreamInfo`\n\n**Stream Conversion Convenience Functions**\n  :py:func:`get_sample_size`, :py:func:`get_format_from_width`\n\n**PortAudio version**\n  :py:func:`get_portaudio_version`, :py:func:`get_portaudio_version_text`\n\n.. |PaSampleFormat| replace:: :ref:`PortAudio Sample Format <PaSampleFormat>`\n.. _PaSampleFormat:\n\n**Portaudio Sample Formats**\n  :py:data:`paFloat32`, :py:data:`paInt32`, :py:data:`paInt24`,\n  :py:data:`paInt16`, :py:data:`paInt8`, :py:data:`paUInt8`,\n  :py:data:`paCustomFormat`\n\n.. |PaHostAPI| replace:: :ref:`PortAudio Host API <PaHostAPI>`\n.. _PaHostAPI:\n\n**PortAudio Host APIs**\n  :py:data:`paInDevelopment`, :py:data:`paDirectSound`, :py:data:`paMME`,\n  :py:data:`paASIO`, :py:data:`paSoundManager`, :py:data:`paCoreAudio`,\n  :py:data:`paOSS`, :py:data:`paALSA`, :py:data:`paAL`, :py:data:`paBeOS`,\n  :py:data:`paWDMKS`, :py:data:`paJACK`, :py:data:`paWASAPI`,\n  :py:data:`paNoDevice`\n\n.. |PaErrorCode| replace:: :ref:`PortAudio Error Code <PaErrorCode>`\n.. _PaErrorCode:\n\n**PortAudio Error Codes**\n  :py:data:`paNoError`, :py:data:`paNotInitialized`,\n  :py:data:`paUnanticipatedHostError`, :py:data:`paInvalidChannelCount`,\n  :py:data:`paInvalidSampleRate`, :py:data:`paInvalidDevice`,\n  :py:data:`paInvalidFlag`, :py:data:`paSampleFormatNotSupported`,\n  :py:data:`paBadIODeviceCombination`, :py:data:`paInsufficientMemory`,\n  :py:data:`paBufferTooBig`, :py:data:`paBufferTooSmall`,\n  :py:data:`paNullCallback`, :py:data:`paBadStreamPtr`,\n  :py:data:`paTimedOut`, :py:data:`paInternalError`,\n  :py:data:`paDeviceUnavailable`,\n  :py:data:`paIncompatibleHostApiSpecificStreamInfo`,\n  :py:data:`paStreamIsStopped`, :py:data:`paStreamIsNotStopped`,\n  :py:data:`paInputOverflowed`, :py:data:`paOutputUnderflowed`,\n  :py:data:`paHostApiNotFound`, :py:data:`paInvalidHostApi`,\n  :py:data:`paCanNotReadFromACallbackStream`,\n  :py:data:`paCanNotWriteToACallbackStream`,\n  :py:data:`paCanNotReadFromAnOutputOnlyStream`,\n  :py:data:`paCanNotWriteToAnInputOnlyStream`,\n  :py:data:`paIncompatibleStreamHostApi`\n\n.. |PaCallbackReturnCodes| replace:: :ref:`PortAudio Callback Return Code <PaCallbackReturnCodes>`\n.. _PaCallbackReturnCodes:\n\n**PortAudio Callback Return Codes**\n  :py:data:`paContinue`, :py:data:`paComplete`, :py:data:`paAbort`\n\n.. |PaCallbackFlags| replace:: :ref:`PortAutio Callback Flag <PaCallbackFlags>`\n.. _PaCallbackFlags:\n\n**PortAudio Callback Flags**\n  :py:data:`paInputUnderflow`, :py:data:`paInputOverflow`,\n  :py:data:`paOutputUnderflow`, :py:data:`paOutputOverflow`,\n  :py:data:`paPrimingOutput`\n\"\"\"\n\n__author__ = \"Hubert Pham\"\n__version__ = \"0.2.14\"\n__docformat__ = \"restructuredtext en\"\n\nimport locale\nimport warnings\n\ntry:\n    import pyaudio._portaudio as pa\nexcept ImportError:\n    print(\"Could not import the PyAudio C module 'pyaudio._portaudio'.\")\n    raise\n\n\n# PaSampleFormat Sample Formats\n\npaFloat32 = pa.paFloat32  #: 32 bit float\npaInt32 = pa.paInt32  #: 32 bit int\npaInt24 = pa.paInt24  #: 24 bit int\npaInt16 = pa.paInt16  #: 16 bit int\npaInt8 = pa.paInt8  #: 8 bit int\npaUInt8 = pa.paUInt8  #: 8 bit unsigned int\npaCustomFormat = pa.paCustomFormat  #: a custom data format\n\n# HostAPI TypeId\n\npaInDevelopment = pa.paInDevelopment  #: Still in development\npaDirectSound = pa.paDirectSound  #: DirectSound (Windows only)\npaMME = pa.paMME  #: Multimedia Extension (Windows only)\npaASIO = pa.paASIO  #: Steinberg Audio Stream Input/Output\npaSoundManager = pa.paSoundManager  #: SoundManager (OSX only)\npaCoreAudio = pa.paCoreAudio  #: CoreAudio (OSX only)\npaOSS = pa.paOSS  #: Open Sound System (Linux only)\npaALSA = pa.paALSA  #: Advanced Linux Sound Architecture (Linux only)\npaAL = pa.paAL  #: Open Audio Library\npaBeOS = pa.paBeOS  #: BeOS Sound System\npaWDMKS = pa.paWDMKS  #: Windows Driver Model (Windows only)\npaJACK = pa.paJACK  #: JACK Audio Connection Kit\npaWASAPI = pa.paWASAPI  #: Windows Vista Audio stack architecture\npaNoDevice = pa.paNoDevice  #: Not actually an audio device\n\n# PortAudio Error Codes\n\npaNoError = pa.paNoError\npaNotInitialized = pa.paNotInitialized\npaUnanticipatedHostError = pa.paUnanticipatedHostError\npaInvalidChannelCount = pa.paInvalidChannelCount\npaInvalidSampleRate = pa.paInvalidSampleRate\npaInvalidDevice = pa.paInvalidDevice\npaInvalidFlag = pa.paInvalidFlag\npaSampleFormatNotSupported = pa.paSampleFormatNotSupported\npaBadIODeviceCombination = pa.paBadIODeviceCombination\npaInsufficientMemory = pa.paInsufficientMemory\npaBufferTooBig = pa.paBufferTooBig\npaBufferTooSmall = pa.paBufferTooSmall\npaNullCallback = pa.paNullCallback\npaBadStreamPtr = pa.paBadStreamPtr\npaTimedOut = pa.paTimedOut\npaInternalError = pa.paInternalError\npaDeviceUnavailable = pa.paDeviceUnavailable\npaIncompatibleHostApiSpecificStreamInfo = (\n    pa.paIncompatibleHostApiSpecificStreamInfo)\npaStreamIsStopped = pa.paStreamIsStopped\npaStreamIsNotStopped = pa.paStreamIsNotStopped\npaInputOverflowed = pa.paInputOverflowed\npaOutputUnderflowed = pa.paOutputUnderflowed\npaHostApiNotFound = pa.paHostApiNotFound\npaInvalidHostApi = pa.paInvalidHostApi\npaCanNotReadFromACallbackStream = pa.paCanNotReadFromACallbackStream\npaCanNotWriteToACallbackStream = pa.paCanNotWriteToACallbackStream\npaCanNotReadFromAnOutputOnlyStream = pa.paCanNotReadFromAnOutputOnlyStream\npaCanNotWriteToAnInputOnlyStream = pa.paCanNotWriteToAnInputOnlyStream\npaIncompatibleStreamHostApi = pa.paIncompatibleStreamHostApi\n\n# PortAudio Callback Return Codes\n\npaContinue = pa.paContinue  #: There is more audio data to come\npaComplete = pa.paComplete  #: This was the last block of audio data\npaAbort = pa.paAbort  #: An error ocurred, stop playback/recording\n\n# PortAudio Callback Flags\n\npaInputUnderflow = pa.paInputUnderflow  #: Buffer underflow in input\npaInputOverflow = pa.paInputOverflow  #: Buffer overflow in input\npaOutputUnderflow = pa.paOutputUnderflow  #: Buffer underflow in output\npaOutputOverflow = pa.paOutputOverflow  #: Buffer overflow in output\npaPrimingOutput = pa.paPrimingOutput  #: Just priming, not playing yet\n\n# PortAudio Misc Constants\n\npaFramesPerBufferUnspecified = pa.paFramesPerBufferUnspecified\n\n\n# Utilities\n\ndef get_sample_size(format):\n    \"\"\"Returns the size (in bytes) for the specified sample *format*.\n\n    :param format: A |PaSampleFormat| constant.\n    :raises ValueError: on invalid specified `format`.\n    :rtype: integer\n    \"\"\"\n    return pa.get_sample_size(format)\n\n\ndef get_format_from_width(width, unsigned=True):\n    \"\"\"Returns a PortAudio format constant for the specified *width*.\n\n    :param width: The desired sample width in bytes (1, 2, 3, or 4)\n    :param unsigned: For 1 byte width, specifies signed or unsigned format.\n\n    :raises ValueError: when invalid *width*\n    :rtype: A |PaSampleFormat| constant\n    \"\"\"\n    if width == 1:\n        if unsigned:\n            return paUInt8\n        return paInt8\n    if width == 2:\n        return paInt16\n    if width == 3:\n        return paInt24\n    if width == 4:\n        return paFloat32\n\n    raise ValueError(f\"Invalid width: {width}\")\n\n\n# Versioning\n\ndef get_portaudio_version():\n    \"\"\"Returns portaudio version.\n\n    :rtype: int\n    \"\"\"\n    return pa.get_version()\n\n\ndef get_portaudio_version_text():\n    \"\"\"Returns PortAudio version as a text string.\n\n    :rtype: string\n    \"\"\"\n    return pa.get_version_text()\n\n\nclass PyAudio:\n    \"\"\"Python interface to PortAudio.\n\n    Provides methods to:\n     - initialize and terminate PortAudio\n     - open and close streams\n     - query and inspect the available PortAudio Host APIs\n     - query and inspect the available PortAudio audio devices.\n\n    **Stream Management**\n      :py:func:`open`, :py:func:`close`\n\n    **Host API**\n      :py:func:`get_host_api_count`, :py:func:`get_default_host_api_info`,\n      :py:func:`get_host_api_info_by_type`,\n      :py:func:`get_host_api_info_by_index`,\n      :py:func:`get_device_info_by_host_api_device_index`\n\n    **Device API**\n      :py:func:`get_device_count`, :py:func:`is_format_supported`,\n      :py:func:`get_default_input_device_info`,\n      :py:func:`get_default_output_device_info`,\n      :py:func:`get_device_info_by_index`\n\n    **Stream Format Conversion**\n      :py:func:`get_sample_size`, :py:func:`get_format_from_width`\n\n    **Details**\n    \"\"\"\n\n    class Stream:\n        \"\"\"PortAudio Stream Wrapper. Use :py:func:`PyAudio.open` to instantiate.\n\n        **Opening and Closing**\n          :py:func:`__init__`, :py:func:`close`\n\n        **Stream Info**\n          :py:func:`get_input_latency`, :py:func:`get_output_latency`,\n          :py:func:`get_time`, :py:func:`get_cpu_load`\n\n        **Stream Management**\n          :py:func:`start_stream`, :py:func:`stop_stream`, :py:func:`is_active`,\n          :py:func:`is_stopped`\n\n        **Input Output**\n          :py:func:`write`, :py:func:`read`, :py:func:`get_read_available`,\n          :py:func:`get_write_available`\n        \"\"\"\n        def __init__(self,\n                     PA_manager,\n                     rate,\n                     channels,\n                     format,\n                     input=False,\n                     output=False,\n                     input_device_index=None,\n                     output_device_index=None,\n                     frames_per_buffer=pa.paFramesPerBufferUnspecified,\n                     start=True,\n                     input_host_api_specific_stream_info=None,\n                     output_host_api_specific_stream_info=None,\n                     stream_callback=None):\n            \"\"\"Initialize an audio stream.\n\n            Do not call directly. Use :py:func:`PyAudio.open`.\n\n            A stream can either be input, output, or both.\n\n            :param PA_manager: A reference to the managing :py:class:`PyAudio`\n                instance\n            :param rate: Sampling rate\n            :param channels: Number of channels\n            :param format: Sampling size and format. See |PaSampleFormat|.\n            :param input: Specifies whether this is an input stream.\n                Defaults to ``False``.\n            :param output: Specifies whether this is an output stream.\n                Defaults to ``False``.\n            :param input_device_index: Index of Input Device to use.\n                Unspecified (or ``None``) uses default device.\n                Ignored if `input` is ``False``.\n            :param output_device_index:\n                Index of Output Device to use.\n                Unspecified (or ``None``) uses the default device.\n                Ignored if `output` is ``False``.\n            :param frames_per_buffer: Specifies the number of frames per buffer.\n            :param start: Start the stream running immediately.\n                Defaults to ``True``. In general, there is no reason to set\n                this to ``False``.\n            :param input_host_api_specific_stream_info: Specifies a host API\n                specific stream information data structure for input.\n\n                .. only:: pamac\n\n                   See :py:class:`PaMacCoreStreamInfo`.\n\n            :param output_host_api_specific_stream_info: Specifies a host API\n                specific stream information data structure for output.\n\n                .. only:: pamac\n\n                   See :py:class:`PaMacCoreStreamInfo`.\n\n            :param stream_callback: Specifies a callback function for\n                *non-blocking* (callback) operation.  Default is\n                ``None``, which indicates *blocking* operation (i.e.,\n                :py:func:`PyAudio.Stream.read` and\n                :py:func:`PyAudio.Stream.write`).  To use non-blocking\n                operation, specify a callback that conforms to the following\n                signature:\n\n                .. code-block:: python\n\n                   callback(in_data,      # input data if input=True; else None\n                            frame_count,  # number of frames\n                            time_info,    # dictionary\n                            status_flags) # PaCallbackFlags\n\n                ``time_info`` is a dictionary with the following keys:\n                ``input_buffer_adc_time``, ``current_time``, and\n                ``output_buffer_dac_time``; see the PortAudio\n                documentation for their meanings.  ``status_flags`` is one\n                of |PaCallbackFlags|.\n\n                The callback must return a tuple:\n\n                .. code-block:: python\n\n                    (out_data, flag)\n\n                ``out_data`` is a byte array whose length should be the\n                (``frame_count * channels * bytes-per-channel``) if\n                ``output=True`` or ``None`` if ``output=False``.  ``flag``\n                must be either :py:data:`paContinue`, :py:data:`paComplete` or\n                :py:data:`paAbort` (one of |PaCallbackReturnCodes|).\n                When ``output=True`` and ``out_data`` does not contain at\n                least ``frame_count`` frames, :py:data:`paComplete` is\n                assumed for ``flag``.\n\n                **Note:** ``stream_callback`` is called in a separate\n                thread (from the main thread).  Exceptions that occur in\n                the ``stream_callback`` will:\n\n                1. print a traceback on standard error to aid debugging,\n                2. queue the exception to be thrown (at some point) in\n                   the main thread, and\n                3. return `paAbort` to PortAudio to stop the stream.\n\n                **Note:** Do not call :py:func:`PyAudio.Stream.read` or\n                :py:func:`PyAudio.Stream.write` if using non-blocking operation.\n\n                **See:** PortAudio's callback signature for additional\n                details: http://portaudio.com/docs/v19-doxydocs/portaudio_8h.html#a8a60fb2a5ec9cbade3f54a9c978e2710\n\n            :raise ValueError: Neither input nor output are set True.\n            \"\"\"\n            if not (input or output):\n                raise ValueError(\"Must specify an input or output \" + \"stream.\")\n\n            self._parent = PA_manager\n            self._is_input = input\n            self._is_output = output\n            self._is_running = start\n            self._rate = rate\n            self._channels = channels\n            self._format = format\n            self._frames_per_buffer = frames_per_buffer\n\n            arguments = {\n                'rate': rate,\n                'channels': channels,\n                'format': format,\n                'input': input,\n                'output': output,\n                'input_device_index': input_device_index,\n                'output_device_index': output_device_index,\n                'frames_per_buffer': frames_per_buffer\n            }\n\n            if input_host_api_specific_stream_info:\n                arguments[\n                    'input_host_api_specific_stream_info'\n                ] = input_host_api_specific_stream_info\n\n            if output_host_api_specific_stream_info:\n                arguments[\n                    'output_host_api_specific_stream_info'\n                ] = output_host_api_specific_stream_info\n\n            if stream_callback:\n                arguments['stream_callback'] = stream_callback\n\n            # calling pa.open returns a stream object\n            self._stream = pa.open(**arguments)\n\n            self._input_latency = self._stream.inputLatency\n            self._output_latency = self._stream.outputLatency\n\n            if self._is_running:\n                pa.start_stream(self._stream)\n\n        def close(self):\n            \"\"\"Closes the stream.\"\"\"\n            pa.close(self._stream)\n            self._is_running = False\n            self._parent._remove_stream(self)\n\n        # Stream Info\n\n        def get_input_latency(self):\n            \"\"\"Returns the input latency.\n\n            :rtype: float\n            \"\"\"\n            return self._stream.inputLatency\n\n        def get_output_latency(self):\n            \"\"\"Returns the output latency.\n\n            :rtype: float\n            \"\"\"\n            return self._stream.outputLatency\n\n        def get_time(self):\n            \"\"\"Returns stream time.\n\n            :rtype: float\n            \"\"\"\n            return pa.get_stream_time(self._stream)\n\n        def get_cpu_load(self):\n            \"\"\"Return the CPU load. Always 0.0 when using the blocking API.\n\n            :rtype: float\n            \"\"\"\n            return pa.get_stream_cpu_load(self._stream)\n\n        # Stream Lifecycle\n\n        def start_stream(self):\n            \"\"\"Starts the stream.\"\"\"\n            if self._is_running:\n                return\n\n            pa.start_stream(self._stream)\n            self._is_running = True\n\n        def stop_stream(self):\n            \"\"\"Stops the stream.\"\"\"\n            if not self._is_running:\n                return\n\n            pa.stop_stream(self._stream)\n            self._is_running = False\n\n        def is_active(self):\n            \"\"\"Returns whether the stream is active.\n\n            :rtype: bool\n            \"\"\"\n            return pa.is_stream_active(self._stream)\n\n        def is_stopped(self):\n            \"\"\"Returns whether the stream is stopped.\n\n            :rtype: bool\n            \"\"\"\n            return pa.is_stream_stopped(self._stream)\n\n        # Stream blocking I/O\n\n        def write(self, frames, num_frames=None, exception_on_underflow=False):\n            \"\"\"Write samples to the stream for playback.\n\n            Do not call when using non-blocking mode.\n\n            :param frames:\n               The frames of data.\n            :param num_frames:\n               The number of frames to write.\n               Defaults to None, in which this value will be\n               automatically computed.\n            :param exception_on_underflow:\n               Specifies whether an IOError exception should be thrown\n               (or silently ignored) on buffer underflow. Defaults\n               to False for improved performance, especially on\n               slower platforms.\n\n            :raises IOError: if the stream is not an output stream\n               or if the write operation was unsuccessful.\n\n            :rtype: `None`\n            \"\"\"\n            if not self._is_output:\n                raise IOError(\"Not output stream\",\n                              paCanNotWriteToAnInputOnlyStream)\n\n            if num_frames is None:\n                # Determine how many frames to read:\n                width = get_sample_size(self._format)\n                num_frames = int(len(frames) / (self._channels * width))\n\n            pa.write_stream(self._stream, frames, num_frames,\n                            exception_on_underflow)\n\n        def read(self, num_frames, exception_on_overflow=True):\n            \"\"\"Read samples from the stream.\n\n            Do not call when using non-blocking mode.\n\n            :param num_frames: The number of frames to read.\n            :param exception_on_overflow:\n               Specifies whether an IOError exception should be thrown\n               (or silently ignored) on input buffer overflow. Defaults\n               to True.\n            :raises IOError: if stream is not an input stream\n              or if the read operation was unsuccessful.\n            :rtype: bytes\n            \"\"\"\n            if not self._is_input:\n                raise IOError(\"Not input stream\",\n                              paCanNotReadFromAnOutputOnlyStream)\n            return pa.read_stream(self._stream, num_frames,\n                                  exception_on_overflow)\n\n        def get_read_available(self):\n            \"\"\"Return the number of frames that can be read without waiting.\n\n            :rtype: integer\n            \"\"\"\n            return pa.get_stream_read_available(self._stream)\n\n        def get_write_available(self):\n            \"\"\"Return the number of frames that can be written without waiting.\n\n            :rtype: integer\n            \"\"\"\n            return pa.get_stream_write_available(self._stream)\n\n    # Initialization and Termination\n\n    def __init__(self):\n        \"\"\"Initialize PortAudio.\"\"\"\n        pa.initialize()\n        self._streams = set()\n\n    def terminate(self):\n        \"\"\"Terminates PortAudio.\n\n        :attention: Be sure to call this method for every instance of this\n          object to release PortAudio resources.\n        \"\"\"\n        for stream in self._streams.copy():\n            stream.close()\n\n        self._streams = set()\n        pa.terminate()\n\n    # Utilities\n\n    def get_sample_size(self, format):\n        \"\"\"Returns the size (in bytes) for the specified sample `format`\n        (a |PaSampleFormat| constant).\n\n        :param format: A |PaSampleFormat| constant.\n        :raises ValueError: Invalid specified `format`.\n        :rtype: integer\n        \"\"\"\n        return pa.get_sample_size(format)\n\n    def get_format_from_width(self, width, unsigned=True):\n        \"\"\"Returns a PortAudio format constant for the specified `width`.\n\n        :param width: The desired sample width in bytes (1, 2, 3, or 4)\n        :param unsigned: For 1 byte width, specifies signed or unsigned format.\n\n        :raises ValueError: for invalid `width`\n        :rtype: A |PaSampleFormat| constant.\n        \"\"\"\n        return get_format_from_width(width, unsigned)\n\n    # Stream Factory\n\n    def open(self, *args, **kwargs):\n        \"\"\"Opens a new stream.\n\n        See constructor for :py:func:`PyAudio.Stream.__init__` for parameter\n        details.\n\n        :returns: A new :py:class:`PyAudio.Stream`\n        \"\"\"\n        stream = PyAudio.Stream(self, *args, **kwargs)\n        self._streams.add(stream)\n        return stream\n\n    def close(self, stream):\n        \"\"\"Closes a stream. Use :py:func:`PyAudio.Stream.close` instead.\n\n        :param stream: An instance of the :py:class:`PyAudio.Stream` object.\n        :raises ValueError: if stream does not exist.\n        \"\"\"\n        if stream not in self._streams:\n            raise ValueError(f\"Stream {stream} not found\")\n\n        stream.close()\n\n    def _remove_stream(self, stream):\n        \"\"\"Removes a stream. (Internal)\n\n        :param stream: An instance of the :py:class:`PyAudio.Stream` object.\n        \"\"\"\n        if stream in self._streams:\n            self._streams.remove(stream)\n\n    # Host API Inspection\n\n    def get_host_api_count(self):\n        \"\"\"Returns the number of available PortAudio Host APIs.\n\n        :rtype: integer\n        \"\"\"\n        return pa.get_host_api_count()\n\n    def get_default_host_api_info(self):\n        \"\"\"Returns a dictionary containing the default Host API parameters.\n\n        The keys of the dictionary mirror the data fields of PortAudio's\n        ``PaHostApiInfo`` structure.\n\n        :raises IOError: if no default input device is available\n        :rtype: dict\n        \"\"\"\n        default_host_api_index = pa.get_default_host_api()\n        return self.get_host_api_info_by_index(default_host_api_index)\n\n    def get_host_api_info_by_type(self, host_api_type):\n        \"\"\"Returns a dictionary containing the Host API parameters for the\n        host API specified by the `host_api_type`. The keys of the\n        dictionary mirror the data fields of PortAudio's ``PaHostApiInfo``\n        structure.\n\n        :param host_api_type: The desired |PaHostAPI|\n        :raises IOError: for invalid `host_api_type`\n        :rtype: dict\n        \"\"\"\n        index = pa.host_api_type_id_to_host_api_index(host_api_type)\n        return self.get_host_api_info_by_index(index)\n\n    def get_host_api_info_by_index(self, host_api_index):\n        \"\"\"Returns a dictionary containing the Host API parameters for the\n        host API specified by the `host_api_index`. The keys of the\n        dictionary mirror the data fields of PortAudio's ``PaHostApiInfo``\n        structure.\n\n        :param host_api_index: The host api index\n        :raises IOError: for invalid `host_api_index`\n        :rtype: dict\n        \"\"\"\n        return self._make_host_api_dictionary(\n            host_api_index,\n            pa.get_host_api_info(host_api_index))\n\n    def get_device_info_by_host_api_device_index(self,\n                                                 host_api_index,\n                                                 host_api_device_index):\n        \"\"\"Returns a dictionary containing the Device parameters for a\n        given Host API's n'th device. The keys of the dictionary\n        mirror the data fields of PortAudio's ``PaDeviceInfo`` structure.\n\n        :param host_api_index: The Host API index number\n        :param host_api_device_index: The n'th device of the host API\n        :raises IOError: for invalid indices\n        :rtype: dict\n        \"\"\"\n        long_method_name = pa.host_api_device_index_to_device_index\n        device_index = long_method_name(host_api_index, host_api_device_index)\n        return self.get_device_info_by_index(device_index)\n\n    def _make_host_api_dictionary(self, index, host_api_struct):\n        \"\"\"Creates dictionary like PortAudio's ``PaHostApiInfo`` structure.\n\n        :rtype: dict\n        \"\"\"\n        return {\n            'index': index,\n            'structVersion': host_api_struct.structVersion,\n            'type': host_api_struct.type,\n            'name': host_api_struct.name,\n            'deviceCount': host_api_struct.deviceCount,\n            'defaultInputDevice': host_api_struct.defaultInputDevice,\n            'defaultOutputDevice': host_api_struct.defaultOutputDevice\n        }\n\n    # Device Inspection\n\n    def get_device_count(self):\n        \"\"\"Returns the number of PortAudio Host APIs.\n\n        :rtype: integer\n        \"\"\"\n        return pa.get_device_count()\n\n    def is_format_supported(self, rate,\n                            input_device=None,\n                            input_channels=None,\n                            input_format=None,\n                            output_device=None,\n                            output_channels=None,\n                            output_format=None):\n        \"\"\"Checks if specified device configuration is supported.\n\n        Returns True if the configuration is supported; raises ValueError\n        otherwise.\n\n        :param rate:\n           Specifies the desired rate (in Hz)\n        :param input_device:\n           The input device index. Specify ``None`` (default) for\n           half-duplex output-only streams.\n        :param input_channels:\n           The desired number of input channels. Ignored if\n           `input_device` is not specified (or ``None``).\n        :param input_format:\n           PortAudio sample format constant defined\n           in this module\n        :param output_device:\n           The output device index. Specify ``None`` (default) for\n           half-duplex input-only streams.\n        :param output_channels:\n           The desired number of output channels. Ignored if\n           `input_device` is not specified (or ``None``).\n        :param output_format:\n           |PaSampleFormat| constant.\n\n        :rtype: bool\n        :raises ValueError: tuple containing (error string, |PaErrorCode|).\n        \"\"\"\n        if input_device is None and output_device is None:\n            raise ValueError(\n                \"Must specify stream format for input, output, or both\",\n                paInvalidDevice)\n\n        kwargs = {}\n        if input_device is not None:\n            kwargs['input_device'] = input_device\n            kwargs['input_channels'] = input_channels\n            kwargs['input_format'] = input_format\n\n        if output_device is not None:\n            kwargs['output_device'] = output_device\n            kwargs['output_channels'] = output_channels\n            kwargs['output_format'] = output_format\n\n        return pa.is_format_supported(rate, **kwargs)\n\n    def get_default_input_device_info(self):\n        \"\"\"Returns the default input device parameters as a dictionary.\n\n        The keys of the dictionary mirror the data fields of PortAudio's\n        ``PaDeviceInfo`` structure.\n\n        :raises IOError: No default input device available.\n        :rtype: dict\n        \"\"\"\n        device_index = pa.get_default_input_device()\n        return self.get_device_info_by_index(device_index)\n\n    def get_default_output_device_info(self):\n        \"\"\"Returns the default output device parameters as a dictionary.\n\n        The keys of the dictionary mirror the data fields of PortAudio's\n        ``PaDeviceInfo`` structure.\n\n        :raises IOError: No default output device available.\n        :rtype: dict\n        \"\"\"\n        device_index = pa.get_default_output_device()\n        return self.get_device_info_by_index(device_index)\n\n    def get_device_info_by_index(self, device_index):\n        \"\"\"Returns the device parameters for device specified in `device_index`\n        as a dictionary. The keys of the dictionary mirror the data fields of\n        PortAudio's ``PaDeviceInfo`` structure.\n\n        :param device_index: The device index\n        :raises IOError: Invalid `device_index`.\n        :rtype: dict\n        \"\"\"\n        return self._make_device_info_dictionary(\n            device_index,\n            pa.get_device_info(device_index))\n\n    def _make_device_info_dictionary(self, index, device_info):\n        \"\"\"Creates a dictionary like PortAudio's ``PaDeviceInfo`` structure.\n\n        :rtype: dict\n        \"\"\"\n        device_name = device_info.name\n\n        # Attempt to decode device_name. If we fail to decode, return the raw\n        # bytes and let the caller deal with the encoding.\n        os_encoding = locale.getpreferredencoding(do_setlocale=False)\n        for codec in [os_encoding, \"utf-8\"]:\n            try:\n                device_name = device_name.decode(codec)\n                break\n            except:\n                pass\n\n        return {'index': index,\n                'structVersion': device_info.structVersion,\n                'name': device_name,\n                'hostApi': device_info.hostApi,\n                'maxInputChannels': device_info.maxInputChannels,\n                'maxOutputChannels': device_info.maxOutputChannels,\n                'defaultLowInputLatency':\n                device_info.defaultLowInputLatency,\n                'defaultLowOutputLatency':\n                device_info.defaultLowOutputLatency,\n                'defaultHighInputLatency':\n                device_info.defaultHighInputLatency,\n                'defaultHighOutputLatency':\n                device_info.defaultHighOutputLatency,\n                'defaultSampleRate':\n                device_info.defaultSampleRate}\n\n\n# Host Specific Stream Info\n\nif hasattr(pa, 'paMacCoreStreamInfo'):\n    class PaMacCoreStreamInfo(pa.paMacCoreStreamInfo):\n        \"\"\"PortAudio Host API Specific Stream Info for macOS-specific settings.\n\n        To configure macOS-specific settings, instantiate this class and pass\n        it as the argument in :py:func:`PyAudio.open` to parameters\n        ``input_host_api_specific_stream_info`` or\n        ``output_host_api_specific_stream_info``.  (See\n        :py:func:`PyAudio.Stream.__init__`.)\n\n        :note: macOS-only.\n\n        .. |PaMacCoreFlags| replace:: :ref:`PortAudio Mac Core Flags <PaMacCoreFlags>`\n        .. _PaMacCoreFlags:\n\n        **PortAudio Mac Core Flags**\n          :py:data:`paMacCoreChangeDeviceParameters`,\n          :py:data:`paMacCoreFailIfConversionRequired`,\n          :py:data:`paMacCoreConversionQualityMin`,\n          :py:data:`paMacCoreConversionQualityMedium`,\n          :py:data:`paMacCoreConversionQualityLow`,\n          :py:data:`paMacCoreConversionQualityHigh`,\n          :py:data:`paMacCoreConversionQualityMax`,\n          :py:data:`paMacCorePlayNice`,\n          :py:data:`paMacCorePro`,\n          :py:data:`paMacCoreMinimizeCPUButPlayNice`,\n          :py:data:`paMacCoreMinimizeCPU`\n\n        .. attribute:: flags\n\n           The flags specified to the constructor.\n\n           :type: |PaMacCoreFlags|\n\n        .. attribute:: channel_map\n\n           The channel_map specified to the constructor\n\n           :type: tuple or None if unspecified\n        \"\"\"\n        paMacCoreChangeDeviceParameters = pa.paMacCoreChangeDeviceParameters\n        paMacCoreFailIfConversionRequired = pa.paMacCoreFailIfConversionRequired\n        paMacCoreConversionQualityMin = pa.paMacCoreConversionQualityMin\n        paMacCoreConversionQualityMedium = pa.paMacCoreConversionQualityMedium\n        paMacCoreConversionQualityLow = pa.paMacCoreConversionQualityLow\n        paMacCoreConversionQualityHigh = pa.paMacCoreConversionQualityHigh\n        paMacCoreConversionQualityMax = pa.paMacCoreConversionQualityMax\n        paMacCorePlayNice = pa.paMacCorePlayNice\n        paMacCorePro = pa.paMacCorePro\n        paMacCoreMinimizeCPUButPlayNice = pa.paMacCoreMinimizeCPUButPlayNice\n        paMacCoreMinimizeCPU = pa.paMacCoreMinimizeCPU\n\n        def __init__(self, flags=None, channel_map=None):\n            \"\"\"Initialize with macOS setting flags and channel_map.\n\n            See PortAudio documentation for more details on these parameters.\n\n            :param flags: |PaMacCoreFlags| OR'ed together.\n            :param channel_map: An array describing the channel mapping.\n                See PortAudio documentation for usage.\n            \"\"\"\n            kwargs = {}\n            if flags is not None:\n                kwargs[\"flags\"] = flags\n            if channel_map is not None:\n                kwargs[\"channel_map\"] = channel_map\n            super().__init__(**kwargs)\n\n        # Deprecated:\n\n        def get_flags(self):\n            \"\"\"Returns the flags set at instantiation. Deprecated.\n\n            :rtype: integer\n\n            .. deprecated:: 0.2.13\n               Use :py:attr:`flags` property.\n            \"\"\"\n            warnings.warn(\n                \"PaMacCoreStreamInfo.get_flags is deprecated. Use the flags \"\n                \"property instead.\",\n                DeprecationWarning,\n                stacklevel=2)\n            return self.flags\n\n        def get_channel_map(self):\n            \"\"\"Returns the channel map set at instantiation. Deprecated.\n\n            :rtype: tuple or None\n\n            .. deprecated:: 0.2.13\n               Use :py:attr:`channel_map` property.\n            \"\"\"\n            warnings.warn(\n                \"PaMacCoreStreamInfo.get_channel_map is deprecated. Use the \"\n                \"channel_map property instead.\",\n                DeprecationWarning,\n                stacklevel=2)\n            return self.channel_map\n\n        def _get_host_api_stream_object(self):\n            \"\"\"Returns the underyling stream info.\n\n            .. :deprecated:: 0.2.13\n               Use stream_info property.\n            \"\"\"\n            warnings.warn(\n                \"PaMacCoreStreamInfo._get_host_api_stream_object is \"\n                \"deprecated. Use this object instance instead.\",\n                DeprecationWarning,\n                stacklevel=2)\n            return self\n\n\n# The top-level Stream class is reserved for future API changes. Users should\n# never instantiate Stream directly. Instead, users must use PyAudio.open()\n# instead, as documented.\n#\n# But for existing code that happens to instantiate Stream directly, this class\n# issues a warning and maintains backwards-compatibility, for now. In the\n# future, Stream may be repurposed.\nclass Stream(PyAudio.Stream):\n    \"\"\"Reserved. Do not instantiate.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Users should never instantiate this class.\n        warnings.warn(\n            \"Do not instantiate pyaudio.Stream directly. Use \"\n            \"pyaudio.PyAudio.open() instead. pyaudio.Stream may change or be \"\n            \"removed in the future.\",\n            DeprecationWarning,\n            stacklevel=2)\n        super().__init__(*args, **kwargs)\n", 1009], "C:\\Programming\\Python313\\Lib\\configparser.py": ["\"\"\"Configuration file parser.\n\nA configuration file consists of sections, lead by a \"[section]\" header,\nand followed by \"name: value\" entries, with continuations and such in\nthe style of RFC 822.\n\nIntrinsic defaults can be specified by passing them into the\nConfigParser constructor as a dictionary.\n\nclass:\n\nConfigParser -- responsible for parsing a list of\n                    configuration files, and managing the parsed database.\n\n    methods:\n\n    __init__(defaults=None, dict_type=_default_dict, allow_no_value=False,\n             delimiters=('=', ':'), comment_prefixes=('#', ';'),\n             inline_comment_prefixes=None, strict=True,\n             empty_lines_in_values=True, default_section='DEFAULT',\n             interpolation=<unset>, converters=<unset>,\n             allow_unnamed_section=False):\n        Create the parser. When `defaults` is given, it is initialized into the\n        dictionary or intrinsic defaults. The keys must be strings, the values\n        must be appropriate for %()s string interpolation.\n\n        When `dict_type` is given, it will be used to create the dictionary\n        objects for the list of sections, for the options within a section, and\n        for the default values.\n\n        When `delimiters` is given, it will be used as the set of substrings\n        that divide keys from values.\n\n        When `comment_prefixes` is given, it will be used as the set of\n        substrings that prefix comments in empty lines. Comments can be\n        indented.\n\n        When `inline_comment_prefixes` is given, it will be used as the set of\n        substrings that prefix comments in non-empty lines.\n\n        When `strict` is True, the parser won't allow for any section or option\n        duplicates while reading from a single source (file, string or\n        dictionary). Default is True.\n\n        When `empty_lines_in_values` is False (default: True), each empty line\n        marks the end of an option. Otherwise, internal empty lines of\n        a multiline option are kept as part of the value.\n\n        When `allow_no_value` is True (default: False), options without\n        values are accepted; the value presented for these is None.\n\n        When `default_section` is given, the name of the special section is\n        named accordingly. By default it is called ``\"DEFAULT\"`` but this can\n        be customized to point to any other valid section name. Its current\n        value can be retrieved using the ``parser_instance.default_section``\n        attribute and may be modified at runtime.\n\n        When `interpolation` is given, it should be an Interpolation subclass\n        instance. It will be used as the handler for option value\n        pre-processing when using getters. RawConfigParser objects don't do\n        any sort of interpolation, whereas ConfigParser uses an instance of\n        BasicInterpolation. The library also provides a ``zc.buildout``\n        inspired ExtendedInterpolation implementation.\n\n        When `converters` is given, it should be a dictionary where each key\n        represents the name of a type converter and each value is a callable\n        implementing the conversion from string to the desired datatype. Every\n        converter gets its corresponding get*() method on the parser object and\n        section proxies.\n\n        When `allow_unnamed_section` is True (default: False), options\n        without section are accepted: the section for these is\n        ``configparser.UNNAMED_SECTION``.\n\n    sections()\n        Return all the configuration section names, sans DEFAULT.\n\n    has_section(section)\n        Return whether the given section exists.\n\n    has_option(section, option)\n        Return whether the given option exists in the given section.\n\n    options(section)\n        Return list of configuration options for the named section.\n\n    read(filenames, encoding=None)\n        Read and parse the iterable of named configuration files, given by\n        name.  A single filename is also allowed.  Non-existing files\n        are ignored.  Return list of successfully read files.\n\n    read_file(f, filename=None)\n        Read and parse one configuration file, given as a file object.\n        The filename defaults to f.name; it is only used in error\n        messages (if f has no `name` attribute, the string `<???>` is used).\n\n    read_string(string)\n        Read configuration from a given string.\n\n    read_dict(dictionary)\n        Read configuration from a dictionary. Keys are section names,\n        values are dictionaries with keys and values that should be present\n        in the section. If the used dictionary type preserves order, sections\n        and their keys will be added in order. Values are automatically\n        converted to strings.\n\n    get(section, option, raw=False, vars=None, fallback=_UNSET)\n        Return a string value for the named option.  All % interpolations are\n        expanded in the return values, based on the defaults passed into the\n        constructor and the DEFAULT section.  Additional substitutions may be\n        provided using the `vars` argument, which must be a dictionary whose\n        contents override any pre-existing defaults. If `option` is a key in\n        `vars`, the value from `vars` is used.\n\n    getint(section, options, raw=False, vars=None, fallback=_UNSET)\n        Like get(), but convert value to an integer.\n\n    getfloat(section, options, raw=False, vars=None, fallback=_UNSET)\n        Like get(), but convert value to a float.\n\n    getboolean(section, options, raw=False, vars=None, fallback=_UNSET)\n        Like get(), but convert value to a boolean (currently case\n        insensitively defined as 0, false, no, off for False, and 1, true,\n        yes, on for True).  Returns False or True.\n\n    items(section=_UNSET, raw=False, vars=None)\n        If section is given, return a list of tuples with (name, value) for\n        each option in the section. Otherwise, return a list of tuples with\n        (section_name, section_proxy) for each section, including DEFAULTSECT.\n\n    remove_section(section)\n        Remove the given file section and all its options.\n\n    remove_option(section, option)\n        Remove the given option from the given section.\n\n    set(section, option, value)\n        Set the given option.\n\n    write(fp, space_around_delimiters=True)\n        Write the configuration state in .ini format. If\n        `space_around_delimiters` is True (the default), delimiters\n        between keys and values are surrounded by spaces.\n\"\"\"\n\n# Do not import dataclasses; overhead is unacceptable (gh-117703)\n\nfrom collections.abc import Iterable, MutableMapping\nfrom collections import ChainMap as _ChainMap\nimport contextlib\nimport functools\nimport io\nimport itertools\nimport os\nimport re\nimport sys\nimport types\n\n__all__ = (\"NoSectionError\", \"DuplicateOptionError\", \"DuplicateSectionError\",\n           \"NoOptionError\", \"InterpolationError\", \"InterpolationDepthError\",\n           \"InterpolationMissingOptionError\", \"InterpolationSyntaxError\",\n           \"ParsingError\", \"MissingSectionHeaderError\",\n           \"MultilineContinuationError\",\n           \"ConfigParser\", \"RawConfigParser\",\n           \"Interpolation\", \"BasicInterpolation\",  \"ExtendedInterpolation\",\n           \"SectionProxy\", \"ConverterMapping\",\n           \"DEFAULTSECT\", \"MAX_INTERPOLATION_DEPTH\", \"UNNAMED_SECTION\")\n\n_default_dict = dict\nDEFAULTSECT = \"DEFAULT\"\n\nMAX_INTERPOLATION_DEPTH = 10\n\n\n\n# exception classes\nclass Error(Exception):\n    \"\"\"Base class for ConfigParser exceptions.\"\"\"\n\n    def __init__(self, msg=''):\n        self.message = msg\n        Exception.__init__(self, msg)\n\n    def __repr__(self):\n        return self.message\n\n    __str__ = __repr__\n\n\nclass NoSectionError(Error):\n    \"\"\"Raised when no section matches a requested option.\"\"\"\n\n    def __init__(self, section):\n        Error.__init__(self, 'No section: %r' % (section,))\n        self.section = section\n        self.args = (section, )\n\n\nclass DuplicateSectionError(Error):\n    \"\"\"Raised when a section is repeated in an input source.\n\n    Possible repetitions that raise this exception are: multiple creation\n    using the API or in strict parsers when a section is found more than once\n    in a single input file, string or dictionary.\n    \"\"\"\n\n    def __init__(self, section, source=None, lineno=None):\n        msg = [repr(section), \" already exists\"]\n        if source is not None:\n            message = [\"While reading from \", repr(source)]\n            if lineno is not None:\n                message.append(\" [line {0:2d}]\".format(lineno))\n            message.append(\": section \")\n            message.extend(msg)\n            msg = message\n        else:\n            msg.insert(0, \"Section \")\n        Error.__init__(self, \"\".join(msg))\n        self.section = section\n        self.source = source\n        self.lineno = lineno\n        self.args = (section, source, lineno)\n\n\nclass DuplicateOptionError(Error):\n    \"\"\"Raised by strict parsers when an option is repeated in an input source.\n\n    Current implementation raises this exception only when an option is found\n    more than once in a single file, string or dictionary.\n    \"\"\"\n\n    def __init__(self, section, option, source=None, lineno=None):\n        msg = [repr(option), \" in section \", repr(section),\n               \" already exists\"]\n        if source is not None:\n            message = [\"While reading from \", repr(source)]\n            if lineno is not None:\n                message.append(\" [line {0:2d}]\".format(lineno))\n            message.append(\": option \")\n            message.extend(msg)\n            msg = message\n        else:\n            msg.insert(0, \"Option \")\n        Error.__init__(self, \"\".join(msg))\n        self.section = section\n        self.option = option\n        self.source = source\n        self.lineno = lineno\n        self.args = (section, option, source, lineno)\n\n\nclass NoOptionError(Error):\n    \"\"\"A requested option was not found.\"\"\"\n\n    def __init__(self, option, section):\n        Error.__init__(self, \"No option %r in section: %r\" %\n                       (option, section))\n        self.option = option\n        self.section = section\n        self.args = (option, section)\n\n\nclass InterpolationError(Error):\n    \"\"\"Base class for interpolation-related exceptions.\"\"\"\n\n    def __init__(self, option, section, msg):\n        Error.__init__(self, msg)\n        self.option = option\n        self.section = section\n        self.args = (option, section, msg)\n\n\nclass InterpolationMissingOptionError(InterpolationError):\n    \"\"\"A string substitution required a setting which was not available.\"\"\"\n\n    def __init__(self, option, section, rawval, reference):\n        msg = (\"Bad value substitution: option {!r} in section {!r} contains \"\n               \"an interpolation key {!r} which is not a valid option name. \"\n               \"Raw value: {!r}\".format(option, section, reference, rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.reference = reference\n        self.args = (option, section, rawval, reference)\n\n\nclass InterpolationSyntaxError(InterpolationError):\n    \"\"\"Raised when the source text contains invalid syntax.\n\n    Current implementation raises this exception when the source text into\n    which substitutions are made does not conform to the required syntax.\n    \"\"\"\n\n\nclass InterpolationDepthError(InterpolationError):\n    \"\"\"Raised when substitutions are nested too deeply.\"\"\"\n\n    def __init__(self, option, section, rawval):\n        msg = (\"Recursion limit exceeded in value substitution: option {!r} \"\n               \"in section {!r} contains an interpolation key which \"\n               \"cannot be substituted in {} steps. Raw value: {!r}\"\n               \"\".format(option, section, MAX_INTERPOLATION_DEPTH,\n                         rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.args = (option, section, rawval)\n\n\nclass ParsingError(Error):\n    \"\"\"Raised when a configuration file does not follow legal syntax.\"\"\"\n\n    def __init__(self, source, *args):\n        super().__init__(f'Source contains parsing errors: {source!r}')\n        self.source = source\n        self.errors = []\n        self.args = (source, )\n        if args:\n            self.append(*args)\n\n    def append(self, lineno, line):\n        self.errors.append((lineno, line))\n        self.message += '\\n\\t[line %2d]: %s' % (lineno, repr(line))\n\n    def combine(self, others):\n        for other in others:\n            for error in other.errors:\n                self.append(*error)\n        return self\n\n    @staticmethod\n    def _raise_all(exceptions: Iterable['ParsingError']):\n        \"\"\"\n        Combine any number of ParsingErrors into one and raise it.\n        \"\"\"\n        exceptions = iter(exceptions)\n        with contextlib.suppress(StopIteration):\n            raise next(exceptions).combine(exceptions)\n\n\n\nclass MissingSectionHeaderError(ParsingError):\n    \"\"\"Raised when a key-value pair is found before any section header.\"\"\"\n\n    def __init__(self, filename, lineno, line):\n        Error.__init__(\n            self,\n            'File contains no section headers.\\nfile: %r, line: %d\\n%r' %\n            (filename, lineno, line))\n        self.source = filename\n        self.lineno = lineno\n        self.line = line\n        self.args = (filename, lineno, line)\n\n\nclass MultilineContinuationError(ParsingError):\n    \"\"\"Raised when a key without value is followed by continuation line\"\"\"\n    def __init__(self, filename, lineno, line):\n        Error.__init__(\n            self,\n            \"Key without value continued with an indented line.\\n\"\n            \"file: %r, line: %d\\n%r\"\n            %(filename, lineno, line))\n        self.source = filename\n        self.lineno = lineno\n        self.line = line\n        self.args = (filename, lineno, line)\n\nclass _UnnamedSection:\n\n    def __repr__(self):\n        return \"<UNNAMED_SECTION>\"\n\n\nUNNAMED_SECTION = _UnnamedSection()\n\n\n# Used in parser getters to indicate the default behaviour when a specific\n# option is not found it to raise an exception. Created to enable `None` as\n# a valid fallback value.\n_UNSET = object()\n\n\nclass Interpolation:\n    \"\"\"Dummy interpolation that passes the value through with no changes.\"\"\"\n\n    def before_get(self, parser, section, option, value, defaults):\n        return value\n\n    def before_set(self, parser, section, option, value):\n        return value\n\n    def before_read(self, parser, section, option, value):\n        return value\n\n    def before_write(self, parser, section, option, value):\n        return value\n\n\nclass BasicInterpolation(Interpolation):\n    \"\"\"Interpolation as implemented in the classic ConfigParser.\n\n    The option values can contain format strings which refer to other values in\n    the same section, or values in the special default section.\n\n    For example:\n\n        something: %(dir)s/whatever\n\n    would resolve the \"%(dir)s\" to the value of dir.  All reference\n    expansions are done late, on demand. If a user needs to use a bare % in\n    a configuration file, she can escape it by writing %%. Other % usage\n    is considered a user error and raises `InterpolationSyntaxError`.\"\"\"\n\n    _KEYCRE = re.compile(r\"%\\(([^)]+)\\)s\")\n\n    def before_get(self, parser, section, option, value, defaults):\n        L = []\n        self._interpolate_some(parser, option, L, value, section, defaults, 1)\n        return ''.join(L)\n\n    def before_set(self, parser, section, option, value):\n        tmp_value = value.replace('%%', '') # escaped percent signs\n        tmp_value = self._KEYCRE.sub('', tmp_value) # valid syntax\n        if '%' in tmp_value:\n            raise ValueError(\"invalid interpolation syntax in %r at \"\n                             \"position %d\" % (value, tmp_value.find('%')))\n        return value\n\n    def _interpolate_some(self, parser, option, accum, rest, section, map,\n                          depth):\n        rawval = parser.get(section, option, raw=True, fallback=rest)\n        if depth > MAX_INTERPOLATION_DEPTH:\n            raise InterpolationDepthError(option, section, rawval)\n        while rest:\n            p = rest.find(\"%\")\n            if p < 0:\n                accum.append(rest)\n                return\n            if p > 0:\n                accum.append(rest[:p])\n                rest = rest[p:]\n            # p is no longer used\n            c = rest[1:2]\n            if c == \"%\":\n                accum.append(\"%\")\n                rest = rest[2:]\n            elif c == \"(\":\n                m = self._KEYCRE.match(rest)\n                if m is None:\n                    raise InterpolationSyntaxError(option, section,\n                        \"bad interpolation variable reference %r\" % rest)\n                var = parser.optionxform(m.group(1))\n                rest = rest[m.end():]\n                try:\n                    v = map[var]\n                except KeyError:\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, var) from None\n                if \"%\" in v:\n                    self._interpolate_some(parser, option, accum, v,\n                                           section, map, depth + 1)\n                else:\n                    accum.append(v)\n            else:\n                raise InterpolationSyntaxError(\n                    option, section,\n                    \"'%%' must be followed by '%%' or '(', \"\n                    \"found: %r\" % (rest,))\n\n\nclass ExtendedInterpolation(Interpolation):\n    \"\"\"Advanced variant of interpolation, supports the syntax used by\n    `zc.buildout`. Enables interpolation between sections.\"\"\"\n\n    _KEYCRE = re.compile(r\"\\$\\{([^}]+)\\}\")\n\n    def before_get(self, parser, section, option, value, defaults):\n        L = []\n        self._interpolate_some(parser, option, L, value, section, defaults, 1)\n        return ''.join(L)\n\n    def before_set(self, parser, section, option, value):\n        tmp_value = value.replace('$$', '') # escaped dollar signs\n        tmp_value = self._KEYCRE.sub('', tmp_value) # valid syntax\n        if '$' in tmp_value:\n            raise ValueError(\"invalid interpolation syntax in %r at \"\n                             \"position %d\" % (value, tmp_value.find('$')))\n        return value\n\n    def _interpolate_some(self, parser, option, accum, rest, section, map,\n                          depth):\n        rawval = parser.get(section, option, raw=True, fallback=rest)\n        if depth > MAX_INTERPOLATION_DEPTH:\n            raise InterpolationDepthError(option, section, rawval)\n        while rest:\n            p = rest.find(\"$\")\n            if p < 0:\n                accum.append(rest)\n                return\n            if p > 0:\n                accum.append(rest[:p])\n                rest = rest[p:]\n            # p is no longer used\n            c = rest[1:2]\n            if c == \"$\":\n                accum.append(\"$\")\n                rest = rest[2:]\n            elif c == \"{\":\n                m = self._KEYCRE.match(rest)\n                if m is None:\n                    raise InterpolationSyntaxError(option, section,\n                        \"bad interpolation variable reference %r\" % rest)\n                path = m.group(1).split(':')\n                rest = rest[m.end():]\n                sect = section\n                opt = option\n                try:\n                    if len(path) == 1:\n                        opt = parser.optionxform(path[0])\n                        v = map[opt]\n                    elif len(path) == 2:\n                        sect = path[0]\n                        opt = parser.optionxform(path[1])\n                        v = parser.get(sect, opt, raw=True)\n                    else:\n                        raise InterpolationSyntaxError(\n                            option, section,\n                            \"More than one ':' found: %r\" % (rest,))\n                except (KeyError, NoSectionError, NoOptionError):\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, \":\".join(path)) from None\n                if \"$\" in v:\n                    self._interpolate_some(parser, opt, accum, v, sect,\n                                           dict(parser.items(sect, raw=True)),\n                                           depth + 1)\n                else:\n                    accum.append(v)\n            else:\n                raise InterpolationSyntaxError(\n                    option, section,\n                    \"'$' must be followed by '$' or '{', \"\n                    \"found: %r\" % (rest,))\n\n\nclass _ReadState:\n    elements_added : set[str]\n    cursect : dict[str, str] | None = None\n    sectname : str | None = None\n    optname : str | None = None\n    lineno : int = 0\n    indent_level : int = 0\n    errors : list[ParsingError]\n\n    def __init__(self):\n        self.elements_added = set()\n        self.errors = list()\n\n\nclass _Line(str):\n\n    def __new__(cls, val, *args, **kwargs):\n        return super().__new__(cls, val)\n\n    def __init__(self, val, prefixes):\n        self.prefixes = prefixes\n\n    @functools.cached_property\n    def clean(self):\n        return self._strip_full() and self._strip_inline()\n\n    @property\n    def has_comments(self):\n        return self.strip() != self.clean\n\n    def _strip_inline(self):\n        \"\"\"\n        Search for the earliest prefix at the beginning of the line or following a space.\n        \"\"\"\n        matcher = re.compile(\n            '|'.join(fr'(^|\\s)({re.escape(prefix)})' for prefix in self.prefixes.inline)\n            # match nothing if no prefixes\n            or '(?!)'\n        )\n        match = matcher.search(self)\n        return self[:match.start() if match else None].strip()\n\n    def _strip_full(self):\n        return '' if any(map(self.strip().startswith, self.prefixes.full)) else True\n\n\nclass RawConfigParser(MutableMapping):\n    \"\"\"ConfigParser that does not do interpolation.\"\"\"\n\n    # Regular expressions for parsing section headers and options\n    _SECT_TMPL = r\"\"\"\n        \\[                                 # [\n        (?P<header>.+)                     # very permissive!\n        \\]                                 # ]\n        \"\"\"\n    _OPT_TMPL = r\"\"\"\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?P<vi>{delim})\\s*              # any number of space/tab,\n                                           # followed by any of the\n                                           # allowed delimiters,\n                                           # followed by any space/tab\n        (?P<value>.*)$                     # everything up to eol\n        \"\"\"\n    _OPT_NV_TMPL = r\"\"\"\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?:                             # any number of space/tab,\n        (?P<vi>{delim})\\s*                 # optionally followed by\n                                           # any of the allowed\n                                           # delimiters, followed by any\n                                           # space/tab\n        (?P<value>.*))?$                   # everything up to eol\n        \"\"\"\n    # Interpolation algorithm to be used if the user does not specify another\n    _DEFAULT_INTERPOLATION = Interpolation()\n    # Compiled regular expression for matching sections\n    SECTCRE = re.compile(_SECT_TMPL, re.VERBOSE)\n    # Compiled regular expression for matching options with typical separators\n    OPTCRE = re.compile(_OPT_TMPL.format(delim=\"=|:\"), re.VERBOSE)\n    # Compiled regular expression for matching options with optional values\n    # delimited using typical separators\n    OPTCRE_NV = re.compile(_OPT_NV_TMPL.format(delim=\"=|:\"), re.VERBOSE)\n    # Compiled regular expression for matching leading whitespace in a line\n    NONSPACECRE = re.compile(r\"\\S\")\n    # Possible boolean values in the configuration.\n    BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True,\n                      '0': False, 'no': False, 'false': False, 'off': False}\n\n    def __init__(self, defaults=None, dict_type=_default_dict,\n                 allow_no_value=False, *, delimiters=('=', ':'),\n                 comment_prefixes=('#', ';'), inline_comment_prefixes=None,\n                 strict=True, empty_lines_in_values=True,\n                 default_section=DEFAULTSECT,\n                 interpolation=_UNSET, converters=_UNSET,\n                 allow_unnamed_section=False,):\n\n        self._dict = dict_type\n        self._sections = self._dict()\n        self._defaults = self._dict()\n        self._converters = ConverterMapping(self)\n        self._proxies = self._dict()\n        self._proxies[default_section] = SectionProxy(self, default_section)\n        self._delimiters = tuple(delimiters)\n        if delimiters == ('=', ':'):\n            self._optcre = self.OPTCRE_NV if allow_no_value else self.OPTCRE\n        else:\n            d = \"|\".join(re.escape(d) for d in delimiters)\n            if allow_no_value:\n                self._optcre = re.compile(self._OPT_NV_TMPL.format(delim=d),\n                                          re.VERBOSE)\n            else:\n                self._optcre = re.compile(self._OPT_TMPL.format(delim=d),\n                                          re.VERBOSE)\n        self._prefixes = types.SimpleNamespace(\n            full=tuple(comment_prefixes or ()),\n            inline=tuple(inline_comment_prefixes or ()),\n        )\n        self._strict = strict\n        self._allow_no_value = allow_no_value\n        self._empty_lines_in_values = empty_lines_in_values\n        self.default_section=default_section\n        self._interpolation = interpolation\n        if self._interpolation is _UNSET:\n            self._interpolation = self._DEFAULT_INTERPOLATION\n        if self._interpolation is None:\n            self._interpolation = Interpolation()\n        if not isinstance(self._interpolation, Interpolation):\n            raise TypeError(\n                f\"interpolation= must be None or an instance of Interpolation;\"\n                f\" got an object of type {type(self._interpolation)}\"\n            )\n        if converters is not _UNSET:\n            self._converters.update(converters)\n        if defaults:\n            self._read_defaults(defaults)\n        self._allow_unnamed_section = allow_unnamed_section\n\n    def defaults(self):\n        return self._defaults\n\n    def sections(self):\n        \"\"\"Return a list of section names, excluding [DEFAULT]\"\"\"\n        # self._sections will never have [DEFAULT] in it\n        return list(self._sections.keys())\n\n    def add_section(self, section):\n        \"\"\"Create a new section in the configuration.\n\n        Raise DuplicateSectionError if a section by the specified name\n        already exists. Raise ValueError if name is DEFAULT.\n        \"\"\"\n        if section == self.default_section:\n            raise ValueError('Invalid section name: %r' % section)\n\n        if section in self._sections:\n            raise DuplicateSectionError(section)\n        self._sections[section] = self._dict()\n        self._proxies[section] = SectionProxy(self, section)\n\n    def has_section(self, section):\n        \"\"\"Indicate whether the named section is present in the configuration.\n\n        The DEFAULT section is not acknowledged.\n        \"\"\"\n        return section in self._sections\n\n    def options(self, section):\n        \"\"\"Return a list of option names for the given section name.\"\"\"\n        try:\n            opts = self._sections[section].copy()\n        except KeyError:\n            raise NoSectionError(section) from None\n        opts.update(self._defaults)\n        return list(opts.keys())\n\n    def read(self, filenames, encoding=None):\n        \"\"\"Read and parse a filename or an iterable of filenames.\n\n        Files that cannot be opened are silently ignored; this is\n        designed so that you can specify an iterable of potential\n        configuration file locations (e.g. current directory, user's\n        home directory, systemwide directory), and all existing\n        configuration files in the iterable will be read.  A single\n        filename may also be given.\n\n        Return list of successfully read files.\n        \"\"\"\n        if isinstance(filenames, (str, bytes, os.PathLike)):\n            filenames = [filenames]\n        encoding = io.text_encoding(encoding)\n        read_ok = []\n        for filename in filenames:\n            try:\n                with open(filename, encoding=encoding) as fp:\n                    self._read(fp, filename)\n            except OSError:\n                continue\n            if isinstance(filename, os.PathLike):\n                filename = os.fspath(filename)\n            read_ok.append(filename)\n        return read_ok\n\n    def read_file(self, f, source=None):\n        \"\"\"Like read() but the argument must be a file-like object.\n\n        The `f` argument must be iterable, returning one line at a time.\n        Optional second argument is the `source` specifying the name of the\n        file being read. If not given, it is taken from f.name. If `f` has no\n        `name` attribute, `<???>` is used.\n        \"\"\"\n        if source is None:\n            try:\n                source = f.name\n            except AttributeError:\n                source = '<???>'\n        self._read(f, source)\n\n    def read_string(self, string, source='<string>'):\n        \"\"\"Read configuration from a given string.\"\"\"\n        sfile = io.StringIO(string)\n        self.read_file(sfile, source)\n\n    def read_dict(self, dictionary, source='<dict>'):\n        \"\"\"Read configuration from a dictionary.\n\n        Keys are section names, values are dictionaries with keys and values\n        that should be present in the section. If the used dictionary type\n        preserves order, sections and their keys will be added in order.\n\n        All types held in the dictionary are converted to strings during\n        reading, including section names, option names and keys.\n\n        Optional second argument is the `source` specifying the name of the\n        dictionary being read.\n        \"\"\"\n        elements_added = set()\n        for section, keys in dictionary.items():\n            section = str(section)\n            try:\n                self.add_section(section)\n            except (DuplicateSectionError, ValueError):\n                if self._strict and section in elements_added:\n                    raise\n            elements_added.add(section)\n            for key, value in keys.items():\n                key = self.optionxform(str(key))\n                if value is not None:\n                    value = str(value)\n                if self._strict and (section, key) in elements_added:\n                    raise DuplicateOptionError(section, key, source)\n                elements_added.add((section, key))\n                self.set(section, key, value)\n\n    def get(self, section, option, *, raw=False, vars=None, fallback=_UNSET):\n        \"\"\"Get an option value for a given section.\n\n        If `vars` is provided, it must be a dictionary. The option is looked up\n        in `vars` (if provided), `section`, and in `DEFAULTSECT` in that order.\n        If the key is not found and `fallback` is provided, it is used as\n        a fallback value. `None` can be provided as a `fallback` value.\n\n        If interpolation is enabled and the optional argument `raw` is False,\n        all interpolations are expanded in the return values.\n\n        Arguments `raw`, `vars`, and `fallback` are keyword only.\n\n        The section DEFAULT is special.\n        \"\"\"\n        try:\n            d = self._unify_values(section, vars)\n        except NoSectionError:\n            if fallback is _UNSET:\n                raise\n            else:\n                return fallback\n        option = self.optionxform(option)\n        try:\n            value = d[option]\n        except KeyError:\n            if fallback is _UNSET:\n                raise NoOptionError(option, section)\n            else:\n                return fallback\n\n        if raw or value is None:\n            return value\n        else:\n            return self._interpolation.before_get(self, section, option, value,\n                                                  d)\n\n    def _get(self, section, conv, option, **kwargs):\n        return conv(self.get(section, option, **kwargs))\n\n    def _get_conv(self, section, option, conv, *, raw=False, vars=None,\n                  fallback=_UNSET, **kwargs):\n        try:\n            return self._get(section, conv, option, raw=raw, vars=vars,\n                             **kwargs)\n        except (NoSectionError, NoOptionError):\n            if fallback is _UNSET:\n                raise\n            return fallback\n\n    # getint, getfloat and getboolean provided directly for backwards compat\n    def getint(self, section, option, *, raw=False, vars=None,\n               fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, int, raw=raw, vars=vars,\n                              fallback=fallback, **kwargs)\n\n    def getfloat(self, section, option, *, raw=False, vars=None,\n                 fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, float, raw=raw, vars=vars,\n                              fallback=fallback, **kwargs)\n\n    def getboolean(self, section, option, *, raw=False, vars=None,\n                   fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, self._convert_to_boolean,\n                              raw=raw, vars=vars, fallback=fallback, **kwargs)\n\n    def items(self, section=_UNSET, raw=False, vars=None):\n        \"\"\"Return a list of (name, value) tuples for each option in a section.\n\n        All % interpolations are expanded in the return values, based on the\n        defaults passed into the constructor, unless the optional argument\n        `raw` is true.  Additional substitutions may be provided using the\n        `vars` argument, which must be a dictionary whose contents overrides\n        any pre-existing defaults.\n\n        The section DEFAULT is special.\n        \"\"\"\n        if section is _UNSET:\n            return super().items()\n        d = self._defaults.copy()\n        try:\n            d.update(self._sections[section])\n        except KeyError:\n            if section != self.default_section:\n                raise NoSectionError(section)\n        orig_keys = list(d.keys())\n        # Update with the entry specific variables\n        if vars:\n            for key, value in vars.items():\n                d[self.optionxform(key)] = value\n        value_getter = lambda option: self._interpolation.before_get(self,\n            section, option, d[option], d)\n        if raw:\n            value_getter = lambda option: d[option]\n        return [(option, value_getter(option)) for option in orig_keys]\n\n    def popitem(self):\n        \"\"\"Remove a section from the parser and return it as\n        a (section_name, section_proxy) tuple. If no section is present, raise\n        KeyError.\n\n        The section DEFAULT is never returned because it cannot be removed.\n        \"\"\"\n        for key in self.sections():\n            value = self[key]\n            del self[key]\n            return key, value\n        raise KeyError\n\n    def optionxform(self, optionstr):\n        return optionstr.lower()\n\n    def has_option(self, section, option):\n        \"\"\"Check for the existence of a given option in a given section.\n        If the specified `section` is None or an empty string, DEFAULT is\n        assumed. If the specified `section` does not exist, returns False.\"\"\"\n        if not section or section == self.default_section:\n            option = self.optionxform(option)\n            return option in self._defaults\n        elif section not in self._sections:\n            return False\n        else:\n            option = self.optionxform(option)\n            return (option in self._sections[section]\n                    or option in self._defaults)\n\n    def set(self, section, option, value=None):\n        \"\"\"Set an option.\"\"\"\n        if value:\n            value = self._interpolation.before_set(self, section, option,\n                                                   value)\n        if not section or section == self.default_section:\n            sectdict = self._defaults\n        else:\n            try:\n                sectdict = self._sections[section]\n            except KeyError:\n                raise NoSectionError(section) from None\n        sectdict[self.optionxform(option)] = value\n\n    def write(self, fp, space_around_delimiters=True):\n        \"\"\"Write an .ini-format representation of the configuration state.\n\n        If `space_around_delimiters` is True (the default), delimiters\n        between keys and values are surrounded by spaces.\n\n        Please note that comments in the original configuration file are not\n        preserved when writing the configuration back.\n        \"\"\"\n        if space_around_delimiters:\n            d = \" {} \".format(self._delimiters[0])\n        else:\n            d = self._delimiters[0]\n        if self._defaults:\n            self._write_section(fp, self.default_section,\n                                    self._defaults.items(), d)\n        if UNNAMED_SECTION in self._sections:\n            self._write_section(fp, UNNAMED_SECTION, self._sections[UNNAMED_SECTION].items(), d, unnamed=True)\n\n        for section in self._sections:\n            if section is UNNAMED_SECTION:\n                continue\n            self._write_section(fp, section,\n                                self._sections[section].items(), d)\n\n    def _write_section(self, fp, section_name, section_items, delimiter, unnamed=False):\n        \"\"\"Write a single section to the specified `fp'.\"\"\"\n        if not unnamed:\n            fp.write(\"[{}]\\n\".format(section_name))\n        for key, value in section_items:\n            value = self._interpolation.before_write(self, section_name, key,\n                                                     value)\n            if value is not None or not self._allow_no_value:\n                value = delimiter + str(value).replace('\\n', '\\n\\t')\n            else:\n                value = \"\"\n            fp.write(\"{}{}\\n\".format(key, value))\n        fp.write(\"\\n\")\n\n    def remove_option(self, section, option):\n        \"\"\"Remove an option.\"\"\"\n        if not section or section == self.default_section:\n            sectdict = self._defaults\n        else:\n            try:\n                sectdict = self._sections[section]\n            except KeyError:\n                raise NoSectionError(section) from None\n        option = self.optionxform(option)\n        existed = option in sectdict\n        if existed:\n            del sectdict[option]\n        return existed\n\n    def remove_section(self, section):\n        \"\"\"Remove a file section.\"\"\"\n        existed = section in self._sections\n        if existed:\n            del self._sections[section]\n            del self._proxies[section]\n        return existed\n\n    def __getitem__(self, key):\n        if key != self.default_section and not self.has_section(key):\n            raise KeyError(key)\n        return self._proxies[key]\n\n    def __setitem__(self, key, value):\n        # To conform with the mapping protocol, overwrites existing values in\n        # the section.\n        if key in self and self[key] is value:\n            return\n        # XXX this is not atomic if read_dict fails at any point. Then again,\n        # no update method in configparser is atomic in this implementation.\n        if key == self.default_section:\n            self._defaults.clear()\n        elif key in self._sections:\n            self._sections[key].clear()\n        self.read_dict({key: value})\n\n    def __delitem__(self, key):\n        if key == self.default_section:\n            raise ValueError(\"Cannot remove the default section.\")\n        if not self.has_section(key):\n            raise KeyError(key)\n        self.remove_section(key)\n\n    def __contains__(self, key):\n        return key == self.default_section or self.has_section(key)\n\n    def __len__(self):\n        return len(self._sections) + 1 # the default section\n\n    def __iter__(self):\n        # XXX does it break when underlying container state changed?\n        return itertools.chain((self.default_section,), self._sections.keys())\n\n    def _read(self, fp, fpname):\n        \"\"\"Parse a sectioned configuration file.\n\n        Each section in a configuration file contains a header, indicated by\n        a name in square brackets (`[]`), plus key/value options, indicated by\n        `name` and `value` delimited with a specific substring (`=` or `:` by\n        default).\n\n        Values can span multiple lines, as long as they are indented deeper\n        than the first line of the value. Depending on the parser's mode, blank\n        lines may be treated as parts of multiline values or ignored.\n\n        Configuration files may include comments, prefixed by specific\n        characters (`#` and `;` by default). Comments may appear on their own\n        in an otherwise empty line or may be entered in lines holding values or\n        section names. Please note that comments get stripped off when reading configuration files.\n        \"\"\"\n\n        try:\n            ParsingError._raise_all(self._read_inner(fp, fpname))\n        finally:\n            self._join_multiline_values()\n\n    def _read_inner(self, fp, fpname):\n        st = _ReadState()\n\n        Line = functools.partial(_Line, prefixes=self._prefixes)\n        for st.lineno, line in enumerate(map(Line, fp), start=1):\n            if not line.clean:\n                if self._empty_lines_in_values:\n                    # add empty line to the value, but only if there was no\n                    # comment on the line\n                    if (not line.has_comments and\n                        st.cursect is not None and\n                        st.optname and\n                        st.cursect[st.optname] is not None):\n                        st.cursect[st.optname].append('') # newlines added at join\n                else:\n                    # empty line marks end of value\n                    st.indent_level = sys.maxsize\n                continue\n\n            first_nonspace = self.NONSPACECRE.search(line)\n            st.cur_indent_level = first_nonspace.start() if first_nonspace else 0\n\n            if self._handle_continuation_line(st, line, fpname):\n                continue\n\n            self._handle_rest(st, line, fpname)\n\n        return st.errors\n\n    def _handle_continuation_line(self, st, line, fpname):\n        # continuation line?\n        is_continue = (st.cursect is not None and st.optname and\n            st.cur_indent_level > st.indent_level)\n        if is_continue:\n            if st.cursect[st.optname] is None:\n                raise MultilineContinuationError(fpname, st.lineno, line)\n            st.cursect[st.optname].append(line.clean)\n        return is_continue\n\n    def _handle_rest(self, st, line, fpname):\n        # a section header or option header?\n        if self._allow_unnamed_section and st.cursect is None:\n            self._handle_header(st, UNNAMED_SECTION, fpname)\n\n        st.indent_level = st.cur_indent_level\n        # is it a section header?\n        mo = self.SECTCRE.match(line.clean)\n\n        if not mo and st.cursect is None:\n            raise MissingSectionHeaderError(fpname, st.lineno, line)\n\n        self._handle_header(st, mo.group('header'), fpname) if mo else self._handle_option(st, line, fpname)\n\n    def _handle_header(self, st, sectname, fpname):\n        st.sectname = sectname\n        if st.sectname in self._sections:\n            if self._strict and st.sectname in st.elements_added:\n                raise DuplicateSectionError(st.sectname, fpname,\n                                            st.lineno)\n            st.cursect = self._sections[st.sectname]\n            st.elements_added.add(st.sectname)\n        elif st.sectname == self.default_section:\n            st.cursect = self._defaults\n        else:\n            st.cursect = self._dict()\n            self._sections[st.sectname] = st.cursect\n            self._proxies[st.sectname] = SectionProxy(self, st.sectname)\n            st.elements_added.add(st.sectname)\n        # So sections can't start with a continuation line\n        st.optname = None\n\n    def _handle_option(self, st, line, fpname):\n        # an option line?\n        st.indent_level = st.cur_indent_level\n\n        mo = self._optcre.match(line.clean)\n        if not mo:\n            # a non-fatal parsing error occurred. set up the\n            # exception but keep going. the exception will be\n            # raised at the end of the file and will contain a\n            # list of all bogus lines\n            st.errors.append(ParsingError(fpname, st.lineno, line))\n            return\n\n        st.optname, vi, optval = mo.group('option', 'vi', 'value')\n        if not st.optname:\n            st.errors.append(ParsingError(fpname, st.lineno, line))\n        st.optname = self.optionxform(st.optname.rstrip())\n        if (self._strict and\n            (st.sectname, st.optname) in st.elements_added):\n            raise DuplicateOptionError(st.sectname, st.optname,\n                                    fpname, st.lineno)\n        st.elements_added.add((st.sectname, st.optname))\n        # This check is fine because the OPTCRE cannot\n        # match if it would set optval to None\n        if optval is not None:\n            optval = optval.strip()\n            st.cursect[st.optname] = [optval]\n        else:\n            # valueless option handling\n            st.cursect[st.optname] = None\n\n    def _join_multiline_values(self):\n        defaults = self.default_section, self._defaults\n        all_sections = itertools.chain((defaults,),\n                                       self._sections.items())\n        for section, options in all_sections:\n            for name, val in options.items():\n                if isinstance(val, list):\n                    val = '\\n'.join(val).rstrip()\n                options[name] = self._interpolation.before_read(self,\n                                                                section,\n                                                                name, val)\n\n    def _read_defaults(self, defaults):\n        \"\"\"Read the defaults passed in the initializer.\n        Note: values can be non-string.\"\"\"\n        for key, value in defaults.items():\n            self._defaults[self.optionxform(key)] = value\n\n    def _unify_values(self, section, vars):\n        \"\"\"Create a sequence of lookups with 'vars' taking priority over\n        the 'section' which takes priority over the DEFAULTSECT.\n\n        \"\"\"\n        sectiondict = {}\n        try:\n            sectiondict = self._sections[section]\n        except KeyError:\n            if section != self.default_section:\n                raise NoSectionError(section) from None\n        # Update with the entry specific variables\n        vardict = {}\n        if vars:\n            for key, value in vars.items():\n                if value is not None:\n                    value = str(value)\n                vardict[self.optionxform(key)] = value\n        return _ChainMap(vardict, sectiondict, self._defaults)\n\n    def _convert_to_boolean(self, value):\n        \"\"\"Return a boolean value translating from other types if necessary.\n        \"\"\"\n        if value.lower() not in self.BOOLEAN_STATES:\n            raise ValueError('Not a boolean: %s' % value)\n        return self.BOOLEAN_STATES[value.lower()]\n\n    def _validate_value_types(self, *, section=\"\", option=\"\", value=\"\"):\n        \"\"\"Raises a TypeError for non-string values.\n\n        The only legal non-string value if we allow valueless\n        options is None, so we need to check if the value is a\n        string if:\n        - we do not allow valueless options, or\n        - we allow valueless options but the value is not None\n\n        For compatibility reasons this method is not used in classic set()\n        for RawConfigParsers. It is invoked in every case for mapping protocol\n        access and in ConfigParser.set().\n        \"\"\"\n        if not isinstance(section, str):\n            raise TypeError(\"section names must be strings\")\n        if not isinstance(option, str):\n            raise TypeError(\"option keys must be strings\")\n        if not self._allow_no_value or value:\n            if not isinstance(value, str):\n                raise TypeError(\"option values must be strings\")\n\n    @property\n    def converters(self):\n        return self._converters\n\n\nclass ConfigParser(RawConfigParser):\n    \"\"\"ConfigParser implementing interpolation.\"\"\"\n\n    _DEFAULT_INTERPOLATION = BasicInterpolation()\n\n    def set(self, section, option, value=None):\n        \"\"\"Set an option.  Extends RawConfigParser.set by validating type and\n        interpolation syntax on the value.\"\"\"\n        self._validate_value_types(option=option, value=value)\n        super().set(section, option, value)\n\n    def add_section(self, section):\n        \"\"\"Create a new section in the configuration.  Extends\n        RawConfigParser.add_section by validating if the section name is\n        a string.\"\"\"\n        self._validate_value_types(section=section)\n        super().add_section(section)\n\n    def _read_defaults(self, defaults):\n        \"\"\"Reads the defaults passed in the initializer, implicitly converting\n        values to strings like the rest of the API.\n\n        Does not perform interpolation for backwards compatibility.\n        \"\"\"\n        try:\n            hold_interpolation = self._interpolation\n            self._interpolation = Interpolation()\n            self.read_dict({self.default_section: defaults})\n        finally:\n            self._interpolation = hold_interpolation\n\n\nclass SectionProxy(MutableMapping):\n    \"\"\"A proxy for a single section from a parser.\"\"\"\n\n    def __init__(self, parser, name):\n        \"\"\"Creates a view on a section of the specified `name` in `parser`.\"\"\"\n        self._parser = parser\n        self._name = name\n        for conv in parser.converters:\n            key = 'get' + conv\n            getter = functools.partial(self.get, _impl=getattr(parser, key))\n            setattr(self, key, getter)\n\n    def __repr__(self):\n        return '<Section: {}>'.format(self._name)\n\n    def __getitem__(self, key):\n        if not self._parser.has_option(self._name, key):\n            raise KeyError(key)\n        return self._parser.get(self._name, key)\n\n    def __setitem__(self, key, value):\n        self._parser._validate_value_types(option=key, value=value)\n        return self._parser.set(self._name, key, value)\n\n    def __delitem__(self, key):\n        if not (self._parser.has_option(self._name, key) and\n                self._parser.remove_option(self._name, key)):\n            raise KeyError(key)\n\n    def __contains__(self, key):\n        return self._parser.has_option(self._name, key)\n\n    def __len__(self):\n        return len(self._options())\n\n    def __iter__(self):\n        return self._options().__iter__()\n\n    def _options(self):\n        if self._name != self._parser.default_section:\n            return self._parser.options(self._name)\n        else:\n            return self._parser.defaults()\n\n    @property\n    def parser(self):\n        # The parser object of the proxy is read-only.\n        return self._parser\n\n    @property\n    def name(self):\n        # The name of the section on a proxy is read-only.\n        return self._name\n\n    def get(self, option, fallback=None, *, raw=False, vars=None,\n            _impl=None, **kwargs):\n        \"\"\"Get an option value.\n\n        Unless `fallback` is provided, `None` will be returned if the option\n        is not found.\n\n        \"\"\"\n        # If `_impl` is provided, it should be a getter method on the parser\n        # object that provides the desired type conversion.\n        if not _impl:\n            _impl = self._parser.get\n        return _impl(self._name, option, raw=raw, vars=vars,\n                     fallback=fallback, **kwargs)\n\n\nclass ConverterMapping(MutableMapping):\n    \"\"\"Enables reuse of get*() methods between the parser and section proxies.\n\n    If a parser class implements a getter directly, the value for the given\n    key will be ``None``. The presence of the converter name here enables\n    section proxies to find and use the implementation on the parser class.\n    \"\"\"\n\n    GETTERCRE = re.compile(r\"^get(?P<name>.+)$\")\n\n    def __init__(self, parser):\n        self._parser = parser\n        self._data = {}\n        for getter in dir(self._parser):\n            m = self.GETTERCRE.match(getter)\n            if not m or not callable(getattr(self._parser, getter)):\n                continue\n            self._data[m.group('name')] = None   # See class docstring.\n\n    def __getitem__(self, key):\n        return self._data[key]\n\n    def __setitem__(self, key, value):\n        try:\n            k = 'get' + key\n        except TypeError:\n            raise ValueError('Incompatible key: {} (type: {})'\n                             ''.format(key, type(key)))\n        if k == 'get':\n            raise ValueError('Incompatible key: cannot use \"\" as a name')\n        self._data[key] = value\n        func = functools.partial(self._parser._get_conv, conv=value)\n        func.converter = value\n        setattr(self._parser, k, func)\n        for proxy in self._parser.values():\n            getter = functools.partial(proxy.get, _impl=func)\n            setattr(proxy, k, getter)\n\n    def __delitem__(self, key):\n        try:\n            k = 'get' + (key or None)\n        except TypeError:\n            raise KeyError(key)\n        del self._data[key]\n        for inst in itertools.chain((self._parser,), self._parser.values()):\n            try:\n                delattr(inst, k)\n            except AttributeError:\n                # don't raise since the entry was present in _data, silently\n                # clean up\n                continue\n\n    def __iter__(self):\n        return iter(self._data)\n\n    def __len__(self):\n        return len(self._data)\n", 1385], "C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py": ["'''\n# -----------------------------------------------------------------------------\n# Author: MIRKO THULKE \n# Copyright (c) 2025, MIRKO THULKE\n# All rights reserved.\n#\n# Date: 2025, VERSAILLES, FRANCE\n#\n# MIT License\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING\n# FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n#\n# -----------------------------------------------------------------------------\n'''\n\n\n'''\nimportant commands : \ncmd> python -m pip install --upgrade pip\ncmd> pip install pyaudio\ncmd> pip install numpy\ncmd> where python\ncmd> python --version\ncmd> python3 --version\ncmd> pip install --upgrade -r requirements.txt\ncmd> pip freeze > requirements.txt\ncmd> pip list --outdated\n'''\nimport wx # click button GUI\nimport pyaudio\nimport scipy.signal as signal\nimport sympy\nimport librosa\nfrom endolith_weighting_filters import A_weight\nimport numpy as np\nimport wave\nimport matplotlib.pyplot as plt\nimport configparser\nimport multiprocessing\nimport threading\nimport subprocess\nimport os\nimport psutil\nimport time\nimport datetime\nfrom viztracer import VizTracer # visual thread debugging\n\n\n# visual thead debugging\n\n#tracer = VizTracer()  # Start VizTracer\n#tracer.start()\n\n# open results in CMD : \"vizviewer Python_AudioLogger_JSON_LogFile.json\"\n# ZOOM into timeline by pressing CTLR + Mouse wheel\n# and check for status update and display update tasks. \n# Should be called every 20ms aprox with chunk size 1024 and 48kHz\n\n\n\n# Behringer UMC control panel settings :\n# ASIO buffer size 512   \n# Sampling rate 48kHz\n# Format : 4 Channel 16 bits  \n\n\n# Set parameters for audio input\nFORMAT = pyaudio.paInt16  # Format for the audio\nCHANNELS = 1  # Mono audio (1 channel)\nRATE = 48000  # Sampling rate (samples per second)\nCHUNK = 1024  # Number of frames per buffer (size of each audio chunk)\nDEVICE_INDEX = None  # Set to the correct device index if you have multiple devices\nCHUNK_SEC = CHUNK/RATE # Chunk duration in seconds\nWAVE_DT_SEC = 1.5 # Delta time duration before and after noise event, that will be added to wave output\nCHUNK_DNUM = int(WAVE_DT_SEC/CHUNK_SEC) # number of chunks to be added before and after noise event, that will be added to wave output\n\n\nREFERENCE_PRESSURE = 20e-6  # in Pa. Reference pressure in Pa (20 \u00b5Pa)\nMIC_SENSITIVITY = 15 # 15mV Sensitivity (mV / Pa) of the Behringer ECM8000 (for better understanding only)\nMIC_SPL_MAX_DB = 120   # in dB. virtual SPL max. value that the microphone can measure\nMIC_PA_MAX = 20     # in Pa. Maximum Number of Pa that the mcicrophone can measure (120dB converted to Pascal)\nMIC_MAX_MVOLT = MIC_PA_MAX * MIC_SENSITIVITY # maximum mV that the microphone can measure (corresponds to 120dB, 20Pa)\n\nPRE_AMP_GAIN_DB = 45  # in dB. Assupmption that the Gain poti on the UMC is on 3h00. Virtuel Pre-Amp Gain Factor for better understanding only\nPRE_AMP_GAIN_LIN = np.power(10, (PRE_AMP_GAIN_DB / 20) ) # Converted to linear scale.\n\nsystem_calibration_factor_94db = 1 # Microphone calibration factor to obtain 94dB at 1kHz. Default value 1\nCALIB_ITERATION_LENGTH = 50 # 50 chunks are checked during calibration\nMAX_INT16 = np.iinfo(np.int16).max\n\n# dB(A) Threshold for indoor noise\n# NIGHT : 22h00 - 06h00\nSPL_MAX_DAY_DBA     = 50\nSPL_MAX_NIGH_DBA    = 35\n\n\n\n# Set parameters for audio outut\nRECORD_SECONDS = 4        # Duration of the recording in seconds\nOUTPUT_FILENAME = \"output.wav\"  # Output WAV file\nOUTPUT_NOISE_FILENAME = \"Bruit\" #Output filename prefix for logged noise events\nOUTPUT_FILE_DIRECTORY = \"audio_logfiles\"\n\n\n\n#Global Variables #######################################\n\n# Initialize PyAudio\np                                   = pyaudio.PyAudio()\n\n# Device list user input \n_device_index                       = 0\n\n# Persist Settings. Create config object.\nconfig                              = configparser.ConfigParser()\n\n# flag to track recoding state\nis_recording                        = False\n# flag to track logging state\nis_logging                          = False\n\n# Open stream to read audio from the microphone\n\nstream = p.open(format=FORMAT,\n    channels=CHANNELS,\n    rate=RATE,\n    input=True,\n    input_device_index = _device_index ,\n    frames_per_buffer=CHUNK)\n\nprint(\"Audio stream opened\")\n\n\n# audio data extraceted from chunk in np format.\naudio_data                          = np.array([])\na_weighted_signal                   = np.array([])\naudio_data_pcm_abs                  = np.array([])\naudio_data_mV                       = np.array([])\naudio_data_mV_calib                 = np.array([])\naudio_data_pressurePa               = np.array([])\naudio_data_pressurePa_square        = np.array([])\naudio_data_pressurePa_squareMean    = 0\naudio_data_pressurePa_rms           = 0\naudio_data_pressurePa_rms_calib     = 0\naudio_data_pressurePa_spl           = 0\naudio_data_max_pcm_value            = 0\n\n#for output wave file creation / all chunks, complete measurement\nframes                              = []\n\nchunk_index_i                       = 0\nchunk_noise_list_index              = []\nchunk_noise_list_spl                = []\n\n\n# Global Funtion definitions ##########################################\ndef get_commit_version():\n    try:\n        # Run 'git rev-parse HEAD' to get the commit hash\n        commit_hash = subprocess.check_output(['git', 'rev-parse', 'HEAD']).strip().decode('utf-8')\n        return commit_hash\n    except subprocess.CalledProcessError:\n        return \"Not a git repository or error retrieving commit.\"\n \ndef func_check_devices():\n    global p\n    \n    i=0\n    \n    # List available devices\n    print(\"Available devices:\")\n    for i in range(p.get_device_count()):\n            device_info = p.get_device_info_by_index(i)\n            print(f\"Device {i}: {device_info['name']}\")\n\n\n\ndef func_on_button_setDevices_click(frame):\n    global _device_index \n    global p\n    \n    _device_index = 0\n    min_range = 0\n    max_range = 100\n\n    user_value = int(frame.text_ctrl.GetValue())\n    \n    # Check if the input is within the valid range\n    # obtain user text input for device selection\n    if min_range <= user_value  <= max_range:\n        _device_index = user_value\n        wx.MessageBox(f\"Device {_device_index}: {p.get_device_info_by_index(_device_index)}\",\"Info\", wx.OK | wx.ICON_INFORMATION)\n    else :\n        wx.MessageBox(f\"Error: The number must be between {min_range} and {max_range}.\",\"Info\", wx.OK | wx.ICON_INFORMATION)\n\n\ndef apply_a_weighting(audio_data):\n    \"\"\"Apply the A-weighting filter to the signal\"\"\"\n\n    \n    # convert to float for filtering\n    float_array  = audio_data.astype(np.float32)\n    \n\n    # Apply A-weighting\n    float_array_filt = A_weight(float_array, RATE)\n    \n    #convert back to integer for further processing\n    int_array   = float_array_filt.astype(np.int16)\n    \n    #print(f'audio_data: {audio_data}')\n    #print(f'float_array: {float_array}')\n    #print(f'float_array_filt: {float_array_filt}') \n    #print(f'int_array: {int_array}')   \n    \n    return ( int_array )\n\n\ndef func_calc_SPL():\n \n    # input data\n    global audio_data\n    global a_weighted_signal\n    global system_calibration_factor_94db\n    \n    #output data\n    global audio_data_max_pcm_value\n    global audio_data_pcm_abs\n    global audio_data_mV\n    global audio_data_pressurePa\n    global audio_data_pressurePa_square\n    global audio_data_pressurePa_squareMean\n    global audio_data_pressurePa_rms\n    global audio_data_pressurePa_rms_calib\n    global audio_data_pressurePa_spl\n\n    \n    \n    # reset output arrays :\n    a_weighted_signal                   = np.zeros(a_weighted_signal.shape)\n    audio_data_pcm_abs                  = np.zeros(audio_data_pcm_abs.shape)\n    audio_data_mV                       = np.zeros(audio_data_mV.shape)\n    audio_data_pressurePa               = np.zeros(audio_data_pressurePa.shape)\n    audio_data_pressurePa_square        = np.zeros(audio_data_pressurePa_square.shape)\n    audio_data_pressurePa_squareMean    = 0\n    audio_data_pressurePa_rms           = 0\n    audio_data_pressurePa_rms_calib     = 0\n    audio_data_pressurePa_spl           = 0\n\n    \n    # Apply A-weighting to the signal\n    # A-weighting does not have an impcat on microphone calibration at 1000Hz, because weighting is 1 at 1000Hz. \n    # Convert to float for A-weighting processing ( scipy.signal requires type 'signal', thus float32)\n    a_weighted_signal = apply_a_weighting(audio_data)\n\n    # Check  the maximum absolute value\n    audio_data_max_pcm_value_new = np.max(np.abs(a_weighted_signal))\n    \n    # save if highest of all chunks\n    audio_data_max_pcm_value = max(audio_data_max_pcm_value, audio_data_max_pcm_value_new)\n    # Example: Process the audio (e.g., calculate RMS for volume level) \n        \n    # Absolute values first      \n    audio_data_pcm_abs = np.abs(a_weighted_signal)\n    \n    # Convert to mV using the Sensitivy value of the microphone/ Assuming that the microphone uses the full int16 signale range . \n    # Applying a preamp gain factor (only for better understanding)\n    audio_data_mV = audio_data_pcm_abs / PRE_AMP_GAIN_LIN\n    #print(f\"audio_data_mV: {audio_data_mV}\")\n    \n    \n    # Converting mV to Pa using the Sensitivy value\n    audio_data_pressurePa = audio_data_mV / MIC_SENSITIVITY\n    #print(f\"audio_data_pressurePa: {audio_data_pressurePa}\")\n    \n    # Convert to RMS - Root mean square\n    audio_data_pressurePa_square = audio_data_pressurePa ** 2    \n    audio_data_pressurePa_squareMean =  np.mean(audio_data_pressurePa_square)         \n    if audio_data_pressurePa_squareMean > 0 :\n        audio_data_pressurePa_rms = np.sqrt(audio_data_pressurePa_squareMean)\n    else :\n        audio_data_pressurePa_rms = 0           \n    #print(f\"audio_data_pressurePa_rms: {audio_data_pressurePa_rms}\")   \n    \n    audio_data_pressurePa_rms_calib =audio_data_pressurePa_rms* system_calibration_factor_94db\n    \n    # convert RMS to SPL (explained below)\n    # Reference pressure in air = 20 \u00b5Pa\n    if audio_data_pressurePa_rms_calib > 0:\n        audio_data_pressurePa_spl = 20 * np.log10(audio_data_pressurePa_rms_calib / REFERENCE_PRESSURE)    \n    else :\n        audio_data_pressurePa_spl = 0     \n        \n    #print(f\"SPL (dB): {audio_data_pressurePa_spl}\")\n\n\ndef func_process_audio_input():\n    global p\n    global stream\n    global frames\n    global is_recording\n    global _device_index\n    \n    global max_value\n    global audio_data \n    global audio_data_pcm_abs\n    global audio_data_mV\n    global audio_data_pressurePa\n    global audio_data_pressurePa_square\n    global audio_data_pressurePa_squareMean\n    global audio_data_pressurePa_rms\n    global audio_data_pressurePa_rms_calib\n    global audio_data_pressurePa_spl\n    global system_calibration_factor_94db\n    \n    global chunk_index_i\n    global chunk_noise_list_index\n    global chunk_noise_list_spl\n    \n    #whole process will run in high priority mode\n    p_func_process_audio_input = psutil.Process(os.getpid())\n    p_func_process_audio_input.nice(psutil.REALTIME_PRIORITY_CLASS)  \n\n    \n    print(\"recording_process started 1/2\\n\")\n    \n    # frame.update_status.AppendText  -> updateAfter is replaced by AppendText because we use a queue as argument.\n    # Because theading has been replaced by processes\n    \n    #reset audio input related lists and counters\n    chunk_index_i = 0    # counter of processed chunks\n    chunk_noise_list_index = []\n    chunk_noise_list_spl = []\n    frames = []\n    \n    while is_recording:    \n        # Read a chunk of audio data\n        data = stream.read(CHUNK)\n      \n        # Convert the audio data to a numpy array\n        audio_data = np.frombuffer(data, dtype=np.int16)\n        \n        #for output wave file creation, add to a list\n        frames.append(data)\n        \n        # Calculate PCM to SPl ! \n        func_calc_SPL()\n        \n        #chunk counter\n        chunk_index_i = chunk_index_i+1\n        #frame.update_status.AppendText(f\"Recording running. Number of chunks processed: {chunk_index_i}\\n\")\n        print(f\"chunk_index : {chunk_index_i}\\n\")\n        \n        #frame.update_dba_display.AppendText(f\"  {round(audio_data_pressurePa_spl, 2)} [dbA]\\n\")\n        \n        if audio_data_pressurePa_spl > SPL_MAX_DAY_DBA :\n            chunk_noise_list_index.append(chunk_index_i)\n            chunk_noise_list_spl.append(audio_data_pressurePa_spl)\n         \n    #frame.update_status.AppendText(f\"Recording terminated. Number of chunks processed: {chunk_index_i}\\n\")\n\n    print(\"Recording thread stopped.\\n\")\n    #frame.update_status.AppendText(\"Recording stopped ...\\n\")\n    print(f\"chunk_noise_list_index : {chunk_noise_list_index}\\n\")\n\n    \n    \ndef func_run_calibration():\n    global p\n    global stream\n    global frames\n    global is_recording\n    global  _device_index\n    \n    global audio_data_max_pcm_value\n    global audio_data \n    global audio_data_pcm_abs\n    global audio_data_mV\n    global audio_data_pressurePa\n    global audio_data_pressurePa_square\n    global audio_data_pressurePa_squareMean\n    global audio_data_pressurePa_rms\n    global audio_data_pressurePa_rms_calib\n    global audio_data_pressurePa_spl\n    global system_calibration_factor_94db\n\n    #whole process will run in high priority mode\n    p_func_run_calibration = psutil.Process(os.getpid())\n    p_func_run_calibration.nice(psutil.REALTIME_PRIORITY_CLASS)  \n\n\n    calib_arr = []\n    i= 0 \n    audio_data_max_pcm_value  = 0\n    \n    \n    while i<CALIB_ITERATION_LENGTH :\n        \n        i=i+1\n    \n        # Read a chunk of audio data\n        data = stream.read(CHUNK)\n      \n        # Convert the audio data to a numpy array\n        audio_data = np.frombuffer(data, dtype=np.int16)\n        \n        #for output wave file creation, add to a list\n        frames.append(data)\n        \n        # Calculate PCM to SPl ! \n        func_calc_SPL()\n        \n        \n        if audio_data_pressurePa_rms > 0 : \n            \n            # 94 dB != 20 log (rms /p_0) :\n            system_calibration_factor_94db_new = (REFERENCE_PRESSURE * (np.power(10, 94/20))) /audio_data_pressurePa_rms\n            print(f\"system_calibration_factor_94db_new: {system_calibration_factor_94db_new}\\n\") \n            \n            # Store new value in array \n            calib_arr.append(system_calibration_factor_94db_new)\n            \n        else :\n            print(\"SPL or Pa equal to zero in this chunk. Check sound input ! \\n\") \n        \n         \n    # Check if the input PCM coded signal at 94dB calibration db (which is quite loud) is using the full range of the sint16 signal range\n    # Check maximum across all chunks, see while loop\n    print(f\"Maximum PCM  amplitude: {audio_data_max_pcm_value}\\n\")\n    if audio_data_max_pcm_value > int(MAX_INT16*0.95) :\n        wx.MessageBox(f\"Maximum PCM 16bit amplitude: {audio_data_max_pcm_value}/{MAX_INT16}. Upper threshold: {int(MAX_INT16*0.95)} . Reduce GAIN on PreAmp !\\n\",\"Info\", wx.OK | wx.ICON_INFORMATION)       \n    elif audio_data_max_pcm_value < int(MAX_INT16*0.8) :\n        wx.MessageBox(f\"Maximum PCM 16bit amplitude: {audio_data_max_pcm_value}/{MAX_INT16}. lower threshold: {int(MAX_INT16*0.8)}  . Increase GAIN on PreAmp !\\n\",\"Info\", wx.OK | wx.ICON_INFORMATION)      \n    else :\n        wx.MessageBox(f\"Maximum PCM 16bit amplitude: {audio_data_max_pcm_value}/{MAX_INT16}. PreAmp GAIN OK !\\n\",\"Info\", wx.OK | wx.ICON_INFORMATION)\n    \n    # calculate average calibration factor across all chunks, see while loop\n    calib_average = sum(calib_arr) / len(calib_arr)\n    \n    #store average as new calibration factor\n    system_calibration_factor_94db = calib_average\n    print(f\"Averaged system_calibration_factor_94db: {system_calibration_factor_94db}\\n\") \n       \n\n\n\ndef func_check_calibration():\n    global p\n    global stream\n    global frames\n    global is_recording\n    global  _device_index\n\n    global max_value\n    global audio_data \n    global audio_data_pcm_abs\n    global audio_data_mV\n    global audio_data_pressurePa\n    global audio_data_pressurePa_square\n    global audio_data_pressurePa_squareMean\n    global audio_data_pressurePa_rms\n    global audio_data_pressurePa_rms_calib\n    global audio_data_pressurePa_spl\n    global system_calibration_factor_94db\n       \n    #whole process will run in high priority mode, but lower than Real Time\n    p_func_run_calibration = psutil.Process(os.getpid())\n    p_func_run_calibration.nice(psutil.HIGH_PRIORITY_CLASS)  \n    \n    spl_error_arr = []\n    spl_error_arr_square = []\n    \n    i= 0 \n   \n    while i<CALIB_ITERATION_LENGTH :       \n        i=i+1\n    \n        # Read a chunk of audio data\n        data = stream.read(CHUNK)\n      \n        # Convert the audio data to a numpy array\n        audio_data = np.frombuffer(data, dtype=np.int16)\n        \n        #for output wave file creation, add to a list\n        frames.append(data)\n        \n        # Calculate PCM to SPl ! \n        func_calc_SPL()\n        \n        \n        if audio_data_pressurePa_spl > 0 : \n            \n            # calculate error in dB SPL\n            spl_error = 94 - audio_data_pressurePa_spl\n            print(f\"spl_error: {spl_error}\\n\")\n            \n            spl_error_square = np.power(spl_error, 2)\n                                                \n            # Store new value in array \n            spl_error_arr_square.append(spl_error_square)\n            spl_error_arr.append(spl_error)\n            \n        else :\n            print(\"SPL or Pa equal to zero in this chunk. Check sound input !\\n \") \n\n                          \n    # calculate root mean square error \n    spl_error_average = np.sqrt(np.average(spl_error_square ))\n    print(f\"spl_error_average: {spl_error_average}\\n\")\n\n       \n\ndef func_on_button_start_click(frame):\n    global is_recording\n    global is_logging \n    \n    # Enable / Disable buttons\n    frame.button_start.Disable()\n    frame.button_stop.Enable()\n    \n    # Start recording process\n    wx.CallAfter(frame.update_status,  \"Start button pressed...\\n\")\n    print(f\"is_recording: {is_recording}\\n\")\n    if not is_recording:\n        is_recording = True\n        print(f\"is_recording: {is_recording}\\n\")\n        # Create a separate processto run the audio processing task\n        # The processes are required to decouple the input stream reading from the GUI app \n        \n        print(\"recording process will be created now.\\n\")\n        if frame.recording_process is None or not frame.recording_process.is_alive():\n            try:\n                print(\"Creating and starting recording process...\\n\")\n                frame.recording_queue  = multiprocessing.Queue()\n                frame.recording_process =multiprocessing.Process(target=func_process_audio_input)\n                print(\"recording process created\\n\")\n            \n                # Argument : frame. Required to create a process from inside the GUI that serves as longrunning\n                # background task. And must refresh the GUI (frame instance) from inside the backround task via AppendText\n       \n                frame.recording_process.start()\n                print(\"recording process started\\n\")\n            \n                # Update the status text after the task is complete (safely in the main process)  \n                wx.CallAfter(frame.update_status,  \"recording process started 2/2\\n\")\n            \n            except Exception as e:\n                print(f\"Error starting recording process : {e}\\n\")\n            \n        else:\n            wx.CallAfter(frame.update_status,  \"recording process is already running 1.\\n\")\n            print(\"recording process is already running 1.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"recording process is already running 2.\\n\")\n        print(\"recording process is already running 2.\\n\")\n\n    print(f\"logging process will be started: {is_logging}\\n\")   \n    # Start logging thread\n    if not is_logging:\n        is_logging = True\n        print(f\"is_logging: {is_logging}\\n\")\n        # Create a separate thread to run the process\n        # The thread is required to decouple the input stream reading from the GUI app \n\n        if frame.logging_process is None or not frame.logging_process.is_alive():\n            print(\"logging process will be created now.\\n\")\n            \n            # Argument : frame. Required to create a process from inside the GUI that serves as longrunning\n            # background task. And must refresh the GUI (frame instance) from inside the backround task via callAfter\n           \n            frame.logging_queue  = multiprocessing.Queue()\n            frame.logging_process = multiprocessing.Process(target=func_saveWave_on_noise_event)\n            print(\"logging process created\\n\")\n \n            frame.logging_process.start()\n            print(\"logging process started 2/2\\n\")\n            \n            # Update the status text after the task is complete (safely in the main process)\n            wx.CallAfter(frame.update_status,  \"logging process started 2...\\n\")\n        else:\n            wx.CallAfter(frame.update_status,  \"logging process is already running.\\n\")\n            print(\"logging process is already running 1.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"logging process is already running.\\n\")\n        print(\"logging Thread is already running 2.\\n\")\n\n\ndef func_on_button_stop_click(frame):\n    global is_recording\n    global is_logging\n    \n    # Enable / Disable buttons\n    frame.button_start.Enable()\n    frame.button_stop.Disable()\n    \n    print(f\"is_recording: {is_recording}\\n\")\n    is_recording = False\n    print(f\"is_recording: {is_recording}\\n\")\n    \n    print(f\"is_logging: {is_logging}\\n\")\n    is_logging = False\n    print(f\"is_logging: {is_logging}\\n\")\n    \n    if frame.recording_process is not None and frame.recording_process.is_alive():\n        frame.recording_process.join()  # Wait for the process to finish gracefully\n        wx.CallAfter(frame.update_status,  \"Recording process stopped.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"No Recording process is running.\\n\")\n    \n    if frame.logging_process is not None and frame.logging_process.is_alive():\n        frame.logging_process.join()  # Wait for the process to finish gracefully\n        wx.CallAfter(frame.update_status,  \"logging process stopped.\\n\")\n    else:\n        wx.CallAfter(frame.update_status,  \"No logging process is running.\\n\")\n   \n\ndef func_on_button_runCalib_click(frame):\n    \n    # Create a separate thread to run the process\n    # The thread is required to decouple the input stream reading from the GUI app \n    frame.runCalib_thread   =multiprocessing.Process(target=func_run_calibration)\n    frame.runCalib_thread.daemon = True\n    frame.runCalib_thread.start()\n       \n       \ndef func_on_button_checkCalib_click(frame):\n    \n    # Create a separate thread to run the process\n    # The thread is required to decouple the input stream reading from the GUI app \n    frame.checkCalib_thread  =multiprocessing.Process(target=func_check_calibration)\n    frame.checkCalib_thread.daemon = True\n    frame.checkCalib_thread.start()\n\n\ndef func_on_button_exit_click(frame):\n\n    # Close the parent application and the GUI event loop (-> indicated by self)\n    frame.Close()\n\n\n\ndef func_saveWave_on_noise_event():\n    global p\n    global frames\n    \n    global chunk_index_i\n    global chunk_noise_list_index\n    global chunk_noise_list_spl\n    \n    global is_logging\n    \n    max_spl_in_chunk = 0\n    max_spl_index_in_chunk = 0\n    max_spl_chunk_index = 0\n    start_chunk = 0\n    stop_chunk = 0\n    \n    noise_frames = []\n  \n    #whole process will run in high priority mode, but lower than the Audio processing task\n    p_func_saveWave_on_noise_event = psutil.Process(os.getpid())\n    p_func_saveWave_on_noise_event.nice(psutil.HIGH_PRIORITY_CLASS)  \n  \n    print(\"logging_thread started 1/2\\n\")\n    \n\n    #Start with offset of wave output length\n    time.sleep(WAVE_DT_SEC)\n    \n    while is_logging:  \n        \n\n              \n        # check if events are detected and stored in the list\n        if len(chunk_noise_list_index) > 0 :\n            print()\n            print(\"New Recording event: \\n\")\n\n        \n            #identify max spl value and repsective hunk number \n            max_spl_in_chunk = max(chunk_noise_list_spl)\n            max_spl_index_in_chunk = chunk_noise_list_spl.index(max_spl_in_chunk)\n            #index of the chunk with maximum spl \n            max_spl_chunk_index = chunk_noise_list_index[max_spl_index_in_chunk]\n        \n            #extract the relevant noise frames + some delta\n            start_chunk = max(max_spl_chunk_index-CHUNK_DNUM, 0)\n            stop_chunk = max_spl_chunk_index+CHUNK_DNUM\n        \n            # Wait for minimum time CHUNK_DNUM before saveing to add delta to the wave. \n            while chunk_index_i < stop_chunk :\n                i = stop_chunk-chunk_index_i\n            \n            noise_frames = frames[start_chunk:stop_chunk]\n        \n            print(f\"Current chunk processed is : {chunk_index_i}\\n\")\n            print(f\"Events detected : {chunk_noise_list_index}\\n\")\n            print(f\"start_chunk is : {start_chunk}\\n\")\n            print(f\"stop_chunk is : {stop_chunk}\\n\")\n            \n            # Get the current local time\n            current_time = datetime.datetime.now()\n            # Round to the nearest second (remove microseconds)\n            rounded_time = current_time.replace(microsecond=0)\n        \n            # construct file name with relevant data\n            noise_file_name = f\"{OUTPUT_NOISE_FILENAME}_DataID{max_spl_chunk_index}_dBA{round(max_spl_in_chunk,2)}_Date{rounded_time}.wav\"\n            # make it compatible with windows filename rules\n            noise_file_name = noise_file_name.replace(' ', '_').replace(':', '-')\n            print(noise_file_name)\n\n            # Ensure the directory exists (optional, for better handling)\n            os.makedirs(OUTPUT_FILE_DIRECTORY, exist_ok=True)\n\n            # Combine directory and file name\n            full_path = os.path.join(OUTPUT_FILE_DIRECTORY, noise_file_name)\n            print(full_path)\n                        \n            # Write the recorded data to a WAV file\n\n            with wave.open(full_path, 'wb') as wf:\n                wf.setnchannels(CHANNELS)\n                wf.setsampwidth(p.get_sample_size(FORMAT))\n                wf.setframerate(RATE)\n                wf.writeframes(b''.join(noise_frames))\n                print(f\"Audio saved as {noise_file_name}\\n\")\n\n\n            #erase noise event arrays\n            chunk_noise_list_index = []\n            chunk_noise_list_spl = []\n            \n            max_spl_in_chunk = 0\n            max_spl_index_in_chunk = 0\n            max_spl_chunk_index = 0\n            start_chunk = 0\n            stop_chunk = 0\n            noise_frames = []\n        \n            #remove chunks from wave output which are already treated. To free local resources.\n            frames = frames[start_chunk:]\n            #frame.update_status.AppendText(f\"DataID_{max_spl_chunk_index}__dB_{max_spl_in_chunk}__Horaire:_{rounded_time}.wav\")\n            print()\n\n\n\ndef func_on_saveWave_exit_click():\n    global p\n    global frames\n    \n    \n    # Write the recorded data to a WAV file\n    with wave.open(OUTPUT_FILENAME, 'wb') as wf:\n        wf.setnchannels(CHANNELS)\n        wf.setsampwidth(p.get_sample_size(FORMAT))\n        wf.setframerate(RATE)\n        wf.writeframes(b''.join(frames))\n        print(f\"Audio saved as {OUTPUT_FILENAME}\")\n\n    # open the recorded data to a WAV file\n    with wave.open(OUTPUT_FILENAME, 'rb') as wav_file:\n        sample_rate = wav_file.getframerate()  # Sample rate (samples per second)\n        num_frames = wav_file.getnframes()\n        num_channels = wav_file.getnchannels()\n        sample_width = wav_file.getsampwidth()\n        num_frames = wav_file.getnframes()\n           \n        raw_data = wav_file.readframes(num_frames)\n \n    \n    # read audio data and apply weighting filter    \n    # Convert raw byte data into a numpy array\n    # For 16-bit audio (common for WAV), use np.int16\n    audio_data = np.frombuffer(raw_data, dtype=np.int16)\n    # A-weighted audio data\n    audio_data_weighted =   apply_a_weighting(audio_data )\n    # Create a time axis for plotting\n    time = np.linspace(0, num_frames / sample_rate, num_frames)\n   \n   \n   \n    # FFT  \n    # Perform FFT on the audio signal\n    fft_signal = np.fft.fft(audio_data)\n    # Perform FFT on the audio signal\n    fft_signal_weighted = np.fft.fft(audio_data_weighted)\n\n    # Compute the corresponding frequencies\n    frequencies = np.fft.fftfreq(len(fft_signal), d=1/RATE)\n    \n    # Get the magnitude of the FFT\n    fft_magnitude = np.abs(fft_signal)\n        # Get the magnitude of the FFT\n    fft_magnitude_weighted = np.abs(fft_signal_weighted)\n    \n    # We only want the positive frequencies\n    positive_frequencies = frequencies[:len(frequencies)//2]\n    positive_magnitude = fft_magnitude[:len(frequencies)//2]\n    positive_magnitude_weighted = fft_magnitude_weighted[:len(frequencies)//2]    \n \n    '''\n    # Plot the waveform\n    plt.figure(figsize=(10, 6))\n    plt.plot(time, audio_data, color='blue')\n    plt.title('Raw audio time domain')\n    plt.xlabel(\"Time [s]\")\n    plt.ylabel('PCM encoded audio [sint16]')\n    plt.grid(True)\n    plt.show()        \n    '''\n    \n    # plot frames in time domaine\n    # plot process frames in time domaine\n    # plot frames FFT\n    # plot process frames FFT\n    \n    # Create some data for plotting\n    x1 = time\n    y1 = audio_data\n\n    x2 = time\n    y2 = audio_data_weighted\n    \n    x3 = positive_frequencies\n    y3 = positive_magnitude\n    \n    x4 = positive_frequencies\n    y4 = positive_magnitude_weighted\n    \n    \n\n \n    ymin_t = MAX_INT16 = np.iinfo(np.int16).min\n    ymax_t = MAX_INT16 = np.iinfo(np.int16).max\n    \n    \n    xmin_f = 0\n    xmax_f = 16000\n    \n    ymin_f = 0\n    ymax_f = max(max(positive_magnitude_weighted),max(positive_magnitude))\n\n\n    \n    # Create a 2x2 grid of subplots (2 rows, 2 columns)\n    fig, axs = plt.subplots(2, 2, figsize=(10, 6))\n    \n    # First plot (top-left)\n    axs[0, 0].plot(x1, y1)\n    axs[0, 0].set_title('Raw audio time domain')\n    axs[0, 0].set_xlabel(\"Time [s]\")\n    axs[0, 0].set_ylabel('PCM encoded audio [sint16]')\n    axs[0, 0].set_ylim(ymin_t, ymax_t)\n    \n    # Third plot (bottom-left)\n    axs[1, 0].plot(x2, y2)\n    axs[1, 0].set_title('A-weighted audio time domain')\n    axs[1, 0].set_xlabel(\"Time [s]\")\n    axs[1, 0].set_ylabel('PCM encoded audio [sint16]')\n    axs[1, 0].set_ylim(ymin_t, ymax_t)\n    \n    # Second plot (top-right)\n    axs[0, 1].plot(x3, y3)\n    axs[0, 1].set_title('Raw audio frequency domain')\n    axs[0, 1].set_xlabel(\"Freq. [kHz]\")\n    axs[0, 1].set_ylabel('PCM encoded audio [sint16]')\n    axs[0, 1].set_xlim(xmin_f, xmax_f)\n    axs[0, 1].set_ylim(ymin_f, ymax_f)\n    \n    # Fourth plot (bottom-right) with a different x-axis range\n    axs[1, 1].plot(x4, y4)\n    axs[1, 1].set_title('A-weighted audio frequency domain')\n    axs[1, 1].set_xlabel(\"Freq. [kHz]\")\n    axs[1, 1].set_ylabel('PCM encoded audio [sint16]')\n    axs[1, 1].set_xlim(xmin_f, xmax_f)\n    axs[1, 1].set_ylim(ymin_f, ymax_f)\n    \n    # Adjust layout to prevent overlap\n    plt.tight_layout()\n    \n    # Show the plots\n    plt.show()\n    \n    \n    \n# GUI ############################################\"\n# Define the main application frame\nclass MyFrame(wx.Frame):\n    def __init__(self, parent, title):\n        super().__init__(parent, title=title, size=(350, 550))\n        \n        # Load settings from previous sessions\n        global config\n        global _device_index\n        global system_calibration_factor_94db\n        \n        print(f\"_device_index [default]:  {_device_index}\")\n        print(f\"system_calibration_factor_94db[default]:  {system_calibration_factor_94db}\")\n        \n        # Read Settings\n        config.read('config.ini')\n        \n        # Access values from the config\n        _device_index                   = config.getint('Settings', \"_device_index\")\n        system_calibration_factor_94db  = config.getfloat('Settings', \"system_calibration_factor_94db\") \n\n        # getint is used for integers\n        print(f\"_device_index[loaded from config file]:  {_device_index}\")\n        print(f\"system_calibration_factor_94db[loaded from config file]:  {system_calibration_factor_94db}\")\n\n        # Print the commit hash\n        print(\"Commit version:\", get_commit_version())\n        \n        # Create a panel inside the frame\n        panel = wx.Panel(self)\n   \n        # To store reference to the thread or process (optional choice)\n        self.recording_thread   = None\n        self.recording_process  = None\n        self.recording_queue    = None\n        \n        self.logging_thread     = None\n        self.logging_process    = None  \n        self.logging_queue      = None\n        \n        self.runCalib_thread    = None\n        self.runCalib_process   = None\n        self.runCalib_queue     = None\n                \n        self.checkCalib_thread  = None\n        self.checkCalib_process = None\n        self.checkCalib_queue   = None\n              \n        # Create a text box for user input\n        self.text_ctrl   = wx.TextCtrl(panel, value=str(_device_index), pos=(290, 40), size=(30, 25))\n\n        # Create a button on the panel\n        self.button_checkDevices = wx.Button(panel, label=\"CheckDevices\", pos=(200, 10))\n\n        # Create a button on the panel\n        self.button_setDevices = wx.Button(panel, label=\"SetDevices\", pos=(200, 42))\n\n        # Create a button on the panel\n        self.button_start = wx.Button(panel, label=\"Start Measurement!\", pos=(10, 10))\n\n        # Create a button on the panel\n        self.button_stop = wx.Button(panel, label=\"Stop Measurement!\", pos=(10, 40))\n        \n        # Create a button on the panel\n        self.button_runCalib = wx.Button(panel, label=\"Calibrate!\", pos=(10, 80))\n \n        # Create a button on the panel\n        self.button_checkCalib = wx.Button(panel, label=\"Check Calibration!\", pos=(10, 110))\n\n        # Create a button on the panel\n        self.button_saveWave = wx.Button(panel, label=\"Save and Plot Wave File [check signal]\", pos=(10, 140))\n  \n  \n        # Create text output field\n        self.status_text = wx.StaticText(panel, label=\"Status:\", pos=(10, 180), size=(300, 50))\n        \n        # Create text output field\n        self.dba_display = wx.StaticText(panel, label=\"dbA:\", pos=(10, 210), size=(33, 50))\n        # Set a larger font\n        font_large = wx.Font(18, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)\n        self.dba_display.SetFont(font_large)\n        \n        # Create a button on the panel\n        self.button_exit = wx.Button(panel, label=\"Close Application\", pos=(190, 400))\n \n\n        \n        ##################################################################\n        \n        \n        # Bind the button click event to an event handler function\n        self.button_checkDevices.Bind(wx.EVT_BUTTON, self.on_button_checkDevices_click)\n \n        # Bind the button click event to an event handler function\n        self.button_setDevices.Bind(wx.EVT_BUTTON, self.on_button_setDevices_click)\n        \n        # Bind the button click event to an event handler function\n        self.button_start.Bind(wx.EVT_BUTTON, self.on_button_start_click)\n        \n        # Bind the button click event to an event handler function\n        self.button_stop.Bind(wx.EVT_BUTTON, self.on_button_stop_click)\n        \n        # Bind the button click event to an event handler function\n        self.button_runCalib.Bind(wx.EVT_BUTTON, self.on_button_runCalib_click)\n \n        # Bind the button click event to an event handler function\n        self.button_checkCalib.Bind(wx.EVT_BUTTON, self.on_button_checkCalib_click)\n   \n        # Bind the button click event to an event handler function\n        self.button_exit.Bind(wx.EVT_BUTTON, self.on_button_exit_click)\n   \n        # Bind the button click event to an event handler function\n        self.button_saveWave.Bind(wx.EVT_BUTTON, self.on_button_saveWave_click)\n   \n    \n        # Show the window\n        self.Show()\n\n\n    def update_status(self, text):\n        # Safely append text to the TextCtrl\n        self.status_text.SetLabel(text)\n\n    def update_dba_display(self, text):\n        # Safely append text to the TextCtrl\n        self.dba_display.SetLabel(text)\n\n\n    def on_button_checkDevices_click(self, event):\n        \"\"\"Event handler function for the button click.\"\"\"\n        wx.MessageBox(\"Check Device List in console and set device number in the text box!!\", \"Info\", wx.OK | wx.ICON_INFORMATION)\n        # Call the check device function\n        func_check_devices()\n\n            \n    def on_button_setDevices_click(self, event):  \n        # Call function\n        func_on_button_setDevices_click(self)\n\n\n    def on_button_start_click(self, event):\n        # Call function\n        func_on_button_start_click(self)\n\n            \n    def on_button_stop_click(self, event):       \n        # Call function\n        func_on_button_stop_click(self)\n\n\n    def on_button_runCalib_click(self, event):\n        # Call function\n        func_on_button_runCalib_click(self)\n\n\n    def on_button_checkCalib_click(self, event):\n        # Call function\n        func_on_button_checkCalib_click(self)\n        \n\n    def on_button_exit_click(self, event):\n        # Call function\n        # need self arguments to know which class instance to close\n        func_on_button_exit_click(self)\n        \n        \n    def on_button_saveWave_click(self, event):\n        # Call function\n        # need self arguments to know which class instance to close\n        func_on_saveWave_exit_click()\n        \n    \n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        self.frame = MyFrame(None, title=\"Task Scheduler GUI\")      \n        return True\n\n# Main GUI application loop ###################################\nif __name__ == \"__main__\":\n    \n    # required to start new process under windows systems\n    multiprocessing.set_start_method(\"spawn\", force=True)  # optional but clear\n    \n    app = MyApp()\n\n    # Wrap the main event loop in a try-except block\n    try:\n\n        \n        app.MainLoop()\n        \n        \n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        # You can add additional cleanup or logging here if needed\n    \n    finally:\n        # Add settings to the config\n        # Add USB device index\n        # Add calibration value\n        config.set(\"Settings\",\"_device_index\", f\"{_device_index}\")\n        config.set(\"Settings\",\"system_calibration_factor_94db\", f\"{system_calibration_factor_94db}\") \n        print(f\"_device_index [saved]:  {_device_index}\")\n        print(f\"system_calibration_factor_94db[saved]:  {system_calibration_factor_94db}\")\n    \n        # Save the program state (configuration) to a file\n        with open('config.ini', 'w') as configfile:\n            config.write(configfile)\n        \n\n    \n        # Close the stream and terminate PyAudio\n        stream.stop_stream()\n        stream.close()\n    \n        # Close audio interface\n        p.terminate()\n        chunk_index_i = 0    # counter of processed chunks\n        chunk_noise_list_index = []\n        chunk_noise_list_spl = []\n        frames = []\n        is_recording = False\n        is_logging = False\n        audio_data                          = np.array([])\n        audio_data_pcm_abs                  = np.array([])\n        audio_data_mV                       = np.array([])\n        audio_data_mV_calib                 = np.array([])\n        audio_data_pressurePa               = np.array([])\n        audio_data_pressurePa_square        = np.array([])\n        audio_data_pressurePa_squareMean    = 0\n        audio_data_pressurePa_rms           = 0\n        audio_data_pressurePa_rms_calib     = 0\n        audio_data_pressurePa_spl           = 0\n        audio_data_max_pcm_value            = 0\n        \n        # Terminate running process, in case they are not closed already.\n        #if recording_process.is_alive() :\n        #    print(\"Timeout reached, terminating process...\")\n        #    app.recording.terminate()\n        #   app.recording.join()\n    \n        #if logging_process.is_alive() :\n        #   print(\"Timeout reached, terminating process...\")\n        #   app.logging.terminate()\n        #   app.logging.join()\n    \n        print(\"Application has finished.\")\n\n# visual thead debugging\n\n#tracer.stop()  # Stop VizTracer\n#tracer.save(\"Python_AudioLogger_JSON_LogFile.json\")  # Save trace data to a file\n\n##############################################################################", 1156], "C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py": ["import os\nimport sys\nimport threading\n\nfrom . import process\nfrom . import reduction\n\n__all__ = ()\n\n#\n# Exceptions\n#\n\nclass ProcessError(Exception):\n    pass\n\nclass BufferTooShort(ProcessError):\n    pass\n\nclass TimeoutError(ProcessError):\n    pass\n\nclass AuthenticationError(ProcessError):\n    pass\n\n#\n# Base type for contexts. Bound methods of an instance of this type are included in __all__ of __init__.py\n#\n\nclass BaseContext(object):\n\n    ProcessError = ProcessError\n    BufferTooShort = BufferTooShort\n    TimeoutError = TimeoutError\n    AuthenticationError = AuthenticationError\n\n    current_process = staticmethod(process.current_process)\n    parent_process = staticmethod(process.parent_process)\n    active_children = staticmethod(process.active_children)\n\n    def cpu_count(self):\n        '''Returns the number of CPUs in the system'''\n        num = os.cpu_count()\n        if num is None:\n            raise NotImplementedError('cannot determine number of cpus')\n        else:\n            return num\n\n    def Manager(self):\n        '''Returns a manager associated with a running server process\n\n        The managers methods such as `Lock()`, `Condition()` and `Queue()`\n        can be used to create shared objects.\n        '''\n        from .managers import SyncManager\n        m = SyncManager(ctx=self.get_context())\n        m.start()\n        return m\n\n    def Pipe(self, duplex=True):\n        '''Returns two connection object connected by a pipe'''\n        from .connection import Pipe\n        return Pipe(duplex)\n\n    def Lock(self):\n        '''Returns a non-recursive lock object'''\n        from .synchronize import Lock\n        return Lock(ctx=self.get_context())\n\n    def RLock(self):\n        '''Returns a recursive lock object'''\n        from .synchronize import RLock\n        return RLock(ctx=self.get_context())\n\n    def Condition(self, lock=None):\n        '''Returns a condition object'''\n        from .synchronize import Condition\n        return Condition(lock, ctx=self.get_context())\n\n    def Semaphore(self, value=1):\n        '''Returns a semaphore object'''\n        from .synchronize import Semaphore\n        return Semaphore(value, ctx=self.get_context())\n\n    def BoundedSemaphore(self, value=1):\n        '''Returns a bounded semaphore object'''\n        from .synchronize import BoundedSemaphore\n        return BoundedSemaphore(value, ctx=self.get_context())\n\n    def Event(self):\n        '''Returns an event object'''\n        from .synchronize import Event\n        return Event(ctx=self.get_context())\n\n    def Barrier(self, parties, action=None, timeout=None):\n        '''Returns a barrier object'''\n        from .synchronize import Barrier\n        return Barrier(parties, action, timeout, ctx=self.get_context())\n\n    def Queue(self, maxsize=0):\n        '''Returns a queue object'''\n        from .queues import Queue\n        return Queue(maxsize, ctx=self.get_context())\n\n    def JoinableQueue(self, maxsize=0):\n        '''Returns a queue object'''\n        from .queues import JoinableQueue\n        return JoinableQueue(maxsize, ctx=self.get_context())\n\n    def SimpleQueue(self):\n        '''Returns a queue object'''\n        from .queues import SimpleQueue\n        return SimpleQueue(ctx=self.get_context())\n\n    def Pool(self, processes=None, initializer=None, initargs=(),\n             maxtasksperchild=None):\n        '''Returns a process pool object'''\n        from .pool import Pool\n        return Pool(processes, initializer, initargs, maxtasksperchild,\n                    context=self.get_context())\n\n    def RawValue(self, typecode_or_type, *args):\n        '''Returns a shared object'''\n        from .sharedctypes import RawValue\n        return RawValue(typecode_or_type, *args)\n\n    def RawArray(self, typecode_or_type, size_or_initializer):\n        '''Returns a shared array'''\n        from .sharedctypes import RawArray\n        return RawArray(typecode_or_type, size_or_initializer)\n\n    def Value(self, typecode_or_type, *args, lock=True):\n        '''Returns a synchronized shared object'''\n        from .sharedctypes import Value\n        return Value(typecode_or_type, *args, lock=lock,\n                     ctx=self.get_context())\n\n    def Array(self, typecode_or_type, size_or_initializer, *, lock=True):\n        '''Returns a synchronized shared array'''\n        from .sharedctypes import Array\n        return Array(typecode_or_type, size_or_initializer, lock=lock,\n                     ctx=self.get_context())\n\n    def freeze_support(self):\n        '''Check whether this is a fake forked process in a frozen executable.\n        If so then run code specified by commandline and exit.\n        '''\n        if sys.platform == 'win32' and getattr(sys, 'frozen', False):\n            from .spawn import freeze_support\n            freeze_support()\n\n    def get_logger(self):\n        '''Return package logger -- if it does not already exist then\n        it is created.\n        '''\n        from .util import get_logger\n        return get_logger()\n\n    def log_to_stderr(self, level=None):\n        '''Turn on logging and add a handler which prints to stderr'''\n        from .util import log_to_stderr\n        return log_to_stderr(level)\n\n    def allow_connection_pickling(self):\n        '''Install support for sending connections and sockets\n        between processes\n        '''\n        # This is undocumented.  In previous versions of multiprocessing\n        # its only effect was to make socket objects inheritable on Windows.\n        from . import connection\n\n    def set_executable(self, executable):\n        '''Sets the path to a python.exe or pythonw.exe binary used to run\n        child processes instead of sys.executable when using the 'spawn'\n        start method.  Useful for people embedding Python.\n        '''\n        from .spawn import set_executable\n        set_executable(executable)\n\n    def set_forkserver_preload(self, module_names):\n        '''Set list of module names to try to load in forkserver process.\n        This is really just a hint.\n        '''\n        from .forkserver import set_forkserver_preload\n        set_forkserver_preload(module_names)\n\n    def get_context(self, method=None):\n        if method is None:\n            return self\n        try:\n            ctx = _concrete_contexts[method]\n        except KeyError:\n            raise ValueError('cannot find context for %r' % method) from None\n        ctx._check_available()\n        return ctx\n\n    def get_start_method(self, allow_none=False):\n        return self._name\n\n    def set_start_method(self, method, force=False):\n        raise ValueError('cannot set start method of concrete context')\n\n    @property\n    def reducer(self):\n        '''Controls how objects will be reduced to a form that can be\n        shared with other processes.'''\n        return globals().get('reduction')\n\n    @reducer.setter\n    def reducer(self, reduction):\n        globals()['reduction'] = reduction\n\n    def _check_available(self):\n        pass\n\n#\n# Type of default context -- underlying context can be set at most once\n#\n\nclass Process(process.BaseProcess):\n    _start_method = None\n    @staticmethod\n    def _Popen(process_obj):\n        return _default_context.get_context().Process._Popen(process_obj)\n\n    @staticmethod\n    def _after_fork():\n        return _default_context.get_context().Process._after_fork()\n\nclass DefaultContext(BaseContext):\n    Process = Process\n\n    def __init__(self, context):\n        self._default_context = context\n        self._actual_context = None\n\n    def get_context(self, method=None):\n        if method is None:\n            if self._actual_context is None:\n                self._actual_context = self._default_context\n            return self._actual_context\n        else:\n            return super().get_context(method)\n\n    def set_start_method(self, method, force=False):\n        if self._actual_context is not None and not force:\n            raise RuntimeError('context has already been set')\n        if method is None and force:\n            self._actual_context = None\n            return\n        self._actual_context = self.get_context(method)\n\n    def get_start_method(self, allow_none=False):\n        if self._actual_context is None:\n            if allow_none:\n                return None\n            self._actual_context = self._default_context\n        return self._actual_context._name\n\n    def get_all_start_methods(self):\n        \"\"\"Returns a list of the supported start methods, default first.\"\"\"\n        if sys.platform == 'win32':\n            return ['spawn']\n        else:\n            methods = ['spawn', 'fork'] if sys.platform == 'darwin' else ['fork', 'spawn']\n            if reduction.HAVE_SEND_HANDLE:\n                methods.append('forkserver')\n            return methods\n\n\n#\n# Context types for fixed start method\n#\n\nif sys.platform != 'win32':\n\n    class ForkProcess(process.BaseProcess):\n        _start_method = 'fork'\n        @staticmethod\n        def _Popen(process_obj):\n            from .popen_fork import Popen\n            return Popen(process_obj)\n\n    class SpawnProcess(process.BaseProcess):\n        _start_method = 'spawn'\n        @staticmethod\n        def _Popen(process_obj):\n            from .popen_spawn_posix import Popen\n            return Popen(process_obj)\n\n        @staticmethod\n        def _after_fork():\n            # process is spawned, nothing to do\n            pass\n\n    class ForkServerProcess(process.BaseProcess):\n        _start_method = 'forkserver'\n        @staticmethod\n        def _Popen(process_obj):\n            from .popen_forkserver import Popen\n            return Popen(process_obj)\n\n    class ForkContext(BaseContext):\n        _name = 'fork'\n        Process = ForkProcess\n\n    class SpawnContext(BaseContext):\n        _name = 'spawn'\n        Process = SpawnProcess\n\n    class ForkServerContext(BaseContext):\n        _name = 'forkserver'\n        Process = ForkServerProcess\n        def _check_available(self):\n            if not reduction.HAVE_SEND_HANDLE:\n                raise ValueError('forkserver start method not available')\n\n    _concrete_contexts = {\n        'fork': ForkContext(),\n        'spawn': SpawnContext(),\n        'forkserver': ForkServerContext(),\n    }\n    if sys.platform == 'darwin':\n        # bpo-33725: running arbitrary code after fork() is no longer reliable\n        # on macOS since macOS 10.14 (Mojave). Use spawn by default instead.\n        _default_context = DefaultContext(_concrete_contexts['spawn'])\n    else:\n        _default_context = DefaultContext(_concrete_contexts['fork'])\n\nelse:\n\n    class SpawnProcess(process.BaseProcess):\n        _start_method = 'spawn'\n        @staticmethod\n        def _Popen(process_obj):\n            from .popen_spawn_win32 import Popen\n            return Popen(process_obj)\n\n        @staticmethod\n        def _after_fork():\n            # process is spawned, nothing to do\n            pass\n\n    class SpawnContext(BaseContext):\n        _name = 'spawn'\n        Process = SpawnProcess\n\n    _concrete_contexts = {\n        'spawn': SpawnContext(),\n    }\n    _default_context = DefaultContext(_concrete_contexts['spawn'])\n\n#\n# Force the start method\n#\n\ndef _force_start_method(method):\n    _default_context._actual_context = _concrete_contexts[method]\n\n#\n# Check that the current thread is spawning a child process\n#\n\n_tls = threading.local()\n\ndef get_spawning_popen():\n    return getattr(_tls, 'spawning_popen', None)\n\ndef set_spawning_popen(popen):\n    _tls.spawning_popen = popen\n\ndef assert_spawning(obj):\n    if get_spawning_popen() is None:\n        raise RuntimeError(\n            '%s objects should only be shared between processes'\n            ' through inheritance' % type(obj).__name__\n            )\n", 377], "C:\\Programming\\Python313\\Lib\\signal.py": ["import _signal\nfrom _signal import *\nfrom enum import IntEnum as _IntEnum\n\n_globals = globals()\n\n_IntEnum._convert_(\n        'Signals', __name__,\n        lambda name:\n            name.isupper()\n            and (name.startswith('SIG') and not name.startswith('SIG_'))\n            or name.startswith('CTRL_'))\n\n_IntEnum._convert_(\n        'Handlers', __name__,\n        lambda name: name in ('SIG_DFL', 'SIG_IGN'))\n\nif 'pthread_sigmask' in _globals:\n    _IntEnum._convert_(\n            'Sigmasks', __name__,\n            lambda name: name in ('SIG_BLOCK', 'SIG_UNBLOCK', 'SIG_SETMASK'))\n\n\ndef _int_to_enum(value, enum_klass):\n    \"\"\"Convert a possible numeric value to an IntEnum member.\n    If it's not a known member, return the value itself.\n    \"\"\"\n    if not isinstance(value, int):\n        return value\n    try:\n        return enum_klass(value)\n    except ValueError:\n        return value\n\n\ndef _enum_to_int(value):\n    \"\"\"Convert an IntEnum member to a numeric value.\n    If it's not an IntEnum member return the value itself.\n    \"\"\"\n    try:\n        return int(value)\n    except (ValueError, TypeError):\n        return value\n\n\n# Similar to functools.wraps(), but only assign __doc__.\n# __module__ should be preserved,\n# __name__ and __qualname__ are already fine,\n# __annotations__ is not set.\ndef _wraps(wrapped):\n    def decorator(wrapper):\n        wrapper.__doc__ = wrapped.__doc__\n        return wrapper\n    return decorator\n\n@_wraps(_signal.signal)\ndef signal(signalnum, handler):\n    handler = _signal.signal(_enum_to_int(signalnum), _enum_to_int(handler))\n    return _int_to_enum(handler, Handlers)\n\n\n@_wraps(_signal.getsignal)\ndef getsignal(signalnum):\n    handler = _signal.getsignal(signalnum)\n    return _int_to_enum(handler, Handlers)\n\n\nif 'pthread_sigmask' in _globals:\n    @_wraps(_signal.pthread_sigmask)\n    def pthread_sigmask(how, mask):\n        sigs_set = _signal.pthread_sigmask(how, mask)\n        return set(_int_to_enum(x, Signals) for x in sigs_set)\n\n\nif 'sigpending' in _globals:\n    @_wraps(_signal.sigpending)\n    def sigpending():\n        return {_int_to_enum(x, Signals) for x in _signal.sigpending()}\n\n\nif 'sigwait' in _globals:\n    @_wraps(_signal.sigwait)\n    def sigwait(sigset):\n        retsig = _signal.sigwait(sigset)\n        return _int_to_enum(retsig, Signals)\n\n\nif 'valid_signals' in _globals:\n    @_wraps(_signal.valid_signals)\n    def valid_signals():\n        return {_int_to_enum(x, Signals) for x in _signal.valid_signals()}\n\n\ndel _globals, _wraps\n", 94], "C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py": ["# This file is generated by wxPython's SIP generator.  Do not edit by hand.\n#\n# Copyright: (c) 2020 by Total Control Software\n# License:   wxWindows License\n\n\"\"\"\nThe classes in this module are the most commonly used classes for wxPython,\nwhich is why they have been made visible in the core `wx` namespace.\nEverything you need for building typical GUI applications is here.\n\"\"\"\n\nfrom ._core import *\n\n#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n# This code block was included from src/core_ex.py\nimport sys as _sys\n\n# Load version numbers from __version__ and some other initialization tasks...\nif 'wxEVT_NULL' in dir():\n    from wx.__version__ import *\n    import wx._core\n    __version__ = VERSION_STRING\n\n    # Add the build type to PlatformInfo\n    PlatformInfo = PlatformInfo + ('build-type: ' + BUILD_TYPE, )\n\n    # Register a function to be called when Python terminates that will clean\n    # up and release all system resources that wxWidgets allocated.\n    import atexit\n    atexit.register(wx._core._wxPyCleanup)\n    del atexit\n\nelse:\n    Port = ''\n    Platform = ''\n    PlatformInfo = []\n\n# A little trick to make 'wx' be a reference to this module so wx.Names can\n# be used in the python code here.\nwx = _sys.modules[__name__]\n\n\nimport warnings\nclass wxPyDeprecationWarning(DeprecationWarning):\n    pass\n\nwarnings.simplefilter('default', wxPyDeprecationWarning)\ndel warnings\n\n\ndef deprecated(item, msg='', useName=False):\n    \"\"\"\n    Create a delegating wrapper that raises a deprecation warning.  Can be\n    used with callable objects (functions, methods, classes) or with\n    properties.\n    \"\"\"\n    import warnings\n\n    name = ''\n    if useName:\n        try:\n            name = ' ' + item.__name__\n        except AttributeError:\n            pass\n\n    if isinstance(item, type):\n        # It is a class.  Make a subclass that raises a warning.\n        class DeprecatedClassProxy(item):\n            def __init__(*args, **kw):\n                warnings.warn(\"Using deprecated class%s. %s\" % (name, msg),\n                          wxPyDeprecationWarning, stacklevel=2)\n                item.__init__(*args, **kw)\n        DeprecatedClassProxy.__name__ = item.__name__\n        return DeprecatedClassProxy\n\n    elif callable(item):\n        # wrap a new function around the callable\n        def deprecated_func(*args, **kw):\n            warnings.warn(\"Call to deprecated item%s. %s\" % (name, msg),\n                          wxPyDeprecationWarning, stacklevel=2)\n            if not kw:\n                return item(*args)\n            return item(*args, **kw)\n        deprecated_func.__name__ = item.__name__\n        deprecated_func.__doc__ = item.__doc__\n        if hasattr(item, '__dict__'):\n            deprecated_func.__dict__.update(item.__dict__)\n        return deprecated_func\n\n    elif hasattr(item, '__get__'):\n        # it should be a property if there is a getter\n        class DepGetProp(object):\n            def __init__(self, item, msg):\n                self.item = item\n                self.msg = msg\n            def __get__(self, inst, klass):\n                warnings.warn(\"Accessing deprecated property. %s\" % msg,\n                              wxPyDeprecationWarning, stacklevel=2)\n                return self.item.__get__(inst, klass)\n        class DepGetSetProp(DepGetProp):\n            def __set__(self, inst, val):\n                warnings.warn(\"Accessing deprecated property. %s\" % msg,\n                              wxPyDeprecationWarning, stacklevel=2)\n                return self.item.__set__(inst, val)\n        class DepGetSetDelProp(DepGetSetProp):\n            def __delete__(self, inst):\n                warnings.warn(\"Accessing deprecated property. %s\" % msg,\n                              wxPyDeprecationWarning, stacklevel=2)\n                return self.item.__delete__(inst)\n\n        if hasattr(item, '__set__') and hasattr(item, '__delete__'):\n            return DepGetSetDelProp(item, msg)\n        elif hasattr(item, '__set__'):\n            return DepGetSetProp(item, msg)\n        else:\n            return DepGetProp(item, msg)\n    else:\n        raise TypeError(\"unsupported type %s\" % type(item))\n\n\ndef deprecatedMsg(msg):\n    \"\"\"\n    A wrapper for the deprecated decorator that makes it easier to attach a\n    custom message to the warning that is raised if the item is used. This\n    can also be used in the @decorator role since it returns the real\n    decorator when called.\n    \"\"\"\n    import functools\n    return functools.partial(deprecated, msg=msg, useName=True)\n\n#----------------------------------------------------------------------------\n\nEmptyString = \"\"\n\n#----------------------------------------------------------------------------\n\n# End of included code block\n#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\nBG_STYLE_CUSTOM = BG_STYLE_PAINT\n\nADJUST_MINSIZE = 0\n\nWS_EX_VALIDATE_RECURSIVELY = 0\n\ndef _ClientDataContainer_GetClientObject(self):\n    \"\"\"\n    Alias for :meth:`GetClientData`\n    \"\"\"\n    return self.GetClientData()\nClientDataContainer.GetClientObject = _ClientDataContainer_GetClientObject\ndel _ClientDataContainer_GetClientObject\ndef _ClientDataContainer_SetClientObject(self, data):\n    \"\"\"\n    Alias for :meth:`SetClientData`\n    \"\"\"\n    self.SetClientData(data)\nClientDataContainer.SetClientObject = _ClientDataContainer_SetClientObject\ndel _ClientDataContainer_SetClientObject\nClientDataContainer.ClientData = property(ClientDataContainer.GetClientData, ClientDataContainer.SetClientData)\ndef _initStockObjects():\n    import wx\n    wx.NORMAL_FONT._copyFrom(       StockGDI.instance().GetFont(StockGDI.FONT_NORMAL))\n    wx.SMALL_FONT._copyFrom(        StockGDI.instance().GetFont(StockGDI.FONT_SMALL))\n    wx.SWISS_FONT._copyFrom(        StockGDI.instance().GetFont(StockGDI.FONT_SWISS))\n    wx.ITALIC_FONT._copyFrom(       StockGDI.instance().GetFont(StockGDI.FONT_ITALIC))\n\n    wx.BLACK_DASHED_PEN._copyFrom(  StockGDI.GetPen(StockGDI.PEN_BLACKDASHED))\n    wx.BLACK_PEN._copyFrom(         StockGDI.GetPen(StockGDI.PEN_BLACK))\n    wx.BLUE_PEN._copyFrom(          StockGDI.GetPen(StockGDI.PEN_BLUE))\n    wx.CYAN_PEN._copyFrom(          StockGDI.GetPen(StockGDI.PEN_CYAN))\n    wx.GREEN_PEN._copyFrom(         StockGDI.GetPen(StockGDI.PEN_GREEN))\n    wx.YELLOW_PEN._copyFrom(        StockGDI.GetPen(StockGDI.PEN_YELLOW))\n    wx.GREY_PEN._copyFrom(          StockGDI.GetPen(StockGDI.PEN_GREY))\n    wx.LIGHT_GREY_PEN._copyFrom(    StockGDI.GetPen(StockGDI.PEN_LIGHTGREY))\n    wx.MEDIUM_GREY_PEN._copyFrom(   StockGDI.GetPen(StockGDI.PEN_MEDIUMGREY))\n    wx.RED_PEN._copyFrom(           StockGDI.GetPen(StockGDI.PEN_RED))\n    wx.TRANSPARENT_PEN._copyFrom(   StockGDI.GetPen(StockGDI.PEN_TRANSPARENT))\n    wx.WHITE_PEN._copyFrom(         StockGDI.GetPen(StockGDI.PEN_WHITE))\n\n    wx.BLACK_BRUSH._copyFrom(       StockGDI.GetBrush(StockGDI.BRUSH_BLACK))\n    wx.BLUE_BRUSH._copyFrom(        StockGDI.GetBrush(StockGDI.BRUSH_BLUE))\n    wx.CYAN_BRUSH._copyFrom(        StockGDI.GetBrush(StockGDI.BRUSH_CYAN))\n    wx.GREEN_BRUSH._copyFrom(       StockGDI.GetBrush(StockGDI.BRUSH_GREEN))\n    wx.YELLOW_BRUSH._copyFrom(      StockGDI.GetBrush(StockGDI.BRUSH_YELLOW))\n    wx.GREY_BRUSH._copyFrom(        StockGDI.GetBrush(StockGDI.BRUSH_GREY))\n    wx.LIGHT_GREY_BRUSH._copyFrom(  StockGDI.GetBrush(StockGDI.BRUSH_LIGHTGREY))\n    wx.MEDIUM_GREY_BRUSH._copyFrom( StockGDI.GetBrush(StockGDI.BRUSH_MEDIUMGREY))\n    wx.RED_BRUSH._copyFrom(         StockGDI.GetBrush(StockGDI.BRUSH_RED))\n    wx.TRANSPARENT_BRUSH._copyFrom( StockGDI.GetBrush(StockGDI.BRUSH_TRANSPARENT))\n    wx.WHITE_BRUSH._copyFrom(       StockGDI.GetBrush(StockGDI.BRUSH_WHITE))\n\n    wx.BLACK._copyFrom(             StockGDI.GetColour(StockGDI.COLOUR_BLACK))\n    wx.BLUE._copyFrom(              StockGDI.GetColour(StockGDI.COLOUR_BLUE))\n    wx.CYAN._copyFrom(              StockGDI.GetColour(StockGDI.COLOUR_CYAN))\n    wx.GREEN._copyFrom(             StockGDI.GetColour(StockGDI.COLOUR_GREEN))\n    wx.YELLOW._copyFrom(            StockGDI.GetColour(StockGDI.COLOUR_YELLOW))\n    wx.LIGHT_GREY._copyFrom(        StockGDI.GetColour(StockGDI.COLOUR_LIGHTGREY))\n    wx.RED._copyFrom(               StockGDI.GetColour(StockGDI.COLOUR_RED))\n    wx.WHITE._copyFrom(             StockGDI.GetColour(StockGDI.COLOUR_WHITE))\n\n    wx.CROSS_CURSOR._copyFrom(      StockGDI.GetCursor(StockGDI.CURSOR_CROSS))\n    wx.HOURGLASS_CURSOR._copyFrom(  StockGDI.GetCursor(StockGDI.CURSOR_HOURGLASS))\n    wx.STANDARD_CURSOR._copyFrom(   StockGDI.GetCursor(StockGDI.CURSOR_STANDARD))\n\n    wx.TheFontList       = StockGDI._getTheFontList()\n    wx.ThePenList        = StockGDI._getThePenList()\n    wx.TheBrushList      = StockGDI._getTheBrushList()\n    wx.TheColourDatabase = StockGDI._getTheColourDatabase()\n\n\nStockGDI._initStockObjects = staticmethod(_initStockObjects)\ndef _DateTime___repr__(self):\n    from six import PY2\n    if self.IsValid():\n        f = self.Format()\n        if PY2: f = f.encode('utf-8')\n        return '<wx.DateTime: \"%s\">' % f\n    else:\n        return '<wx.DateTime: \"INVALID\">'\nDateTime.__repr__ = _DateTime___repr__\ndel _DateTime___repr__\ndef _DateTime___str__(self):\n    from six import PY2\n    if self.IsValid():\n        f = self.Format()\n        if PY2: f = f.encode('utf-8')\n        return f\n    else:\n        return \"INVALID DateTime\"\nDateTime.__str__ = _DateTime___str__\ndel _DateTime___str__\nInvalidDateTime = DefaultDateTime\n\n@wx.deprecatedMsg(\"Use :meth:`DateTime.FromTimeT` instead.\")\ndef DateTimeFromTimeT(timet):\n    \"\"\"\n    Compatibility wrapper for :meth:`DateTime.FromTimeT`\n    \"\"\"\n    return DateTime.FromTimeT(timet)\n\n@wx.deprecatedMsg(\"Use :meth:`DateTime.FromJDN` instead.\")\ndef DateTimeFromJDN(jdn):\n    \"\"\"\n    Compatibility wrapper for :meth:`DateTime.FromJDN`\n    \"\"\"\n    return DateTime.FromJDN(jdn)\n\n@wx.deprecatedMsg(\"Use :meth:`DateTime.FromHMS` instead.\")\ndef DateTimeFromHMS(hour, minute=0, second=0, millisecond=0):\n    \"\"\"\n    Compatibility wrapper for :meth:`DateTime.FromHMS`\n    \"\"\"\n    return DateTime.FromHMS(hour, minute, second, millisecond)\n\n@wx.deprecatedMsg(\"Use :meth:`DateTime.FromDMY` instead.\")\ndef DateTimeFromDMY(day, month, year=DateTime.Inv_Year, hour=0, minute=0, second=0, millisecond=0):\n    \"\"\"\n    Compatibility wrapper for :meth:`DateTime.FromDMY`\n    \"\"\"\n    return DateTime.FromDMY(day, month, year, hour, minute, second, millisecond)\n\ndef pydate2wxdate(date):\n    \"\"\"\n    Convert a Python date or datetime to a :class:`DateTime` object\n    \"\"\"\n    import datetime\n    assert isinstance(date, (datetime.datetime, datetime.date))\n    return DateTime(date)  # the built-in typemap will convert it for us\n\ndef wxdate2pydate(date):\n    \"\"\"\n    Convert a :class:`DateTime` object to a Python datetime.\n    \"\"\"\n    import datetime\n    assert isinstance(date, DateTime)\n    if date.IsValid():\n        return datetime.datetime(date.year, date.month+1, date.day,\n                                 date.hour, date.minute, date.second, date.millisecond*1000)\n    else:\n        return None\n\ndef _WindowIDRef___repr__(self):\n    return \"WindowIDRef: {}\".format(self.GetId())\nWindowIDRef.__repr__ = _WindowIDRef___repr__\ndel _WindowIDRef___repr__\ndef _WindowIDRef___hash__(self):\n    return hash(self.GetValue())\nWindowIDRef.__hash__ = _WindowIDRef___hash__\ndel _WindowIDRef___hash__\ndef NewIdRef(count=1):\n    \"\"\"\n    Reserves a new Window ID (or range of WindowIDs) and returns a\n    :class:`wx.WindowIDRef` object (or list of them) that will help\n    manage the reservation of that ID.\n    \n    This function is intended to be a drop-in replacement of the old\n    and deprecated :func:`wx.NewId` function, with the added benefit\n    that the ID should never conflict with an in-use ID or other IDs\n    generated by this function.\n    \"\"\"\n    if count == 1:\n        return WindowIDRef(IdManager.ReserveId())\n    else:\n        start = IdManager.ReserveId(count)\n        IDRefs = []\n        for id in range(start, start+count):\n            IDRefs.append(WindowIDRef(id))\n        return IDRefs\n\ndef _ArrayVideoModes___repr__(self):\n    return \"ArrayVideoModes: \" + repr(list(self))\nArrayVideoModes.__repr__ = _ArrayVideoModes___repr__\ndel _ArrayVideoModes___repr__\n#----------------------------------------------------------------------------\n# Add the directory where the wxWidgets catalogs were installed\n# to the default catalog path, if they were put in the package dir.\nimport os\n_localedir = os.path.join(os.path.dirname(__file__), \"locale\")\nif os.path.exists(_localedir):\n    if isinstance(_localedir, (bytes, bytearray)):\n        _localedir = _localedir.decode(_sys.getfilesystemencoding())\n    Locale.AddCatalogLookupPathPrefix(_localedir)\ndel os\n#----------------------------------------------------------------------------\n\ndef _Point_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.Point`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.Point``\n    with a simple statement like this: ``obj = wx.Point(imObj)``.\n    \"\"\"\n    return _im_Point(*self.Get())\nPoint.GetIM = _Point_GetIM\ndel _Point_GetIM\ndef _Point___str__(self):\n    return str(self.Get())\nPoint.__str__ = _Point___str__\ndel _Point___str__\ndef _Point___repr__(self):\n    return \"wx.Point\"+str(self.Get())\nPoint.__repr__ = _Point___repr__\ndel _Point___repr__\ndef _Point___len__(self):\n    return len(self.Get())\nPoint.__len__ = _Point___len__\ndel _Point___len__\ndef _Point___reduce__(self):\n    return (Point, self.Get())\nPoint.__reduce__ = _Point___reduce__\ndel _Point___reduce__\ndef _Point___getitem__(self, idx):\n    return self.Get()[idx]\nPoint.__getitem__ = _Point___getitem__\ndel _Point___getitem__\ndef _Point___setitem__(self, idx, val):\n    if idx == 0: self.x = val\n    elif idx == 1: self.y = val\n    else: raise IndexError\nPoint.__setitem__ = _Point___setitem__\ndel _Point___setitem__\nPoint.__safe_for_unpickling__ = True\n\nPoint.IM = property(Point.GetIM)\ndef _Size_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.Size`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.Size``\n    with a simple statement like this: ``obj = wx.Size(imObj)``.\n    \"\"\"\n    return _im_Size(*self.Get())\nSize.GetIM = _Size_GetIM\ndel _Size_GetIM\ndef _Size___str__(self):\n    return str(self.Get())\nSize.__str__ = _Size___str__\ndel _Size___str__\ndef _Size___repr__(self):\n    return \"wx.Size\"+str(self.Get())\nSize.__repr__ = _Size___repr__\ndel _Size___repr__\ndef _Size___len__(self):\n    return len(self.Get())\nSize.__len__ = _Size___len__\ndel _Size___len__\ndef _Size___nonzero__(self):\n    return self.Get() != (0,0)\nSize.__nonzero__ = _Size___nonzero__\ndel _Size___nonzero__\ndef _Size___bool__(self):\n    return self.Get() != (0,0)\nSize.__bool__ = _Size___bool__\ndel _Size___bool__\ndef _Size___reduce__(self):\n    return (Size, self.Get())\nSize.__reduce__ = _Size___reduce__\ndel _Size___reduce__\ndef _Size___getitem__(self, idx):\n    return self.Get()[idx]\nSize.__getitem__ = _Size___getitem__\ndel _Size___getitem__\ndef _Size___setitem__(self, idx, val):\n    if idx == 0: self.width = val\n    elif idx == 1: self.height = val\n    else: raise IndexError\nSize.__setitem__ = _Size___setitem__\ndel _Size___setitem__\nSize.__safe_for_unpickling__ = True\n\ndef _Rect_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.Rect`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.Rect``\n    with a simple statement like this: ``obj = wx.Rect(imObj)``.\n    \"\"\"\n    return _im_Rect(*self.Get())\nRect.GetIM = _Rect_GetIM\ndel _Rect_GetIM\ndef _Rect___str__(self):\n    return str(self.Get())\nRect.__str__ = _Rect___str__\ndel _Rect___str__\ndef _Rect___repr__(self):\n    return \"wx.Rect\"+str(self.Get())\nRect.__repr__ = _Rect___repr__\ndel _Rect___repr__\ndef _Rect___len__(self):\n    return len(self.Get())\nRect.__len__ = _Rect___len__\ndel _Rect___len__\ndef _Rect___nonzero__(self):\n    return self.Get() != (0,0,0,0)\nRect.__nonzero__ = _Rect___nonzero__\ndel _Rect___nonzero__\ndef _Rect___bool__(self):\n    return self.Get() != (0,0,0,0)\nRect.__bool__ = _Rect___bool__\ndel _Rect___bool__\ndef _Rect___reduce__(self):\n    return (Rect, self.Get())\nRect.__reduce__ = _Rect___reduce__\ndel _Rect___reduce__\ndef _Rect___getitem__(self, idx):\n    return self.Get()[idx]\nRect.__getitem__ = _Rect___getitem__\ndel _Rect___getitem__\ndef _Rect___setitem__(self, idx, val):\n    if idx == 0: self.x = val\n    elif idx == 1: self.y = val\n    elif idx == 2: self.width = val\n    elif idx == 3: self.height = val\n    else: raise IndexError\nRect.__setitem__ = _Rect___setitem__\ndel _Rect___setitem__\nRect.__safe_for_unpickling__ = True\n\ndef _RealPoint_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.RealPoint`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.RealPoint``\n    with a simple statement like this: ``obj = wx.RealPoint(imObj)``.\n    \"\"\"\n    return _im_RealPoint(*self.Get())\nRealPoint.GetIM = _RealPoint_GetIM\ndel _RealPoint_GetIM\ndef _RealPoint___str__(self):\n    return str(self.Get())\nRealPoint.__str__ = _RealPoint___str__\ndel _RealPoint___str__\ndef _RealPoint___repr__(self):\n    return \"wx.RealPoint\"+str(self.Get())\nRealPoint.__repr__ = _RealPoint___repr__\ndel _RealPoint___repr__\ndef _RealPoint___len__(self):\n    return len(self.Get())\nRealPoint.__len__ = _RealPoint___len__\ndel _RealPoint___len__\ndef _RealPoint___nonzero__(self):\n    return self.Get() != (0,0)\nRealPoint.__nonzero__ = _RealPoint___nonzero__\ndel _RealPoint___nonzero__\ndef _RealPoint___bool__(self):\n    return self.Get() != (0,0)\nRealPoint.__bool__ = _RealPoint___bool__\ndel _RealPoint___bool__\ndef _RealPoint___reduce__(self):\n    return (Rect, self.Get())\nRealPoint.__reduce__ = _RealPoint___reduce__\ndel _RealPoint___reduce__\ndef _RealPoint___getitem__(self, idx):\n    return self.Get()[idx]\nRealPoint.__getitem__ = _RealPoint___getitem__\ndel _RealPoint___getitem__\ndef _RealPoint___setitem__(self, idx, val):\n    if idx == 0: self.x = val\n    elif idx == 1: self.y = val\n    else: raise IndexError\nRealPoint.__setitem__ = _RealPoint___setitem__\ndel _RealPoint___setitem__\nRealPoint.__safe_for_unpickling__ = True\n\nRealPoint.IM = property(RealPoint.GetIM)\ndef _ColourDatabase_FindColour(self, colour):\n    return self.Find(colour)\nColourDatabase.FindColour = _ColourDatabase_FindColour\ndel _ColourDatabase_FindColour\nfrom collections import namedtuple\n_im_Point = namedtuple('_im_Point', ['x', 'y'])\ndel namedtuple\n\ndef _PointList___repr__(self):\n    return \"PointList: \" + repr(list(self))\nPointList.__repr__ = _PointList___repr__\ndel _PointList___repr__\nfrom collections import namedtuple\n_im_Size = namedtuple('_im_Size', ['width', 'height'])\ndel namedtuple\n\nfrom collections import namedtuple\n_im_Rect = namedtuple('_im_Rect', ['x', 'y', 'width', 'height'])\ndel namedtuple\n\nfrom collections import namedtuple\n_im_RealPoint = namedtuple('_im_RealPoint', ['x', 'y'])\ndel namedtuple\n\ndef _Point2D_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.Point2D`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.Point2D``\n    with a simple statement like this: ``obj = wx.Point2D(imObj)``.\n    \"\"\"\n    return _im_Point2D(*self.Get())\nPoint2D.GetIM = _Point2D_GetIM\ndel _Point2D_GetIM\ndef _Point2D___str__(self):\n    return str(self.Get())\nPoint2D.__str__ = _Point2D___str__\ndel _Point2D___str__\ndef _Point2D___repr__(self):\n    return \"wx.Point2D\"+str(self.Get())\nPoint2D.__repr__ = _Point2D___repr__\ndel _Point2D___repr__\ndef _Point2D___len__(self):\n    return len(self.Get())\nPoint2D.__len__ = _Point2D___len__\ndel _Point2D___len__\ndef _Point2D___nonzero__(self):\n    return self.Get() != (0,0)\nPoint2D.__nonzero__ = _Point2D___nonzero__\ndel _Point2D___nonzero__\ndef _Point2D___bool__(self):\n    return self.Get() != (0,0)\nPoint2D.__bool__ = _Point2D___bool__\ndel _Point2D___bool__\ndef _Point2D___reduce__(self):\n    return (Point2D, self.Get())\nPoint2D.__reduce__ = _Point2D___reduce__\ndel _Point2D___reduce__\ndef _Point2D___getitem__(self, idx):\n    return self.Get()[idx]\nPoint2D.__getitem__ = _Point2D___getitem__\ndel _Point2D___getitem__\ndef _Point2D___setitem__(self, idx, val):\n    if idx == 0: self.x = val\n    elif idx == 1: self.y = val\n    else: raise IndexError\nPoint2D.__setitem__ = _Point2D___setitem__\ndel _Point2D___setitem__\nPoint2D.__safe_for_unpickling__ = True\n\nPoint2D.IM = property(Point2D.GetIM)\ndef _Rect2D_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.Rect2D`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.Rect2D``\n    with a simple statement like this: ``obj = wx.Rect2D(imObj)``.\n    \"\"\"\n    return _im_Rect2D(*self.Get())\nRect2D.GetIM = _Rect2D_GetIM\ndel _Rect2D_GetIM\ndef _Rect2D___str__(self):\n    return str(self.Get())\nRect2D.__str__ = _Rect2D___str__\ndel _Rect2D___str__\ndef _Rect2D___repr__(self):\n    return \"wx.Rect2D\"+str(self.Get())\nRect2D.__repr__ = _Rect2D___repr__\ndel _Rect2D___repr__\ndef _Rect2D___len__(self):\n    return len(self.Get())\nRect2D.__len__ = _Rect2D___len__\ndel _Rect2D___len__\ndef _Rect2D___nonzero__(self):\n    return self.Get() != (0,0,0,0)\nRect2D.__nonzero__ = _Rect2D___nonzero__\ndel _Rect2D___nonzero__\ndef _Rect2D___bool__(self):\n    return self.Get() != (0,0,0,0)\nRect2D.__bool__ = _Rect2D___bool__\ndel _Rect2D___bool__\ndef _Rect2D___reduce__(self):\n    return (Rect2D, self.Get())\nRect2D.__reduce__ = _Rect2D___reduce__\ndel _Rect2D___reduce__\ndef _Rect2D___getitem__(self, idx):\n    return self.Get()[idx]\nRect2D.__getitem__ = _Rect2D___getitem__\ndel _Rect2D___getitem__\ndef _Rect2D___setitem__(self, idx, val):\n    if idx == 0: self.x = val\n    elif idx == 1: self.y = val\n    elif idx == 2: self.width = val\n    elif idx == 3: self.height = val\n    else: raise IndexError\nRect2D.__setitem__ = _Rect2D___setitem__\ndel _Rect2D___setitem__\nRect2D.__safe_for_unpickling__ = True\n\nRect2D.IM = property(Rect2D.GetIM)\nfrom collections import namedtuple\n_im_Point2D = namedtuple('_im_Point2D', ['x', 'y'])\ndel namedtuple\n\nfrom collections import namedtuple\n_im_Rect2D = namedtuple('_im_Rect2D', ['x', 'y', 'width', 'height'])\ndel namedtuple\n\ndef _Position_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.Position`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.Position``\n    with a simple statement like this: ``obj = wx.Position(imObj)``.\n    \"\"\"\n    return _im_Position(*self.Get())\nPosition.GetIM = _Position_GetIM\ndel _Position_GetIM\ndef _Position___str__(self):\n    return str(self.Get())\nPosition.__str__ = _Position___str__\ndel _Position___str__\ndef _Position___repr__(self):\n    return \"wx.Position\"+str(self.Get())\nPosition.__repr__ = _Position___repr__\ndel _Position___repr__\ndef _Position___len__(self):\n    return len(self.Get())\nPosition.__len__ = _Position___len__\ndel _Position___len__\ndef _Position___nonzero__(self):\n    return self.Get() != (0,0)\nPosition.__nonzero__ = _Position___nonzero__\ndel _Position___nonzero__\ndef _Position___bool__(self):\n    return self.Get() != (0,0)\nPosition.__bool__ = _Position___bool__\ndel _Position___bool__\ndef _Position___reduce__(self):\n    return (Position, self.Get())\nPosition.__reduce__ = _Position___reduce__\ndel _Position___reduce__\ndef _Position___getitem__(self, idx):\n    return self.Get()[idx]\nPosition.__getitem__ = _Position___getitem__\ndel _Position___getitem__\ndef _Position___setitem__(self, idx, val):\n    if idx == 0: self.Row = val\n    elif idx == 1: self.Col = val\n    else: raise IndexError\nPosition.__setitem__ = _Position___setitem__\ndel _Position___setitem__\nPosition.__safe_for_unpickling__ = True\n\nPosition.IM = property(Position.GetIM)\nfrom collections import namedtuple\n_im_Position = namedtuple('_im_Position', ['Row', 'Col'])\ndel namedtuple\n\ndef _Colour_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.Colour`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.Colour``\n    with a simple statement like this: ``obj = wx.Colour(imObj)``.\n    \"\"\"\n    return _im_Colour(*self.Get())\nColour.GetIM = _Colour_GetIM\ndel _Colour_GetIM\ndef _Colour___str__(self):\n    return str(self.Get())\nColour.__str__ = _Colour___str__\ndel _Colour___str__\ndef _Colour___repr__(self):\n    return \"wx.Colour\"+str(self.Get())\nColour.__repr__ = _Colour___repr__\ndel _Colour___repr__\ndef _Colour___len__(self):\n    return len(self.Get())\nColour.__len__ = _Colour___len__\ndel _Colour___len__\ndef _Colour___reduce__(self):\n    return (Colour, self.Get())\nColour.__reduce__ = _Colour___reduce__\ndel _Colour___reduce__\ndef _Colour___getitem__(self, idx):\n    return self.Get()[idx]\nColour.__getitem__ = _Colour___getitem__\ndel _Colour___getitem__\ndef _Colour___setitem__(self, idx, val):\n    if idx == 0:   self.red = val\n    elif idx == 1: self.green = val\n    elif idx == 2: self.blue = val\n    elif idx == 3: self.alpha = val\n    else: raise IndexError\nColour.__setitem__ = _Colour___setitem__\ndel _Colour___setitem__\nColour.__safe_for_unpickling__ = True\n\n# These stock colours will be initialized when the wx.App object is created.\nBLACK = Colour()\nBLUE = Colour()\nCYAN = Colour()\nGREEN = Colour()\nYELLOW = Colour()\nLIGHT_GREY = Colour()\nRED = Colour()\nWHITE = Colour()\n\nfrom collections import namedtuple\n_im_Colour = namedtuple('_im_Colour', ['red', 'green', 'blue', 'alpha'])\ndel namedtuple\n\nNamedColour = wx.deprecated(Colour, \"Use Colour instead.\")\n\nZipFSHandler = wx.deprecated(ArchiveFSHandler, \"Use ArchiveFSHandler instead.\")\n\ndef _Image_ConvertToBitmap(self, depth=-1):\n    \"\"\"\n    ConvertToBitmap(depth=-1) -> Bitmap\n    \n    Convert the image to a :class:`wx.Bitmap`.\n    \"\"\"\n    bmp = wx.Bitmap(self, depth)\n    return bmp\nImage.ConvertToBitmap = _Image_ConvertToBitmap\ndel _Image_ConvertToBitmap\ndef _Image_ConvertToMonoBitmap(self, red, green, blue):\n    \"\"\"\n    ConvertToMonoBitmap(red, green, blue) -> Bitmap\n    \n    Creates a monochrome version of the image and returns it as a :class:`wx.Bitmap`.\n    \"\"\"\n    mono = self.ConvertToMono( red, green, blue )\n    bmp = wx.Bitmap( mono, 1 )\n    return bmp\nImage.ConvertToMonoBitmap = _Image_ConvertToMonoBitmap\ndel _Image_ConvertToMonoBitmap\n@wx.deprecatedMsg(\"Use :class:`Image` instead.\")\ndef EmptyImage(width=0, height=0, clear=True):\n    \"\"\"\n    A compatibility wrapper for the wx.Image(width, height) constructor\n    \"\"\"\n    return Image(width, height, clear)\n\n@wx.deprecatedMsg(\"Use bitmap.ConvertToImage instead.\")\ndef ImageFromBitmap(bitmap):\n    \"\"\"\n    Create a :class:`Image` from a :class:`wx.Bitmap`\n    \"\"\"\n    return bitmap.ConvertToImage()\n\n@wx.deprecatedMsg(\"Use :class:`Image` instead.\")\ndef ImageFromStream(stream, type=BITMAP_TYPE_ANY, index=-1):\n    \"\"\"\n    Load an image from a stream (file-like object)\n    \"\"\"\n    return wx.Image(stream, type, index)\n\n@wx.deprecatedMsg(\"Use :class:`Image` instead.\")\ndef ImageFromData(width, height, data):\n    \"\"\"\n    Compatibility wrapper for creating an image from RGB data\n    \"\"\"\n    return Image(width, height, data)\n\n@wx.deprecatedMsg(\"Use :class:`Image` instead.\")\ndef ImageFromDataWithAlpha(width, height, data, alpha):\n    \"\"\"\n    Compatibility wrapper for creating an image from RGB and Alpha data\n    \"\"\"\n    return Image(width, height, data, alpha)\n\ndef ImageFromBuffer(width, height, dataBuffer, alphaBuffer=None):\n    \"\"\"\n    Creates a :class:`Image` from the data in `dataBuffer`.  The `dataBuffer`\n    parameter must be a Python object that implements the buffer interface,\n    such as a string, array, etc.  The `dataBuffer` object is expected to\n    contain a series of RGB bytes and be width*height*3 bytes long.  A buffer\n    object can optionally be supplied for the image's alpha channel data, and\n    it is expected to be width*height bytes long.\n    \n    The :class:`Image` will be created with its data and alpha pointers initialized\n    to the memory address pointed to by the buffer objects, thus saving the\n    time needed to copy the image data from the buffer object to the :class:`Image`.\n    While this has advantages, it also has the shoot-yourself-in-the-foot\n    risks associated with sharing a C pointer between two objects.\n    \n    To help alleviate the risk a reference to the data and alpha buffer\n    objects are kept with the :class:`Image`, so that they won't get deleted until\n    after the wx.Image is deleted.  However please be aware that it is not\n    guaranteed that an object won't move its memory buffer to a new location\n    when it needs to resize its contents.  If that happens then the :class:`Image`\n    will end up referring to an invalid memory location and could cause the\n    application to crash.  Therefore care should be taken to not manipulate\n    the objects used for the data and alpha buffers in a way that would cause\n    them to change size.\n    \"\"\"\n    img = Image(width, height)\n    img.SetDataBuffer(dataBuffer)\n    if alphaBuffer:\n        img.SetAlphaBuffer(alphaBuffer)\n    img._buffer = dataBuffer\n    img._alpha = alphaBuffer\n    return img\n\ndef _ImageArray___repr__(self):\n    return \"ImageArray: \" + repr(list(self))\nImageArray.__repr__ = _ImageArray___repr__\ndel _ImageArray___repr__\nIMAGE_OPTION_QUALITY = \"quality\"\nIMAGE_OPTION_FILENAME = \"FileName\"\nIMAGE_OPTION_RESOLUTION = \"Resolution\"\nIMAGE_OPTION_RESOLUTIONX = \"ResolutionX\"\nIMAGE_OPTION_RESOLUTIONY = \"ResolutionY\"\nIMAGE_OPTION_RESOLUTIONUNIT = \"ResolutionUnit\"\nIMAGE_OPTION_MAX_WIDTH = \"MaxWidth\"\nIMAGE_OPTION_MAX_HEIGHT = \"MaxHeight\"\nIMAGE_OPTION_ORIGINAL_WIDTH = \"OriginalWidth\"\nIMAGE_OPTION_ORIGINAL_HEIGHT = \"OriginalHeight\"\nIMAGE_OPTION_BMP_FORMAT = \"wxBMP_FORMAT\"\nIMAGE_OPTION_CUR_HOTSPOT_X = \"HotSpotX\"\nIMAGE_OPTION_CUR_HOTSPOT_Y = \"HotSpotY\"\nIMAGE_OPTION_GIF_COMMENT = \"GifComment\"\nIMAGE_OPTION_GIF_TRANSPARENCY = \"Transparency\"\nIMAGE_OPTION_GIF_TRANSPARENCY_HIGHLIGHT = \"Highlight\"\nIMAGE_OPTION_GIF_TRANSPARENCY_UNCHANGED = \"Unchanged\"\nIMAGE_OPTION_PNG_FORMAT = \"PngFormat\"\nIMAGE_OPTION_PNG_BITDEPTH = \"PngBitDepth\"\nIMAGE_OPTION_PNG_FILTER = \"PngF\"\nIMAGE_OPTION_PNG_COMPRESSION_LEVEL = \"PngZL\"\nIMAGE_OPTION_PNG_COMPRESSION_MEM_LEVEL = \"PngZM\"\nIMAGE_OPTION_PNG_COMPRESSION_STRATEGY = \"PngZS\"\nIMAGE_OPTION_PNG_COMPRESSION_BUFFER_SIZE = \"PngZB\"\nIMAGE_OPTION_TIFF_BITSPERSAMPLE = \"BitsPerSample\"\nIMAGE_OPTION_TIFF_SAMPLESPERPIXEL = \"SamplesPerPixel\"\nIMAGE_OPTION_TIFF_COMPRESSION = \"Compression\"\nIMAGE_OPTION_TIFF_PHOTOMETRIC = \"Photometric\"\nIMAGE_OPTION_TIFF_IMAGEDESCRIPTOR = \"ImageDescriptor\"\nIMAGE_OPTION_TIFF_BITSPERSAMPLE = \"BitsPerSample\"\nIMAGE_OPTION_TIFF_SAMPLESPERPIXEL = \"SamplesPerPixel\"\nIMAGE_OPTION_TIFF_COMPRESSION = \"Compression\"\nIMAGE_OPTION_TIFF_PHOTOMETRIC = \"Photometric\"\nIMAGE_OPTION_TIFF_IMAGEDESCRIPTOR = \"ImageDescriptor\"\nIMAGE_OPTION_GIF_COMMENT = \"GifComment\"\nIMAGE_OPTION_PNG_FORMAT = \"PngFormat\"\nIMAGE_OPTION_PNG_BITDEPTH = \"PngBitDepth\"\nIMAGE_OPTION_PNG_FILTER = \"PngF\"\nIMAGE_OPTION_PNG_COMPRESSION_LEVEL = \"PngZL\"\nIMAGE_OPTION_PNG_COMPRESSION_MEM_LEVEL = \"PngZM\"\nIMAGE_OPTION_PNG_COMPRESSION_STRATEGY = \"PngZS\"\nIMAGE_OPTION_PNG_COMPRESSION_BUFFER_SIZE = \"PngZB\"\n\n@wx.deprecatedMsg(\"Use :meth:`wx.Bitmap.FromBuffer` or :meth:`wx.Bitmap.FromBufferAndAlpha` instead.\")\ndef BitmapFromBuffer(width, height, dataBuffer, alphaBuffer=None):\n    \"\"\"\n    A compatibility wrapper for :meth:`wx.Bitmap.FromBuffer` and :meth:`wx.Bitmap.FromBufferAndAlpha`\n    \"\"\"\n    if alphaBuffer is not None:\n        return Bitmap.FromBufferAndAlpha(width, height, dataBuffer, alphaBuffer)\n    else:\n        return Bitmap.FromBuffer(width, height, dataBuffer)\n\n@wx.deprecatedMsg(\"Use :meth:`wx.Bitmap.FromBufferRGBA` instead.\")\ndef BitmapFromBufferRGBA(width, height, dataBuffer):\n    \"\"\"\n    A compatibility wrapper for :meth:`wx.Bitmap.FromBufferRGBA`\n    \"\"\"\n    return Bitmap.FromBufferRGBA(width, height, dataBuffer)\n\n@wx.deprecatedMsg(\"Use :meth:`wx.Bitmap.FromRGBA` instead.\")\ndef EmptyBitmapRGBA(width, height, red=0, green=0, blue=0, alpha=0):\n    \"\"\"\n    A compatibility wrapper for :meth:`wx.Bitmap.FromRGBA`\n    \"\"\"\n    return Bitmap.FromRGBA(width, height, red, green, blue, alpha)\n\n@wx.deprecatedMsg(\"Use :class:`wx.Bitmap` instead\")\ndef EmptyBitmap(width, height, depth=BITMAP_SCREEN_DEPTH):\n    \"\"\"\n    A compatibility wrapper for the wx.Bitmap(width, height, depth) constructor\n    \"\"\"\n    return Bitmap(width, height, depth)\n\n@wx.deprecatedMsg(\"Use :class:`wx.Bitmap` instead\")\ndef BitmapFromImage(image):\n    \"\"\"\n    A compatibility wrapper for the wx.Bitmap(wx.Image) constructor\n    \"\"\"\n    return Bitmap(image)\n\n@wx.deprecatedMsg(\"Use :class:`Icon` instead\")\ndef EmptyIcon():\n    \"\"\"\n    A compatibility wrapper for the :class:`Icon` constructor\n    \"\"\"\n    return Icon()\n\ndef _Font_SetNoAntiAliasing(self, no=True):\n    pass\nFont.SetNoAntiAliasing = wx.deprecated(_Font_SetNoAntiAliasing)\ndel _Font_SetNoAntiAliasing\ndef _Font_GetNoAntiAliasing(self):\n    pass\nFont.GetNoAntiAliasing = wx.deprecated(_Font_GetNoAntiAliasing)\ndel _Font_GetNoAntiAliasing\n# These stock fonts will be initialized when the wx.App object is created.\nNORMAL_FONT = Font()\nSMALL_FONT = Font()\nITALIC_FONT = Font()\nSWISS_FONT = Font()\n\nwx.DEFAULT    = int(wx.FONTFAMILY_DEFAULT)\nwx.DECORATIVE = int(wx.FONTFAMILY_DECORATIVE)\nwx.ROMAN      = int(wx.FONTFAMILY_ROMAN)\nwx.SCRIPT     = int(wx.FONTFAMILY_SCRIPT)\nwx.SWISS      = int(wx.FONTFAMILY_SWISS)\nwx.MODERN     = int(wx.FONTFAMILY_MODERN)\nwx.TELETYPE   = int(wx.FONTFAMILY_TELETYPE)\n\nwx.NORMAL = int(wx.FONTWEIGHT_NORMAL)\nwx.LIGHT  = int(wx.FONTWEIGHT_LIGHT)\nwx.BOLD   = int(wx.FONTWEIGHT_BOLD)\n\nwx.NORMAL = int(wx.FONTSTYLE_NORMAL)\nwx.ITALIC = int(wx.FONTSTYLE_ITALIC)\nwx.SLANT  = int(wx.FONTSTYLE_SLANT)\n\n# These stock pens will be initialized when the wx.App object is created.\nRED_PEN = Pen()\nBLUE_PEN = Pen()\nCYAN_PEN = Pen()\nGREEN_PEN = Pen()\nYELLOW_PEN = Pen()\nBLACK_PEN = Pen()\nWHITE_PEN = Pen()\nTRANSPARENT_PEN = Pen()\nBLACK_DASHED_PEN = Pen()\nGREY_PEN = Pen()\nMEDIUM_GREY_PEN = Pen()\nLIGHT_GREY_PEN = Pen()\n\nwx.SOLID       = int(wx.PENSTYLE_SOLID)\nwx.DOT         = int(wx.PENSTYLE_DOT)\nwx.LONG_DASH   = int(wx.PENSTYLE_LONG_DASH)\nwx.SHORT_DASH  = int(wx.PENSTYLE_SHORT_DASH)\nwx.DOT_DASH    = int(wx.PENSTYLE_DOT_DASH)\nwx.USER_DASH   = int(wx.PENSTYLE_USER_DASH)\nwx.TRANSPARENT = int(wx.PENSTYLE_TRANSPARENT)\n\n# These stock brushes will be initialized when the wx.App object is created.\nBLUE_BRUSH = Brush()\nGREEN_BRUSH = Brush()\nYELLOW_BRUSH = Brush()\nWHITE_BRUSH = Brush()\nBLACK_BRUSH = Brush()\nGREY_BRUSH = Brush()\nMEDIUM_GREY_BRUSH = Brush()\nLIGHT_GREY_BRUSH = Brush()\nTRANSPARENT_BRUSH = Brush()\nCYAN_BRUSH = Brush()\nRED_BRUSH = Brush()\n\nwx.STIPPLE_MASK_OPAQUE = int(wx.BRUSHSTYLE_STIPPLE_MASK_OPAQUE)\nwx.STIPPLE_MASK        = int(wx.BRUSHSTYLE_STIPPLE_MASK)\nwx.STIPPLE             = int(wx.BRUSHSTYLE_STIPPLE)\nwx.BDIAGONAL_HATCH     = int(wx.BRUSHSTYLE_BDIAGONAL_HATCH)\nwx.CROSSDIAG_HATCH     = int(wx.BRUSHSTYLE_CROSSDIAG_HATCH)\nwx.FDIAGONAL_HATCH     = int(wx.BRUSHSTYLE_FDIAGONAL_HATCH)\nwx.CROSS_HATCH         = int(wx.BRUSHSTYLE_CROSS_HATCH)\nwx.HORIZONTAL_HATCH    = int(wx.BRUSHSTYLE_HORIZONTAL_HATCH)\nwx.VERTICAL_HATCH      = int(wx.BRUSHSTYLE_VERTICAL_HATCH)\n\n# These stock cursors will be initialized when the wx.App object is created.\nSTANDARD_CURSOR = Cursor()\nHOURGLASS_CURSOR = Cursor()\nCROSS_CURSOR = Cursor()\n\nStockCursor = wx.deprecated(Cursor, \"Use Cursor instead.\")\n\nCursorFromImage = wx.deprecated(Cursor, \"Use Cursor instead.\")\n\ndef _Region___iter__(self):\n    \"\"\"\n    Returns a rectangle iterator conforming to the Python iterator\n    protocol.\n    \"\"\"\n    return PyRegionIterator(self)\nRegion.__iter__ = _Region___iter__\ndel _Region___iter__\nclass PyRegionIterator(object):\n    \"A Python iterator for wx.Region objects\"\n    def __init__(self, region):\n        self._region = region\n        self._iterator = wx.RegionIterator(region)\n    def next(self):\n        if not self._iterator:\n            raise StopIteration\n        rect = self._iterator.GetRect()\n        if self._iterator.HaveRects():\n            self._iterator.Next()\n        return rect\n    __next__ = next  # for Python 3\n\ndef _DC_GetClippingRect(self):\n    \"\"\"\n    Returns the rectangle surrounding the current clipping region as a wx.Rect.\n    \"\"\"\n    rv, x, y, w, h = self.GetClippingBox()\n    return wx.Rect(x,y,w,h)\nDC.GetClippingRect = _DC_GetClippingRect\ndel _DC_GetClippingRect\nDC.DrawImageLabel = wx.deprecated(DC.DrawLabel, \"Use DrawLabel instead.\")\n\ndef _DC_GetBoundingBox(self):\n    \"\"\"\n    GetBoundingBox() -> (x1,y1, x2,y2)\n    \n    Returns the min and max points used in drawing commands so far.\n    \"\"\"\n    return (self.MinX(), self.MinY(), self.MaxX(), self.MaxY())\nDC.GetBoundingBox = _DC_GetBoundingBox\ndel _DC_GetBoundingBox\nDC.GetHDC = wx.deprecated(DC.GetHDC, \"Use GetHandle instead.\")\n\nDC.GetCGContext = wx.deprecated(DC.GetCGContext, \"Use GetHandle instead.\")\n\nDC.GetGdkDrawable = wx.deprecated(DC.GetGdkDrawable, \"Use GetHandle instead.\")\n\ndef _DC___enter__(self):\n    return self\nDC.__enter__ = _DC___enter__\ndel _DC___enter__\ndef _DC___exit__(self, exc_type, exc_val, exc_tb):\n    self.Destroy()\nDC.__exit__ = _DC___exit__\ndel _DC___exit__\ndef _DC_DrawPointList(self, points, pens=None):\n    \"\"\"\n    Draw a list of points as quickly as possible.\n    \n    :param points: A sequence of 2-element sequences representing\n                   each point to draw, (x,y).\n    :param pens:   If None, then the current pen is used.  If a single\n                   pen then it will be used for all points.  If a list of\n                   pens then there should be one for each point in points.\n    \"\"\"\n    if pens is None:\n        pens = []\n    elif isinstance(pens, wx.Pen):\n        pens = [pens]\n    elif len(pens) != len(points):\n        raise ValueError('points and pens must have same length')\n    return self._DrawPointList(points, pens, [])\nDC.DrawPointList = _DC_DrawPointList\ndel _DC_DrawPointList\ndef _DC_DrawLineList(self, lines, pens=None):\n    \"\"\"\n    Draw a list of lines as quickly as possible.\n    \n    :param lines: A sequence of 4-element sequences representing\n                  each line to draw, (x1,y1, x2,y2).\n    :param pens:  If None, then the current pen is used.  If a\n                  single pen then it will be used for all lines.  If\n                  a list of pens then there should be one for each line\n                  in lines.\n    \"\"\"\n    if pens is None:\n        pens = []\n    elif isinstance(pens, wx.Pen):\n        pens = [pens]\n    elif len(pens) != len(lines):\n        raise ValueError('lines and pens must have same length')\n    return self._DrawLineList(lines, pens, [])\nDC.DrawLineList = _DC_DrawLineList\ndel _DC_DrawLineList\ndef _DC_DrawRectangleList(self, rectangles, pens=None, brushes=None):\n    \"\"\"\n    Draw a list of rectangles as quickly as possible.\n    \n    :param rectangles: A sequence of 4-element sequences representing\n                       each rectangle to draw, (x,y, w,h).\n    :param pens:       If None, then the current pen is used.  If a\n                       single pen then it will be used for all rectangles.\n                       If a list of pens then there should be one for each\n                       rectangle in rectangles.\n    :param brushes:    A brush or brushes to be used to fill the rectagles,\n                       with similar semantics as the pens parameter.\n    \"\"\"\n    if pens is None:\n        pens = []\n    elif isinstance(pens, wx.Pen):\n        pens = [pens]\n    elif len(pens) != len(rectangles):\n        raise ValueError('rectangles and pens must have same length')\n    if brushes is None:\n        brushes = []\n    elif isinstance(brushes, wx.Brush):\n        brushes = [brushes]\n    elif len(brushes) != len(rectangles):\n        raise ValueError('rectangles and brushes must have same length')\n    return self._DrawRectangleList(rectangles, pens, brushes)\nDC.DrawRectangleList = _DC_DrawRectangleList\ndel _DC_DrawRectangleList\ndef _DC_DrawEllipseList(self, ellipses, pens=None, brushes=None):\n    \"\"\"\n    Draw a list of ellipses as quickly as possible.\n    \n    :param ellipses: A sequence of 4-element sequences representing\n                     each ellipse to draw, (x,y, w,h).\n    :param pens:     If None, then the current pen is used.  If a\n                     single pen then it will be used for all ellipses.\n                     If a list of pens then there should be one for each\n                     ellipse in ellipses.\n    :param brushes:  A brush or brushes to be used to fill the ellipses,\n                     with similar semantics as the pens parameter.\n    \"\"\"\n    if pens is None:\n        pens = []\n    elif isinstance(pens, wx.Pen):\n        pens = [pens]\n    elif len(pens) != len(ellipses):\n        raise ValueError('ellipses and pens must have same length')\n    if brushes is None:\n        brushes = []\n    elif isinstance(brushes, wx.Brush):\n        brushes = [brushes]\n    elif len(brushes) != len(ellipses):\n        raise ValueError('ellipses and brushes must have same length')\n    return self._DrawEllipseList(ellipses, pens, brushes)\nDC.DrawEllipseList = _DC_DrawEllipseList\ndel _DC_DrawEllipseList\ndef _DC_DrawPolygonList(self, polygons, pens=None, brushes=None):\n    \"\"\"\n    Draw a list of polygons, each of which is a list of points.\n    \n    :param polygons: A sequence of sequences of sequences.\n                     [[(x1,y1),(x2,y2),(x3,y3)...], [(x1,y1),(x2,y2),(x3,y3)...]]\n    \n    :param pens:     If None, then the current pen is used.  If a\n                     single pen then it will be used for all polygons.\n                     If a list of pens then there should be one for each\n                     polygon.\n    :param brushes:  A brush or brushes to be used to fill the polygons,\n                     with similar semantics as the pens parameter.\n    \"\"\"\n    if pens is None:\n        pens = []\n    elif isinstance(pens, wx.Pen):\n        pens = [pens]\n    elif len(pens) != len(polygons):\n        raise ValueError('polygons and pens must have same length')\n    if brushes is None:\n        brushes = []\n    elif isinstance(brushes, wx.Brush):\n        brushes = [brushes]\n    elif len(brushes) != len(polygons):\n        raise ValueError('polygons and brushes must have same length')\n    return self._DrawPolygonList(polygons, pens, brushes)\nDC.DrawPolygonList = _DC_DrawPolygonList\ndel _DC_DrawPolygonList\ndef _DC_DrawTextList(self, textList, coords, foregrounds=None, backgrounds=None):\n    \"\"\"\n    Draw a list of strings using a list of coordinants for positioning each string.\n    \n    :param textList:    A list of strings\n    :param coords:      A list of (x,y) positions\n    :param foregrounds: A list of `wx.Colour` objects to use for the\n                        foregrounds of the strings.\n    :param backgrounds: A list of `wx.Colour` objects to use for the\n                        backgrounds of the strings.\n    \n    NOTE: Make sure you set background mode to wx.Solid (DC.SetBackgroundMode)\n          If you want backgrounds to do anything.\n    \"\"\"\n    if type(textList) == type(''):\n        textList = [textList]\n    elif len(textList) != len(coords):\n        raise ValueError('textlist and coords must have same length')\n    if foregrounds is None:\n        foregrounds = []\n    elif isinstance(foregrounds, wx.Colour):\n        foregrounds = [foregrounds]\n    elif len(foregrounds) != len(coords):\n        raise ValueError('foregrounds and coords must have same length')\n    if backgrounds is None:\n        backgrounds = []\n    elif isinstance(backgrounds, wx.Colour):\n        backgrounds = [backgrounds]\n    elif len(backgrounds) != len(coords):\n        raise ValueError('backgrounds and coords must have same length')\n    return  self._DrawTextList(textList, coords, foregrounds, backgrounds)\nDC.DrawTextList = _DC_DrawTextList\ndel _DC_DrawTextList\ndef _DC_DrawLinesFromBuffer(self, pyBuff):\n    \"\"\"\n    Implementation of DrawLines that can use numpy arrays, or anything else that uses the\n    python buffer protocol directly without any element conversion.  This provides a \n    significant performance increase over the standard DrawLines function.\n    \n    The pyBuff argument needs to provide an array of C integers organized as \n    x, y point pairs.  The size of a C integer is platform dependent.\n    With numpy, the intc data type will provide the appropriate element size.\n    \n    If called with an object that doesn't support\n    the python buffer protocol, or if the underlying element size does not\n    match the size of a C integer, a TypeError exception is raised.  If \n    the buffer provided has float data with the same element size as a \n    C integer, no error will be raised, but the lines will not be drawn\n    in the appropriate places.\n    \n    :param pyBuff:    A python buffer containing integer pairs\n    \"\"\"\n    return  self._DrawLinesFromBuffer(pyBuff)\nDC.DrawLinesFromBuffer = _DC_DrawLinesFromBuffer\ndel _DC_DrawLinesFromBuffer\nDC.BoundingBox = property(DC.GetBoundingBox)\nDC.ClippingRect = property(DC.GetClippingRect)\ndef _DCClipper___enter__(self):\n    return self\nDCClipper.__enter__ = _DCClipper___enter__\ndel _DCClipper___enter__\ndef _DCClipper___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nDCClipper.__exit__ = _DCClipper___exit__\ndel _DCClipper___exit__\ndef _DCBrushChanger___enter__(self):\n    return self\nDCBrushChanger.__enter__ = _DCBrushChanger___enter__\ndel _DCBrushChanger___enter__\ndef _DCBrushChanger___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nDCBrushChanger.__exit__ = _DCBrushChanger___exit__\ndel _DCBrushChanger___exit__\ndef _DCPenChanger___enter__(self):\n    return self\nDCPenChanger.__enter__ = _DCPenChanger___enter__\ndel _DCPenChanger___enter__\ndef _DCPenChanger___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nDCPenChanger.__exit__ = _DCPenChanger___exit__\ndel _DCPenChanger___exit__\ndef _DCTextColourChanger___enter__(self):\n    return self\nDCTextColourChanger.__enter__ = _DCTextColourChanger___enter__\ndel _DCTextColourChanger___enter__\ndef _DCTextColourChanger___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nDCTextColourChanger.__exit__ = _DCTextColourChanger___exit__\ndel _DCTextColourChanger___exit__\ndef _DCFontChanger___enter__(self):\n    return self\nDCFontChanger.__enter__ = _DCFontChanger___enter__\ndel _DCFontChanger___enter__\ndef _DCFontChanger___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nDCFontChanger.__exit__ = _DCFontChanger___exit__\ndel _DCFontChanger___exit__\ndef _DCTextBgColourChanger___enter__(self):\n    return self\nDCTextBgColourChanger.__enter__ = _DCTextBgColourChanger___enter__\ndel _DCTextBgColourChanger___enter__\ndef _DCTextBgColourChanger___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nDCTextBgColourChanger.__exit__ = _DCTextBgColourChanger___exit__\ndel _DCTextBgColourChanger___exit__\ndef _DCTextBgModeChanger___enter__(self):\n    return self\nDCTextBgModeChanger.__enter__ = _DCTextBgModeChanger___enter__\ndel _DCTextBgModeChanger___enter__\ndef _DCTextBgModeChanger___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nDCTextBgModeChanger.__exit__ = _DCTextBgModeChanger___exit__\ndel _DCTextBgModeChanger___exit__\nGraphicsContext.DrawRotatedText = wx.deprecated(GraphicsContext.DrawText, 'Use DrawText instead.')\n\ndef _ctx_hold_ref(f):\n    from functools import wraps\n    @wraps(f)\n    def wrapper(self, obj):\n        ctx = f(self, obj)\n        if ctx is not None:\n            ctx._obj = obj\n        return ctx\n    return wrapper\nGraphicsRenderer.CreateContext = _ctx_hold_ref(GraphicsRenderer.CreateContext)\nGraphicsRenderer.CreateContextFromImage = _ctx_hold_ref(GraphicsRenderer.CreateContextFromImage)\nGraphicsRenderer.CreateContextFromUnknownDC = _ctx_hold_ref(GraphicsRenderer.CreateContextFromUnknownDC)\n\ndef _GraphicsRenderer_GetType(self):\n    \"\"\"\n    Returns the name of the GraphicsRenderer class.\n    \"\"\"\n    return self.GetClassInfo().GetClassName()\nGraphicsRenderer.GetType = _GraphicsRenderer_GetType\ndel _GraphicsRenderer_GetType\nGraphicsRenderer.Type = property(GraphicsRenderer.GetType)\ndef _PixelDataBase___iter__(self):\n    \"\"\"\n    Create and return an iterator/generator object for traversing\n    this pixel data object.\n    \"\"\"\n    width  = self.GetWidth()\n    height = self.GetHeight()\n    pixels = self.GetPixels() # this is the C++ iterator\n    \n    # This class is a facade over the pixels object (using the one\n    # in the enclosing scope) that only allows Get() and Set() to\n    # be called.\n    class PixelFacade(object):\n        def Get(self):\n            return pixels.Get()\n        def Set(self, *args, **kw):\n            return pixels.Set(*args, **kw)\n        def __str__(self):\n            return str(self.Get())\n        def __repr__(self):\n            return 'pixel(%d,%d): %s' % (x,y,self.Get())\n        X = property(lambda self: x)\n        Y = property(lambda self: y)\n    \n    import sys\n    rangeFunc = range if sys.version_info >= (3,) else xrange\n    \n    pf = PixelFacade()\n    for y in rangeFunc(height):\n        pixels.MoveTo(self, 0, y)\n        for x in rangeFunc(width):\n            # We always generate the same pf instance, but it\n            # accesses the pixels object which we use to iterate\n            # over the pixel buffer.\n            yield pf\n            pixels.nextPixel()\nPixelDataBase.__iter__ = _PixelDataBase___iter__\ndel _PixelDataBase___iter__\n@wx.deprecated\ndef GetAccelFromString(label):\n    accel = wx.AcceleratorEntry()\n    accel.FromString(label)\n    return accel\n\ndef _LogNull___enter__(self):\n    return self\nLogNull.__enter__ = _LogNull___enter__\ndel _LogNull___enter__\ndef _LogNull___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nLogNull.__exit__ = _LogNull___exit__\ndel _LogNull___exit__\ndef CustomDataFormat(format):\n    return wx.DataFormat(format)\nCustomDataFormat = wx.deprecated(CustomDataFormat, \"Use wx.DataFormat instead.\")\n\nPyDataObjectSimple = wx.deprecated(DataObjectSimple), 'Use DataObjectSimple instead.'\n\nPyTextDataObject = wx.deprecated(TextDataObject, 'Use TextDataObject instead.')\n\nPyBitmapDataObject = wx.deprecated(BitmapDataObject, 'Use TextDataObject instead.')\n\nPyDropTarget = wx.deprecated(DropTarget, 'Use DropTarget instead.')\n\n# Since wxTheClipboard is not really a global variable (it is a macro\n# that calls the Get static method) we can't declare it as a global\n# variable for the wrapper generator, otherwise it will try to run the\n# function at module import and the wxApp object won't exist yet.  So\n# we'll use a class that will allow us to delay calling the Get until\n# wx.TheClipboard is actually being used for the first time.\nclass _wxPyDelayedInitWrapper(object):\n    def __init__(self, initfunc, *args, **kwargs):\n        self._initfunc = initfunc\n        self._args = args\n        self._kwargs = kwargs\n        self._instance = None\n    def _checkInstance(self):\n        if self._instance is None:\n            if wx.GetApp():\n                self._instance = self._initfunc(*self._args, **self._kwargs)\n    def __getattr__(self, name):\n        self._checkInstance()\n        return getattr(self._instance, name)\n    def __repr__(self):\n        self._checkInstance()\n        return repr(self._instance)\n\n    # context manager methods\n    def __enter__(self):\n        self._checkInstance()\n        if not self.Open():\n            raise RuntimeError('Unable to open clipboard.')\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.Close()\n\nTheClipboard = _wxPyDelayedInitWrapper(Clipboard.Get)\n\ndef _ConfigBase_ReadInt(self, key, defaultVal=0):\n    import six\n    rv = self._cpp_ReadInt(key, defaultVal)\n    if six.PY2:\n        rv = int(rv)\n    return rv\nConfigBase.ReadInt = _ConfigBase_ReadInt\ndel _ConfigBase_ReadInt\ndef _ConfigPathChanger___enter__(self):\n    return self\nConfigPathChanger.__enter__ = _ConfigPathChanger___enter__\ndel _ConfigPathChanger___enter__\ndef _ConfigPathChanger___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nConfigPathChanger.__exit__ = _ConfigPathChanger___exit__\ndel _ConfigPathChanger___exit__\n# For 2.8 compatibility\nKeyboardState.m_controlDown = wx.deprecated(KeyboardState.controlDown, \"Use controlDown instead.\")\nKeyboardState.m_shiftDown   = wx.deprecated(KeyboardState.shiftDown, \"Use shiftDown instead.\")\nKeyboardState.m_altDown     = wx.deprecated(KeyboardState.altDown, \"Use altDown instead.\")\nKeyboardState.m_metaDown    = wx.deprecated(KeyboardState.metaDown, \"Use metaDown instead.\")\n\ndef _EvtHandler_Bind(self, event, handler, source=None, id=wx.ID_ANY, id2=wx.ID_ANY):\n    \"\"\"\n    Bind an event to an event handler.\n    \n    :param event: One of the ``EVT_*`` event binder objects that\n                  specifies the type of event to bind.\n    \n    :param handler: A callable object to be invoked when the\n                    event is delivered to self.  Pass ``None`` to\n                    disconnect an event handler.\n    \n    :param source: Sometimes the event originates from a\n                   different window than self, but you still\n                   want to catch it in self.  (For example, a\n                   button event delivered to a frame.)  By\n                   passing the source of the event, the event\n                   handling system is able to differentiate\n                   between the same event type from different\n                   controls.\n    \n    :param id: Used to spcify the event source by ID instead\n               of instance.\n    \n    :param id2: Used when it is desirable to bind a handler\n                to a range of IDs, such as with EVT_MENU_RANGE.\n    \"\"\"\n    assert isinstance(event, wx.PyEventBinder)\n    assert callable(handler) or handler is None\n    assert source is None or hasattr(source, 'GetId')\n    if source is not None:\n        id  = source.GetId()\n    event.Bind(self, id, id2, handler)\nEvtHandler.Bind = _EvtHandler_Bind\ndel _EvtHandler_Bind\ndef _EvtHandler_Unbind(self, event, source=None, id=wx.ID_ANY, id2=wx.ID_ANY, handler=None):\n    \"\"\"\n    Disconnects the event handler binding for event from `self`.\n    Returns ``True`` if successful.\n    \"\"\"\n    if source is not None:\n        id  = source.GetId()\n    return event.Unbind(self, id, id2, handler)\nEvtHandler.Unbind = _EvtHandler_Unbind\ndel _EvtHandler_Unbind\ndef _EventBlocker___enter__(self):\n    return self\nEventBlocker.__enter__ = _EventBlocker___enter__\ndel _EventBlocker___enter__\ndef _EventBlocker___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nEventBlocker.__exit__ = _EventBlocker___exit__\ndel _EventBlocker___exit__\ndef _PropagationDisabler___enter__(self):\n    return self\nPropagationDisabler.__enter__ = _PropagationDisabler___enter__\ndel _PropagationDisabler___enter__\ndef _PropagationDisabler___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nPropagationDisabler.__exit__ = _PropagationDisabler___exit__\ndel _PropagationDisabler___exit__\ndef _PropagateOnce___enter__(self):\n    return self\nPropagateOnce.__enter__ = _PropagateOnce___enter__\ndel _PropagateOnce___enter__\ndef _PropagateOnce___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nPropagateOnce.__exit__ = _PropagateOnce___exit__\ndel _PropagateOnce___exit__\ndef _CommandEvent_GetClientObject(self):\n    \"\"\"\n    Alias for :meth:`GetClientData`\n    \"\"\"\n    return self.GetClientData()\nCommandEvent.GetClientObject = _CommandEvent_GetClientObject\ndel _CommandEvent_GetClientObject\ndef _CommandEvent_SetClientObject(self, data):\n    \"\"\"\n    Alias for :meth:`SetClientData`\n    \"\"\"\n    self.SetClientData(data)\nCommandEvent.SetClientObject = _CommandEvent_SetClientObject\ndel _CommandEvent_SetClientObject\nCommandEvent.ClientData = property(CommandEvent.GetClientData, CommandEvent.SetClientData)\nclass PyEventBinder(object):\n    \"\"\"\n    Instances of this class are used to bind specific events to event handlers.\n    \"\"\"\n    def __init__(self, evtType, expectedIDs=0):\n        if expectedIDs not in [0, 1, 2]:\n            raise ValueError(\"Invalid number of expectedIDs\")\n        self.expectedIDs = expectedIDs\n        \n        if isinstance(evtType, (list, tuple)):\n            self.evtType = list(evtType)\n        else:\n            self.evtType = [evtType]\n\n    def Bind(self, target, id1, id2, function):\n        \"\"\"\n        Bind this set of event types to target using its Connect() method.\n        \"\"\"\n        for et in self.evtType:\n            target.Connect(id1, id2, et, function)\n\n    def Unbind(self, target, id1, id2, handler=None):\n        \"\"\"\n        Remove an event binding.\n        \"\"\"\n        success = 0\n        for et in self.evtType:\n            success += int(target.Disconnect(id1, id2, et, handler))\n        return success != 0\n\n    def _getEvtType(self):\n        \"\"\"\n        Make it easy to get to the default wxEventType typeID for this\n        event binder.\n        \"\"\"\n        return self.evtType[0]\n\n    typeId = property(_getEvtType)\n    @wx.deprecatedMsg(\"Use :meth:`EvtHandler.Bind` instead.\")\n    def __call__(self, *args):\n        \"\"\"\n        For backwards compatibility with the old ``EVT_*`` functions.\n        Should be called with either (window, func), (window, ID,\n        func) or (window, ID1, ID2, func) parameters depending on the\n        type of the event.\n        \"\"\"\n        assert len(args) == 2 + self.expectedIDs\n        id1 = ID_ANY\n        id2 = ID_ANY\n        target = args[0]\n        if self.expectedIDs == 0:\n            func = args[1]\n        elif self.expectedIDs == 1:\n            id1 = args[1]\n            func = args[2]\n        elif self.expectedIDs == 2:\n            id1 = args[1]\n            id2 = args[2]\n            func = args[3]\n        else:\n            raise ValueError(\"Unexpected number of IDs\")\n        \n        self.Bind(target, id1, id2, func)\n\n\n#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n# This code block was included from src/event_ex.py\n# Create some event binders\nEVT_SIZE = wx.PyEventBinder( wxEVT_SIZE )\nEVT_SIZING = wx.PyEventBinder( wxEVT_SIZING )\nEVT_MOVE = wx.PyEventBinder( wxEVT_MOVE )\nEVT_MOVING = wx.PyEventBinder( wxEVT_MOVING )\nEVT_MOVE_START = wx.PyEventBinder( wxEVT_MOVE_START )\nEVT_MOVE_END = wx.PyEventBinder( wxEVT_MOVE_END )\nEVT_CLOSE = wx.PyEventBinder( wxEVT_CLOSE_WINDOW )\nEVT_END_SESSION = wx.PyEventBinder( wxEVT_END_SESSION )\nEVT_QUERY_END_SESSION = wx.PyEventBinder( wxEVT_QUERY_END_SESSION )\nEVT_PAINT = wx.PyEventBinder( wxEVT_PAINT )\nEVT_NC_PAINT = wx.PyEventBinder( wxEVT_NC_PAINT )\nEVT_ERASE_BACKGROUND = wx.PyEventBinder( wxEVT_ERASE_BACKGROUND )\nEVT_CHAR = wx.PyEventBinder( wxEVT_CHAR )\nEVT_KEY_DOWN = wx.PyEventBinder( wxEVT_KEY_DOWN )\nEVT_KEY_UP = wx.PyEventBinder( wxEVT_KEY_UP )\nEVT_HOTKEY = wx.PyEventBinder( wxEVT_HOTKEY, 1)\nEVT_CHAR_HOOK = wx.PyEventBinder( wxEVT_CHAR_HOOK )\nEVT_MENU_OPEN = wx.PyEventBinder( wxEVT_MENU_OPEN )\nEVT_MENU_CLOSE = wx.PyEventBinder( wxEVT_MENU_CLOSE )\nEVT_MENU_HIGHLIGHT = wx.PyEventBinder( wxEVT_MENU_HIGHLIGHT, 1)\nEVT_MENU_HIGHLIGHT_ALL = wx.PyEventBinder( wxEVT_MENU_HIGHLIGHT )\nEVT_SET_FOCUS = wx.PyEventBinder( wxEVT_SET_FOCUS )\nEVT_KILL_FOCUS = wx.PyEventBinder( wxEVT_KILL_FOCUS )\nEVT_CHILD_FOCUS = wx.PyEventBinder( wxEVT_CHILD_FOCUS )\nEVT_ACTIVATE = wx.PyEventBinder( wxEVT_ACTIVATE )\nEVT_ACTIVATE_APP = wx.PyEventBinder( wxEVT_ACTIVATE_APP )\nEVT_HIBERNATE = wx.PyEventBinder( wxEVT_HIBERNATE )\nEVT_DROP_FILES = wx.PyEventBinder( wxEVT_DROP_FILES )\nEVT_INIT_DIALOG = wx.PyEventBinder( wxEVT_INIT_DIALOG )\nEVT_SYS_COLOUR_CHANGED = wx.PyEventBinder( wxEVT_SYS_COLOUR_CHANGED )\nEVT_DISPLAY_CHANGED = wx.PyEventBinder( wxEVT_DISPLAY_CHANGED )\nEVT_DPI_CHANGED = wx.PyEventBinder( wxEVT_DPI_CHANGED )\nEVT_SHOW = wx.PyEventBinder( wxEVT_SHOW )\nEVT_MAXIMIZE = wx.PyEventBinder( wxEVT_MAXIMIZE )\nEVT_ICONIZE = wx.PyEventBinder( wxEVT_ICONIZE )\nEVT_NAVIGATION_KEY = wx.PyEventBinder( wxEVT_NAVIGATION_KEY )\nEVT_PALETTE_CHANGED = wx.PyEventBinder( wxEVT_PALETTE_CHANGED )\nEVT_QUERY_NEW_PALETTE = wx.PyEventBinder( wxEVT_QUERY_NEW_PALETTE )\nEVT_WINDOW_CREATE = wx.PyEventBinder( wxEVT_CREATE )\nEVT_WINDOW_DESTROY = wx.PyEventBinder( wxEVT_DESTROY )\nEVT_SET_CURSOR = wx.PyEventBinder( wxEVT_SET_CURSOR )\nEVT_MOUSE_CAPTURE_CHANGED = wx.PyEventBinder( wxEVT_MOUSE_CAPTURE_CHANGED )\nEVT_MOUSE_CAPTURE_LOST = wx.PyEventBinder( wxEVT_MOUSE_CAPTURE_LOST )\n\nEVT_LEFT_DOWN = wx.PyEventBinder( wxEVT_LEFT_DOWN )\nEVT_LEFT_UP = wx.PyEventBinder( wxEVT_LEFT_UP )\nEVT_MIDDLE_DOWN = wx.PyEventBinder( wxEVT_MIDDLE_DOWN )\nEVT_MIDDLE_UP = wx.PyEventBinder( wxEVT_MIDDLE_UP )\nEVT_RIGHT_DOWN = wx.PyEventBinder( wxEVT_RIGHT_DOWN )\nEVT_RIGHT_UP = wx.PyEventBinder( wxEVT_RIGHT_UP )\nEVT_MOTION = wx.PyEventBinder( wxEVT_MOTION )\nEVT_LEFT_DCLICK = wx.PyEventBinder( wxEVT_LEFT_DCLICK )\nEVT_MIDDLE_DCLICK = wx.PyEventBinder( wxEVT_MIDDLE_DCLICK )\nEVT_RIGHT_DCLICK = wx.PyEventBinder( wxEVT_RIGHT_DCLICK )\nEVT_LEAVE_WINDOW = wx.PyEventBinder( wxEVT_LEAVE_WINDOW )\nEVT_ENTER_WINDOW = wx.PyEventBinder( wxEVT_ENTER_WINDOW )\nEVT_MOUSEWHEEL = wx.PyEventBinder( wxEVT_MOUSEWHEEL )\nEVT_MOUSE_AUX1_DOWN = wx.PyEventBinder( wxEVT_AUX1_DOWN )\nEVT_MOUSE_AUX1_UP = wx.PyEventBinder( wxEVT_AUX1_UP )\nEVT_MOUSE_AUX1_DCLICK = wx.PyEventBinder( wxEVT_AUX1_DCLICK )\nEVT_MOUSE_AUX2_DOWN = wx.PyEventBinder( wxEVT_AUX2_DOWN )\nEVT_MOUSE_AUX2_UP = wx.PyEventBinder( wxEVT_AUX2_UP )\nEVT_MOUSE_AUX2_DCLICK = wx.PyEventBinder( wxEVT_AUX2_DCLICK )\n\nEVT_MOUSE_EVENTS = wx.PyEventBinder([ wxEVT_LEFT_DOWN,\n                                      wxEVT_LEFT_UP,\n                                      wxEVT_MIDDLE_DOWN,\n                                      wxEVT_MIDDLE_UP,\n                                      wxEVT_RIGHT_DOWN,\n                                      wxEVT_RIGHT_UP,\n                                      wxEVT_MOTION,\n                                      wxEVT_LEFT_DCLICK,\n                                      wxEVT_MIDDLE_DCLICK,\n                                      wxEVT_RIGHT_DCLICK,\n                                      wxEVT_ENTER_WINDOW,\n                                      wxEVT_LEAVE_WINDOW,\n                                      wxEVT_MOUSEWHEEL,\n                                      wxEVT_AUX1_DOWN,\n                                      wxEVT_AUX1_UP,\n                                      wxEVT_AUX1_DCLICK,\n                                      wxEVT_AUX2_DOWN,\n                                      wxEVT_AUX2_UP,\n                                      wxEVT_AUX2_DCLICK,\n                                     ])\nEVT_MAGNIFY = wx.PyEventBinder( wxEVT_MAGNIFY )\n\n\n# Scrolling from wxWindow (sent to wxScrolledWindow)\nEVT_SCROLLWIN = wx.PyEventBinder([ wxEVT_SCROLLWIN_TOP,\n                                  wxEVT_SCROLLWIN_BOTTOM,\n                                  wxEVT_SCROLLWIN_LINEUP,\n                                  wxEVT_SCROLLWIN_LINEDOWN,\n                                  wxEVT_SCROLLWIN_PAGEUP,\n                                  wxEVT_SCROLLWIN_PAGEDOWN,\n                                  wxEVT_SCROLLWIN_THUMBTRACK,\n                                  wxEVT_SCROLLWIN_THUMBRELEASE,\n                                  ])\n\nEVT_SCROLLWIN_TOP = wx.PyEventBinder( wxEVT_SCROLLWIN_TOP )\nEVT_SCROLLWIN_BOTTOM = wx.PyEventBinder( wxEVT_SCROLLWIN_BOTTOM )\nEVT_SCROLLWIN_LINEUP = wx.PyEventBinder( wxEVT_SCROLLWIN_LINEUP )\nEVT_SCROLLWIN_LINEDOWN = wx.PyEventBinder( wxEVT_SCROLLWIN_LINEDOWN )\nEVT_SCROLLWIN_PAGEUP = wx.PyEventBinder( wxEVT_SCROLLWIN_PAGEUP )\nEVT_SCROLLWIN_PAGEDOWN = wx.PyEventBinder( wxEVT_SCROLLWIN_PAGEDOWN )\nEVT_SCROLLWIN_THUMBTRACK = wx.PyEventBinder( wxEVT_SCROLLWIN_THUMBTRACK )\nEVT_SCROLLWIN_THUMBRELEASE = wx.PyEventBinder( wxEVT_SCROLLWIN_THUMBRELEASE )\n\n# Scrolling from wx.Slider and wx.ScrollBar\nEVT_SCROLL = wx.PyEventBinder([ wxEVT_SCROLL_TOP,\n                               wxEVT_SCROLL_BOTTOM,\n                               wxEVT_SCROLL_LINEUP,\n                               wxEVT_SCROLL_LINEDOWN,\n                               wxEVT_SCROLL_PAGEUP,\n                               wxEVT_SCROLL_PAGEDOWN,\n                               wxEVT_SCROLL_THUMBTRACK,\n                               wxEVT_SCROLL_THUMBRELEASE,\n                               wxEVT_SCROLL_CHANGED,\n                               ])\n\nEVT_SCROLL_TOP = wx.PyEventBinder( wxEVT_SCROLL_TOP )\nEVT_SCROLL_BOTTOM = wx.PyEventBinder( wxEVT_SCROLL_BOTTOM )\nEVT_SCROLL_LINEUP = wx.PyEventBinder( wxEVT_SCROLL_LINEUP )\nEVT_SCROLL_LINEDOWN = wx.PyEventBinder( wxEVT_SCROLL_LINEDOWN )\nEVT_SCROLL_PAGEUP = wx.PyEventBinder( wxEVT_SCROLL_PAGEUP )\nEVT_SCROLL_PAGEDOWN = wx.PyEventBinder( wxEVT_SCROLL_PAGEDOWN )\nEVT_SCROLL_THUMBTRACK = wx.PyEventBinder( wxEVT_SCROLL_THUMBTRACK )\nEVT_SCROLL_THUMBRELEASE = wx.PyEventBinder( wxEVT_SCROLL_THUMBRELEASE )\nEVT_SCROLL_CHANGED = wx.PyEventBinder( wxEVT_SCROLL_CHANGED )\nEVT_SCROLL_ENDSCROLL = EVT_SCROLL_CHANGED\n\n# Scrolling from wx.Slider and wx.ScrollBar, with an id\nEVT_COMMAND_SCROLL = wx.PyEventBinder([ wxEVT_SCROLL_TOP,\n                                       wxEVT_SCROLL_BOTTOM,\n                                       wxEVT_SCROLL_LINEUP,\n                                       wxEVT_SCROLL_LINEDOWN,\n                                       wxEVT_SCROLL_PAGEUP,\n                                       wxEVT_SCROLL_PAGEDOWN,\n                                       wxEVT_SCROLL_THUMBTRACK,\n                                       wxEVT_SCROLL_THUMBRELEASE,\n                                       wxEVT_SCROLL_CHANGED,\n                                       ], 1)\n\nEVT_COMMAND_SCROLL_TOP = wx.PyEventBinder( wxEVT_SCROLL_TOP, 1)\nEVT_COMMAND_SCROLL_BOTTOM = wx.PyEventBinder( wxEVT_SCROLL_BOTTOM, 1)\nEVT_COMMAND_SCROLL_LINEUP = wx.PyEventBinder( wxEVT_SCROLL_LINEUP, 1)\nEVT_COMMAND_SCROLL_LINEDOWN = wx.PyEventBinder( wxEVT_SCROLL_LINEDOWN, 1)\nEVT_COMMAND_SCROLL_PAGEUP = wx.PyEventBinder( wxEVT_SCROLL_PAGEUP, 1)\nEVT_COMMAND_SCROLL_PAGEDOWN = wx.PyEventBinder( wxEVT_SCROLL_PAGEDOWN, 1)\nEVT_COMMAND_SCROLL_THUMBTRACK = wx.PyEventBinder( wxEVT_SCROLL_THUMBTRACK, 1)\nEVT_COMMAND_SCROLL_THUMBRELEASE = wx.PyEventBinder( wxEVT_SCROLL_THUMBRELEASE, 1)\nEVT_COMMAND_SCROLL_CHANGED = wx.PyEventBinder( wxEVT_SCROLL_CHANGED, 1)\nEVT_COMMAND_SCROLL_ENDSCROLL = EVT_COMMAND_SCROLL_CHANGED\n\nEVT_BUTTON = wx.PyEventBinder( wxEVT_BUTTON, 1)\nEVT_CHECKBOX = wx.PyEventBinder( wxEVT_CHECKBOX, 1)\nEVT_CHOICE = wx.PyEventBinder( wxEVT_CHOICE, 1)\nEVT_LISTBOX = wx.PyEventBinder( wxEVT_LISTBOX, 1)\nEVT_LISTBOX_DCLICK = wx.PyEventBinder( wxEVT_LISTBOX_DCLICK, 1)\nEVT_MENU = wx.PyEventBinder( wxEVT_MENU, 1)\nEVT_MENU_RANGE = wx.PyEventBinder( wxEVT_MENU, 2)\nEVT_SLIDER = wx.PyEventBinder( wxEVT_SLIDER, 1)\nEVT_RADIOBOX = wx.PyEventBinder( wxEVT_RADIOBOX, 1)\nEVT_RADIOBUTTON = wx.PyEventBinder( wxEVT_RADIOBUTTON, 1)\n\nEVT_SCROLLBAR = wx.PyEventBinder( wxEVT_SCROLLBAR, 1)\nEVT_VLBOX = wx.PyEventBinder( wxEVT_VLBOX, 1)\nEVT_COMBOBOX = wx.PyEventBinder( wxEVT_COMBOBOX, 1)\nEVT_TOOL = wx.PyEventBinder( wxEVT_TOOL, 1)\nEVT_TOOL_RANGE = wx.PyEventBinder( wxEVT_TOOL, 2)\nEVT_TOOL_RCLICKED = wx.PyEventBinder( wxEVT_TOOL_RCLICKED, 1)\nEVT_TOOL_RCLICKED_RANGE = wx.PyEventBinder( wxEVT_TOOL_RCLICKED, 2)\nEVT_TOOL_ENTER = wx.PyEventBinder( wxEVT_TOOL_ENTER, 1)\nEVT_TOOL_DROPDOWN = wx.PyEventBinder( wxEVT_TOOL_DROPDOWN, 1)\nEVT_CHECKLISTBOX = wx.PyEventBinder( wxEVT_CHECKLISTBOX, 1)\nEVT_COMBOBOX_DROPDOWN = wx.PyEventBinder( wxEVT_COMBOBOX_DROPDOWN , 1)\nEVT_COMBOBOX_CLOSEUP  = wx.PyEventBinder( wxEVT_COMBOBOX_CLOSEUP , 1)\n\nEVT_COMMAND_LEFT_CLICK = wx.PyEventBinder( wxEVT_COMMAND_LEFT_CLICK, 1)\nEVT_COMMAND_LEFT_DCLICK = wx.PyEventBinder( wxEVT_COMMAND_LEFT_DCLICK, 1)\nEVT_COMMAND_RIGHT_CLICK = wx.PyEventBinder( wxEVT_COMMAND_RIGHT_CLICK, 1)\nEVT_COMMAND_RIGHT_DCLICK = wx.PyEventBinder( wxEVT_COMMAND_RIGHT_DCLICK, 1)\nEVT_COMMAND_SET_FOCUS = wx.PyEventBinder( wxEVT_COMMAND_SET_FOCUS, 1)\nEVT_COMMAND_KILL_FOCUS = wx.PyEventBinder( wxEVT_COMMAND_KILL_FOCUS, 1)\nEVT_COMMAND_ENTER = wx.PyEventBinder( wxEVT_COMMAND_ENTER, 1)\n\nEVT_HELP = wx.PyEventBinder( wxEVT_HELP, 1)\nEVT_HELP_RANGE = wx.PyEventBinder(  wxEVT_HELP, 2)\nEVT_DETAILED_HELP = wx.PyEventBinder( wxEVT_DETAILED_HELP, 1)\nEVT_DETAILED_HELP_RANGE = wx.PyEventBinder( wxEVT_DETAILED_HELP, 2)\n\nEVT_IDLE = wx.PyEventBinder( wxEVT_IDLE )\n\nEVT_UPDATE_UI = wx.PyEventBinder( wxEVT_UPDATE_UI, 1)\nEVT_UPDATE_UI_RANGE = wx.PyEventBinder( wxEVT_UPDATE_UI, 2)\n\nEVT_CONTEXT_MENU = wx.PyEventBinder( wxEVT_CONTEXT_MENU )\n\nEVT_THREAD = wx.PyEventBinder( wxEVT_THREAD )\n\nEVT_WINDOW_MODAL_DIALOG_CLOSED = wx.PyEventBinder( wxEVT_WINDOW_MODAL_DIALOG_CLOSED )\n\nEVT_JOY_BUTTON_DOWN = wx.PyEventBinder( wxEVT_JOY_BUTTON_DOWN )\nEVT_JOY_BUTTON_UP = wx.PyEventBinder( wxEVT_JOY_BUTTON_UP )\nEVT_JOY_MOVE = wx.PyEventBinder( wxEVT_JOY_MOVE )\nEVT_JOY_ZMOVE = wx.PyEventBinder( wxEVT_JOY_ZMOVE )\nEVT_JOYSTICK_EVENTS = wx.PyEventBinder([ wxEVT_JOY_BUTTON_DOWN,\n                                        wxEVT_JOY_BUTTON_UP,\n                                        wxEVT_JOY_MOVE,\n                                        wxEVT_JOY_ZMOVE,\n                                        ])\n\nEVT_GESTURE_PAN = wx.PyEventBinder( wxEVT_GESTURE_PAN )\nEVT_GESTURE_ZOOM = wx.PyEventBinder( wxEVT_GESTURE_ZOOM )\nEVT_GESTURE_ROTATE = wx.PyEventBinder( wxEVT_GESTURE_ROTATE )\nEVT_TWO_FINGER_TAP = wx.PyEventBinder( wxEVT_TWO_FINGER_TAP )\nEVT_LONG_PRESS = wx.PyEventBinder( wxEVT_LONG_PRESS )\nEVT_PRESS_AND_TAP = wx.PyEventBinder( wxEVT_PRESS_AND_TAP )\n\nEVT_CLIPBOARD_CHANGED = wx.PyEventBinder(wxEVT_CLIPBOARD_CHANGED, 1)\n\nEVT_FULLSCREEN = wx.PyEventBinder(wxEVT_FULLSCREEN, 1)\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_BUTTON_CLICKED         = wxEVT_BUTTON\nwxEVT_COMMAND_CHECKBOX_CLICKED       = wxEVT_CHECKBOX\nwxEVT_COMMAND_CHOICE_SELECTED        = wxEVT_CHOICE\nwxEVT_COMMAND_LISTBOX_SELECTED       = wxEVT_LISTBOX\nwxEVT_COMMAND_LISTBOX_DOUBLECLICKED  = wxEVT_LISTBOX_DCLICK\nwxEVT_COMMAND_CHECKLISTBOX_TOGGLED   = wxEVT_CHECKLISTBOX\nwxEVT_COMMAND_MENU_SELECTED          = wxEVT_MENU\nwxEVT_COMMAND_TOOL_CLICKED           = wxEVT_TOOL\nwxEVT_COMMAND_SLIDER_UPDATED         = wxEVT_SLIDER\nwxEVT_COMMAND_RADIOBOX_SELECTED      = wxEVT_RADIOBOX\nwxEVT_COMMAND_RADIOBUTTON_SELECTED   = wxEVT_RADIOBUTTON\nwxEVT_COMMAND_SCROLLBAR_UPDATED      = wxEVT_SCROLLBAR\nwxEVT_COMMAND_VLBOX_SELECTED         = wxEVT_VLBOX\nwxEVT_COMMAND_COMBOBOX_SELECTED      = wxEVT_COMBOBOX\nwxEVT_COMMAND_TOOL_RCLICKED          = wxEVT_TOOL_RCLICKED\nwxEVT_COMMAND_TOOL_DROPDOWN_CLICKED  = wxEVT_TOOL_DROPDOWN\nwxEVT_COMMAND_TOOL_ENTER             = wxEVT_TOOL_ENTER\nwxEVT_COMMAND_COMBOBOX_DROPDOWN      = wxEVT_COMBOBOX_DROPDOWN\nwxEVT_COMMAND_COMBOBOX_CLOSEUP       = wxEVT_COMBOBOX_CLOSEUP\n\n# End of included code block\n#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\nPyEvtHandler = wx.deprecated(EvtHandler, \"Use :class:`EvtHandler` instead.\")\n\ndef _PyEvent_Clone(self):\n    \"\"\"\n    Make a new instance of the event that is a copy of self.\n    \n    Through the magic of Python this implementation should work for\n    this and all derived classes.\n    \"\"\"\n    # Create a new instance of the same type as this instance and\n    # then invoke the C++ copy constructor to copy the C++ parts and\n    # any custom attributes.\n    clone = wx.PyEvent.__new__(self.__class__)\n    wx.PyEvent.__init__(clone, self)\n    return clone\nPyEvent.Clone = _PyEvent_Clone\ndel _PyEvent_Clone\ndef _PyCommandEvent_Clone(self):\n    \"\"\"\n    Make a new instance of the event that is a copy of self.\n    \n    Through the magic of Python this implementation should work for\n    this and all derived classes.\n    \"\"\"\n    # Create a new instance of the same type as this instance and\n    # then invoke the C++ copy constructor to copy the C++ parts and\n    # any custom attributes.\n    clone = wx.PyCommandEvent.__new__(self.__class__)\n    wx.PyCommandEvent.__init__(clone, self)\n    return clone\nPyCommandEvent.Clone = _PyCommandEvent_Clone\ndel _PyCommandEvent_Clone\ndef _Sizer_AddMany(self, items):\n    \"\"\"\n    :meth:`AddMany` is a convenience method for adding several items to a sizer\n    at one time. Simply pass it a list of tuples, where each tuple\n    consists of the parameters that you would normally pass to the :meth:`Add`\n    method.\n    \"\"\"\n    for item in items:\n        if not isinstance(item, (tuple, list)):\n            item = (item, )\n        self.Add(*item)\nSizer.AddMany = _Sizer_AddMany\ndel _Sizer_AddMany\ndef _Sizer___nonzero__(self):\n    \"\"\"\n    Can be used to test if the C++ part of the sizer still exists, with \n    code like this::\n    \n        if theSizer:\n            doSomething()\n    \"\"\"\n    import wx.siplib\n    return not wx.siplib.isdeleted(self)\nSizer.__nonzero__ = _Sizer___nonzero__\ndel _Sizer___nonzero__\ndef _Sizer___iter__(self):\n    \"\"\"\n    A Python convenience method that allows Sizers to act as iterables that will yield their wx.SizerItems.\n    \"\"\"\n    for item in self.GetChildren(): yield item\nSizer.__iter__ = _Sizer___iter__\ndel _Sizer___iter__\nSizer.__bool__ = Sizer.__nonzero__\n\ndef _GridSizer_CalcRowsCols(self):\n    \"\"\"\n    CalcRowsCols() -> (rows, cols)\n    \n    Calculates how many rows and columns will be in the sizer based\n    on the current number of items and also the rows, cols specified\n    in the constructor.\n    \"\"\"\n    nitems = len(self.GetChildren())\n    rows = self.GetRows()\n    cols = self.GetCols()\n    assert rows != 0 or cols != 0, \"Grid sizer must have either rows or columns fixed\"\n    if cols != 0:\n        rows = (nitems + cols - 1) / cols\n    elif rows != 0:\n        cols = (nitems + rows - 1) / rows\n    return (rows, cols)\nGridSizer.CalcRowsCols = _GridSizer_CalcRowsCols\ndel _GridSizer_CalcRowsCols\nPySizer = wx.deprecated(Sizer, 'Use Sizer instead.')\n\ndef _SizerItemList___repr__(self):\n    return \"SizerItemList: \" + repr(list(self))\nSizerItemList.__repr__ = _SizerItemList___repr__\ndel _SizerItemList___repr__\ndef _GBPosition_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.GBPosition`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.GBPosition``\n    with a simple statement like this: ``obj = wx.GBPosition(imObj)``.\n    \"\"\"\n    return _im_GBPosition(*self.Get())\nGBPosition.GetIM = _GBPosition_GetIM\ndel _GBPosition_GetIM\ndef _GBPosition___str__(self):\n    return str(self.Get())\nGBPosition.__str__ = _GBPosition___str__\ndel _GBPosition___str__\ndef _GBPosition___repr__(self):\n    return \"wx.GBPosition\"+str(self.Get())\nGBPosition.__repr__ = _GBPosition___repr__\ndel _GBPosition___repr__\ndef _GBPosition___len__(self):\n    return len(self.Get())\nGBPosition.__len__ = _GBPosition___len__\ndel _GBPosition___len__\ndef _GBPosition___nonzero__(self):\n    return self.Get() != (0,0)\nGBPosition.__nonzero__ = _GBPosition___nonzero__\ndel _GBPosition___nonzero__\ndef _GBPosition___bool__(self):\n    return self.Get() != (0,0)\nGBPosition.__bool__ = _GBPosition___bool__\ndel _GBPosition___bool__\ndef _GBPosition___reduce__(self):\n    return (GBPosition, self.Get())\nGBPosition.__reduce__ = _GBPosition___reduce__\ndel _GBPosition___reduce__\ndef _GBPosition___getitem__(self, idx):\n    return self.Get()[idx]\nGBPosition.__getitem__ = _GBPosition___getitem__\ndel _GBPosition___getitem__\ndef _GBPosition___setitem__(self, idx, val):\n    if idx == 0: self.Row = val\n    elif idx == 1: self.Col = val\n    else: raise IndexError\nGBPosition.__setitem__ = _GBPosition___setitem__\ndel _GBPosition___setitem__\nGBPosition.__safe_for_unpickling__ = True\n\ndef _GBSpan_GetIM(self):\n    \"\"\"\n    Returns an immutable representation of the ``wx.GBSpan`` object, based on ``namedtuple``.\n    \n    This new object is hashable and can be used as a dictionary key,\n    be added to sets, etc.  It can be converted back into a real ``wx.GBSpan``\n    with a simple statement like this: ``obj = wx.GBSpan(imObj)``.\n    \"\"\"\n    return _im_GBSpan(*self.Get())\nGBSpan.GetIM = _GBSpan_GetIM\ndel _GBSpan_GetIM\ndef _GBSpan___str__(self):\n    return str(self.Get())\nGBSpan.__str__ = _GBSpan___str__\ndel _GBSpan___str__\ndef _GBSpan___repr__(self):\n    return \"wx.GBSpan\"+str(self.Get())\nGBSpan.__repr__ = _GBSpan___repr__\ndel _GBSpan___repr__\ndef _GBSpan___len__(self):\n    return len(self.Get())\nGBSpan.__len__ = _GBSpan___len__\ndel _GBSpan___len__\ndef _GBSpan___nonzero__(self):\n    return self.Get() != (0,0)\nGBSpan.__nonzero__ = _GBSpan___nonzero__\ndel _GBSpan___nonzero__\ndef _GBSpan___bool__(self):\n    return self.Get() != (0,0)\nGBSpan.__bool__ = _GBSpan___bool__\ndel _GBSpan___bool__\ndef _GBSpan___reduce__(self):\n    return (GBSpan, self.Get())\nGBSpan.__reduce__ = _GBSpan___reduce__\ndel _GBSpan___reduce__\ndef _GBSpan___getitem__(self, idx):\n    return self.Get()[idx]\nGBSpan.__getitem__ = _GBSpan___getitem__\ndel _GBSpan___getitem__\ndef _GBSpan___setitem__(self, idx, val):\n    if idx == 0: self.Rowspan = val\n    elif idx == 1: self.Colspan = val\n    else: raise IndexError\nGBSpan.__setitem__ = _GBSpan___setitem__\ndel _GBSpan___setitem__\nGBSpan.__safe_for_unpickling__ = True\n\nGridBagSizer.CheckForIntersectionPos = wx.deprecated(GridBagSizer.CheckForIntersection, 'Use CheckForIntersection instead.')\n\nfrom collections import namedtuple\n_im_GBPosition = namedtuple('_im_GBPosition', ['row', 'col'])\ndel namedtuple\n\nfrom collections import namedtuple\n_im_GBSpan = namedtuple('_im_GBSpan', ['rowspan', 'colspan'])\ndel namedtuple\n\ndef _EventLoopActivator___enter__(self):\n    return self\nEventLoopActivator.__enter__ = _EventLoopActivator___enter__\ndel _EventLoopActivator___enter__\ndef _EventLoopActivator___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nEventLoopActivator.__exit__ = _EventLoopActivator___exit__\ndel _EventLoopActivator___exit__\n@wx.deprecatedMsg('Use GUIEventLoop instead.')\nclass EventLoop(GUIEventLoop):\n    '''A class using the old name for compatibility.'''\n    def __init__(self):\n        GUIEventLoop.__init__(self)\n\ndef YieldIfNeeded():\n    \"\"\"\n    Convenience function for wx.GetApp().Yield(True)\n    \"\"\"\n    return wx.GetApp().Yield(True)\n\nclass PyOnDemandOutputWindow(object):\n    \"\"\"\n    A class that can be used for redirecting Python's stdout and\n    stderr streams.  It will do nothing until something is wrriten to\n    the stream at which point it will create a Frame with a text area\n    and write the text there.\n    \"\"\"\n    def __init__(self, title=\"wxPython: stdout/stderr\"):\n        self.frame  = None\n        self.title  = title\n        self.pos    = wx.DefaultPosition\n        self.size   = (450, 300)\n        self.parent = None\n\n    def SetParent(self, parent):\n        \"\"\"\n        Set the window to be used as the popup Frame's parent.\n        \"\"\"\n        self.parent = parent\n\n    def CreateOutputWindow(self, txt):\n        self.frame = wx.Frame(self.parent, -1, self.title, self.pos, self.size,\n                              style=wx.DEFAULT_FRAME_STYLE)\n        self.text  = wx.TextCtrl(self.frame, -1, \"\",\n                                 style=wx.TE_MULTILINE|wx.TE_READONLY)\n        self.text.AppendText(txt)\n        self.frame.Show(True)\n        self.frame.Bind(wx.EVT_CLOSE, self.OnCloseWindow)\n\n    def OnCloseWindow(self, event):\n        if self.frame is not None:\n            self.frame.Destroy()\n        self.frame = None\n        self.text  = None\n        self.parent = None\n\n    def write(self, text):\n        \"\"\"\n        Create the output window if needed and write the string to it.\n        If not called in the context of the gui thread then CallAfter is\n        used to do the work there.\n        \"\"\"\n        if self.frame is None:\n            if not wx.IsMainThread():\n                wx.CallAfter(self.CreateOutputWindow, text)\n            else:\n                self.CreateOutputWindow(text)\n        else:\n            if not wx.IsMainThread():\n                wx.CallAfter(self.text.AppendText, text)\n            else:\n                self.text.AppendText(text)\n\n    def close(self):\n        if self.frame is not None:\n            wx.CallAfter(self.frame.Close)\n\n    def flush(self):\n        pass\n\n\nclass App(PyApp):\n    \"\"\"\n    The ``wx.App`` class represents the application and is used to:\n    \n      * bootstrap the wxPython system and initialize the underlying\n        gui toolkit\n      * set and get application-wide properties\n      * implement the native windowing system main message or event loop,\n        and to dispatch events to window instances\n      * etc.\n    \n    Every wx application must have a single ``wx.App`` instance, and all\n    creation of UI objects should be delayed until after the ``wx.App`` object\n    has been created in order to ensure that the gui platform and wxWidgets\n    have been fully initialized.\n    \n    Normally you would derive from this class and implement an ``OnInit``\n    method that creates a frame and then calls ``self.SetTopWindow(frame)``,\n    however ``wx.App`` is also usable on its own without derivation.\n    \n    :note: In Python the wrapper for the C++ class ``wxApp`` has been renamed tp\n        :class:`wx.PyApp`. This ``wx.App`` class derives from ``wx.PyApp``, and is\n        responsible for handling the Python-specific needs for bootstrapping the\n        wxWidgets library and other Python integration related requirements.\n    \"\"\"\n    outputWindowClass = PyOnDemandOutputWindow\n    def __init__(self, redirect=False, filename=None, useBestVisual=False, clearSigInt=True):\n        \"\"\"\n        Construct a ``wx.App`` object.\n        \n        :param redirect: Should ``sys.stdout`` and ``sys.stderr`` be\n            redirected?  Defaults to False. If ``filename`` is None\n            then output will be redirected to a window that pops up\n            as needed.  (You can control what kind of window is created\n            for the output by resetting the class variable\n            ``outputWindowClass`` to a class of your choosing.)\n        \n        :param filename: The name of a file to redirect output to, if\n            redirect is True.\n        \n        :param useBestVisual: Should the app try to use the best\n            available visual provided by the system (only relevant on\n            systems that have more than one visual.)  This parameter\n            must be used instead of calling `SetUseBestVisual` later\n            on because it must be set before the underlying GUI\n            toolkit is initialized.\n        \n        :param clearSigInt: Should SIGINT be cleared?  This allows the\n            app to terminate upon a Ctrl-C in the console like other\n            GUI apps will.\n        \n        :note: You should override OnInit to do application\n            initialization to ensure that the system, toolkit and\n            wxWidgets are fully initialized.\n        \"\"\"\n        PyApp.__init__(self)\n        \n        # make sure we can create a GUI\n        if not self.IsDisplayAvailable():\n        \n            if wx.Port == \"__WXMAC__\":\n                msg = \"This program needs access to the screen. Please run with a\\n\" \\\n                      \"Framework build of python, and only when you are logged in\\n\" \\\n                      \"on the main display of your Mac.\"\n        \n            elif wx.Port == \"__WXGTK__\":\n                msg =\"Unable to access the X Display, is $DISPLAY set properly?\"\n        \n            else:\n                msg = \"Unable to create GUI\"\n                # TODO: more description is needed for wxMSW...\n        \n            raise SystemExit(msg)\n        \n        # This has to be done before OnInit\n        self.SetUseBestVisual(useBestVisual)\n        \n        # Set the default handler for SIGINT.  This fixes a problem\n        # where if Ctrl-C is pressed in the console that started this\n        # app then it will not appear to do anything, (not even send\n        # KeyboardInterrupt???)  but will later segfault on exit.  By\n        # setting the default handler then the app will exit, as\n        # expected (depending on platform.)\n        if clearSigInt:\n            try:\n                import signal\n                signal.signal(signal.SIGINT, signal.SIG_DFL)\n            except:\n                pass\n        \n        # Save and redirect the stdio to a window?\n        self.stdioWin = None\n        self.saveStdio = (_sys.stdout, _sys.stderr)\n        if redirect:\n            self.RedirectStdio(filename)\n        \n        # Use Python's install prefix as the default\n        prefix = _sys.prefix\n        if isinstance(prefix, (bytes, bytearray)):\n            prefix = prefix.decode(_sys.getfilesystemencoding())\n        wx.StandardPaths.Get().SetInstallPrefix(prefix)\n        \n        # Until the new native control for wxMac is up to par, still use the generic one.\n        wx.SystemOptions.SetOption(\"mac.listctrl.always_use_generic\", 1)\n        \n        # This finishes the initialization of wxWindows and then calls\n        # the OnInit that should be present in the derived class\n        self._BootstrapApp()\n\n    def OnPreInit(self):\n        \"\"\"\n        Things that must be done after _BootstrapApp has done its thing, but\n        would be nice if they were already done by the time that OnInit is\n        called.  This can be overridden in derived classes, but be sure to call\n        this method from there.\n        \"\"\"\n        wx.StockGDI._initStockObjects()\n        self.InitLocale()\n\n    def __del__(self):\n        # Just in case the MainLoop was overridden without calling RestoreStio\n        self.RestoreStdio()\n\n    def SetTopWindow(self, frame):\n        \"\"\"\n        Set the \"main\" top level window, which will be used for the parent of\n        the on-demand output window as well as for dialogs that do not have\n        an explicit parent set.\n        \"\"\"\n        if self.stdioWin:\n            self.stdioWin.SetParent(frame)\n        wx.PyApp.SetTopWindow(self, frame)\n\n    def MainLoop(self):\n        \"\"\"\n        Execute the main GUI event loop\n        \"\"\"\n        rv = wx.PyApp.MainLoop(self)\n        self.RestoreStdio()\n        return rv\n\n    def RedirectStdio(self, filename=None):\n        \"\"\"\n        Redirect sys.stdout and sys.stderr to a file or a popup window.\n        \"\"\"\n        if filename:\n            _sys.stdout = _sys.stderr = open(filename, 'a')\n        else:\n            self.stdioWin = self.outputWindowClass()\n            _sys.stdout = _sys.stderr = self.stdioWin\n\n    def RestoreStdio(self):\n        try:\n            _sys.stdout, _sys.stderr = self.saveStdio\n        except:\n            pass\n\n    def SetOutputWindowAttributes(self, title=None, pos=None, size=None):\n        \"\"\"\n        Set the title, position and/or size of the output window if the stdio\n        has been redirected. This should be called before any output would\n        cause the output window to be created.\n        \"\"\"\n        if self.stdioWin:\n            if title is not None:\n                self.stdioWin.title = title\n            if pos is not None:\n                self.stdioWin.pos = pos\n            if size is not None:\n                self.stdioWin.size = size\n\n    def InitLocale(self):\n        \"\"\"\n        Starting with version 3.8 on Windows, Python is now setting the locale\n        to what is defined by the system as the default locale. This causes\n        problems with wxWidgets which expects to be able to manage the locale\n        via the wx.Locale class, so the locale will be reset here to be the\n        default \"C\" locale settings.\n        \n        If you have troubles from the default behavior of this method you can\n        override it in a derived class to behave differently. Please report\n        the problem you encountered.\n        \"\"\"\n        if _sys.platform.startswith('win') and _sys.version_info > (3,8):\n            import locale\n            locale.setlocale(locale.LC_ALL, \"C\")\n\n    def ResetLocale(self):\n        \"\"\"\n        This method is now a NOP and will be deprecated.\n        \"\"\"\n        pass\n\n    @staticmethod\n    def Get():\n        \"\"\"\n        A staticmethod returning the currently active application object.\n        Essentially just a more pythonic version of :meth:`GetApp`.\n        \"\"\"\n        return GetApp()\n\n\n@wx.deprecatedMsg(\"Use :class:`App` instead.\")\nclass PySimpleApp(App):\n    \"\"\"\n    This class is deprecated.  Please use :class:`App` instead.\n    \"\"\"\n    def __init__(self, *args, **kw):\n        App.__init__(self, *args, **kw)\n\n\nEVT_TIMER = wx.PyEventBinder( wxEVT_TIMER )\n\nclass PyTimer(Timer):\n    '''This timer class is passed the callable object to be called when the timer expires.'''\n    def __init__(self, notify):\n        Timer.__init__(self)\n        self.notify = notify\n\n    def Notify(self):\n        if self.notify:\n            self.notify()\n\ndef _Window_SetRect(self, rect):\n    return self.SetSize(rect)\nWindow.SetRect = _Window_SetRect\ndel _Window_SetRect\nWindow.Rect = property(Window.GetRect, Window.SetRect)\ndef _Window_SetClientRect(self, rect):\n    return self.SetClientSize(rect)\nWindow.SetClientRect = _Window_SetClientRect\ndel _Window_SetClientRect\nWindow.ClientRect = property(Window.GetClientRect, Window.SetClientRect)\nWindow.SetDimensions = wx.deprecated(Window.SetDimensions, 'Use SetSize instead.')\n\ndef _Window___nonzero__(self):\n    \"\"\"\n    Can be used to test if the C++ part of the window still exists, with \n    code like this::\n    \n        if theWindow:\n            doSomething()\n    \"\"\"\n    import wx.siplib\n    return not wx.siplib.isdeleted(self)\nWindow.__nonzero__ = _Window___nonzero__\ndel _Window___nonzero__\nWindow.__bool__ = Window.__nonzero__\n\ndef _Window_DestroyLater(self):\n    \"\"\"\n    Schedules the window to be destroyed in the near future.\n    \n    This should be used whenever Destroy could happen too soon, such\n    as when there may still be events for this window or its children\n    waiting in the event queue.\n    \"\"\"\n    self.Hide()\n    wx.GetApp().ScheduleForDestruction(self)\nWindow.DestroyLater = _Window_DestroyLater\ndel _Window_DestroyLater\ndef _Window_DLG_UNIT(self, dlg_unit):\n    \"\"\"\n    A convenience wrapper for :meth:`ConvertDialogToPixels`.\n    \"\"\"\n    is_wxType = isinstance(dlg_unit, (wx.Size, wx.Point))\n    pix = self.ConvertDialogToPixels(dlg_unit)\n    if not is_wxType:\n        pix = tuple(pix)\n    return pix\nWindow.DLG_UNIT = _Window_DLG_UNIT\ndel _Window_DLG_UNIT\ndef _Window_PostCreate(self, pre):\n    pass\nWindow.PostCreate = wx.deprecated(_Window_PostCreate, \"PostCreate is no longer necessary.\")\ndel _Window_PostCreate\ndef _Window_GetPositionTuple(self):\n    return self.GetPosition()\nWindow.GetPositionTuple = wx.deprecated(_Window_GetPositionTuple, \"Use GetPosition instead\")\ndel _Window_GetPositionTuple\ndef _Window_GetSizeTuple(self):\n    return self.GetSize()\nWindow.GetSizeTuple = wx.deprecated(_Window_GetSizeTuple, \"Use GetSize instead\")\ndel _Window_GetSizeTuple\ndef _Window_MoveXY(self, x, y):\n    return self.Move(x, y)\nWindow.MoveXY = wx.deprecated(_Window_MoveXY, \"Use Move instead.\")\ndel _Window_MoveXY\ndef _Window_SetSizeWH(self, w, h):\n    return self.SetSize(w,h)\nWindow.SetSizeWH = wx.deprecated(_Window_SetSizeWH, \"Use SetSize instead.\")\ndel _Window_SetSizeWH\ndef _Window_SetVirtualSizeWH(self, w, h):\n    return self.SetVirtualSize(w,h)\nWindow.SetVirtualSizeWH = wx.deprecated(_Window_SetVirtualSizeWH, \"Use SetVirtualSize instead.\")\ndel _Window_SetVirtualSizeWH\ndef _Window_GetVirtualSizeTuple(self):\n    return self.GetVirtualSize()\nWindow.GetVirtualSizeTuple = wx.deprecated(_Window_GetVirtualSizeTuple, \"Use GetVirtualSize instead.\")\ndel _Window_GetVirtualSizeTuple\ndef _Window_SetToolTipString(self, string):\n    return self.SetToolTip(string)\nWindow.SetToolTipString = wx.deprecated(_Window_SetToolTipString, \"Use SetToolTip instead.\")\ndel _Window_SetToolTipString\ndef _Window_ConvertDialogPointToPixels(self, point):\n    return self.ConvertDialogToPixels(point)\nWindow.ConvertDialogPointToPixels = wx.deprecated(_Window_ConvertDialogPointToPixels, \"Use ConvertDialogToPixels instead.\")\ndel _Window_ConvertDialogPointToPixels\ndef _Window_ConvertDialogSizeToPixels(self, size):\n    return self.ConvertDialogToPixels(point)\nWindow.ConvertDialogSizeToPixels = wx.deprecated(_Window_ConvertDialogSizeToPixels, \"Use ConvertDialogToPixels instead.\")\ndel _Window_ConvertDialogSizeToPixels\ndef _Window_SetSizeHintsSz(self, minSize, maxSize=wx.DefaultSize, incSize=wx.DefaultSize):\n    return self.SetSizeHints(minSize, maxSize, incSize)\nWindow.SetSizeHintsSz = wx.deprecated(_Window_SetSizeHintsSz, \"Use SetSizeHints instead.\")\ndel _Window_SetSizeHintsSz\nclass FrozenWindow(object):\n    \"\"\"\n    A context manager to be used with Python 'with' statements\n    that will freeze the given window for the duration of the\n    with block.\n    \"\"\"\n    def __init__(self, window):\n        self._win = window\n    def __enter__(self):\n        self._win.Freeze()\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self._win.Thaw()\n\ndef DLG_UNIT(win, dlg_unit, val2=None):\n    \"\"\"\n    Convenience function for converting a wx.Point, wx.Size or\n    (x,y) in dialog units to pixels, using the given window as a\n    reference.\n    \"\"\"\n    if val2 is not None:\n        dlg_unit = (dlg_unit, val2)\n    is_wxType = isinstance(dlg_unit, (wx.Size, wx.Point))\n    pix = win.ConvertDialogToPixels(dlg_unit)\n    if not is_wxType:\n        pix = tuple(pix)\n    return pix\n\nDLG_PNT = wx.deprecated(DLG_UNIT, \"Use DLG_UNIT instead.\")\nDLG_SZE = wx.deprecated(DLG_UNIT, \"Use DLG_UNIT instead.\")\n\ndef _WindowList___repr__(self):\n    return \"WindowList: \" + repr(list(self))\nWindowList.__repr__ = _WindowList___repr__\ndel _WindowList___repr__\nPyWindow = wx.deprecated(Window, 'Use Window instead.')\n\nPyValidator = wx.deprecated(Validator, 'Use Validator instead.')\n\nPyPanel = wx.deprecated(Panel, 'Use Panel instead.')\n\ndef _MenuItemList___repr__(self):\n    return \"MenuItemList: \" + repr(list(self))\nMenuItemList.__repr__ = _MenuItemList___repr__\ndel _MenuItemList___repr__\ndef _Menu_AppendMenu(self, id, item, subMenu, help=\"\"):\n    return self.Append(id, item, subMenu, help)\nMenu.AppendMenu = wx.deprecated(_Menu_AppendMenu, \"Use Append instead.\")\ndel _Menu_AppendMenu\ndef _Menu_AppendItem(self, menuItem):\n    return self.Append(menuItem)\nMenu.AppendItem = wx.deprecated(_Menu_AppendItem, \"Use Append instead.\")\ndel _Menu_AppendItem\ndef _Menu_InsertMenu(self, pos, id, item, subMenu, help=\"\"):\n    return self.Insert(pos, id, item, subMenu, help)\nMenu.InsertMenu = wx.deprecated(_Menu_InsertMenu, \"Use Insert instead.\")\ndel _Menu_InsertMenu\ndef _Menu_InsertItem(self, pos, menuItem):\n    return self.Insert(pos, menuItem)\nMenu.InsertItem = wx.deprecated(_Menu_InsertItem, \"Use Insert instead.\")\ndel _Menu_InsertItem\ndef _Menu_PrependMenu(self, id, item, subMenu, help=\"\"):\n    return self.Prepend(id, item, subMenu, help)\nMenu.PrependMenu = wx.deprecated(_Menu_PrependMenu, \"Use Prepend instead.\")\ndel _Menu_PrependMenu\ndef _Menu_PrependItem(self, menuItem):\n    return self.Prepend(menuItem)\nMenu.PrependItem = wx.deprecated(_Menu_PrependItem, \"Use Prepend instead.\")\ndel _Menu_PrependItem\ndef _Menu_RemoveMenu(self, id, item, subMenu, help=\"\"):\n    return self.Remove(id, item, subMenu, help)\nMenu.RemoveMenu = wx.deprecated(_Menu_RemoveMenu, \"Use Remove instead.\")\ndel _Menu_RemoveMenu\ndef _Menu_RemoveItem(self, menuItem):\n    return self.Remove(menuItem)\nMenu.RemoveItem = wx.deprecated(_Menu_RemoveItem, \"Use Remove instead.\")\ndel _Menu_RemoveItem\ndef _MenuBar_GetMenus(self):\n    \"\"\"\n    GetMenus() -> (menu, label)\n    \n    Return a list of (menu, label) items for the menus in the :class:`MenuBar`.\n    \"\"\"\n    return [(self.GetMenu(i), self.GetMenuLabel(i)) for i in range(self.GetMenuCount())]\nMenuBar.GetMenus = _MenuBar_GetMenus\ndel _MenuBar_GetMenus\ndef _MenuBar_SetMenus(self, items):\n    \"\"\"\n    SetMenus()\n    \n    Clear and add new menus to the :class:`MenuBar` from a list of (menu, label) items.\n    \"\"\"\n    for i in range(self.GetMenuCount()-1, -1, -1):\n        self.Remove(i)\n    for m, l in items:\n        self.Append(m, l)\nMenuBar.SetMenus = _MenuBar_SetMenus\ndel _MenuBar_SetMenus\nMenuBar.Menus = property(MenuBar.GetMenus, MenuBar.SetMenus)\ndef _MenuList___repr__(self):\n    return \"MenuList: \" + repr(list(self))\nMenuList.__repr__ = _MenuList___repr__\ndel _MenuList___repr__\nPyScrolledWindow = wx.deprecated(ScrolledWindow, 'Use ScrolledWindow instead.')\n\ndef _VScrolledWindow_HitTest(self, *args):\n    \"\"\"\n    Deprecated compatibility helper.\n    \"\"\"\n    if len(args) == 2:\n        x, y = args\n        return self.VirtualHitTest(y)\n    else:\n        pt = args[0]\n        return self.VirtualHitTest(pt[1])\nVScrolledWindow.HitTest = wx.deprecated(_VScrolledWindow_HitTest, \"Use VirtualHitTest instead.\")\ndel _VScrolledWindow_HitTest\nPyControl = wx.deprecated(Control, 'Use Control instead.')\n\ndef _ItemContainer_GetClientObject(self, n):\n    \"\"\"\n    Alias for :meth:`GetClientData`\n    \"\"\"\n    return self.GetClientData(n)\nItemContainer.GetClientObject = _ItemContainer_GetClientObject\ndel _ItemContainer_GetClientObject\ndef _ItemContainer_SetClientObject(self, n, data):\n    \"\"\"\n    Alias for :meth:`SetClientData`\n    \"\"\"\n    self.SetClientData(n, data)\nItemContainer.SetClientObject = _ItemContainer_SetClientObject\ndel _ItemContainer_SetClientObject\ndef _ItemContainer_AppendItems(self, items):\n    \"\"\"\n    Alias for :meth:`Append`\n    \"\"\"\n    self.Append(items)\nItemContainer.AppendItems = _ItemContainer_AppendItems\ndel _ItemContainer_AppendItems\ndef _ItemContainer_GetItems(self):\n    \"\"\"\n    Alias for :meth:`GetStrings`\n    \"\"\"\n    return self.GetStrings()\nItemContainer.GetItems = _ItemContainer_GetItems\ndel _ItemContainer_GetItems\ndef _ItemContainer_SetItems(self, items):\n    \"\"\"\n    Alias for :meth:`Set`\n    \"\"\"\n    self.Set(items)\nItemContainer.SetItems = _ItemContainer_SetItems\ndel _ItemContainer_SetItems\nItemContainer.Items = property(ItemContainer.GetItems, ItemContainer.SetItems)\nEVT_NOTEBOOK_PAGE_CHANGED  = wx.PyEventBinder( wxEVT_NOTEBOOK_PAGE_CHANGED, 1 )\nEVT_NOTEBOOK_PAGE_CHANGING = wx.PyEventBinder( wxEVT_NOTEBOOK_PAGE_CHANGING, 1 )\n\n# Aliases for the \"best book\" control as described in the overview\nBookCtrl =                       Notebook\nwxEVT_BOOKCTRL_PAGE_CHANGED =    wxEVT_NOTEBOOK_PAGE_CHANGED\nwxEVT_BOOKCTRL_PAGE_CHANGING =   wxEVT_NOTEBOOK_PAGE_CHANGING\nEVT_BOOKCTRL_PAGE_CHANGED =      EVT_NOTEBOOK_PAGE_CHANGED\nEVT_BOOKCTRL_PAGE_CHANGING =     EVT_NOTEBOOK_PAGE_CHANGING\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_BOOKCTRL_PAGE_CHANGED   = wxEVT_BOOKCTRL_PAGE_CHANGED\nwxEVT_COMMAND_BOOKCTRL_PAGE_CHANGING  = wxEVT_BOOKCTRL_PAGE_CHANGING\nwxEVT_COMMAND_NOTEBOOK_PAGE_CHANGED   = wxEVT_NOTEBOOK_PAGE_CHANGED\nwxEVT_COMMAND_NOTEBOOK_PAGE_CHANGING  = wxEVT_NOTEBOOK_PAGE_CHANGING\n\n# Add wx.NotebookPage alias, as seen in the documentation\nNotebookPage = Window\n\nEVT_SPLITTER_SASH_POS_CHANGED = wx.PyEventBinder( wxEVT_SPLITTER_SASH_POS_CHANGED, 1 )\nEVT_SPLITTER_SASH_POS_CHANGING = wx.PyEventBinder( wxEVT_SPLITTER_SASH_POS_CHANGING, 1 )\nEVT_SPLITTER_DOUBLECLICKED = wx.PyEventBinder( wxEVT_SPLITTER_DOUBLECLICKED, 1 )\nEVT_SPLITTER_UNSPLIT = wx.PyEventBinder( wxEVT_SPLITTER_UNSPLIT, 1 )\nEVT_SPLITTER_DCLICK = EVT_SPLITTER_DOUBLECLICKED\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_SPLITTER_SASH_POS_CHANGED   = wxEVT_SPLITTER_SASH_POS_CHANGED\nwxEVT_COMMAND_SPLITTER_SASH_POS_CHANGING  = wxEVT_SPLITTER_SASH_POS_CHANGING\nwxEVT_COMMAND_SPLITTER_DOUBLECLICKED      = wxEVT_SPLITTER_DOUBLECLICKED\nwxEVT_COMMAND_SPLITTER_UNSPLIT            = wxEVT_SPLITTER_UNSPLIT\n\nEVT_COLLAPSIBLEPANE_CHANGED = wx.PyEventBinder( wxEVT_COLLAPSIBLEPANE_CHANGED )\n\n# deprecated wxEVT alias\nwxEVT_COMMAND_COLLPANE_CHANGED  = wxEVT_COLLAPSIBLEPANE_CHANGED\n\nEVT_TEXT        = wx.PyEventBinder( wxEVT_TEXT, 1)\nEVT_TEXT_ENTER  = wx.PyEventBinder( wxEVT_TEXT_ENTER, 1)\nEVT_TEXT_URL    = wx.PyEventBinder( wxEVT_TEXT_URL, 1)\nEVT_TEXT_MAXLEN = wx.PyEventBinder( wxEVT_TEXT_MAXLEN, 1)\nEVT_TEXT_CUT    = wx.PyEventBinder( wxEVT_TEXT_CUT )\nEVT_TEXT_COPY   = wx.PyEventBinder( wxEVT_TEXT_COPY )\nEVT_TEXT_PASTE  = wx.PyEventBinder( wxEVT_TEXT_PASTE )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_TEXT_UPDATED   = wxEVT_TEXT\nwxEVT_COMMAND_TEXT_ENTER     = wxEVT_TEXT_ENTER\nwxEVT_COMMAND_TEXT_URL       = wxEVT_TEXT_URL\nwxEVT_COMMAND_TEXT_MAXLEN    = wxEVT_TEXT_MAXLEN\nwxEVT_COMMAND_TEXT_CUT       = wxEVT_TEXT_CUT\nwxEVT_COMMAND_TEXT_COPY      = wxEVT_TEXT_COPY\nwxEVT_COMMAND_TEXT_PASTE     = wxEVT_TEXT_PASTE\n\nComboBox.SetMark = wx.deprecated(ComboBox.SetTextSelection, 'Use SetTextSelection instead.')\n\nComboBox.GetMark = wx.deprecated(ComboBox.GetTextSelection, 'Use GetTextSelection instead.')\n\ndef _CheckListBox_GetCheckedItems(self):\n    \"\"\"\n    GetCheckedItems()\n    \n    Return a sequence of integers corresponding to the checked items in\n    the control, based on :meth:`IsChecked`.\n    \"\"\"\n    return tuple([i for i in range(self.Count) if self.IsChecked(i)])\nCheckListBox.GetCheckedItems = _CheckListBox_GetCheckedItems\ndel _CheckListBox_GetCheckedItems\ndef _CheckListBox_GetCheckedStrings(self):\n    \"\"\"\n    GetCheckedStrings()\n    \n    Return a tuple of strings corresponding to the checked\n    items of the control, based on :meth:`GetChecked`.\n    \"\"\"\n    return tuple([self.GetString(i) for i in self.GetCheckedItems()])\nCheckListBox.GetCheckedStrings = _CheckListBox_GetCheckedStrings\ndel _CheckListBox_GetCheckedStrings\ndef _CheckListBox_SetCheckedItems(self, indexes):\n    \"\"\"\n    SetCheckedItems(indexes)\n    \n    Sets the checked state of items if the index of the item is\n    found in the indexes sequence.\n    \"\"\"\n    for i in indexes:\n        assert 0 <= i < self.Count, \"Index (%s) out of range\" % i\n    for i in range(self.Count):\n        self.Check(i, i in indexes)\nCheckListBox.SetCheckedItems = _CheckListBox_SetCheckedItems\ndel _CheckListBox_SetCheckedItems\ndef _CheckListBox_SetCheckedStrings(self, strings):\n    \"\"\"\n    SetCheckedStrings(strings)\n    \n    Sets the checked state of items if the item's string is found\n    in the strings sequence.\n    \"\"\"\n    for s in strings:\n        assert s in self.GetStrings(), \"String ('%s') not found\" % s\n    for i in range(self.Count):\n        self.Check(i, self.GetString(i) in strings)\nCheckListBox.SetCheckedStrings = _CheckListBox_SetCheckedStrings\ndel _CheckListBox_SetCheckedStrings\ndef _CheckListBox_GetChecked(self):\n    return self.GetCheckedItems()\nCheckListBox.GetChecked = wx.deprecated(_CheckListBox_GetChecked, \"Use GetCheckedItems instead.\")\ndel _CheckListBox_GetChecked\ndef _CheckListBox_SetChecked(self, indexes):\n    return self.SetCheckedItems(indexes)\nCheckListBox.SetChecked = wx.deprecated(_CheckListBox_SetChecked, \"Use SetCheckedItems instead.\")\ndel _CheckListBox_SetChecked\nCheckListBox.Checked = property(CheckListBox.GetChecked, CheckListBox.SetChecked)\nCheckListBox.CheckedItems = property(CheckListBox.GetCheckedItems, CheckListBox.SetCheckedItems)\nCheckListBox.CheckedStrings = property(CheckListBox.GetCheckedStrings, CheckListBox.SetCheckedStrings)\nSettableHeaderColumn.Title = property(HeaderColumn.GetTitle, SettableHeaderColumn.SetTitle)\nSettableHeaderColumn.Bitmap = property(HeaderColumn.GetBitmap, SettableHeaderColumn.SetBitmap)\nSettableHeaderColumn.Width = property(HeaderColumn.GetWidth, SettableHeaderColumn.SetWidth)\nSettableHeaderColumn.MinWidth = property(HeaderColumn.GetMinWidth, SettableHeaderColumn.SetMinWidth)\nSettableHeaderColumn.Alignment = property(HeaderColumn.GetAlignment, SettableHeaderColumn.SetAlignment)\nSettableHeaderColumn.Flags = property(HeaderColumn.GetFlags, SettableHeaderColumn.SetFlags)\nSettableHeaderColumn.Resizeable = property(HeaderColumn.IsResizeable, SettableHeaderColumn.SetResizeable)\nSettableHeaderColumn.Sortable = property(HeaderColumn.IsSortable, SettableHeaderColumn.SetSortable)\nSettableHeaderColumn.Reorderable = property(HeaderColumn.IsReorderable, SettableHeaderColumn.SetReorderable)\nSettableHeaderColumn.Hidden = property(HeaderColumn.IsHidden, SettableHeaderColumn.SetHidden)\nEVT_HEADER_CLICK =              wx.PyEventBinder( wxEVT_HEADER_CLICK )\nEVT_HEADER_RIGHT_CLICK =        wx.PyEventBinder( wxEVT_HEADER_RIGHT_CLICK )\nEVT_HEADER_MIDDLE_CLICK =       wx.PyEventBinder( wxEVT_HEADER_MIDDLE_CLICK )\nEVT_HEADER_DCLICK =             wx.PyEventBinder( wxEVT_HEADER_DCLICK )\nEVT_HEADER_RIGHT_DCLICK =       wx.PyEventBinder( wxEVT_HEADER_RIGHT_DCLICK )\nEVT_HEADER_MIDDLE_DCLICK =      wx.PyEventBinder( wxEVT_HEADER_MIDDLE_DCLICK )\nEVT_HEADER_SEPARATOR_DCLICK =   wx.PyEventBinder( wxEVT_HEADER_SEPARATOR_DCLICK )\nEVT_HEADER_BEGIN_RESIZE =       wx.PyEventBinder( wxEVT_HEADER_BEGIN_RESIZE )\nEVT_HEADER_RESIZING =           wx.PyEventBinder( wxEVT_HEADER_RESIZING )\nEVT_HEADER_END_RESIZE =         wx.PyEventBinder( wxEVT_HEADER_END_RESIZE )\nEVT_HEADER_BEGIN_REORDER =      wx.PyEventBinder( wxEVT_HEADER_BEGIN_REORDER )\nEVT_HEADER_END_REORDER =        wx.PyEventBinder( wxEVT_HEADER_END_REORDER )\nEVT_HEADER_DRAGGING_CANCELLED = wx.PyEventBinder( wxEVT_HEADER_DRAGGING_CANCELLED )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_HEADER_CLICK               = wxEVT_HEADER_CLICK\nwxEVT_COMMAND_HEADER_RIGHT_CLICK         = wxEVT_HEADER_RIGHT_CLICK\nwxEVT_COMMAND_HEADER_MIDDLE_CLICK        = wxEVT_HEADER_MIDDLE_CLICK\nwxEVT_COMMAND_HEADER_DCLICK              = wxEVT_HEADER_DCLICK\nwxEVT_COMMAND_HEADER_RIGHT_DCLICK        = wxEVT_HEADER_RIGHT_DCLICK\nwxEVT_COMMAND_HEADER_MIDDLE_DCLICK       = wxEVT_HEADER_MIDDLE_DCLICK\nwxEVT_COMMAND_HEADER_SEPARATOR_DCLICK    = wxEVT_HEADER_SEPARATOR_DCLICK\nwxEVT_COMMAND_HEADER_BEGIN_RESIZE        = wxEVT_HEADER_BEGIN_RESIZE\nwxEVT_COMMAND_HEADER_RESIZING            = wxEVT_HEADER_RESIZING\nwxEVT_COMMAND_HEADER_END_RESIZE          = wxEVT_HEADER_END_RESIZE\nwxEVT_COMMAND_HEADER_BEGIN_REORDER       = wxEVT_HEADER_BEGIN_REORDER\nwxEVT_COMMAND_HEADER_END_REORDER         = wxEVT_HEADER_END_REORDER\nwxEVT_COMMAND_HEADER_DRAGGING_CANCELLED  = wxEVT_HEADER_DRAGGING_CANCELLED\n\nEVT_SEARCH_CANCEL = wx.PyEventBinder( wxEVT_SEARCH_CANCEL, 1)\nEVT_SEARCH = wx.PyEventBinder( wxEVT_SEARCH, 1)\n\n# deprecated wxEVT aliases\nwxEVT_SEARCHCTRL_CANCEL_BTN = wxEVT_SEARCH_CANCEL\nwxEVT_SEARCHCTRL_SEARCH_BTN = wxEVT_SEARCH\nwxEVT_COMMAND_SEARCHCTRL_CANCEL_BTN  = wxEVT_SEARCHCTRL_CANCEL_BTN\nwxEVT_COMMAND_SEARCHCTRL_SEARCH_BTN  = wxEVT_SEARCHCTRL_SEARCH_BTN\nEVT_SEARCHCTRL_CANCEL_BTN = wx.PyEventBinder( wxEVT_SEARCHCTRL_CANCEL_BTN, 1)\nEVT_SEARCHCTRL_SEARCH_BTN = wx.PyEventBinder( wxEVT_SEARCHCTRL_SEARCH_BTN, 1)\n\ndef _RadioBox_GetItemLabel(self, n):\n    \"\"\"\n    GetItemLabel(self, n) -> string\n    \n    Return the text of the n'th item in the radio box.\n    \"\"\"\n    return self.GetString(n)\nRadioBox.GetItemLabel = _RadioBox_GetItemLabel\ndel _RadioBox_GetItemLabel\ndef _RadioBox_SetItemLabel(self, n, text):\n    \"\"\"\n    SetItemLabel(self, n, text)\n    \n    Set the text of the n'th item in the radio box.\n    \"\"\"\n    self.SetString(n, text)\nRadioBox.SetItemLabel = _RadioBox_SetItemLabel\ndel _RadioBox_SetItemLabel\ndef _Slider_GetRange(self):\n    return (self.GetMin(), self.GetMax())\nSlider.GetRange = _Slider_GetRange\ndel _Slider_GetRange\nSlider.Range = property(Slider.GetRange)\ndef _SpinButton_GetRange(self):\n    return (self.GetMin(), self.GetMax())\nSpinButton.GetRange = _SpinButton_GetRange\ndel _SpinButton_GetRange\ndef _SpinButton_SetMin(self, minVal):\n    self.SetRange(minVal, self.GetMax())\nSpinButton.SetMin = _SpinButton_SetMin\ndel _SpinButton_SetMin\ndef _SpinButton_SetMax(self, maxVal):\n    self.SetRange(self.GetMin(), maxVal)\nSpinButton.SetMax = _SpinButton_SetMax\ndel _SpinButton_SetMax\nSpinButton.Max = property(SpinButton.GetMax, SpinButton.SetMax)\nSpinButton.Min = property(SpinButton.GetMin, SpinButton.SetMin)\nSpinButton.Range = property(SpinButton.GetRange)\nEVT_SPIN_UP   = wx.PyEventBinder( wxEVT_SPIN_UP, 1)\nEVT_SPIN_DOWN = wx.PyEventBinder( wxEVT_SPIN_DOWN, 1)\nEVT_SPIN      = wx.PyEventBinder( wxEVT_SPIN, 1)\n\ndef _SpinCtrl_GetRange(self):\n    return (self.GetMin(), self.GetMax())\nSpinCtrl.GetRange = _SpinCtrl_GetRange\ndel _SpinCtrl_GetRange\ndef _SpinCtrl_SetMin(self, minVal):\n    self.SetRange(minVal, self.GetMax())\nSpinCtrl.SetMin = _SpinCtrl_SetMin\ndel _SpinCtrl_SetMin\ndef _SpinCtrl_SetMax(self, maxVal):\n    self.SetRange(self.GetMin(), maxVal)\nSpinCtrl.SetMax = _SpinCtrl_SetMax\ndel _SpinCtrl_SetMax\nSpinCtrl.Max = property(SpinCtrl.GetMax, SpinCtrl.SetMax)\nSpinCtrl.Min = property(SpinCtrl.GetMin, SpinCtrl.SetMin)\nSpinCtrl.Range = property(SpinCtrl.GetRange)\ndef _SpinCtrlDouble_GetRange(self):\n    return (self.GetMin(), self.GetMax())\nSpinCtrlDouble.GetRange = _SpinCtrlDouble_GetRange\ndel _SpinCtrlDouble_GetRange\ndef _SpinCtrlDouble_SetMin(self, minVal):\n    self.SetRange(minVal, self.GetMax())\nSpinCtrlDouble.SetMin = _SpinCtrlDouble_SetMin\ndel _SpinCtrlDouble_SetMin\ndef _SpinCtrlDouble_SetMax(self, maxVal):\n    self.SetRange(self.GetMin(), maxVal)\nSpinCtrlDouble.SetMax = _SpinCtrlDouble_SetMax\ndel _SpinCtrlDouble_SetMax\nSpinCtrlDouble.Max = property(SpinCtrlDouble.GetMax, SpinCtrlDouble.SetMax)\nSpinCtrlDouble.Min = property(SpinCtrlDouble.GetMin, SpinCtrlDouble.SetMin)\nSpinCtrlDouble.Range = property(SpinCtrlDouble.GetRange)\nEVT_SPINCTRL = wx.PyEventBinder( wxEVT_SPINCTRL, 1)\nEVT_SPINCTRLDOUBLE = wx.PyEventBinder( wxEVT_SPINCTRLDOUBLE, 1)\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_SPINCTRL_UPDATED        = wxEVT_SPINCTRL\nwxEVT_COMMAND_SPINCTRLDOUBLE_UPDATED  = wxEVT_SPINCTRLDOUBLE\n\nEVT_TOGGLEBUTTON = PyEventBinder(wxEVT_TOGGLEBUTTON, 1)\n\n# deprecated wxEVT alias\nwxEVT_COMMAND_TOGGLEBUTTON_CLICKED   = wxEVT_TOGGLEBUTTON\n\ndef _ToolBar_AddSimpleTool(self, toolId, bitmap, shortHelpString=\"\", longHelpString=\"\", isToggle=0):\n    \"\"\"\n    Old style method to add a tool to the toolbar.\n    \"\"\"\n    kind = wx.ITEM_NORMAL\n    if isToggle: kind = wx.ITEM_CHECK\n    return self.AddTool(toolId, '', bitmap, wx.NullBitmap, kind,\n                        shortHelpString, longHelpString)\nToolBar.AddSimpleTool = wx.deprecated(_ToolBar_AddSimpleTool, \"Use :meth:`AddTool` instead.\")\ndel _ToolBar_AddSimpleTool\ndef _ToolBar_AddLabelTool(self, id, label, bitmap, bmpDisabled=wx.NullBitmap, kind=wx.ITEM_NORMAL, shortHelp=\"\", longHelp=\"\", clientData=None):\n    \"\"\"\n    Old style method to add a tool in the toolbar.\n    \"\"\"\n    return self.AddTool(id, label, bitmap, bmpDisabled, kind,\n                        shortHelp, longHelp, clientData)\nToolBar.AddLabelTool = wx.deprecated(_ToolBar_AddLabelTool, \"Use :meth:`AddTool` instead.\")\ndel _ToolBar_AddLabelTool\ndef _ToolBar_InsertSimpleTool(self, pos, toolId, bitmap, shortHelpString=\"\", longHelpString=\"\", isToggle=0):\n    \"\"\"\n    Old style method to insert a tool in the toolbar.\n    \"\"\"\n    kind = wx.ITEM_NORMAL\n    if isToggle: kind = wx.ITEM_CHECK\n    return self.InsertTool(pos, toolId, '', bitmap, wx.NullBitmap, kind,\n                           shortHelpString, longHelpString)\nToolBar.InsertSimpleTool = wx.deprecated(_ToolBar_InsertSimpleTool, \"Use :meth:`InsertTool` instead.\")\ndel _ToolBar_InsertSimpleTool\ndef _ToolBar_InsertLabelTool(self, pos, id, label, bitmap, bmpDisabled=wx.NullBitmap, kind=wx.ITEM_NORMAL, shortHelp=\"\", longHelp=\"\", clientData=None):\n    \"\"\"\n    Old style method to insert a tool in the toolbar.\n    \"\"\"\n    return self.InsertTool(pos, id, label, bitmap, bmpDisabled, kind,\n                           shortHelp, longHelp, clientData)\nToolBar.InsertLabelTool = wx.deprecated(_ToolBar_InsertLabelTool, \"Use :meth:`InsertTool` instead.\")\ndel _ToolBar_InsertLabelTool\nListCtrl.FindItemData = wx.deprecated(ListCtrl.FindItem, \"Use FindItem instead.\")\n\nListCtrl.FindItemAtPos = wx.deprecated(ListCtrl.FindItem, \"Use FindItem instead.\")\n\nListCtrl.InsertStringItem = wx.deprecated(ListCtrl.InsertItem, \"Use InsertItem instead.\")\n\nListCtrl.InsertImageItem = wx.deprecated(ListCtrl.InsertItem, \"Use InsertItem instead.\")\n\nListCtrl.InsertImageStringItem = wx.deprecated(ListCtrl.InsertItem, \"Use InsertItem instead.\")\n\nListCtrl.SetStringItem = wx.deprecated(ListCtrl.SetItem, \"Use SetItem instead.\")\n\ndef _ListCtrl_Select(self, idx, on=1):\n    \"\"\"\n    Selects/deselects an item.\n    \"\"\"\n    if on: state = wx.LIST_STATE_SELECTED\n    else: state = 0\n    self.SetItemState(idx, state, wx.LIST_STATE_SELECTED)\nListCtrl.Select = _ListCtrl_Select\ndel _ListCtrl_Select\ndef _ListCtrl_Focus(self, idx):\n    \"\"\"\n    Focus and show the given item.\n    \"\"\"\n    self.SetItemState(idx, wx.LIST_STATE_FOCUSED, wx.LIST_STATE_FOCUSED)\n    self.EnsureVisible(idx)\nListCtrl.Focus = _ListCtrl_Focus\ndel _ListCtrl_Focus\ndef _ListCtrl_GetFocusedItem(self):\n    \"\"\"\n    Gets the currently focused item or -1 if none is focused.\n    \"\"\"\n    return self.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_FOCUSED)\nListCtrl.GetFocusedItem = _ListCtrl_GetFocusedItem\ndel _ListCtrl_GetFocusedItem\ndef _ListCtrl_GetFirstSelected(self, *args):\n    \"\"\"\n    Returns the first selected item, or -1 when none is selected.\n    \"\"\"\n    return self.GetNextSelected(-1)\nListCtrl.GetFirstSelected = _ListCtrl_GetFirstSelected\ndel _ListCtrl_GetFirstSelected\ndef _ListCtrl_GetNextSelected(self, item):\n    \"\"\"\n    Returns subsequent selected items, or -1 when no more are selected.\n    \"\"\"\n    return self.GetNextItem(item, wx.LIST_NEXT_ALL, wx.LIST_STATE_SELECTED)\nListCtrl.GetNextSelected = _ListCtrl_GetNextSelected\ndel _ListCtrl_GetNextSelected\ndef _ListCtrl_IsSelected(self, idx):\n    \"\"\"\n    Returns ``True`` if the item is selected.\n    \"\"\"\n    return (self.GetItemState(idx, wx.LIST_STATE_SELECTED) & wx.LIST_STATE_SELECTED) != 0\nListCtrl.IsSelected = _ListCtrl_IsSelected\ndel _ListCtrl_IsSelected\ndef _ListCtrl_SetColumnImage(self, col, image):\n    item = self.GetColumn(col)\n    # preserve all other attributes too\n    item.SetMask( wx.LIST_MASK_STATE |\n                  wx.LIST_MASK_TEXT  |\n                  wx.LIST_MASK_IMAGE |\n                  wx.LIST_MASK_DATA  |\n                  wx.LIST_SET_ITEM   |\n                  wx.LIST_MASK_WIDTH |\n                  wx.LIST_MASK_FORMAT )\n    item.SetImage(image)\n    self.SetColumn(col, item)\nListCtrl.SetColumnImage = _ListCtrl_SetColumnImage\ndel _ListCtrl_SetColumnImage\ndef _ListCtrl_ClearColumnImage(self, col):\n    self.SetColumnImage(col, -1)\nListCtrl.ClearColumnImage = _ListCtrl_ClearColumnImage\ndel _ListCtrl_ClearColumnImage\ndef _ListCtrl_Append(self, entry):\n    \"\"\"\n    Append an item to the list control.  The `entry` parameter should be a\n    sequence with an item for each column\n    \"\"\"\n    if len(entry):\n        from six import text_type\n        pos = self.InsertItem(self.GetItemCount(), text_type(entry[0]))\n        for i in range(1, len(entry)):\n            self.SetItem(pos, i, text_type(entry[i]))\n        return pos\nListCtrl.Append = _ListCtrl_Append\ndel _ListCtrl_Append\nListCtrl.FocusedItem = property(ListCtrl.GetFocusedItem)\nListItemAttr = wx.deprecated(ItemAttr, 'Use ItemAttr instead')\n\nEVT_LIST_BEGIN_DRAG        = PyEventBinder(wxEVT_LIST_BEGIN_DRAG       , 1)\nEVT_LIST_BEGIN_RDRAG       = PyEventBinder(wxEVT_LIST_BEGIN_RDRAG      , 1)\nEVT_LIST_BEGIN_LABEL_EDIT  = PyEventBinder(wxEVT_LIST_BEGIN_LABEL_EDIT , 1)\nEVT_LIST_END_LABEL_EDIT    = PyEventBinder(wxEVT_LIST_END_LABEL_EDIT   , 1)\nEVT_LIST_DELETE_ITEM       = PyEventBinder(wxEVT_LIST_DELETE_ITEM      , 1)\nEVT_LIST_DELETE_ALL_ITEMS  = PyEventBinder(wxEVT_LIST_DELETE_ALL_ITEMS , 1)\nEVT_LIST_ITEM_SELECTED     = PyEventBinder(wxEVT_LIST_ITEM_SELECTED    , 1)\nEVT_LIST_ITEM_DESELECTED   = PyEventBinder(wxEVT_LIST_ITEM_DESELECTED  , 1)\nEVT_LIST_KEY_DOWN          = PyEventBinder(wxEVT_LIST_KEY_DOWN         , 1)\nEVT_LIST_INSERT_ITEM       = PyEventBinder(wxEVT_LIST_INSERT_ITEM      , 1)\nEVT_LIST_COL_CLICK         = PyEventBinder(wxEVT_LIST_COL_CLICK        , 1)\nEVT_LIST_ITEM_RIGHT_CLICK  = PyEventBinder(wxEVT_LIST_ITEM_RIGHT_CLICK , 1)\nEVT_LIST_ITEM_MIDDLE_CLICK = PyEventBinder(wxEVT_LIST_ITEM_MIDDLE_CLICK, 1)\nEVT_LIST_ITEM_ACTIVATED    = PyEventBinder(wxEVT_LIST_ITEM_ACTIVATED   , 1)\nEVT_LIST_CACHE_HINT        = PyEventBinder(wxEVT_LIST_CACHE_HINT       , 1)\nEVT_LIST_COL_RIGHT_CLICK   = PyEventBinder(wxEVT_LIST_COL_RIGHT_CLICK  , 1)\nEVT_LIST_COL_BEGIN_DRAG    = PyEventBinder(wxEVT_LIST_COL_BEGIN_DRAG   , 1)\nEVT_LIST_COL_DRAGGING      = PyEventBinder(wxEVT_LIST_COL_DRAGGING     , 1)\nEVT_LIST_COL_END_DRAG      = PyEventBinder(wxEVT_LIST_COL_END_DRAG     , 1)\nEVT_LIST_ITEM_FOCUSED      = PyEventBinder(wxEVT_LIST_ITEM_FOCUSED     , 1)\nEVT_LIST_ITEM_CHECKED      = PyEventBinder(wxEVT_LIST_ITEM_CHECKED     , 1)\nEVT_LIST_ITEM_UNCHECKED    = PyEventBinder(wxEVT_LIST_ITEM_UNCHECKED   , 1)\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_LIST_BEGIN_DRAG         = wxEVT_LIST_BEGIN_DRAG\nwxEVT_COMMAND_LIST_BEGIN_RDRAG        = wxEVT_LIST_BEGIN_RDRAG\nwxEVT_COMMAND_LIST_BEGIN_LABEL_EDIT   = wxEVT_LIST_BEGIN_LABEL_EDIT\nwxEVT_COMMAND_LIST_END_LABEL_EDIT     = wxEVT_LIST_END_LABEL_EDIT\nwxEVT_COMMAND_LIST_DELETE_ITEM        = wxEVT_LIST_DELETE_ITEM\nwxEVT_COMMAND_LIST_DELETE_ALL_ITEMS   = wxEVT_LIST_DELETE_ALL_ITEMS\nwxEVT_COMMAND_LIST_ITEM_SELECTED      = wxEVT_LIST_ITEM_SELECTED\nwxEVT_COMMAND_LIST_ITEM_DESELECTED    = wxEVT_LIST_ITEM_DESELECTED\nwxEVT_COMMAND_LIST_KEY_DOWN           = wxEVT_LIST_KEY_DOWN\nwxEVT_COMMAND_LIST_INSERT_ITEM        = wxEVT_LIST_INSERT_ITEM\nwxEVT_COMMAND_LIST_COL_CLICK          = wxEVT_LIST_COL_CLICK\nwxEVT_COMMAND_LIST_ITEM_RIGHT_CLICK   = wxEVT_LIST_ITEM_RIGHT_CLICK\nwxEVT_COMMAND_LIST_ITEM_MIDDLE_CLICK  = wxEVT_LIST_ITEM_MIDDLE_CLICK\nwxEVT_COMMAND_LIST_ITEM_ACTIVATED     = wxEVT_LIST_ITEM_ACTIVATED\nwxEVT_COMMAND_LIST_CACHE_HINT         = wxEVT_LIST_CACHE_HINT\nwxEVT_COMMAND_LIST_COL_RIGHT_CLICK    = wxEVT_LIST_COL_RIGHT_CLICK\nwxEVT_COMMAND_LIST_COL_BEGIN_DRAG     = wxEVT_LIST_COL_BEGIN_DRAG\nwxEVT_COMMAND_LIST_COL_DRAGGING       = wxEVT_LIST_COL_DRAGGING\nwxEVT_COMMAND_LIST_COL_END_DRAG       = wxEVT_LIST_COL_END_DRAG\nwxEVT_COMMAND_LIST_ITEM_FOCUSED       = wxEVT_LIST_ITEM_FOCUSED\n\ndef _TreeItemId___hash__(self):\n    return hash(int(self.GetID()))\nTreeItemId.__hash__ = _TreeItemId___hash__\ndel _TreeItemId___hash__\nTreeCtrl.GetItemPyData = wx.deprecated(TreeCtrl.GetItemData, 'Use GetItemData instead.')\nTreeCtrl.SetItemPyData = wx.deprecated(TreeCtrl.SetItemData, 'Use SetItemData instead.')\nTreeCtrl.GetPyData = wx.deprecated(TreeCtrl.GetItemData, 'Use GetItemData instead.')\nTreeCtrl.SetPyData = wx.deprecated(TreeCtrl.SetItemData, 'Use SetItemData instead.')\n\ndef TreeItemData(data):\n    return data\nTreeItemData = deprecated(TreeItemData, \"The TreeItemData class no longer exists, just pass your object directly to the tree instead.\")\n\nEVT_TREE_BEGIN_DRAG        = PyEventBinder(wxEVT_TREE_BEGIN_DRAG       , 1)\nEVT_TREE_BEGIN_RDRAG       = PyEventBinder(wxEVT_TREE_BEGIN_RDRAG      , 1)\nEVT_TREE_BEGIN_LABEL_EDIT  = PyEventBinder(wxEVT_TREE_BEGIN_LABEL_EDIT , 1)\nEVT_TREE_END_LABEL_EDIT    = PyEventBinder(wxEVT_TREE_END_LABEL_EDIT   , 1)\nEVT_TREE_DELETE_ITEM       = PyEventBinder(wxEVT_TREE_DELETE_ITEM      , 1)\nEVT_TREE_GET_INFO          = PyEventBinder(wxEVT_TREE_GET_INFO         , 1)\nEVT_TREE_SET_INFO          = PyEventBinder(wxEVT_TREE_SET_INFO         , 1)\nEVT_TREE_ITEM_EXPANDED     = PyEventBinder(wxEVT_TREE_ITEM_EXPANDED    , 1)\nEVT_TREE_ITEM_EXPANDING    = PyEventBinder(wxEVT_TREE_ITEM_EXPANDING   , 1)\nEVT_TREE_ITEM_COLLAPSED    = PyEventBinder(wxEVT_TREE_ITEM_COLLAPSED   , 1)\nEVT_TREE_ITEM_COLLAPSING   = PyEventBinder(wxEVT_TREE_ITEM_COLLAPSING  , 1)\nEVT_TREE_SEL_CHANGED       = PyEventBinder(wxEVT_TREE_SEL_CHANGED      , 1)\nEVT_TREE_SEL_CHANGING      = PyEventBinder(wxEVT_TREE_SEL_CHANGING     , 1)\nEVT_TREE_KEY_DOWN          = PyEventBinder(wxEVT_TREE_KEY_DOWN         , 1)\nEVT_TREE_ITEM_ACTIVATED    = PyEventBinder(wxEVT_TREE_ITEM_ACTIVATED   , 1)\nEVT_TREE_ITEM_RIGHT_CLICK  = PyEventBinder(wxEVT_TREE_ITEM_RIGHT_CLICK , 1)\nEVT_TREE_ITEM_MIDDLE_CLICK = PyEventBinder(wxEVT_TREE_ITEM_MIDDLE_CLICK, 1)\nEVT_TREE_END_DRAG          = PyEventBinder(wxEVT_TREE_END_DRAG         , 1)\nEVT_TREE_STATE_IMAGE_CLICK = PyEventBinder(wxEVT_TREE_STATE_IMAGE_CLICK, 1)\nEVT_TREE_ITEM_GETTOOLTIP   = PyEventBinder(wxEVT_TREE_ITEM_GETTOOLTIP,   1)\nEVT_TREE_ITEM_MENU         = PyEventBinder(wxEVT_TREE_ITEM_MENU,         1)\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_TREE_BEGIN_DRAG         = wxEVT_TREE_BEGIN_DRAG\nwxEVT_COMMAND_TREE_BEGIN_RDRAG        = wxEVT_TREE_BEGIN_RDRAG\nwxEVT_COMMAND_TREE_BEGIN_LABEL_EDIT   = wxEVT_TREE_BEGIN_LABEL_EDIT\nwxEVT_COMMAND_TREE_END_LABEL_EDIT     = wxEVT_TREE_END_LABEL_EDIT\nwxEVT_COMMAND_TREE_DELETE_ITEM        = wxEVT_TREE_DELETE_ITEM\nwxEVT_COMMAND_TREE_GET_INFO           = wxEVT_TREE_GET_INFO\nwxEVT_COMMAND_TREE_SET_INFO           = wxEVT_TREE_SET_INFO\nwxEVT_COMMAND_TREE_ITEM_EXPANDED      = wxEVT_TREE_ITEM_EXPANDED\nwxEVT_COMMAND_TREE_ITEM_EXPANDING     = wxEVT_TREE_ITEM_EXPANDING\nwxEVT_COMMAND_TREE_ITEM_COLLAPSED     = wxEVT_TREE_ITEM_COLLAPSED\nwxEVT_COMMAND_TREE_ITEM_COLLAPSING    = wxEVT_TREE_ITEM_COLLAPSING\nwxEVT_COMMAND_TREE_SEL_CHANGED        = wxEVT_TREE_SEL_CHANGED\nwxEVT_COMMAND_TREE_SEL_CHANGING       = wxEVT_TREE_SEL_CHANGING\nwxEVT_COMMAND_TREE_KEY_DOWN           = wxEVT_TREE_KEY_DOWN\nwxEVT_COMMAND_TREE_ITEM_ACTIVATED     = wxEVT_TREE_ITEM_ACTIVATED\nwxEVT_COMMAND_TREE_ITEM_RIGHT_CLICK   = wxEVT_TREE_ITEM_RIGHT_CLICK\nwxEVT_COMMAND_TREE_ITEM_MIDDLE_CLICK  = wxEVT_TREE_ITEM_MIDDLE_CLICK\nwxEVT_COMMAND_TREE_END_DRAG           = wxEVT_TREE_END_DRAG\nwxEVT_COMMAND_TREE_STATE_IMAGE_CLICK  = wxEVT_TREE_STATE_IMAGE_CLICK\nwxEVT_COMMAND_TREE_ITEM_GETTOOLTIP    = wxEVT_TREE_ITEM_GETTOOLTIP\nwxEVT_COMMAND_TREE_ITEM_MENU          = wxEVT_TREE_ITEM_MENU\n\nEVT_COLOURPICKER_CHANGED = wx.PyEventBinder( wxEVT_COLOURPICKER_CHANGED, 1 )\nEVT_COLOURPICKER_CURRENT_CHANGED = wx.PyEventBinder( wxEVT_COLOURPICKER_CURRENT_CHANGED, 1 )\nEVT_COLOURPICKER_DIALOG_CANCELLED = wx.PyEventBinder( wxEVT_COLOURPICKER_DIALOG_CANCELLED, 1 )\n\n# deprecated wxEVT alias\nwxEVT_COMMAND_COLOURPICKER_CHANGED  = wxEVT_COLOURPICKER_CHANGED\n\nEVT_FILEPICKER_CHANGED = wx.PyEventBinder( wxEVT_FILEPICKER_CHANGED, 1 )\nEVT_DIRPICKER_CHANGED = wx.PyEventBinder( wxEVT_DIRPICKER_CHANGED, 1 )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_FILEPICKER_CHANGED   = wxEVT_FILEPICKER_CHANGED\nwxEVT_COMMAND_DIRPICKER_CHANGED    = wxEVT_DIRPICKER_CHANGED\n\nEVT_FONTPICKER_CHANGED = wx.PyEventBinder( wxEVT_FONTPICKER_CHANGED, 1 )\n\n# deprecated wxEVT alias\nwxEVT_COMMAND_FONTPICKER_CHANGED  = wxEVT_FONTPICKER_CHANGED\n\nif 'wxMac' in wx.PlatformInfo:\n    class ColourPickerCtrl(PickerBase):\n        '''\n        This control allows the user to select a colour. The\n        implementation varies by platform but is usually a button which\n        brings up a `wx.ColourDialog` when clicked.\n\n\n        Window Styles\n        -------------\n\n            ======================  ============================================\n            wx.CLRP_DEFAULT         Default style.\n            wx.CLRP_USE_TEXTCTRL    Creates a text control to the left of the\n                                    picker button which is completely managed\n                                    by the `wx.ColourPickerCtrl` and which can\n                                    be used by the user to specify a colour.\n                                    The text control is automatically synchronized\n                                    with the button's value. Use functions defined in\n                                    `wx.PickerBase` to modify the text control.\n            wx.CLRP_SHOW_LABEL      Shows the colour in HTML form (AABBCC) as the\n                                    colour button label (instead of no label at all).\n            ======================  ============================================\n\n        Events\n        ------\n\n            ========================  ==========================================\n            EVT_COLOURPICKER_CHANGED  The user changed the colour selected in the\n                                      control either using the button or using the\n                                      text control (see wx.CLRP_USE_TEXTCTRL; note\n                                      that in this case the event is fired only if\n                                      the user's input is valid, i.e. recognizable).\n            ========================  ==========================================\n        '''\n\n        # ColourData object to be shared by all colour pickers, so they can\n        # share the custom colours\n        _colourData = None\n\n        #--------------------------------------------------\n        class ColourPickerButton(BitmapButton):\n            def __init__(self, parent, id=-1, colour=wx.BLACK,\n                         pos=wx.DefaultPosition, size=wx.DefaultSize,\n                         style = CLRP_DEFAULT_STYLE,\n                         validator = wx.DefaultValidator,\n                         name = \"colourpickerwidget\"):\n\n                wx.BitmapButton.__init__(self, parent, id, wx.Bitmap(1,1),\n                                         pos, size, style, validator, name)\n                self.SetColour(colour)\n                self.InvalidateBestSize()\n                self.SetInitialSize(size)\n                self.Bind(wx.EVT_BUTTON, self.OnButtonClick)\n\n                if ColourPickerCtrl._colourData is None:\n                    ColourPickerCtrl._colourData = wx.ColourData()\n                    ColourPickerCtrl._colourData.SetChooseFull(True)\n                    grey = 0\n                    for i in range(16):\n                        c = wx.Colour(grey, grey, grey)\n                        ColourPickerCtrl._colourData.SetCustomColour(i, c)\n                        grey += 16\n\n            def SetColour(self, colour):\n                # force a copy, in case the _colorData is shared\n                self.colour = wx.Colour(colour)\n                bmp = self._makeBitmap()\n                self.SetBitmapLabel(wx.BitmapBundle(bmp))\n\n            def GetColour(self):\n                return self.colour\n\n            def OnButtonClick(self, evt):\n                ColourPickerCtrl._colourData.SetColour(self.colour)\n                dlg = wx.ColourDialog(self, ColourPickerCtrl._colourData)\n                if dlg.ShowModal() == wx.ID_OK:\n                    ColourPickerCtrl._colourData = dlg.GetColourData()\n                    self.SetColour(ColourPickerCtrl._colourData.GetColour())\n                    evt = wx.ColourPickerEvent(self, self.GetId(), self.GetColour())\n                    self.GetEventHandler().ProcessEvent(evt)\n\n            def _makeBitmap(self):\n                width = height = 24\n                bg = self.GetColour()\n                if self.HasFlag(CLRP_SHOW_LABEL):\n                    w, h = self.GetTextExtent(bg.GetAsString(wx.C2S_HTML_SYNTAX))\n                    width += w\n                bmp = wx.Bitmap(width, height)\n                dc = wx.MemoryDC(bmp)\n                dc.SetBackground(wx.Brush(self.colour))\n                dc.Clear()\n                if self.HasFlag(CLRP_SHOW_LABEL):\n                    from wx.lib.colourutils import BestLabelColour\n                    fg = BestLabelColour(bg)\n                    dc.SetTextForeground(fg)\n                    dc.DrawText(bg.GetAsString(wx.C2S_HTML_SYNTAX),\n                                (width - w)/2, (height - h)/2)\n                return bmp\n\n        #--------------------------------------------------\n\n        def __init__(self, parent, id=-1, colour=wx.BLACK,\n                     pos=wx.DefaultPosition, size=wx.DefaultSize,\n                     style = CLRP_DEFAULT_STYLE,\n                     validator = wx.DefaultValidator,\n                     name = \"colourpicker\"):\n            if type(colour) != wx.Colour:\n                colour = wx.Colour(colour)\n            wx.PickerBase.__init__(self)\n            self.CreateBase(parent, id, colour.GetAsString(),\n                            pos, size, style, validator, name)\n            widget = ColourPickerCtrl.ColourPickerButton(\n                self, -1, colour, style=self.GetPickerStyle(style))\n            self.SetPickerCtrl(widget)\n            widget.Bind(wx.EVT_COLOURPICKER_CHANGED, self.OnColourChange)\n            self.PostCreation()\n\n\n        def GetColour(self):\n            '''Set the displayed colour.'''\n            return self.GetPickerCtrl().GetColour()\n\n        def SetColour(self, colour):\n            '''Returns the currently selected colour.'''\n            self.GetPickerCtrl().SetColour(colour)\n            self.UpdateTextCtrlFromPicker()\n        Colour = property(GetColour, SetColour)\n\n\n        def UpdatePickerFromTextCtrl(self):\n            col = wx.Colour(self.GetTextCtrl().GetValue())\n            if not col.IsOk():\n                return\n            if self.GetColour() != col:\n                self.GetPickerCtrl().SetColour(col)\n                evt = wx.ColourPickerEvent(self, self.GetId(), self.GetColour())\n                self.GetEventHandler().ProcessEvent(evt)\n\n        def UpdateTextCtrlFromPicker(self):\n            if not self.GetTextCtrl():\n                return\n            self.GetTextCtrl().SetValue(self.GetColour().GetAsString())\n\n        def GetPickerStyle(self, style):\n            return style & CLRP_SHOW_LABEL\n\n        def OnColourChange(self, evt):\n            self.UpdateTextCtrlFromPicker()\n            evt = wx.ColourPickerEvent(self, self.GetId(), self.GetColour())\n            self.GetEventHandler().ProcessEvent(evt)\n\nEVT_FILECTRL_SELECTIONCHANGED = wx.PyEventBinder( wxEVT_FILECTRL_SELECTIONCHANGED, 1)\nEVT_FILECTRL_FILEACTIVATED = wx.PyEventBinder( wxEVT_FILECTRL_FILEACTIVATED, 1)\nEVT_FILECTRL_FOLDERCHANGED = wx.PyEventBinder( wxEVT_FILECTRL_FOLDERCHANGED, 1)\nEVT_FILECTRL_FILTERCHANGED = wx.PyEventBinder( wxEVT_FILECTRL_FILTERCHANGED, 1)\n\nEVT_CHOICEBOOK_PAGE_CHANGED  = wx.PyEventBinder( wxEVT_CHOICEBOOK_PAGE_CHANGED, 1 )\nEVT_CHOICEBOOK_PAGE_CHANGING = wx.PyEventBinder( wxEVT_CHOICEBOOK_PAGE_CHANGING, 1 )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_CHOICEBOOK_PAGE_CHANGED   = wxEVT_CHOICEBOOK_PAGE_CHANGED\nwxEVT_COMMAND_CHOICEBOOK_PAGE_CHANGING  = wxEVT_CHOICEBOOK_PAGE_CHANGING\n\nEVT_LISTBOOK_PAGE_CHANGED  = wx.PyEventBinder( wxEVT_LISTBOOK_PAGE_CHANGED, 1 )\nEVT_LISTBOOK_PAGE_CHANGING = wx.PyEventBinder( wxEVT_LISTBOOK_PAGE_CHANGING, 1 )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_LISTBOOK_PAGE_CHANGED   = wxEVT_LISTBOOK_PAGE_CHANGED\nwxEVT_COMMAND_LISTBOOK_PAGE_CHANGING  = wxEVT_LISTBOOK_PAGE_CHANGING\n\nEVT_TOOLBOOK_PAGE_CHANGED  = wx.PyEventBinder( wxEVT_TOOLBOOK_PAGE_CHANGED, 1 )\nEVT_TOOLBOOK_PAGE_CHANGING = wx.PyEventBinder( wxEVT_TOOLBOOK_PAGE_CHANGING, 1 )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_TOOLBOOK_PAGE_CHANGED   = wxEVT_TOOLBOOK_PAGE_CHANGED\nwxEVT_COMMAND_TOOLBOOK_PAGE_CHANGING  = wxEVT_TOOLBOOK_PAGE_CHANGING\n\nEVT_TREEBOOK_PAGE_CHANGED = wx.PyEventBinder( wxEVT_TREEBOOK_PAGE_CHANGED, 1 )\nEVT_TREEBOOK_PAGE_CHANGING = wx.PyEventBinder( wxEVT_TREEBOOK_PAGE_CHANGING, 1)\nEVT_TREEBOOK_NODE_COLLAPSED = wx.PyEventBinder( wxEVT_TREEBOOK_NODE_COLLAPSED, 1 )\nEVT_TREEBOOK_NODE_EXPANDED = wx.PyEventBinder( wxEVT_TREEBOOK_NODE_EXPANDED, 1 )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_TREEBOOK_PAGE_CHANGED    = wxEVT_TREEBOOK_PAGE_CHANGED\nwxEVT_COMMAND_TREEBOOK_PAGE_CHANGING   = wxEVT_TREEBOOK_PAGE_CHANGING\nwxEVT_COMMAND_TREEBOOK_NODE_COLLAPSED  = wxEVT_TREEBOOK_NODE_COLLAPSED\nwxEVT_COMMAND_TREEBOOK_NODE_EXPANDED   = wxEVT_TREEBOOK_NODE_EXPANDED\n\nEVT_COLLAPSIBLEHEADER_CHANGED = PyEventBinder(wxEVT_COLLAPSIBLEHEADER_CHANGED, 1)\n\ndef _Dialog___enter__(self):\n    return self\nDialog.__enter__ = _Dialog___enter__\ndel _Dialog___enter__\ndef _Dialog___exit__(self, exc_type, exc_val, exc_tb):\n    self.Destroy()\nDialog.__exit__ = _Dialog___exit__\ndel _Dialog___exit__\nEVT_DIRCTRL_SELECTIONCHANGED = wx.PyEventBinder( wxEVT_DIRCTRL_SELECTIONCHANGED, 1 )\nEVT_DIRCTRL_FILEACTIVATED = wx.PyEventBinder( wxEVT_DIRCTRL_FILEACTIVATED, 1 )\n\nEVT_COLOUR_CHANGED = PyEventBinder(wxEVT_COLOUR_CHANGED, 1)\n\nEVT_FIND = wx.PyEventBinder( wxEVT_FIND, 1 )\nEVT_FIND_NEXT = wx.PyEventBinder( wxEVT_FIND_NEXT, 1 )\nEVT_FIND_REPLACE = wx.PyEventBinder( wxEVT_FIND_REPLACE, 1 )\nEVT_FIND_REPLACE_ALL = wx.PyEventBinder( wxEVT_FIND_REPLACE_ALL, 1 )\nEVT_FIND_CLOSE = wx.PyEventBinder( wxEVT_FIND_CLOSE, 1 )\n\n# deprecated wxEVT aliases\nwxEVT_COMMAND_FIND              = wxEVT_FIND\nwxEVT_COMMAND_FIND_NEXT         = wxEVT_FIND_NEXT\nwxEVT_COMMAND_FIND_REPLACE      = wxEVT_FIND_REPLACE\nwxEVT_COMMAND_FIND_REPLACE_ALL  = wxEVT_FIND_REPLACE_ALL\nwxEVT_COMMAND_FIND_CLOSE        = wxEVT_FIND_CLOSE\n\ndef _PowerResourceBlocker___enter__(self):\n    return self\nPowerResourceBlocker.__enter__ = _PowerResourceBlocker___enter__\ndel _PowerResourceBlocker___enter__\ndef _PowerResourceBlocker___exit__(self, exc_type, exc_val, exc_tb):\n    pass\nPowerResourceBlocker.__exit__ = _PowerResourceBlocker___exit__\ndel _PowerResourceBlocker___exit__\nEVT_POWER_SUSPENDING       = wx.PyEventBinder( wxEVT_POWER_SUSPENDING , 1 )\nEVT_POWER_SUSPENDED        = wx.PyEventBinder( wxEVT_POWER_SUSPENDED , 1 )\nEVT_POWER_SUSPEND_CANCEL   = wx.PyEventBinder( wxEVT_POWER_SUSPEND_CANCEL , 1 )\nEVT_POWER_RESUME           = wx.PyEventBinder( wxEVT_POWER_RESUME , 1 )\n\ndef _WindowDisabler___enter__(self):\n    return self\nWindowDisabler.__enter__ = _WindowDisabler___enter__\ndel _WindowDisabler___enter__\ndef _WindowDisabler___exit__(self, exc_type, exc_val, exc_tb):\n    pass\nWindowDisabler.__exit__ = _WindowDisabler___exit__\ndel _WindowDisabler___exit__\ndef _BusyCursor___enter__(self):\n    return self\nBusyCursor.__enter__ = _BusyCursor___enter__\ndel _BusyCursor___enter__\ndef _BusyCursor___exit__(self, exc_type, exc_val, exc_tb):\n    pass\nBusyCursor.__exit__ = _BusyCursor___exit__\ndel _BusyCursor___exit__\nEVT_END_PROCESS = wx.PyEventBinder( wxEVT_END_PROCESS )\n\ndef HelpController(parentWindow=None):\n    \"\"\"\n    Rather than being an alias for some class, the Python version of\n    ``HelpController`` is a factory function that creates and returns an\n    instance of the best Help Controller for the platform.\n    \"\"\"\n    try:\n        if 'wxMSW' in wx.PlatformInfo:\n            from .msw import CHMHelpController as ControllerClass\n        else:\n            from .html import HtmlHelpController as ControllerClass\n    except ImportError:\n        from .adv import ExtHelpController as ControllerClass\n    \n    return ControllerClass(parentWindow)\n\nPrintPreview.Ok = wx.deprecated(PrintPreview.IsOk, 'Use IsOk instead.')\n\nPyPrintPreview = wx.deprecated(PrintPreview, 'Use PrintPreview instead.')\n\nPyPreviewFrame = wx.deprecated(PreviewFrame, 'Use PreviewFrame instead.')\n\nPyPreviewControlBar = wx.deprecated(PreviewControlBar, 'Use PreviewControlBar instead.')\n\nPyPrintout = wx.deprecated(Printout, 'Use Printout instead.')\n\ndef _BusyInfo___enter__(self):\n    return self\nBusyInfo.__enter__ = _BusyInfo___enter__\ndel _BusyInfo___enter__\ndef _BusyInfo___exit__(self, exc_type, exc_val, exc_tb):\n    return False\nBusyInfo.__exit__ = _BusyInfo___exit__\ndel _BusyInfo___exit__\ndef _FileHistoryMenuList___repr__(self):\n    return \"FileHistoryMenuList: \" + repr(list(self))\nFileHistoryMenuList.__repr__ = _FileHistoryMenuList___repr__\ndel _FileHistoryMenuList___repr__\ndef _CommandList___repr__(self):\n    return \"CommandList: \" + repr(list(self))\nCommandList.__repr__ = _CommandList___repr__\ndel _CommandList___repr__\nEVT_FSWATCHER = wx.PyEventBinder(wxEVT_FSWATCHER)\n\ndef version():\n    \"\"\"\n    Returns a string containing version and port info\n    \"\"\"\n    if wx.Port == '__WXMSW__':\n        port = 'msw'\n    elif wx.Port == '__WXMAC__':\n        if 'wxOSX-carbon' in wx.PlatformInfo:\n            port = 'osx-carbon'\n        else:\n            port = 'osx-cocoa'\n    elif wx.Port == '__WXGTK__':\n        port = 'gtk'\n        if 'gtk2' in wx.PlatformInfo:\n            port = 'gtk2'\n        elif 'gtk3' in wx.PlatformInfo:\n            port = 'gtk3'\n    else:\n        port = '???'\n    return \"%s %s (phoenix) %s\" % (wx.VERSION_STRING, port, wx.wxWidgets_version)\n\ndef CallAfter(callableObj, *args, **kw):\n    \"\"\"\n    Call the specified function after the current and pending event\n    handlers have been completed.  This is also good for making GUI\n    method calls from non-GUI threads.  Any extra positional or\n    keyword args are passed on to the callable when it is called.\n    \n    :param PyObject callableObj: the callable object\n    :param args: arguments to be passed to the callable object\n    :param kw: keywords to be passed to the callable object\n    \n    .. seealso::\n        :ref:`wx.CallLater`\n    \"\"\"\n    assert callable(callableObj), \"callableObj is not callable\"\n    app = wx.GetApp()\n    assert app is not None, 'No wx.App created yet'\n    \n    if not hasattr(app, \"_CallAfterId\"):\n        app._CallAfterId = wx.NewEventType()\n        app.Connect(-1, -1, app._CallAfterId,\n                    lambda event: event.callable(*event.args, **event.kw) )\n    evt = wx.PyEvent()\n    evt.SetEventType(app._CallAfterId)\n    evt.callable = callableObj\n    evt.args = args\n    evt.kw = kw\n    wx.PostEvent(app, evt)\n\nclass CallLater(object):\n    \"\"\"\n    A convenience class for :class:`wx.Timer`, that calls the given callable\n    object once after the given amount of milliseconds, passing any\n    positional or keyword args.  The return value of the callable is\n    available after it has been run with the :meth:`~wx.CallLater.GetResult`\n    method.\n    \n    If you don't need to get the return value or restart the timer\n    then there is no need to hold a reference to this object. CallLater\n    maintains references to its instances while they are running. When they\n    finish, the internal reference is deleted and the GC is free to collect\n    naturally.\n    \n    .. seealso::\n        :func:`wx.CallAfter`\n    \"\"\"\n    __instances = {}\n    def __init__(self, millis, callableObj, *args, **kwargs):\n        \"\"\"\n        Constructs a new :class:`wx.CallLater` object.\n        \n        :param int millis: number of milliseconds to delay until calling the callable object\n        :param PyObject callableObj: the callable object\n        :param args: arguments to be passed to the callable object\n        :param kw: keyword arguments to be passed to the callable object\n        \"\"\"\n        assert callable(callableObj), \"callableObj is not callable\"\n        self.millis = millis\n        self.callable = callableObj\n        self.SetArgs(*args, **kwargs)\n        self.runCount = 0\n        self.running = False\n        self.hasRun = False\n        self.result = None\n        self.timer = None\n        self.Start()\n\n    def __del__(self):\n        self.Stop()\n\n    def Start(self, millis=None, *args, **kwargs):\n        \"\"\"\n        (Re)start the timer\n        \n        :param int millis: number of milli seconds\n        :param args: arguments to be passed to the callable object\n        :param kw: keywords to be passed to the callable object\n        \"\"\"\n        self.hasRun = False\n        if millis is not None:\n            self.millis = millis\n        if args or kwargs:\n            self.SetArgs(*args, **kwargs)\n        self.Stop()\n        CallLater.__instances[self] = \"value irrelevant\"  # Maintain a reference to avoid GC\n        self.timer = wx.PyTimer(self.Notify)\n        self.timer.Start(self.millis, wx.TIMER_ONE_SHOT)\n        self.running = True\n\n    Restart = Start\n    def Stop(self):\n        \"\"\"\n        Stop and destroy the timer.\n        \"\"\"\n        if self in CallLater.__instances:\n            del CallLater.__instances[self]\n        if self.timer is not None:\n            self.timer.Stop()\n            self.timer = None\n\n    def GetInterval(self):\n        if self.timer is not None:\n            return self.timer.GetInterval()\n        else:\n            return 0\n\n    def IsRunning(self):\n        return self.timer is not None and self.timer.IsRunning()\n\n    def SetArgs(self, *args, **kwargs):\n        \"\"\"\n        (Re)set the args passed to the callable object.  This is\n        useful in conjunction with :meth:`Start` if\n        you want to schedule a new call to the same callable\n        object but with different parameters.\n        \n        :param args: arguments to be passed to the callable object\n        :param kw: keywords to be passed to the callable object\n        \"\"\"\n        self.args = args\n        self.kwargs = kwargs\n\n    def HasRun(self):\n        \"\"\"\n        Returns whether or not the callable has run.\n        \n        :rtype: bool\n        \"\"\"\n        return self.hasRun\n\n    def GetResult(self):\n        \"\"\"\n        Returns the value of the callable.\n        \n        :rtype: a Python object\n        :return: result from callable\n        \"\"\"\n        return self.result\n\n    def Notify(self):\n        \"\"\"\n        The timer has expired so call the callable.\n        \"\"\"\n        if self.callable and getattr(self.callable, 'im_self', True):\n            self.runCount += 1\n            self.running = False\n            self.result = self.callable(*self.args, **self.kwargs)\n        self.hasRun = True\n        if not self.running:\n            # if it wasn't restarted, then cleanup\n            wx.CallAfter(self.Stop)\n\n    Interval = property(GetInterval)\n    Result = property(GetResult)\n\nFutureCall = deprecated(CallLater, 'Use CallLater instead.')\n\ndef GetDefaultPyEncoding():\n    return \"utf-8\"\nGetDefaultPyEncoding = deprecated(GetDefaultPyEncoding, msg=\"wxPython now always uses utf-8\")\n\n", 3566], "C:\\Programming\\Python313\\Lib\\locale.py": ["\"\"\"Locale support module.\n\nThe module provides low-level access to the C lib's locale APIs and adds high\nlevel number formatting APIs as well as a locale aliasing engine to complement\nthese.\n\nThe aliasing engine includes support for many commonly used locale names and\nmaps them to values suitable for passing to the C lib's setlocale() function. It\nalso includes default encodings for all supported locale names.\n\n\"\"\"\n\nimport sys\nimport encodings\nimport encodings.aliases\nimport re\nimport _collections_abc\nfrom builtins import str as _builtin_str\nimport functools\n\n# Try importing the _locale module.\n#\n# If this fails, fall back on a basic 'C' locale emulation.\n\n# Yuck:  LC_MESSAGES is non-standard:  can't tell whether it exists before\n# trying the import.  So __all__ is also fiddled at the end of the file.\n__all__ = [\"getlocale\", \"getdefaultlocale\", \"getpreferredencoding\", \"Error\",\n           \"setlocale\", \"localeconv\", \"strcoll\", \"strxfrm\",\n           \"str\", \"atof\", \"atoi\", \"format_string\", \"currency\",\n           \"normalize\", \"LC_CTYPE\", \"LC_COLLATE\", \"LC_TIME\", \"LC_MONETARY\",\n           \"LC_NUMERIC\", \"LC_ALL\", \"CHAR_MAX\", \"getencoding\"]\n\ndef _strcoll(a,b):\n    \"\"\" strcoll(string,string) -> int.\n        Compares two strings according to the locale.\n    \"\"\"\n    return (a > b) - (a < b)\n\ndef _strxfrm(s):\n    \"\"\" strxfrm(string) -> string.\n        Returns a string that behaves for cmp locale-aware.\n    \"\"\"\n    return s\n\ntry:\n\n    from _locale import *\n\nexcept ImportError:\n\n    # Locale emulation\n\n    CHAR_MAX = 127\n    LC_ALL = 6\n    LC_COLLATE = 3\n    LC_CTYPE = 0\n    LC_MESSAGES = 5\n    LC_MONETARY = 4\n    LC_NUMERIC = 1\n    LC_TIME = 2\n    Error = ValueError\n\n    def localeconv():\n        \"\"\" localeconv() -> dict.\n            Returns numeric and monetary locale-specific parameters.\n        \"\"\"\n        # 'C' locale default values\n        return {'grouping': [127],\n                'currency_symbol': '',\n                'n_sign_posn': 127,\n                'p_cs_precedes': 127,\n                'n_cs_precedes': 127,\n                'mon_grouping': [],\n                'n_sep_by_space': 127,\n                'decimal_point': '.',\n                'negative_sign': '',\n                'positive_sign': '',\n                'p_sep_by_space': 127,\n                'int_curr_symbol': '',\n                'p_sign_posn': 127,\n                'thousands_sep': '',\n                'mon_thousands_sep': '',\n                'frac_digits': 127,\n                'mon_decimal_point': '',\n                'int_frac_digits': 127}\n\n    def setlocale(category, value=None):\n        \"\"\" setlocale(integer,string=None) -> string.\n            Activates/queries locale processing.\n        \"\"\"\n        if value not in (None, '', 'C'):\n            raise Error('_locale emulation only supports \"C\" locale')\n        return 'C'\n\n# These may or may not exist in _locale, so be sure to set them.\nif 'strxfrm' not in globals():\n    strxfrm = _strxfrm\nif 'strcoll' not in globals():\n    strcoll = _strcoll\n\n\n_localeconv = localeconv\n\n# With this dict, you can override some items of localeconv's return value.\n# This is useful for testing purposes.\n_override_localeconv = {}\n\n@functools.wraps(_localeconv)\ndef localeconv():\n    d = _localeconv()\n    if _override_localeconv:\n        d.update(_override_localeconv)\n    return d\n\n\n### Number formatting APIs\n\n# Author: Martin von Loewis\n# improved by Georg Brandl\n\n# Iterate over grouping intervals\ndef _grouping_intervals(grouping):\n    last_interval = None\n    for interval in grouping:\n        # if grouping is -1, we are done\n        if interval == CHAR_MAX:\n            return\n        # 0: re-use last group ad infinitum\n        if interval == 0:\n            if last_interval is None:\n                raise ValueError(\"invalid grouping\")\n            while True:\n                yield last_interval\n        yield interval\n        last_interval = interval\n\n#perform the grouping from right to left\ndef _group(s, monetary=False):\n    conv = localeconv()\n    thousands_sep = conv[monetary and 'mon_thousands_sep' or 'thousands_sep']\n    grouping = conv[monetary and 'mon_grouping' or 'grouping']\n    if not grouping:\n        return (s, 0)\n    if s[-1] == ' ':\n        stripped = s.rstrip()\n        right_spaces = s[len(stripped):]\n        s = stripped\n    else:\n        right_spaces = ''\n    left_spaces = ''\n    groups = []\n    for interval in _grouping_intervals(grouping):\n        if not s or s[-1] not in \"0123456789\":\n            # only non-digit characters remain (sign, spaces)\n            left_spaces = s\n            s = ''\n            break\n        groups.append(s[-interval:])\n        s = s[:-interval]\n    if s:\n        groups.append(s)\n    groups.reverse()\n    return (\n        left_spaces + thousands_sep.join(groups) + right_spaces,\n        len(thousands_sep) * (len(groups) - 1)\n    )\n\n# Strip a given amount of excess padding from the given string\ndef _strip_padding(s, amount):\n    lpos = 0\n    while amount and s[lpos] == ' ':\n        lpos += 1\n        amount -= 1\n    rpos = len(s) - 1\n    while amount and s[rpos] == ' ':\n        rpos -= 1\n        amount -= 1\n    return s[lpos:rpos+1]\n\n_percent_re = re.compile(r'%(?:\\((?P<key>.*?)\\))?'\n                         r'(?P<modifiers>[-#0-9 +*.hlL]*?)[eEfFgGdiouxXcrs%]')\n\ndef _format(percent, value, grouping=False, monetary=False, *additional):\n    if additional:\n        formatted = percent % ((value,) + additional)\n    else:\n        formatted = percent % value\n    if percent[-1] in 'eEfFgGdiu':\n        formatted = _localize(formatted, grouping, monetary)\n    return formatted\n\n# Transform formatted as locale number according to the locale settings\ndef _localize(formatted, grouping=False, monetary=False):\n    # floats and decimal ints need special action!\n    if '.' in formatted:\n        seps = 0\n        parts = formatted.split('.')\n        if grouping:\n            parts[0], seps = _group(parts[0], monetary=monetary)\n        decimal_point = localeconv()[monetary and 'mon_decimal_point'\n                                              or 'decimal_point']\n        formatted = decimal_point.join(parts)\n        if seps:\n            formatted = _strip_padding(formatted, seps)\n    else:\n        seps = 0\n        if grouping:\n            formatted, seps = _group(formatted, monetary=monetary)\n        if seps:\n            formatted = _strip_padding(formatted, seps)\n    return formatted\n\ndef format_string(f, val, grouping=False, monetary=False):\n    \"\"\"Formats a string in the same way that the % formatting would use,\n    but takes the current locale into account.\n\n    Grouping is applied if the third parameter is true.\n    Conversion uses monetary thousands separator and grouping strings if\n    forth parameter monetary is true.\"\"\"\n    percents = list(_percent_re.finditer(f))\n    new_f = _percent_re.sub('%s', f)\n\n    if isinstance(val, _collections_abc.Mapping):\n        new_val = []\n        for perc in percents:\n            if perc.group()[-1]=='%':\n                new_val.append('%')\n            else:\n                new_val.append(_format(perc.group(), val, grouping, monetary))\n    else:\n        if not isinstance(val, tuple):\n            val = (val,)\n        new_val = []\n        i = 0\n        for perc in percents:\n            if perc.group()[-1]=='%':\n                new_val.append('%')\n            else:\n                starcount = perc.group('modifiers').count('*')\n                new_val.append(_format(perc.group(),\n                                      val[i],\n                                      grouping,\n                                      monetary,\n                                      *val[i+1:i+1+starcount]))\n                i += (1 + starcount)\n    val = tuple(new_val)\n\n    return new_f % val\n\ndef currency(val, symbol=True, grouping=False, international=False):\n    \"\"\"Formats val according to the currency settings\n    in the current locale.\"\"\"\n    conv = localeconv()\n\n    # check for illegal values\n    digits = conv[international and 'int_frac_digits' or 'frac_digits']\n    if digits == 127:\n        raise ValueError(\"Currency formatting is not possible using \"\n                         \"the 'C' locale.\")\n\n    s = _localize(f'{abs(val):.{digits}f}', grouping, monetary=True)\n    # '<' and '>' are markers if the sign must be inserted between symbol and value\n    s = '<' + s + '>'\n\n    if symbol:\n        smb = conv[international and 'int_curr_symbol' or 'currency_symbol']\n        precedes = conv[val<0 and 'n_cs_precedes' or 'p_cs_precedes']\n        separated = conv[val<0 and 'n_sep_by_space' or 'p_sep_by_space']\n\n        if precedes:\n            s = smb + (separated and ' ' or '') + s\n        else:\n            if international and smb[-1] == ' ':\n                smb = smb[:-1]\n            s = s + (separated and ' ' or '') + smb\n\n    sign_pos = conv[val<0 and 'n_sign_posn' or 'p_sign_posn']\n    sign = conv[val<0 and 'negative_sign' or 'positive_sign']\n\n    if sign_pos == 0:\n        s = '(' + s + ')'\n    elif sign_pos == 1:\n        s = sign + s\n    elif sign_pos == 2:\n        s = s + sign\n    elif sign_pos == 3:\n        s = s.replace('<', sign)\n    elif sign_pos == 4:\n        s = s.replace('>', sign)\n    else:\n        # the default if nothing specified;\n        # this should be the most fitting sign position\n        s = sign + s\n\n    return s.replace('<', '').replace('>', '')\n\ndef str(val):\n    \"\"\"Convert float to string, taking the locale into account.\"\"\"\n    return _format(\"%.12g\", val)\n\ndef delocalize(string):\n    \"Parses a string as a normalized number according to the locale settings.\"\n\n    conv = localeconv()\n\n    #First, get rid of the grouping\n    ts = conv['thousands_sep']\n    if ts:\n        string = string.replace(ts, '')\n\n    #next, replace the decimal point with a dot\n    dd = conv['decimal_point']\n    if dd:\n        string = string.replace(dd, '.')\n    return string\n\ndef localize(string, grouping=False, monetary=False):\n    \"\"\"Parses a string as locale number according to the locale settings.\"\"\"\n    return _localize(string, grouping, monetary)\n\ndef atof(string, func=float):\n    \"Parses a string as a float according to the locale settings.\"\n    return func(delocalize(string))\n\ndef atoi(string):\n    \"Converts a string to an integer according to the locale settings.\"\n    return int(delocalize(string))\n\ndef _test():\n    setlocale(LC_ALL, \"\")\n    #do grouping\n    s1 = format_string(\"%d\", 123456789,1)\n    print(s1, \"is\", atoi(s1))\n    #standard formatting\n    s1 = str(3.14)\n    print(s1, \"is\", atof(s1))\n\n### Locale name aliasing engine\n\n# Author: Marc-Andre Lemburg, mal@lemburg.com\n# Various tweaks by Fredrik Lundh <fredrik@pythonware.com>\n\n# store away the low-level version of setlocale (it's\n# overridden below)\n_setlocale = setlocale\n\ndef _replace_encoding(code, encoding):\n    if '.' in code:\n        langname = code[:code.index('.')]\n    else:\n        langname = code\n    # Convert the encoding to a C lib compatible encoding string\n    norm_encoding = encodings.normalize_encoding(encoding)\n    #print('norm encoding: %r' % norm_encoding)\n    norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),\n                                                  norm_encoding)\n    #print('aliased encoding: %r' % norm_encoding)\n    encoding = norm_encoding\n    norm_encoding = norm_encoding.lower()\n    if norm_encoding in locale_encoding_alias:\n        encoding = locale_encoding_alias[norm_encoding]\n    else:\n        norm_encoding = norm_encoding.replace('_', '')\n        norm_encoding = norm_encoding.replace('-', '')\n        if norm_encoding in locale_encoding_alias:\n            encoding = locale_encoding_alias[norm_encoding]\n    #print('found encoding %r' % encoding)\n    return langname + '.' + encoding\n\ndef _append_modifier(code, modifier):\n    if modifier == 'euro':\n        if '.' not in code:\n            return code + '.ISO8859-15'\n        _, _, encoding = code.partition('.')\n        if encoding in ('ISO8859-15', 'UTF-8'):\n            return code\n        if encoding == 'ISO8859-1':\n            return _replace_encoding(code, 'ISO8859-15')\n    return code + '@' + modifier\n\ndef normalize(localename):\n\n    \"\"\" Returns a normalized locale code for the given locale\n        name.\n\n        The returned locale code is formatted for use with\n        setlocale().\n\n        If normalization fails, the original name is returned\n        unchanged.\n\n        If the given encoding is not known, the function defaults to\n        the default encoding for the locale code just like setlocale()\n        does.\n\n    \"\"\"\n    # Normalize the locale name and extract the encoding and modifier\n    code = localename.lower()\n    if ':' in code:\n        # ':' is sometimes used as encoding delimiter.\n        code = code.replace(':', '.')\n    if '@' in code:\n        code, modifier = code.split('@', 1)\n    else:\n        modifier = ''\n    if '.' in code:\n        langname, encoding = code.split('.')[:2]\n    else:\n        langname = code\n        encoding = ''\n\n    # First lookup: fullname (possibly with encoding and modifier)\n    lang_enc = langname\n    if encoding:\n        norm_encoding = encoding.replace('-', '')\n        norm_encoding = norm_encoding.replace('_', '')\n        lang_enc += '.' + norm_encoding\n    lookup_name = lang_enc\n    if modifier:\n        lookup_name += '@' + modifier\n    code = locale_alias.get(lookup_name, None)\n    if code is not None:\n        return code\n    #print('first lookup failed')\n\n    if modifier:\n        # Second try: fullname without modifier (possibly with encoding)\n        code = locale_alias.get(lang_enc, None)\n        if code is not None:\n            #print('lookup without modifier succeeded')\n            if '@' not in code:\n                return _append_modifier(code, modifier)\n            if code.split('@', 1)[1].lower() == modifier:\n                return code\n        #print('second lookup failed')\n\n    if encoding:\n        # Third try: langname (without encoding, possibly with modifier)\n        lookup_name = langname\n        if modifier:\n            lookup_name += '@' + modifier\n        code = locale_alias.get(lookup_name, None)\n        if code is not None:\n            #print('lookup without encoding succeeded')\n            if '@' not in code:\n                return _replace_encoding(code, encoding)\n            code, modifier = code.split('@', 1)\n            return _replace_encoding(code, encoding) + '@' + modifier\n\n        if modifier:\n            # Fourth try: langname (without encoding and modifier)\n            code = locale_alias.get(langname, None)\n            if code is not None:\n                #print('lookup without modifier and encoding succeeded')\n                if '@' not in code:\n                    code = _replace_encoding(code, encoding)\n                    return _append_modifier(code, modifier)\n                code, defmod = code.split('@', 1)\n                if defmod.lower() == modifier:\n                    return _replace_encoding(code, encoding) + '@' + defmod\n\n    return localename\n\ndef _parse_localename(localename):\n\n    \"\"\" Parses the locale code for localename and returns the\n        result as tuple (language code, encoding).\n\n        The localename is normalized and passed through the locale\n        alias engine. A ValueError is raised in case the locale name\n        cannot be parsed.\n\n        The language code corresponds to RFC 1766.  code and encoding\n        can be None in case the values cannot be determined or are\n        unknown to this implementation.\n\n    \"\"\"\n    code = normalize(localename)\n    if '@' in code:\n        # Deal with locale modifiers\n        code, modifier = code.split('@', 1)\n        if modifier == 'euro' and '.' not in code:\n            # Assume Latin-9 for @euro locales. This is bogus,\n            # since some systems may use other encodings for these\n            # locales. Also, we ignore other modifiers.\n            return code, 'iso-8859-15'\n\n    if '.' in code:\n        return tuple(code.split('.')[:2])\n    elif code == 'C':\n        return None, None\n    elif code == 'UTF-8':\n        # On macOS \"LC_CTYPE=UTF-8\" is a valid locale setting\n        # for getting UTF-8 handling for text.\n        return None, 'UTF-8'\n    raise ValueError('unknown locale: %s' % localename)\n\ndef _build_localename(localetuple):\n\n    \"\"\" Builds a locale code from the given tuple (language code,\n        encoding).\n\n        No aliasing or normalizing takes place.\n\n    \"\"\"\n    try:\n        language, encoding = localetuple\n\n        if language is None:\n            language = 'C'\n        if encoding is None:\n            return language\n        else:\n            return language + '.' + encoding\n    except (TypeError, ValueError):\n        raise TypeError('Locale must be None, a string, or an iterable of '\n                        'two strings -- language code, encoding.') from None\n\ndef getdefaultlocale(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE')):\n\n    \"\"\" Tries to determine the default locale settings and returns\n        them as tuple (language code, encoding).\n\n        According to POSIX, a program which has not called\n        setlocale(LC_ALL, \"\") runs using the portable 'C' locale.\n        Calling setlocale(LC_ALL, \"\") lets it use the default locale as\n        defined by the LANG variable. Since we don't want to interfere\n        with the current locale setting we thus emulate the behavior\n        in the way described above.\n\n        To maintain compatibility with other platforms, not only the\n        LANG variable is tested, but a list of variables given as\n        envvars parameter. The first found to be defined will be\n        used. envvars defaults to the search path used in GNU gettext;\n        it must always contain the variable name 'LANG'.\n\n        Except for the code 'C', the language code corresponds to RFC\n        1766.  code and encoding can be None in case the values cannot\n        be determined.\n\n    \"\"\"\n\n    import warnings\n    warnings._deprecated(\n        \"locale.getdefaultlocale\",\n        \"{name!r} is deprecated and slated for removal in Python {remove}. \"\n        \"Use setlocale(), getencoding() and getlocale() instead.\",\n        remove=(3, 15))\n    return _getdefaultlocale(envvars)\n\n\ndef _getdefaultlocale(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE')):\n    try:\n        # check if it's supported by the _locale module\n        import _locale\n        code, encoding = _locale._getdefaultlocale()\n    except (ImportError, AttributeError):\n        pass\n    else:\n        # make sure the code/encoding values are valid\n        if sys.platform == \"win32\" and code and code[:2] == \"0x\":\n            # map windows language identifier to language name\n            code = windows_locale.get(int(code, 0))\n        # ...add other platform-specific processing here, if\n        # necessary...\n        return code, encoding\n\n    # fall back on POSIX behaviour\n    import os\n    lookup = os.environ.get\n    for variable in envvars:\n        localename = lookup(variable,None)\n        if localename:\n            if variable == 'LANGUAGE':\n                localename = localename.split(':')[0]\n            break\n    else:\n        localename = 'C'\n    return _parse_localename(localename)\n\n\ndef getlocale(category=LC_CTYPE):\n\n    \"\"\" Returns the current setting for the given locale category as\n        tuple (language code, encoding).\n\n        category may be one of the LC_* value except LC_ALL. It\n        defaults to LC_CTYPE.\n\n        Except for the code 'C', the language code corresponds to RFC\n        1766.  code and encoding can be None in case the values cannot\n        be determined.\n\n    \"\"\"\n    localename = _setlocale(category)\n    if category == LC_ALL and ';' in localename:\n        raise TypeError('category LC_ALL is not supported')\n    return _parse_localename(localename)\n\ndef setlocale(category, locale=None):\n\n    \"\"\" Set the locale for the given category.  The locale can be\n        a string, an iterable of two strings (language code and encoding),\n        or None.\n\n        Iterables are converted to strings using the locale aliasing\n        engine.  Locale strings are passed directly to the C lib.\n\n        category may be given as one of the LC_* values.\n\n    \"\"\"\n    if locale and not isinstance(locale, _builtin_str):\n        # convert to string\n        locale = normalize(_build_localename(locale))\n    return _setlocale(category, locale)\n\n\ntry:\n    from _locale import getencoding\nexcept ImportError:\n    # When _locale.getencoding() is missing, locale.getencoding() uses the\n    # Python filesystem encoding.\n    def getencoding():\n        return sys.getfilesystemencoding()\n\n\ntry:\n    CODESET\nexcept NameError:\n    def getpreferredencoding(do_setlocale=True):\n        \"\"\"Return the charset that the user is likely using.\"\"\"\n        if sys.flags.warn_default_encoding:\n            import warnings\n            warnings.warn(\n                \"UTF-8 Mode affects locale.getpreferredencoding(). Consider locale.getencoding() instead.\",\n                EncodingWarning, 2)\n        if sys.flags.utf8_mode:\n            return 'utf-8'\n        return getencoding()\nelse:\n    # On Unix, if CODESET is available, use that.\n    def getpreferredencoding(do_setlocale=True):\n        \"\"\"Return the charset that the user is likely using,\n        according to the system configuration.\"\"\"\n\n        if sys.flags.warn_default_encoding:\n            import warnings\n            warnings.warn(\n                \"UTF-8 Mode affects locale.getpreferredencoding(). Consider locale.getencoding() instead.\",\n                EncodingWarning, 2)\n        if sys.flags.utf8_mode:\n            return 'utf-8'\n\n        if not do_setlocale:\n            return getencoding()\n\n        old_loc = setlocale(LC_CTYPE)\n        try:\n            try:\n                setlocale(LC_CTYPE, \"\")\n            except Error:\n                pass\n            return getencoding()\n        finally:\n            setlocale(LC_CTYPE, old_loc)\n\n\n### Database\n#\n# The following data was extracted from the locale.alias file which\n# comes with X11 and then hand edited removing the explicit encoding\n# definitions and adding some more aliases. The file is usually\n# available as /usr/lib/X11/locale/locale.alias.\n#\n\n#\n# The local_encoding_alias table maps lowercase encoding alias names\n# to C locale encoding names (case-sensitive). Note that normalize()\n# first looks up the encoding in the encodings.aliases dictionary and\n# then applies this mapping to find the correct C lib name for the\n# encoding.\n#\nlocale_encoding_alias = {\n\n    # Mappings for non-standard encoding names used in locale names\n    '437':                          'C',\n    'c':                            'C',\n    'en':                           'ISO8859-1',\n    'jis':                          'JIS7',\n    'jis7':                         'JIS7',\n    'ajec':                         'eucJP',\n    'koi8c':                        'KOI8-C',\n    'microsoftcp1251':              'CP1251',\n    'microsoftcp1255':              'CP1255',\n    'microsoftcp1256':              'CP1256',\n    '88591':                        'ISO8859-1',\n    '88592':                        'ISO8859-2',\n    '88595':                        'ISO8859-5',\n    '885915':                       'ISO8859-15',\n\n    # Mappings from Python codec names to C lib encoding names\n    'ascii':                        'ISO8859-1',\n    'latin_1':                      'ISO8859-1',\n    'iso8859_1':                    'ISO8859-1',\n    'iso8859_10':                   'ISO8859-10',\n    'iso8859_11':                   'ISO8859-11',\n    'iso8859_13':                   'ISO8859-13',\n    'iso8859_14':                   'ISO8859-14',\n    'iso8859_15':                   'ISO8859-15',\n    'iso8859_16':                   'ISO8859-16',\n    'iso8859_2':                    'ISO8859-2',\n    'iso8859_3':                    'ISO8859-3',\n    'iso8859_4':                    'ISO8859-4',\n    'iso8859_5':                    'ISO8859-5',\n    'iso8859_6':                    'ISO8859-6',\n    'iso8859_7':                    'ISO8859-7',\n    'iso8859_8':                    'ISO8859-8',\n    'iso8859_9':                    'ISO8859-9',\n    'iso2022_jp':                   'JIS7',\n    'shift_jis':                    'SJIS',\n    'tactis':                       'TACTIS',\n    'euc_jp':                       'eucJP',\n    'euc_kr':                       'eucKR',\n    'utf_8':                        'UTF-8',\n    'koi8_r':                       'KOI8-R',\n    'koi8_t':                       'KOI8-T',\n    'koi8_u':                       'KOI8-U',\n    'kz1048':                       'RK1048',\n    'cp1251':                       'CP1251',\n    'cp1255':                       'CP1255',\n    'cp1256':                       'CP1256',\n\n    # XXX This list is still incomplete. If you know more\n    # mappings, please file a bug report. Thanks.\n}\n\nfor k, v in sorted(locale_encoding_alias.items()):\n    k = k.replace('_', '')\n    locale_encoding_alias.setdefault(k, v)\ndel k, v\n\n#\n# The locale_alias table maps lowercase alias names to C locale names\n# (case-sensitive). Encodings are always separated from the locale\n# name using a dot ('.'); they should only be given in case the\n# language name is needed to interpret the given encoding alias\n# correctly (CJK codes often have this need).\n#\n# Note that the normalize() function which uses this tables\n# removes '_' and '-' characters from the encoding part of the\n# locale name before doing the lookup. This saves a lot of\n# space in the table.\n#\n# MAL 2004-12-10:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 2.4\n# and older):\n#\n#    updated 'bg' -> 'bg_BG.ISO8859-5' to 'bg_BG.CP1251'\n#    updated 'bg_bg' -> 'bg_BG.ISO8859-5' to 'bg_BG.CP1251'\n#    updated 'bulgarian' -> 'bg_BG.ISO8859-5' to 'bg_BG.CP1251'\n#    updated 'cz' -> 'cz_CZ.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'cz_cz' -> 'cz_CZ.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'czech' -> 'cs_CS.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'dutch' -> 'nl_BE.ISO8859-1' to 'nl_NL.ISO8859-1'\n#    updated 'et' -> 'et_EE.ISO8859-4' to 'et_EE.ISO8859-15'\n#    updated 'et_ee' -> 'et_EE.ISO8859-4' to 'et_EE.ISO8859-15'\n#    updated 'fi' -> 'fi_FI.ISO8859-1' to 'fi_FI.ISO8859-15'\n#    updated 'fi_fi' -> 'fi_FI.ISO8859-1' to 'fi_FI.ISO8859-15'\n#    updated 'iw' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'iw_il' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'japanese' -> 'ja_JP.SJIS' to 'ja_JP.eucJP'\n#    updated 'lt' -> 'lt_LT.ISO8859-4' to 'lt_LT.ISO8859-13'\n#    updated 'lv' -> 'lv_LV.ISO8859-4' to 'lv_LV.ISO8859-13'\n#    updated 'sl' -> 'sl_CS.ISO8859-2' to 'sl_SI.ISO8859-2'\n#    updated 'slovene' -> 'sl_CS.ISO8859-2' to 'sl_SI.ISO8859-2'\n#    updated 'th_th' -> 'th_TH.TACTIS' to 'th_TH.ISO8859-11'\n#    updated 'zh_cn' -> 'zh_CN.eucCN' to 'zh_CN.gb2312'\n#    updated 'zh_cn.big5' -> 'zh_TW.eucTW' to 'zh_TW.big5'\n#    updated 'zh_tw' -> 'zh_TW.eucTW' to 'zh_TW.big5'\n#\n# MAL 2008-05-30:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 2.5\n# and older):\n#\n#    updated 'cs_cs.iso88592' -> 'cs_CZ.ISO8859-2' to 'cs_CS.ISO8859-2'\n#    updated 'serbocroatian' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sh' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sh_hr.iso88592' -> 'sh_HR.ISO8859-2' to 'hr_HR.ISO8859-2'\n#    updated 'sh_sp' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sh_yu' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sp' -> 'sp_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sp_yu' -> 'sp_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr@cyrillic' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_sp' -> 'sr_SP.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sr_yu' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_yu.cp1251@cyrillic' -> 'sr_YU.CP1251' to 'sr_CS.CP1251'\n#    updated 'sr_yu.iso88592' -> 'sr_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sr_yu.iso88595' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_yu.iso88595@cyrillic' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_yu.microsoftcp1251@cyrillic' -> 'sr_YU.CP1251' to 'sr_CS.CP1251'\n#    updated 'sr_yu.utf8@cyrillic' -> 'sr_YU.UTF-8' to 'sr_CS.UTF-8'\n#    updated 'sr_yu@cyrillic' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#\n# AP 2010-04-12:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 2.6.5\n# and older):\n#\n#    updated 'ru' -> 'ru_RU.ISO8859-5' to 'ru_RU.UTF-8'\n#    updated 'ru_ru' -> 'ru_RU.ISO8859-5' to 'ru_RU.UTF-8'\n#    updated 'serbocroatian' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sh' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sh_yu' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sr' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8'\n#    updated 'sr@cyrillic' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8'\n#    updated 'sr@latn' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_cs.utf8@latn' -> 'sr_CS.UTF-8' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_cs@latn' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_yu' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_yu.utf8@cyrillic' -> 'sr_CS.UTF-8' to 'sr_RS.UTF-8'\n#    updated 'sr_yu@cyrillic' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8'\n#\n# SS 2013-12-20:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 3.3.3\n# and older):\n#\n#    updated 'a3' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'\n#    updated 'a3_az' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'\n#    updated 'a3_az.koi8c' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'\n#    updated 'cs_cs.iso88592' -> 'cs_CS.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'hebrew' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'hebrew.iso88598' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'sd' -> 'sd_IN@devanagari.UTF-8' to 'sd_IN.UTF-8'\n#    updated 'sr@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'\n#    updated 'sr_cs' -> 'sr_RS.UTF-8' to 'sr_CS.UTF-8'\n#    updated 'sr_cs.utf8@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'\n#    updated 'sr_cs@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'\n#\n# SS 2014-10-01:\n# Updated alias mapping with glibc 2.19 supported locales.\n#\n# SS 2018-05-05:\n# Updated alias mapping with glibc 2.27 supported locales.\n#\n# These are the differences compared to the old mapping (Python 3.6.5\n# and older):\n#\n#    updated 'ca_es@valencia' -> 'ca_ES.ISO8859-15@valencia' to 'ca_ES.UTF-8@valencia'\n#    updated 'kk_kz' -> 'kk_KZ.RK1048' to 'kk_KZ.ptcp154'\n#    updated 'russian' -> 'ru_RU.ISO8859-5' to 'ru_RU.KOI8-R'\n\nlocale_alias = {\n    'a3':                                   'az_AZ.KOI8-C',\n    'a3_az':                                'az_AZ.KOI8-C',\n    'a3_az.koic':                           'az_AZ.KOI8-C',\n    'aa_dj':                                'aa_DJ.ISO8859-1',\n    'aa_er':                                'aa_ER.UTF-8',\n    'aa_et':                                'aa_ET.UTF-8',\n    'af':                                   'af_ZA.ISO8859-1',\n    'af_za':                                'af_ZA.ISO8859-1',\n    'agr_pe':                               'agr_PE.UTF-8',\n    'ak_gh':                                'ak_GH.UTF-8',\n    'am':                                   'am_ET.UTF-8',\n    'am_et':                                'am_ET.UTF-8',\n    'american':                             'en_US.ISO8859-1',\n    'an_es':                                'an_ES.ISO8859-15',\n    'anp_in':                               'anp_IN.UTF-8',\n    'ar':                                   'ar_AA.ISO8859-6',\n    'ar_aa':                                'ar_AA.ISO8859-6',\n    'ar_ae':                                'ar_AE.ISO8859-6',\n    'ar_bh':                                'ar_BH.ISO8859-6',\n    'ar_dz':                                'ar_DZ.ISO8859-6',\n    'ar_eg':                                'ar_EG.ISO8859-6',\n    'ar_in':                                'ar_IN.UTF-8',\n    'ar_iq':                                'ar_IQ.ISO8859-6',\n    'ar_jo':                                'ar_JO.ISO8859-6',\n    'ar_kw':                                'ar_KW.ISO8859-6',\n    'ar_lb':                                'ar_LB.ISO8859-6',\n    'ar_ly':                                'ar_LY.ISO8859-6',\n    'ar_ma':                                'ar_MA.ISO8859-6',\n    'ar_om':                                'ar_OM.ISO8859-6',\n    'ar_qa':                                'ar_QA.ISO8859-6',\n    'ar_sa':                                'ar_SA.ISO8859-6',\n    'ar_sd':                                'ar_SD.ISO8859-6',\n    'ar_ss':                                'ar_SS.UTF-8',\n    'ar_sy':                                'ar_SY.ISO8859-6',\n    'ar_tn':                                'ar_TN.ISO8859-6',\n    'ar_ye':                                'ar_YE.ISO8859-6',\n    'arabic':                               'ar_AA.ISO8859-6',\n    'as':                                   'as_IN.UTF-8',\n    'as_in':                                'as_IN.UTF-8',\n    'ast_es':                               'ast_ES.ISO8859-15',\n    'ayc_pe':                               'ayc_PE.UTF-8',\n    'az':                                   'az_AZ.ISO8859-9E',\n    'az_az':                                'az_AZ.ISO8859-9E',\n    'az_az.iso88599e':                      'az_AZ.ISO8859-9E',\n    'az_ir':                                'az_IR.UTF-8',\n    'be':                                   'be_BY.CP1251',\n    'be@latin':                             'be_BY.UTF-8@latin',\n    'be_bg.utf8':                           'bg_BG.UTF-8',\n    'be_by':                                'be_BY.CP1251',\n    'be_by@latin':                          'be_BY.UTF-8@latin',\n    'bem_zm':                               'bem_ZM.UTF-8',\n    'ber_dz':                               'ber_DZ.UTF-8',\n    'ber_ma':                               'ber_MA.UTF-8',\n    'bg':                                   'bg_BG.CP1251',\n    'bg_bg':                                'bg_BG.CP1251',\n    'bhb_in.utf8':                          'bhb_IN.UTF-8',\n    'bho_in':                               'bho_IN.UTF-8',\n    'bho_np':                               'bho_NP.UTF-8',\n    'bi_vu':                                'bi_VU.UTF-8',\n    'bn_bd':                                'bn_BD.UTF-8',\n    'bn_in':                                'bn_IN.UTF-8',\n    'bo_cn':                                'bo_CN.UTF-8',\n    'bo_in':                                'bo_IN.UTF-8',\n    'bokmal':                               'nb_NO.ISO8859-1',\n    'bokm\\xe5l':                            'nb_NO.ISO8859-1',\n    'br':                                   'br_FR.ISO8859-1',\n    'br_fr':                                'br_FR.ISO8859-1',\n    'brx_in':                               'brx_IN.UTF-8',\n    'bs':                                   'bs_BA.ISO8859-2',\n    'bs_ba':                                'bs_BA.ISO8859-2',\n    'bulgarian':                            'bg_BG.CP1251',\n    'byn_er':                               'byn_ER.UTF-8',\n    'c':                                    'C',\n    'c-french':                             'fr_CA.ISO8859-1',\n    'c.ascii':                              'C',\n    'c.en':                                 'C',\n    'c.iso88591':                           'en_US.ISO8859-1',\n    'c.utf8':                               'C.UTF-8',\n    'c_c':                                  'C',\n    'c_c.c':                                'C',\n    'ca':                                   'ca_ES.ISO8859-1',\n    'ca_ad':                                'ca_AD.ISO8859-1',\n    'ca_es':                                'ca_ES.ISO8859-1',\n    'ca_es@valencia':                       'ca_ES.UTF-8@valencia',\n    'ca_fr':                                'ca_FR.ISO8859-1',\n    'ca_it':                                'ca_IT.ISO8859-1',\n    'catalan':                              'ca_ES.ISO8859-1',\n    'ce_ru':                                'ce_RU.UTF-8',\n    'cextend':                              'en_US.ISO8859-1',\n    'chinese-s':                            'zh_CN.eucCN',\n    'chinese-t':                            'zh_TW.eucTW',\n    'chr_us':                               'chr_US.UTF-8',\n    'ckb_iq':                               'ckb_IQ.UTF-8',\n    'cmn_tw':                               'cmn_TW.UTF-8',\n    'crh_ua':                               'crh_UA.UTF-8',\n    'croatian':                             'hr_HR.ISO8859-2',\n    'cs':                                   'cs_CZ.ISO8859-2',\n    'cs_cs':                                'cs_CZ.ISO8859-2',\n    'cs_cz':                                'cs_CZ.ISO8859-2',\n    'csb_pl':                               'csb_PL.UTF-8',\n    'cv_ru':                                'cv_RU.UTF-8',\n    'cy':                                   'cy_GB.ISO8859-1',\n    'cy_gb':                                'cy_GB.ISO8859-1',\n    'cz':                                   'cs_CZ.ISO8859-2',\n    'cz_cz':                                'cs_CZ.ISO8859-2',\n    'czech':                                'cs_CZ.ISO8859-2',\n    'da':                                   'da_DK.ISO8859-1',\n    'da_dk':                                'da_DK.ISO8859-1',\n    'danish':                               'da_DK.ISO8859-1',\n    'dansk':                                'da_DK.ISO8859-1',\n    'de':                                   'de_DE.ISO8859-1',\n    'de_at':                                'de_AT.ISO8859-1',\n    'de_be':                                'de_BE.ISO8859-1',\n    'de_ch':                                'de_CH.ISO8859-1',\n    'de_de':                                'de_DE.ISO8859-1',\n    'de_it':                                'de_IT.ISO8859-1',\n    'de_li.utf8':                           'de_LI.UTF-8',\n    'de_lu':                                'de_LU.ISO8859-1',\n    'deutsch':                              'de_DE.ISO8859-1',\n    'doi_in':                               'doi_IN.UTF-8',\n    'dutch':                                'nl_NL.ISO8859-1',\n    'dutch.iso88591':                       'nl_BE.ISO8859-1',\n    'dv_mv':                                'dv_MV.UTF-8',\n    'dz_bt':                                'dz_BT.UTF-8',\n    'ee':                                   'ee_EE.ISO8859-4',\n    'ee_ee':                                'ee_EE.ISO8859-4',\n    'eesti':                                'et_EE.ISO8859-1',\n    'el':                                   'el_GR.ISO8859-7',\n    'el_cy':                                'el_CY.ISO8859-7',\n    'el_gr':                                'el_GR.ISO8859-7',\n    'el_gr@euro':                           'el_GR.ISO8859-15',\n    'en':                                   'en_US.ISO8859-1',\n    'en_ag':                                'en_AG.UTF-8',\n    'en_au':                                'en_AU.ISO8859-1',\n    'en_be':                                'en_BE.ISO8859-1',\n    'en_bw':                                'en_BW.ISO8859-1',\n    'en_ca':                                'en_CA.ISO8859-1',\n    'en_dk':                                'en_DK.ISO8859-1',\n    'en_dl.utf8':                           'en_DL.UTF-8',\n    'en_gb':                                'en_GB.ISO8859-1',\n    'en_hk':                                'en_HK.ISO8859-1',\n    'en_ie':                                'en_IE.ISO8859-1',\n    'en_il':                                'en_IL.UTF-8',\n    'en_in':                                'en_IN.ISO8859-1',\n    'en_ng':                                'en_NG.UTF-8',\n    'en_nz':                                'en_NZ.ISO8859-1',\n    'en_ph':                                'en_PH.ISO8859-1',\n    'en_sc.utf8':                           'en_SC.UTF-8',\n    'en_sg':                                'en_SG.ISO8859-1',\n    'en_uk':                                'en_GB.ISO8859-1',\n    'en_us':                                'en_US.ISO8859-1',\n    'en_us@euro@euro':                      'en_US.ISO8859-15',\n    'en_za':                                'en_ZA.ISO8859-1',\n    'en_zm':                                'en_ZM.UTF-8',\n    'en_zw':                                'en_ZW.ISO8859-1',\n    'en_zw.utf8':                           'en_ZS.UTF-8',\n    'eng_gb':                               'en_GB.ISO8859-1',\n    'english':                              'en_EN.ISO8859-1',\n    'english.iso88591':                     'en_US.ISO8859-1',\n    'english_uk':                           'en_GB.ISO8859-1',\n    'english_united-states':                'en_US.ISO8859-1',\n    'english_united-states.437':            'C',\n    'english_us':                           'en_US.ISO8859-1',\n    'eo':                                   'eo_XX.ISO8859-3',\n    'eo.utf8':                              'eo.UTF-8',\n    'eo_eo':                                'eo_EO.ISO8859-3',\n    'eo_us.utf8':                           'eo_US.UTF-8',\n    'eo_xx':                                'eo_XX.ISO8859-3',\n    'es':                                   'es_ES.ISO8859-1',\n    'es_ar':                                'es_AR.ISO8859-1',\n    'es_bo':                                'es_BO.ISO8859-1',\n    'es_cl':                                'es_CL.ISO8859-1',\n    'es_co':                                'es_CO.ISO8859-1',\n    'es_cr':                                'es_CR.ISO8859-1',\n    'es_cu':                                'es_CU.UTF-8',\n    'es_do':                                'es_DO.ISO8859-1',\n    'es_ec':                                'es_EC.ISO8859-1',\n    'es_es':                                'es_ES.ISO8859-1',\n    'es_gt':                                'es_GT.ISO8859-1',\n    'es_hn':                                'es_HN.ISO8859-1',\n    'es_mx':                                'es_MX.ISO8859-1',\n    'es_ni':                                'es_NI.ISO8859-1',\n    'es_pa':                                'es_PA.ISO8859-1',\n    'es_pe':                                'es_PE.ISO8859-1',\n    'es_pr':                                'es_PR.ISO8859-1',\n    'es_py':                                'es_PY.ISO8859-1',\n    'es_sv':                                'es_SV.ISO8859-1',\n    'es_us':                                'es_US.ISO8859-1',\n    'es_uy':                                'es_UY.ISO8859-1',\n    'es_ve':                                'es_VE.ISO8859-1',\n    'estonian':                             'et_EE.ISO8859-1',\n    'et':                                   'et_EE.ISO8859-15',\n    'et_ee':                                'et_EE.ISO8859-15',\n    'eu':                                   'eu_ES.ISO8859-1',\n    'eu_es':                                'eu_ES.ISO8859-1',\n    'eu_fr':                                'eu_FR.ISO8859-1',\n    'fa':                                   'fa_IR.UTF-8',\n    'fa_ir':                                'fa_IR.UTF-8',\n    'fa_ir.isiri3342':                      'fa_IR.ISIRI-3342',\n    'ff_sn':                                'ff_SN.UTF-8',\n    'fi':                                   'fi_FI.ISO8859-15',\n    'fi_fi':                                'fi_FI.ISO8859-15',\n    'fil_ph':                               'fil_PH.UTF-8',\n    'finnish':                              'fi_FI.ISO8859-1',\n    'fo':                                   'fo_FO.ISO8859-1',\n    'fo_fo':                                'fo_FO.ISO8859-1',\n    'fr':                                   'fr_FR.ISO8859-1',\n    'fr_be':                                'fr_BE.ISO8859-1',\n    'fr_ca':                                'fr_CA.ISO8859-1',\n    'fr_ch':                                'fr_CH.ISO8859-1',\n    'fr_fr':                                'fr_FR.ISO8859-1',\n    'fr_lu':                                'fr_LU.ISO8859-1',\n    'fran\\xe7ais':                          'fr_FR.ISO8859-1',\n    'fre_fr':                               'fr_FR.ISO8859-1',\n    'french':                               'fr_FR.ISO8859-1',\n    'french.iso88591':                      'fr_CH.ISO8859-1',\n    'french_france':                        'fr_FR.ISO8859-1',\n    'fur_it':                               'fur_IT.UTF-8',\n    'fy_de':                                'fy_DE.UTF-8',\n    'fy_nl':                                'fy_NL.UTF-8',\n    'ga':                                   'ga_IE.ISO8859-1',\n    'ga_ie':                                'ga_IE.ISO8859-1',\n    'galego':                               'gl_ES.ISO8859-1',\n    'galician':                             'gl_ES.ISO8859-1',\n    'gd':                                   'gd_GB.ISO8859-1',\n    'gd_gb':                                'gd_GB.ISO8859-1',\n    'ger_de':                               'de_DE.ISO8859-1',\n    'german':                               'de_DE.ISO8859-1',\n    'german.iso88591':                      'de_CH.ISO8859-1',\n    'german_germany':                       'de_DE.ISO8859-1',\n    'gez_er':                               'gez_ER.UTF-8',\n    'gez_et':                               'gez_ET.UTF-8',\n    'gl':                                   'gl_ES.ISO8859-1',\n    'gl_es':                                'gl_ES.ISO8859-1',\n    'greek':                                'el_GR.ISO8859-7',\n    'gu_in':                                'gu_IN.UTF-8',\n    'gv':                                   'gv_GB.ISO8859-1',\n    'gv_gb':                                'gv_GB.ISO8859-1',\n    'ha_ng':                                'ha_NG.UTF-8',\n    'hak_tw':                               'hak_TW.UTF-8',\n    'he':                                   'he_IL.ISO8859-8',\n    'he_il':                                'he_IL.ISO8859-8',\n    'hebrew':                               'he_IL.ISO8859-8',\n    'hi':                                   'hi_IN.ISCII-DEV',\n    'hi_in':                                'hi_IN.ISCII-DEV',\n    'hi_in.isciidev':                       'hi_IN.ISCII-DEV',\n    'hif_fj':                               'hif_FJ.UTF-8',\n    'hne':                                  'hne_IN.UTF-8',\n    'hne_in':                               'hne_IN.UTF-8',\n    'hr':                                   'hr_HR.ISO8859-2',\n    'hr_hr':                                'hr_HR.ISO8859-2',\n    'hrvatski':                             'hr_HR.ISO8859-2',\n    'hsb_de':                               'hsb_DE.ISO8859-2',\n    'ht_ht':                                'ht_HT.UTF-8',\n    'hu':                                   'hu_HU.ISO8859-2',\n    'hu_hu':                                'hu_HU.ISO8859-2',\n    'hungarian':                            'hu_HU.ISO8859-2',\n    'hy_am':                                'hy_AM.UTF-8',\n    'hy_am.armscii8':                       'hy_AM.ARMSCII_8',\n    'ia':                                   'ia.UTF-8',\n    'ia_fr':                                'ia_FR.UTF-8',\n    'icelandic':                            'is_IS.ISO8859-1',\n    'id':                                   'id_ID.ISO8859-1',\n    'id_id':                                'id_ID.ISO8859-1',\n    'ig_ng':                                'ig_NG.UTF-8',\n    'ik_ca':                                'ik_CA.UTF-8',\n    'in':                                   'id_ID.ISO8859-1',\n    'in_id':                                'id_ID.ISO8859-1',\n    'is':                                   'is_IS.ISO8859-1',\n    'is_is':                                'is_IS.ISO8859-1',\n    'iso-8859-1':                           'en_US.ISO8859-1',\n    'iso-8859-15':                          'en_US.ISO8859-15',\n    'iso8859-1':                            'en_US.ISO8859-1',\n    'iso8859-15':                           'en_US.ISO8859-15',\n    'iso_8859_1':                           'en_US.ISO8859-1',\n    'iso_8859_15':                          'en_US.ISO8859-15',\n    'it':                                   'it_IT.ISO8859-1',\n    'it_ch':                                'it_CH.ISO8859-1',\n    'it_it':                                'it_IT.ISO8859-1',\n    'italian':                              'it_IT.ISO8859-1',\n    'iu':                                   'iu_CA.NUNACOM-8',\n    'iu_ca':                                'iu_CA.NUNACOM-8',\n    'iu_ca.nunacom8':                       'iu_CA.NUNACOM-8',\n    'iw':                                   'he_IL.ISO8859-8',\n    'iw_il':                                'he_IL.ISO8859-8',\n    'iw_il.utf8':                           'iw_IL.UTF-8',\n    'ja':                                   'ja_JP.eucJP',\n    'ja_jp':                                'ja_JP.eucJP',\n    'ja_jp.euc':                            'ja_JP.eucJP',\n    'ja_jp.mscode':                         'ja_JP.SJIS',\n    'ja_jp.pck':                            'ja_JP.SJIS',\n    'japan':                                'ja_JP.eucJP',\n    'japanese':                             'ja_JP.eucJP',\n    'japanese-euc':                         'ja_JP.eucJP',\n    'japanese.euc':                         'ja_JP.eucJP',\n    'jp_jp':                                'ja_JP.eucJP',\n    'ka':                                   'ka_GE.GEORGIAN-ACADEMY',\n    'ka_ge':                                'ka_GE.GEORGIAN-ACADEMY',\n    'ka_ge.georgianacademy':                'ka_GE.GEORGIAN-ACADEMY',\n    'ka_ge.georgianps':                     'ka_GE.GEORGIAN-PS',\n    'ka_ge.georgianrs':                     'ka_GE.GEORGIAN-ACADEMY',\n    'kab_dz':                               'kab_DZ.UTF-8',\n    'kk_kz':                                'kk_KZ.ptcp154',\n    'kl':                                   'kl_GL.ISO8859-1',\n    'kl_gl':                                'kl_GL.ISO8859-1',\n    'km_kh':                                'km_KH.UTF-8',\n    'kn':                                   'kn_IN.UTF-8',\n    'kn_in':                                'kn_IN.UTF-8',\n    'ko':                                   'ko_KR.eucKR',\n    'ko_kr':                                'ko_KR.eucKR',\n    'ko_kr.euc':                            'ko_KR.eucKR',\n    'kok_in':                               'kok_IN.UTF-8',\n    'korean':                               'ko_KR.eucKR',\n    'korean.euc':                           'ko_KR.eucKR',\n    'ks':                                   'ks_IN.UTF-8',\n    'ks_in':                                'ks_IN.UTF-8',\n    'ks_in@devanagari.utf8':                'ks_IN.UTF-8@devanagari',\n    'ku_tr':                                'ku_TR.ISO8859-9',\n    'kw':                                   'kw_GB.ISO8859-1',\n    'kw_gb':                                'kw_GB.ISO8859-1',\n    'ky':                                   'ky_KG.UTF-8',\n    'ky_kg':                                'ky_KG.UTF-8',\n    'lb_lu':                                'lb_LU.UTF-8',\n    'lg_ug':                                'lg_UG.ISO8859-10',\n    'li_be':                                'li_BE.UTF-8',\n    'li_nl':                                'li_NL.UTF-8',\n    'lij_it':                               'lij_IT.UTF-8',\n    'lithuanian':                           'lt_LT.ISO8859-13',\n    'ln_cd':                                'ln_CD.UTF-8',\n    'lo':                                   'lo_LA.MULELAO-1',\n    'lo_la':                                'lo_LA.MULELAO-1',\n    'lo_la.cp1133':                         'lo_LA.IBM-CP1133',\n    'lo_la.ibmcp1133':                      'lo_LA.IBM-CP1133',\n    'lo_la.mulelao1':                       'lo_LA.MULELAO-1',\n    'lt':                                   'lt_LT.ISO8859-13',\n    'lt_lt':                                'lt_LT.ISO8859-13',\n    'lv':                                   'lv_LV.ISO8859-13',\n    'lv_lv':                                'lv_LV.ISO8859-13',\n    'lzh_tw':                               'lzh_TW.UTF-8',\n    'mag_in':                               'mag_IN.UTF-8',\n    'mai':                                  'mai_IN.UTF-8',\n    'mai_in':                               'mai_IN.UTF-8',\n    'mai_np':                               'mai_NP.UTF-8',\n    'mfe_mu':                               'mfe_MU.UTF-8',\n    'mg_mg':                                'mg_MG.ISO8859-15',\n    'mhr_ru':                               'mhr_RU.UTF-8',\n    'mi':                                   'mi_NZ.ISO8859-1',\n    'mi_nz':                                'mi_NZ.ISO8859-1',\n    'miq_ni':                               'miq_NI.UTF-8',\n    'mjw_in':                               'mjw_IN.UTF-8',\n    'mk':                                   'mk_MK.ISO8859-5',\n    'mk_mk':                                'mk_MK.ISO8859-5',\n    'ml':                                   'ml_IN.UTF-8',\n    'ml_in':                                'ml_IN.UTF-8',\n    'mn_mn':                                'mn_MN.UTF-8',\n    'mni_in':                               'mni_IN.UTF-8',\n    'mr':                                   'mr_IN.UTF-8',\n    'mr_in':                                'mr_IN.UTF-8',\n    'ms':                                   'ms_MY.ISO8859-1',\n    'ms_my':                                'ms_MY.ISO8859-1',\n    'mt':                                   'mt_MT.ISO8859-3',\n    'mt_mt':                                'mt_MT.ISO8859-3',\n    'my_mm':                                'my_MM.UTF-8',\n    'nan_tw':                               'nan_TW.UTF-8',\n    'nb':                                   'nb_NO.ISO8859-1',\n    'nb_no':                                'nb_NO.ISO8859-1',\n    'nds_de':                               'nds_DE.UTF-8',\n    'nds_nl':                               'nds_NL.UTF-8',\n    'ne_np':                                'ne_NP.UTF-8',\n    'nhn_mx':                               'nhn_MX.UTF-8',\n    'niu_nu':                               'niu_NU.UTF-8',\n    'niu_nz':                               'niu_NZ.UTF-8',\n    'nl':                                   'nl_NL.ISO8859-1',\n    'nl_aw':                                'nl_AW.UTF-8',\n    'nl_be':                                'nl_BE.ISO8859-1',\n    'nl_nl':                                'nl_NL.ISO8859-1',\n    'nn':                                   'nn_NO.ISO8859-1',\n    'nn_no':                                'nn_NO.ISO8859-1',\n    'no':                                   'no_NO.ISO8859-1',\n    'no@nynorsk':                           'ny_NO.ISO8859-1',\n    'no_no':                                'no_NO.ISO8859-1',\n    'no_no.iso88591@bokmal':                'no_NO.ISO8859-1',\n    'no_no.iso88591@nynorsk':               'no_NO.ISO8859-1',\n    'norwegian':                            'no_NO.ISO8859-1',\n    'nr':                                   'nr_ZA.ISO8859-1',\n    'nr_za':                                'nr_ZA.ISO8859-1',\n    'nso':                                  'nso_ZA.ISO8859-15',\n    'nso_za':                               'nso_ZA.ISO8859-15',\n    'ny':                                   'ny_NO.ISO8859-1',\n    'ny_no':                                'ny_NO.ISO8859-1',\n    'nynorsk':                              'nn_NO.ISO8859-1',\n    'oc':                                   'oc_FR.ISO8859-1',\n    'oc_fr':                                'oc_FR.ISO8859-1',\n    'om_et':                                'om_ET.UTF-8',\n    'om_ke':                                'om_KE.ISO8859-1',\n    'or':                                   'or_IN.UTF-8',\n    'or_in':                                'or_IN.UTF-8',\n    'os_ru':                                'os_RU.UTF-8',\n    'pa':                                   'pa_IN.UTF-8',\n    'pa_in':                                'pa_IN.UTF-8',\n    'pa_pk':                                'pa_PK.UTF-8',\n    'pap_an':                               'pap_AN.UTF-8',\n    'pap_aw':                               'pap_AW.UTF-8',\n    'pap_cw':                               'pap_CW.UTF-8',\n    'pd':                                   'pd_US.ISO8859-1',\n    'pd_de':                                'pd_DE.ISO8859-1',\n    'pd_us':                                'pd_US.ISO8859-1',\n    'ph':                                   'ph_PH.ISO8859-1',\n    'ph_ph':                                'ph_PH.ISO8859-1',\n    'pl':                                   'pl_PL.ISO8859-2',\n    'pl_pl':                                'pl_PL.ISO8859-2',\n    'polish':                               'pl_PL.ISO8859-2',\n    'portuguese':                           'pt_PT.ISO8859-1',\n    'portuguese_brazil':                    'pt_BR.ISO8859-1',\n    'posix':                                'C',\n    'posix-utf2':                           'C',\n    'pp':                                   'pp_AN.ISO8859-1',\n    'pp_an':                                'pp_AN.ISO8859-1',\n    'ps_af':                                'ps_AF.UTF-8',\n    'pt':                                   'pt_PT.ISO8859-1',\n    'pt_br':                                'pt_BR.ISO8859-1',\n    'pt_pt':                                'pt_PT.ISO8859-1',\n    'quz_pe':                               'quz_PE.UTF-8',\n    'raj_in':                               'raj_IN.UTF-8',\n    'ro':                                   'ro_RO.ISO8859-2',\n    'ro_ro':                                'ro_RO.ISO8859-2',\n    'romanian':                             'ro_RO.ISO8859-2',\n    'ru':                                   'ru_RU.UTF-8',\n    'ru_ru':                                'ru_RU.UTF-8',\n    'ru_ua':                                'ru_UA.KOI8-U',\n    'rumanian':                             'ro_RO.ISO8859-2',\n    'russian':                              'ru_RU.KOI8-R',\n    'rw':                                   'rw_RW.ISO8859-1',\n    'rw_rw':                                'rw_RW.ISO8859-1',\n    'sa_in':                                'sa_IN.UTF-8',\n    'sat_in':                               'sat_IN.UTF-8',\n    'sc_it':                                'sc_IT.UTF-8',\n    'sd':                                   'sd_IN.UTF-8',\n    'sd_in':                                'sd_IN.UTF-8',\n    'sd_in@devanagari.utf8':                'sd_IN.UTF-8@devanagari',\n    'sd_pk':                                'sd_PK.UTF-8',\n    'se_no':                                'se_NO.UTF-8',\n    'serbocroatian':                        'sr_RS.UTF-8@latin',\n    'sgs_lt':                               'sgs_LT.UTF-8',\n    'sh':                                   'sr_RS.UTF-8@latin',\n    'sh_ba.iso88592@bosnia':                'sr_CS.ISO8859-2',\n    'sh_hr':                                'sh_HR.ISO8859-2',\n    'sh_hr.iso88592':                       'hr_HR.ISO8859-2',\n    'sh_sp':                                'sr_CS.ISO8859-2',\n    'sh_yu':                                'sr_RS.UTF-8@latin',\n    'shn_mm':                               'shn_MM.UTF-8',\n    'shs_ca':                               'shs_CA.UTF-8',\n    'si':                                   'si_LK.UTF-8',\n    'si_lk':                                'si_LK.UTF-8',\n    'sid_et':                               'sid_ET.UTF-8',\n    'sinhala':                              'si_LK.UTF-8',\n    'sk':                                   'sk_SK.ISO8859-2',\n    'sk_sk':                                'sk_SK.ISO8859-2',\n    'sl':                                   'sl_SI.ISO8859-2',\n    'sl_cs':                                'sl_CS.ISO8859-2',\n    'sl_si':                                'sl_SI.ISO8859-2',\n    'slovak':                               'sk_SK.ISO8859-2',\n    'slovene':                              'sl_SI.ISO8859-2',\n    'slovenian':                            'sl_SI.ISO8859-2',\n    'sm_ws':                                'sm_WS.UTF-8',\n    'so_dj':                                'so_DJ.ISO8859-1',\n    'so_et':                                'so_ET.UTF-8',\n    'so_ke':                                'so_KE.ISO8859-1',\n    'so_so':                                'so_SO.ISO8859-1',\n    'sp':                                   'sr_CS.ISO8859-5',\n    'sp_yu':                                'sr_CS.ISO8859-5',\n    'spanish':                              'es_ES.ISO8859-1',\n    'spanish_spain':                        'es_ES.ISO8859-1',\n    'sq':                                   'sq_AL.ISO8859-2',\n    'sq_al':                                'sq_AL.ISO8859-2',\n    'sq_mk':                                'sq_MK.UTF-8',\n    'sr':                                   'sr_RS.UTF-8',\n    'sr@cyrillic':                          'sr_RS.UTF-8',\n    'sr@latn':                              'sr_CS.UTF-8@latin',\n    'sr_cs':                                'sr_CS.UTF-8',\n    'sr_cs.iso88592@latn':                  'sr_CS.ISO8859-2',\n    'sr_cs@latn':                           'sr_CS.UTF-8@latin',\n    'sr_me':                                'sr_ME.UTF-8',\n    'sr_rs':                                'sr_RS.UTF-8',\n    'sr_rs@latn':                           'sr_RS.UTF-8@latin',\n    'sr_sp':                                'sr_CS.ISO8859-2',\n    'sr_yu':                                'sr_RS.UTF-8@latin',\n    'sr_yu.cp1251@cyrillic':                'sr_CS.CP1251',\n    'sr_yu.iso88592':                       'sr_CS.ISO8859-2',\n    'sr_yu.iso88595':                       'sr_CS.ISO8859-5',\n    'sr_yu.iso88595@cyrillic':              'sr_CS.ISO8859-5',\n    'sr_yu.microsoftcp1251@cyrillic':       'sr_CS.CP1251',\n    'sr_yu.utf8':                           'sr_RS.UTF-8',\n    'sr_yu.utf8@cyrillic':                  'sr_RS.UTF-8',\n    'sr_yu@cyrillic':                       'sr_RS.UTF-8',\n    'ss':                                   'ss_ZA.ISO8859-1',\n    'ss_za':                                'ss_ZA.ISO8859-1',\n    'st':                                   'st_ZA.ISO8859-1',\n    'st_za':                                'st_ZA.ISO8859-1',\n    'sv':                                   'sv_SE.ISO8859-1',\n    'sv_fi':                                'sv_FI.ISO8859-1',\n    'sv_se':                                'sv_SE.ISO8859-1',\n    'sw_ke':                                'sw_KE.UTF-8',\n    'sw_tz':                                'sw_TZ.UTF-8',\n    'swedish':                              'sv_SE.ISO8859-1',\n    'szl_pl':                               'szl_PL.UTF-8',\n    'ta':                                   'ta_IN.TSCII-0',\n    'ta_in':                                'ta_IN.TSCII-0',\n    'ta_in.tscii':                          'ta_IN.TSCII-0',\n    'ta_in.tscii0':                         'ta_IN.TSCII-0',\n    'ta_lk':                                'ta_LK.UTF-8',\n    'tcy_in.utf8':                          'tcy_IN.UTF-8',\n    'te':                                   'te_IN.UTF-8',\n    'te_in':                                'te_IN.UTF-8',\n    'tg':                                   'tg_TJ.KOI8-C',\n    'tg_tj':                                'tg_TJ.KOI8-C',\n    'th':                                   'th_TH.ISO8859-11',\n    'th_th':                                'th_TH.ISO8859-11',\n    'th_th.tactis':                         'th_TH.TIS620',\n    'th_th.tis620':                         'th_TH.TIS620',\n    'thai':                                 'th_TH.ISO8859-11',\n    'the_np':                               'the_NP.UTF-8',\n    'ti_er':                                'ti_ER.UTF-8',\n    'ti_et':                                'ti_ET.UTF-8',\n    'tig_er':                               'tig_ER.UTF-8',\n    'tk_tm':                                'tk_TM.UTF-8',\n    'tl':                                   'tl_PH.ISO8859-1',\n    'tl_ph':                                'tl_PH.ISO8859-1',\n    'tn':                                   'tn_ZA.ISO8859-15',\n    'tn_za':                                'tn_ZA.ISO8859-15',\n    'to_to':                                'to_TO.UTF-8',\n    'tpi_pg':                               'tpi_PG.UTF-8',\n    'tr':                                   'tr_TR.ISO8859-9',\n    'tr_cy':                                'tr_CY.ISO8859-9',\n    'tr_tr':                                'tr_TR.ISO8859-9',\n    'ts':                                   'ts_ZA.ISO8859-1',\n    'ts_za':                                'ts_ZA.ISO8859-1',\n    'tt':                                   'tt_RU.TATAR-CYR',\n    'tt_ru':                                'tt_RU.TATAR-CYR',\n    'tt_ru.tatarcyr':                       'tt_RU.TATAR-CYR',\n    'tt_ru@iqtelif':                        'tt_RU.UTF-8@iqtelif',\n    'turkish':                              'tr_TR.ISO8859-9',\n    'ug_cn':                                'ug_CN.UTF-8',\n    'uk':                                   'uk_UA.KOI8-U',\n    'uk_ua':                                'uk_UA.KOI8-U',\n    'univ':                                 'en_US.utf',\n    'universal':                            'en_US.utf',\n    'universal.utf8@ucs4':                  'en_US.UTF-8',\n    'unm_us':                               'unm_US.UTF-8',\n    'ur':                                   'ur_PK.CP1256',\n    'ur_in':                                'ur_IN.UTF-8',\n    'ur_pk':                                'ur_PK.CP1256',\n    'uz':                                   'uz_UZ.UTF-8',\n    'uz_uz':                                'uz_UZ.UTF-8',\n    'uz_uz@cyrillic':                       'uz_UZ.UTF-8',\n    've':                                   've_ZA.UTF-8',\n    've_za':                                've_ZA.UTF-8',\n    'vi':                                   'vi_VN.TCVN',\n    'vi_vn':                                'vi_VN.TCVN',\n    'vi_vn.tcvn':                           'vi_VN.TCVN',\n    'vi_vn.tcvn5712':                       'vi_VN.TCVN',\n    'vi_vn.viscii':                         'vi_VN.VISCII',\n    'vi_vn.viscii111':                      'vi_VN.VISCII',\n    'wa':                                   'wa_BE.ISO8859-1',\n    'wa_be':                                'wa_BE.ISO8859-1',\n    'wae_ch':                               'wae_CH.UTF-8',\n    'wal_et':                               'wal_ET.UTF-8',\n    'wo_sn':                                'wo_SN.UTF-8',\n    'xh':                                   'xh_ZA.ISO8859-1',\n    'xh_za':                                'xh_ZA.ISO8859-1',\n    'yi':                                   'yi_US.CP1255',\n    'yi_us':                                'yi_US.CP1255',\n    'yo_ng':                                'yo_NG.UTF-8',\n    'yue_hk':                               'yue_HK.UTF-8',\n    'yuw_pg':                               'yuw_PG.UTF-8',\n    'zh':                                   'zh_CN.eucCN',\n    'zh_cn':                                'zh_CN.gb2312',\n    'zh_cn.big5':                           'zh_TW.big5',\n    'zh_cn.euc':                            'zh_CN.eucCN',\n    'zh_hk':                                'zh_HK.big5hkscs',\n    'zh_hk.big5hk':                         'zh_HK.big5hkscs',\n    'zh_sg':                                'zh_SG.GB2312',\n    'zh_sg.gbk':                            'zh_SG.GBK',\n    'zh_tw':                                'zh_TW.big5',\n    'zh_tw.euc':                            'zh_TW.eucTW',\n    'zh_tw.euctw':                          'zh_TW.eucTW',\n    'zu':                                   'zu_ZA.ISO8859-1',\n    'zu_za':                                'zu_ZA.ISO8859-1',\n}\n\n#\n# This maps Windows language identifiers to locale strings.\n#\n# This list has been updated from\n# http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/nls_238z.asp\n# to include every locale up to Windows Vista.\n#\n# NOTE: this mapping is incomplete.  If your language is missing, please\n# submit a bug report as detailed in the Python devguide at:\n#    https://devguide.python.org/triage/issue-tracker/\n# Make sure you include the missing language identifier and the suggested\n# locale code.\n#\n\nwindows_locale = {\n    0x0436: \"af_ZA\", # Afrikaans\n    0x041c: \"sq_AL\", # Albanian\n    0x0484: \"gsw_FR\",# Alsatian - France\n    0x045e: \"am_ET\", # Amharic - Ethiopia\n    0x0401: \"ar_SA\", # Arabic - Saudi Arabia\n    0x0801: \"ar_IQ\", # Arabic - Iraq\n    0x0c01: \"ar_EG\", # Arabic - Egypt\n    0x1001: \"ar_LY\", # Arabic - Libya\n    0x1401: \"ar_DZ\", # Arabic - Algeria\n    0x1801: \"ar_MA\", # Arabic - Morocco\n    0x1c01: \"ar_TN\", # Arabic - Tunisia\n    0x2001: \"ar_OM\", # Arabic - Oman\n    0x2401: \"ar_YE\", # Arabic - Yemen\n    0x2801: \"ar_SY\", # Arabic - Syria\n    0x2c01: \"ar_JO\", # Arabic - Jordan\n    0x3001: \"ar_LB\", # Arabic - Lebanon\n    0x3401: \"ar_KW\", # Arabic - Kuwait\n    0x3801: \"ar_AE\", # Arabic - United Arab Emirates\n    0x3c01: \"ar_BH\", # Arabic - Bahrain\n    0x4001: \"ar_QA\", # Arabic - Qatar\n    0x042b: \"hy_AM\", # Armenian\n    0x044d: \"as_IN\", # Assamese - India\n    0x042c: \"az_AZ\", # Azeri - Latin\n    0x082c: \"az_AZ\", # Azeri - Cyrillic\n    0x046d: \"ba_RU\", # Bashkir\n    0x042d: \"eu_ES\", # Basque - Russia\n    0x0423: \"be_BY\", # Belarusian\n    0x0445: \"bn_IN\", # Begali\n    0x201a: \"bs_BA\", # Bosnian - Cyrillic\n    0x141a: \"bs_BA\", # Bosnian - Latin\n    0x047e: \"br_FR\", # Breton - France\n    0x0402: \"bg_BG\", # Bulgarian\n#    0x0455: \"my_MM\", # Burmese - Not supported\n    0x0403: \"ca_ES\", # Catalan\n    0x0004: \"zh_CHS\",# Chinese - Simplified\n    0x0404: \"zh_TW\", # Chinese - Taiwan\n    0x0804: \"zh_CN\", # Chinese - PRC\n    0x0c04: \"zh_HK\", # Chinese - Hong Kong S.A.R.\n    0x1004: \"zh_SG\", # Chinese - Singapore\n    0x1404: \"zh_MO\", # Chinese - Macao S.A.R.\n    0x7c04: \"zh_CHT\",# Chinese - Traditional\n    0x0483: \"co_FR\", # Corsican - France\n    0x041a: \"hr_HR\", # Croatian\n    0x101a: \"hr_BA\", # Croatian - Bosnia\n    0x0405: \"cs_CZ\", # Czech\n    0x0406: \"da_DK\", # Danish\n    0x048c: \"gbz_AF\",# Dari - Afghanistan\n    0x0465: \"div_MV\",# Divehi - Maldives\n    0x0413: \"nl_NL\", # Dutch - The Netherlands\n    0x0813: \"nl_BE\", # Dutch - Belgium\n    0x0409: \"en_US\", # English - United States\n    0x0809: \"en_GB\", # English - United Kingdom\n    0x0c09: \"en_AU\", # English - Australia\n    0x1009: \"en_CA\", # English - Canada\n    0x1409: \"en_NZ\", # English - New Zealand\n    0x1809: \"en_IE\", # English - Ireland\n    0x1c09: \"en_ZA\", # English - South Africa\n    0x2009: \"en_JA\", # English - Jamaica\n    0x2409: \"en_CB\", # English - Caribbean\n    0x2809: \"en_BZ\", # English - Belize\n    0x2c09: \"en_TT\", # English - Trinidad\n    0x3009: \"en_ZW\", # English - Zimbabwe\n    0x3409: \"en_PH\", # English - Philippines\n    0x4009: \"en_IN\", # English - India\n    0x4409: \"en_MY\", # English - Malaysia\n    0x4809: \"en_IN\", # English - Singapore\n    0x0425: \"et_EE\", # Estonian\n    0x0438: \"fo_FO\", # Faroese\n    0x0464: \"fil_PH\",# Filipino\n    0x040b: \"fi_FI\", # Finnish\n    0x040c: \"fr_FR\", # French - France\n    0x080c: \"fr_BE\", # French - Belgium\n    0x0c0c: \"fr_CA\", # French - Canada\n    0x100c: \"fr_CH\", # French - Switzerland\n    0x140c: \"fr_LU\", # French - Luxembourg\n    0x180c: \"fr_MC\", # French - Monaco\n    0x0462: \"fy_NL\", # Frisian - Netherlands\n    0x0456: \"gl_ES\", # Galician\n    0x0437: \"ka_GE\", # Georgian\n    0x0407: \"de_DE\", # German - Germany\n    0x0807: \"de_CH\", # German - Switzerland\n    0x0c07: \"de_AT\", # German - Austria\n    0x1007: \"de_LU\", # German - Luxembourg\n    0x1407: \"de_LI\", # German - Liechtenstein\n    0x0408: \"el_GR\", # Greek\n    0x046f: \"kl_GL\", # Greenlandic - Greenland\n    0x0447: \"gu_IN\", # Gujarati\n    0x0468: \"ha_NG\", # Hausa - Latin\n    0x040d: \"he_IL\", # Hebrew\n    0x0439: \"hi_IN\", # Hindi\n    0x040e: \"hu_HU\", # Hungarian\n    0x040f: \"is_IS\", # Icelandic\n    0x0421: \"id_ID\", # Indonesian\n    0x045d: \"iu_CA\", # Inuktitut - Syllabics\n    0x085d: \"iu_CA\", # Inuktitut - Latin\n    0x083c: \"ga_IE\", # Irish - Ireland\n    0x0410: \"it_IT\", # Italian - Italy\n    0x0810: \"it_CH\", # Italian - Switzerland\n    0x0411: \"ja_JP\", # Japanese\n    0x044b: \"kn_IN\", # Kannada - India\n    0x043f: \"kk_KZ\", # Kazakh\n    0x0453: \"kh_KH\", # Khmer - Cambodia\n    0x0486: \"qut_GT\",# K'iche - Guatemala\n    0x0487: \"rw_RW\", # Kinyarwanda - Rwanda\n    0x0457: \"kok_IN\",# Konkani\n    0x0412: \"ko_KR\", # Korean\n    0x0440: \"ky_KG\", # Kyrgyz\n    0x0454: \"lo_LA\", # Lao - Lao PDR\n    0x0426: \"lv_LV\", # Latvian\n    0x0427: \"lt_LT\", # Lithuanian\n    0x082e: \"dsb_DE\",# Lower Sorbian - Germany\n    0x046e: \"lb_LU\", # Luxembourgish\n    0x042f: \"mk_MK\", # FYROM Macedonian\n    0x043e: \"ms_MY\", # Malay - Malaysia\n    0x083e: \"ms_BN\", # Malay - Brunei Darussalam\n    0x044c: \"ml_IN\", # Malayalam - India\n    0x043a: \"mt_MT\", # Maltese\n    0x0481: \"mi_NZ\", # Maori\n    0x047a: \"arn_CL\",# Mapudungun\n    0x044e: \"mr_IN\", # Marathi\n    0x047c: \"moh_CA\",# Mohawk - Canada\n    0x0450: \"mn_MN\", # Mongolian - Cyrillic\n    0x0850: \"mn_CN\", # Mongolian - PRC\n    0x0461: \"ne_NP\", # Nepali\n    0x0414: \"nb_NO\", # Norwegian - Bokmal\n    0x0814: \"nn_NO\", # Norwegian - Nynorsk\n    0x0482: \"oc_FR\", # Occitan - France\n    0x0448: \"or_IN\", # Oriya - India\n    0x0463: \"ps_AF\", # Pashto - Afghanistan\n    0x0429: \"fa_IR\", # Persian\n    0x0415: \"pl_PL\", # Polish\n    0x0416: \"pt_BR\", # Portuguese - Brazil\n    0x0816: \"pt_PT\", # Portuguese - Portugal\n    0x0446: \"pa_IN\", # Punjabi\n    0x046b: \"quz_BO\",# Quechua (Bolivia)\n    0x086b: \"quz_EC\",# Quechua (Ecuador)\n    0x0c6b: \"quz_PE\",# Quechua (Peru)\n    0x0418: \"ro_RO\", # Romanian - Romania\n    0x0417: \"rm_CH\", # Romansh\n    0x0419: \"ru_RU\", # Russian\n    0x243b: \"smn_FI\",# Sami Finland\n    0x103b: \"smj_NO\",# Sami Norway\n    0x143b: \"smj_SE\",# Sami Sweden\n    0x043b: \"se_NO\", # Sami Northern Norway\n    0x083b: \"se_SE\", # Sami Northern Sweden\n    0x0c3b: \"se_FI\", # Sami Northern Finland\n    0x203b: \"sms_FI\",# Sami Skolt\n    0x183b: \"sma_NO\",# Sami Southern Norway\n    0x1c3b: \"sma_SE\",# Sami Southern Sweden\n    0x044f: \"sa_IN\", # Sanskrit\n    0x0c1a: \"sr_SP\", # Serbian - Cyrillic\n    0x1c1a: \"sr_BA\", # Serbian - Bosnia Cyrillic\n    0x081a: \"sr_SP\", # Serbian - Latin\n    0x181a: \"sr_BA\", # Serbian - Bosnia Latin\n    0x045b: \"si_LK\", # Sinhala - Sri Lanka\n    0x046c: \"ns_ZA\", # Northern Sotho\n    0x0432: \"tn_ZA\", # Setswana - Southern Africa\n    0x041b: \"sk_SK\", # Slovak\n    0x0424: \"sl_SI\", # Slovenian\n    0x040a: \"es_ES\", # Spanish - Spain\n    0x080a: \"es_MX\", # Spanish - Mexico\n    0x0c0a: \"es_ES\", # Spanish - Spain (Modern)\n    0x100a: \"es_GT\", # Spanish - Guatemala\n    0x140a: \"es_CR\", # Spanish - Costa Rica\n    0x180a: \"es_PA\", # Spanish - Panama\n    0x1c0a: \"es_DO\", # Spanish - Dominican Republic\n    0x200a: \"es_VE\", # Spanish - Venezuela\n    0x240a: \"es_CO\", # Spanish - Colombia\n    0x280a: \"es_PE\", # Spanish - Peru\n    0x2c0a: \"es_AR\", # Spanish - Argentina\n    0x300a: \"es_EC\", # Spanish - Ecuador\n    0x340a: \"es_CL\", # Spanish - Chile\n    0x380a: \"es_UR\", # Spanish - Uruguay\n    0x3c0a: \"es_PY\", # Spanish - Paraguay\n    0x400a: \"es_BO\", # Spanish - Bolivia\n    0x440a: \"es_SV\", # Spanish - El Salvador\n    0x480a: \"es_HN\", # Spanish - Honduras\n    0x4c0a: \"es_NI\", # Spanish - Nicaragua\n    0x500a: \"es_PR\", # Spanish - Puerto Rico\n    0x540a: \"es_US\", # Spanish - United States\n#    0x0430: \"\", # Sutu - Not supported\n    0x0441: \"sw_KE\", # Swahili\n    0x041d: \"sv_SE\", # Swedish - Sweden\n    0x081d: \"sv_FI\", # Swedish - Finland\n    0x045a: \"syr_SY\",# Syriac\n    0x0428: \"tg_TJ\", # Tajik - Cyrillic\n    0x085f: \"tmz_DZ\",# Tamazight - Latin\n    0x0449: \"ta_IN\", # Tamil\n    0x0444: \"tt_RU\", # Tatar\n    0x044a: \"te_IN\", # Telugu\n    0x041e: \"th_TH\", # Thai\n    0x0851: \"bo_BT\", # Tibetan - Bhutan\n    0x0451: \"bo_CN\", # Tibetan - PRC\n    0x041f: \"tr_TR\", # Turkish\n    0x0442: \"tk_TM\", # Turkmen - Cyrillic\n    0x0480: \"ug_CN\", # Uighur - Arabic\n    0x0422: \"uk_UA\", # Ukrainian\n    0x042e: \"wen_DE\",# Upper Sorbian - Germany\n    0x0420: \"ur_PK\", # Urdu\n    0x0820: \"ur_IN\", # Urdu - India\n    0x0443: \"uz_UZ\", # Uzbek - Latin\n    0x0843: \"uz_UZ\", # Uzbek - Cyrillic\n    0x042a: \"vi_VN\", # Vietnamese\n    0x0452: \"cy_GB\", # Welsh\n    0x0488: \"wo_SN\", # Wolof - Senegal\n    0x0434: \"xh_ZA\", # Xhosa - South Africa\n    0x0485: \"sah_RU\",# Yakut - Cyrillic\n    0x0478: \"ii_CN\", # Yi - PRC\n    0x046a: \"yo_NG\", # Yoruba - Nigeria\n    0x0435: \"zu_ZA\", # Zulu\n}\n\ndef _print_locale():\n\n    \"\"\" Test function.\n    \"\"\"\n    categories = {}\n    def _init_categories(categories=categories):\n        for k,v in globals().items():\n            if k[:3] == 'LC_':\n                categories[k] = v\n    _init_categories()\n    del categories['LC_ALL']\n\n    print('Locale defaults as determined by getdefaultlocale():')\n    print('-'*72)\n    lang, enc = getdefaultlocale()\n    print('Language: ', lang or '(undefined)')\n    print('Encoding: ', enc or '(undefined)')\n    print()\n\n    print('Locale settings on startup:')\n    print('-'*72)\n    for name,category in categories.items():\n        print(name, '...')\n        lang, enc = getlocale(category)\n        print('   Language: ', lang or '(undefined)')\n        print('   Encoding: ', enc or '(undefined)')\n        print()\n\n    try:\n        setlocale(LC_ALL, \"\")\n    except:\n        print('NOTE:')\n        print('setlocale(LC_ALL, \"\") does not support the default locale')\n        print('given in the OS environment variables.')\n    else:\n        print()\n        print('Locale settings after calling setlocale(LC_ALL, \"\"):')\n        print('-'*72)\n        for name,category in categories.items():\n            print(name, '...')\n            lang, enc = getlocale(category)\n            print('   Language: ', lang or '(undefined)')\n            print('   Encoding: ', enc or '(undefined)')\n            print()\n\n###\n\ntry:\n    LC_MESSAGES\nexcept NameError:\n    pass\nelse:\n    __all__.append(\"LC_MESSAGES\")\n\nif __name__=='__main__':\n    print('Locale aliasing:')\n    print()\n    _print_locale()\n    print()\n    print('Number formatting:')\n    print()\n    _test()\n", 1743], "C:\\Programming\\Python313\\Lib\\codecs.py": ["\"\"\" codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.\n\n\"\"\"\n\nimport builtins\nimport sys\n\n### Registry and builtin stateless codec functions\n\ntry:\n    from _codecs import *\nexcept ImportError as why:\n    raise SystemError('Failed to load the builtin codecs: %s' % why)\n\n__all__ = [\"register\", \"lookup\", \"open\", \"EncodedFile\", \"BOM\", \"BOM_BE\",\n           \"BOM_LE\", \"BOM32_BE\", \"BOM32_LE\", \"BOM64_BE\", \"BOM64_LE\",\n           \"BOM_UTF8\", \"BOM_UTF16\", \"BOM_UTF16_LE\", \"BOM_UTF16_BE\",\n           \"BOM_UTF32\", \"BOM_UTF32_LE\", \"BOM_UTF32_BE\",\n           \"CodecInfo\", \"Codec\", \"IncrementalEncoder\", \"IncrementalDecoder\",\n           \"StreamReader\", \"StreamWriter\",\n           \"StreamReaderWriter\", \"StreamRecoder\",\n           \"getencoder\", \"getdecoder\", \"getincrementalencoder\",\n           \"getincrementaldecoder\", \"getreader\", \"getwriter\",\n           \"encode\", \"decode\", \"iterencode\", \"iterdecode\",\n           \"strict_errors\", \"ignore_errors\", \"replace_errors\",\n           \"xmlcharrefreplace_errors\",\n           \"backslashreplace_errors\", \"namereplace_errors\",\n           \"register_error\", \"lookup_error\"]\n\n### Constants\n\n#\n# Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)\n# and its possible byte string values\n# for UTF8/UTF16/UTF32 output and little/big endian machines\n#\n\n# UTF-8\nBOM_UTF8 = b'\\xef\\xbb\\xbf'\n\n# UTF-16, little endian\nBOM_LE = BOM_UTF16_LE = b'\\xff\\xfe'\n\n# UTF-16, big endian\nBOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n\n# UTF-32, little endian\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\n\nif sys.byteorder == 'little':\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_LE\n\nelse:\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_BE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_BE\n\n# Old broken names (don't use in new code)\nBOM32_LE = BOM_UTF16_LE\nBOM32_BE = BOM_UTF16_BE\nBOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n\n\n### Codec base classes (defining the API)\n\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n\n    # Private API to allow Python 3.4 to denylist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5\n    #\n    # See http://bugs.python.org/issue19619\n    _is_text_encoding = True # Assume codecs are text encodings by default\n\n    def __new__(cls, encode, decode, streamreader=None, streamwriter=None,\n        incrementalencoder=None, incrementaldecoder=None, name=None,\n        *, _is_text_encoding=None):\n        self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))\n        self.name = name\n        self.encode = encode\n        self.decode = decode\n        self.incrementalencoder = incrementalencoder\n        self.incrementaldecoder = incrementaldecoder\n        self.streamwriter = streamwriter\n        self.streamreader = streamreader\n        if _is_text_encoding is not None:\n            self._is_text_encoding = _is_text_encoding\n        return self\n\n    def __repr__(self):\n        return \"<%s.%s object for encoding %s at %#x>\" % \\\n                (self.__class__.__module__, self.__class__.__qualname__,\n                 self.name, id(self))\n\n    def __getnewargs__(self):\n        return tuple(self)\n\nclass Codec:\n\n    \"\"\" Defines the interface for stateless encoders/decoders.\n\n        The .encode()/.decode() methods may use different error\n        handling schemes by providing the errors argument. These\n        string values are predefined:\n\n         'strict' - raise a ValueError error (or a subclass)\n         'ignore' - ignore the character and continue with the next\n         'replace' - replace with a suitable replacement character;\n                    Python will use the official U+FFFD REPLACEMENT\n                    CHARACTER for the builtin Unicode codecs on\n                    decoding and '?' on encoding.\n         'surrogateescape' - replace with private code points U+DCnn.\n         'xmlcharrefreplace' - Replace with the appropriate XML\n                               character reference (only for encoding).\n         'backslashreplace'  - Replace with backslashed escape sequences.\n         'namereplace'       - Replace with \\\\N{...} escape sequences\n                               (only for encoding).\n\n        The set of allowed values can be extended via register_error.\n\n    \"\"\"\n    def encode(self, input, errors='strict'):\n\n        \"\"\" Encodes the object input and returns a tuple (output\n            object, length consumed).\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamWriter for codecs which have to keep state in order to\n            make encoding efficient.\n\n            The encoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def decode(self, input, errors='strict'):\n\n        \"\"\" Decodes the object input and returns a tuple (output\n            object, length consumed).\n\n            input must be an object which provides the bf_getreadbuf\n            buffer slot. Python strings, buffer objects and memory\n            mapped files are examples of objects providing this slot.\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamReader for codecs which have to keep state in order to\n            make decoding efficient.\n\n            The decoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\nclass IncrementalEncoder(object):\n    \"\"\"\n    An IncrementalEncoder encodes an input in multiple steps. The input can\n    be passed piece by piece to the encode() method. The IncrementalEncoder\n    remembers the state of the encoding process between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Creates an IncrementalEncoder instance.\n\n        The IncrementalEncoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n        self.buffer = \"\"\n\n    def encode(self, input, final=False):\n        \"\"\"\n        Encodes input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Resets the encoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the encoder.\n        \"\"\"\n        return 0\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the encoder. state must have been\n        returned by getstate().\n        \"\"\"\n\nclass BufferedIncrementalEncoder(IncrementalEncoder):\n    \"\"\"\n    This subclass of IncrementalEncoder can be used as the baseclass for an\n    incremental encoder if the encoder must keep some of the output in a\n    buffer between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalEncoder.__init__(self, errors)\n        # unencoded input that is kept between calls to encode()\n        self.buffer = \"\"\n\n    def _buffer_encode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must encode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def encode(self, input, final=False):\n        # encode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_encode(data, self.errors, final)\n        # keep unencoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalEncoder.reset(self)\n        self.buffer = \"\"\n\n    def getstate(self):\n        return self.buffer or 0\n\n    def setstate(self, state):\n        self.buffer = state or \"\"\n\nclass IncrementalDecoder(object):\n    \"\"\"\n    An IncrementalDecoder decodes an input in multiple steps. The input can\n    be passed piece by piece to the decode() method. The IncrementalDecoder\n    remembers the state of the decoding process between calls to decode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Create an IncrementalDecoder instance.\n\n        The IncrementalDecoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n\n    def decode(self, input, final=False):\n        \"\"\"\n        Decode input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Reset the decoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the decoder.\n\n        This must be a (buffered_input, additional_state_info) tuple.\n        buffered_input must be a bytes object containing bytes that\n        were passed to decode() that have not yet been converted.\n        additional_state_info must be a non-negative integer\n        representing the state of the decoder WITHOUT yet having\n        processed the contents of buffered_input.  In the initial state\n        and after reset(), getstate() must return (b\"\", 0).\n        \"\"\"\n        return (b\"\", 0)\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the decoder.\n\n        state must have been returned by getstate().  The effect of\n        setstate((b\"\", 0)) must be equivalent to reset().\n        \"\"\"\n\nclass BufferedIncrementalDecoder(IncrementalDecoder):\n    \"\"\"\n    This subclass of IncrementalDecoder can be used as the baseclass for an\n    incremental decoder if the decoder must be able to handle incomplete\n    byte sequences.\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalDecoder.__init__(self, errors)\n        # undecoded input that is kept between calls to decode()\n        self.buffer = b\"\"\n\n    def _buffer_decode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must decode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def decode(self, input, final=False):\n        # decode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_decode(data, self.errors, final)\n        # keep undecoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalDecoder.reset(self)\n        self.buffer = b\"\"\n\n    def getstate(self):\n        # additional state info is always 0\n        return (self.buffer, 0)\n\n    def setstate(self, state):\n        # ignore additional state info\n        self.buffer = state[0]\n\n#\n# The StreamWriter and StreamReader class provide generic working\n# interfaces which can be used to implement new encoding submodules\n# very easily. See encodings/utf_8.py for an example on how this is\n# done.\n#\n\nclass StreamWriter(Codec):\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamWriter instance.\n\n            stream must be a file-like object open for writing.\n\n            The StreamWriter may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'xmlcharrefreplace' - Replace with the appropriate XML\n                                   character reference.\n             'backslashreplace'  - Replace with backslashed escape\n                                   sequences.\n             'namereplace'       - Replace with \\\\N{...} escape sequences.\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n\n    def write(self, object):\n\n        \"\"\" Writes the object's contents encoded to self.stream.\n        \"\"\"\n        data, consumed = self.encode(object, self.errors)\n        self.stream.write(data)\n\n    def writelines(self, list):\n\n        \"\"\" Writes the concatenated list of strings to the stream\n            using .write().\n        \"\"\"\n        self.write(''.join(list))\n\n    def reset(self):\n\n        \"\"\" Resets the codec buffers used for keeping internal state.\n\n            Calling this method should ensure that the data on the\n            output is put into a clean state, that allows appending\n            of new fresh data without having to rescan the whole\n            stream to recover state.\n\n        \"\"\"\n        pass\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        if whence == 0 and offset == 0:\n            self.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n###\n\nclass StreamReader(Codec):\n\n    charbuffertype = str\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamReader instance.\n\n            stream must be a file-like object open for reading.\n\n            The StreamReader may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'backslashreplace' - Replace with backslashed escape sequences;\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n        self.bytebuffer = b\"\"\n        self._empty_charbuffer = self.charbuffertype()\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def decode(self, input, errors='strict'):\n        raise NotImplementedError\n\n    def read(self, size=-1, chars=-1, firstline=False):\n\n        \"\"\" Decodes data from the stream self.stream and returns the\n            resulting object.\n\n            chars indicates the number of decoded code points or bytes to\n            return. read() will never return more data than requested,\n            but it might return less, if there is not enough available.\n\n            size indicates the approximate maximum number of decoded\n            bytes or code points to read for decoding. The decoder\n            can modify this setting as appropriate. The default value\n            -1 indicates to read and decode as much as possible.  size\n            is intended to prevent having to decode huge files in one\n            step.\n\n            If firstline is true, and a UnicodeDecodeError happens\n            after the first line terminator in the input only the first line\n            will be returned, the rest of the input will be kept until the\n            next call to read().\n\n            The method should use a greedy read strategy, meaning that\n            it should read as much data as is allowed within the\n            definition of the encoding and the given size, e.g.  if\n            optional encoding endings or state markers are available\n            on the stream, these should be read too.\n        \"\"\"\n        # If we have lines cached, first merge them back into characters\n        if self.linebuffer:\n            self.charbuffer = self._empty_charbuffer.join(self.linebuffer)\n            self.linebuffer = None\n\n        if chars < 0:\n            # For compatibility with other read() methods that take a\n            # single argument\n            chars = size\n\n        # read until we get the required number of characters (if available)\n        while True:\n            # can the request be satisfied from the character buffer?\n            if chars >= 0:\n                if len(self.charbuffer) >= chars:\n                    break\n            # we need more data\n            if size < 0:\n                newdata = self.stream.read()\n            else:\n                newdata = self.stream.read(size)\n            # decode bytes (those remaining from the last call included)\n            data = self.bytebuffer + newdata\n            if not data:\n                break\n            try:\n                newchars, decodedbytes = self.decode(data, self.errors)\n            except UnicodeDecodeError as exc:\n                if firstline:\n                    newchars, decodedbytes = \\\n                        self.decode(data[:exc.start], self.errors)\n                    lines = newchars.splitlines(keepends=True)\n                    if len(lines)<=1:\n                        raise\n                else:\n                    raise\n            # keep undecoded bytes until the next call\n            self.bytebuffer = data[decodedbytes:]\n            # put new characters in the character buffer\n            self.charbuffer += newchars\n            # there was no data available\n            if not newdata:\n                break\n        if chars < 0:\n            # Return everything we've got\n            result = self.charbuffer\n            self.charbuffer = self._empty_charbuffer\n        else:\n            # Return the first chars characters\n            result = self.charbuffer[:chars]\n            self.charbuffer = self.charbuffer[chars:]\n        return result\n\n    def readline(self, size=None, keepends=True):\n\n        \"\"\" Read one line from the input stream and return the\n            decoded data.\n\n            size, if given, is passed as size argument to the\n            read() method.\n\n        \"\"\"\n        # If we have lines cached from an earlier read, return\n        # them unconditionally\n        if self.linebuffer:\n            line = self.linebuffer[0]\n            del self.linebuffer[0]\n            if len(self.linebuffer) == 1:\n                # revert to charbuffer mode; we might need more data\n                # next time\n                self.charbuffer = self.linebuffer[0]\n                self.linebuffer = None\n            if not keepends:\n                line = line.splitlines(keepends=False)[0]\n            return line\n\n        readsize = size or 72\n        line = self._empty_charbuffer\n        # If size is given, we call read() only once\n        while True:\n            data = self.read(readsize, firstline=True)\n            if data:\n                # If we're at a \"\\r\" read one extra character (which might\n                # be a \"\\n\") to get a proper line ending. If the stream is\n                # temporarily exhausted we return the wrong line ending.\n                if (isinstance(data, str) and data.endswith(\"\\r\")) or \\\n                   (isinstance(data, bytes) and data.endswith(b\"\\r\")):\n                    data += self.read(size=1, chars=1)\n\n            line += data\n            lines = line.splitlines(keepends=True)\n            if lines:\n                if len(lines) > 1:\n                    # More than one line result; the first line is a full line\n                    # to return\n                    line = lines[0]\n                    del lines[0]\n                    if len(lines) > 1:\n                        # cache the remaining lines\n                        lines[-1] += self.charbuffer\n                        self.linebuffer = lines\n                        self.charbuffer = None\n                    else:\n                        # only one remaining line, put it back into charbuffer\n                        self.charbuffer = lines[0] + self.charbuffer\n                    if not keepends:\n                        line = line.splitlines(keepends=False)[0]\n                    break\n                line0withend = lines[0]\n                line0withoutend = lines[0].splitlines(keepends=False)[0]\n                if line0withend != line0withoutend: # We really have a line end\n                    # Put the rest back together and keep it until the next call\n                    self.charbuffer = self._empty_charbuffer.join(lines[1:]) + \\\n                                      self.charbuffer\n                    if keepends:\n                        line = line0withend\n                    else:\n                        line = line0withoutend\n                    break\n            # we didn't get anything or this was our only try\n            if not data or size is not None:\n                if line and not keepends:\n                    line = line.splitlines(keepends=False)[0]\n                break\n            if readsize < 8000:\n                readsize *= 2\n        return line\n\n    def readlines(self, sizehint=None, keepends=True):\n\n        \"\"\" Read all lines available on the input stream\n            and return them as a list.\n\n            Line breaks are implemented using the codec's decoder\n            method and are included in the list entries.\n\n            sizehint, if given, is ignored since there is no efficient\n            way to finding the true end-of-line.\n\n        \"\"\"\n        data = self.read()\n        return data.splitlines(keepends)\n\n    def reset(self):\n\n        \"\"\" Resets the codec buffers used for keeping internal state.\n\n            Note that no stream repositioning should take place.\n            This method is primarily intended to be able to recover\n            from decoding errors.\n\n        \"\"\"\n        self.bytebuffer = b\"\"\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def seek(self, offset, whence=0):\n        \"\"\" Set the input stream's current position.\n\n            Resets the codec buffers used for keeping state.\n        \"\"\"\n        self.stream.seek(offset, whence)\n        self.reset()\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        line = self.readline()\n        if line:\n            return line\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n###\n\nclass StreamReaderWriter:\n\n    \"\"\" StreamReaderWriter instances allow wrapping streams which\n        work in both read and write modes.\n\n        The design is such that one can use the factory functions\n        returned by the codec.lookup() function to construct the\n        instance.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    encoding = 'unknown'\n\n    def __init__(self, stream, Reader, Writer, errors='strict'):\n\n        \"\"\" Creates a StreamReaderWriter instance.\n\n            stream must be a Stream-like object.\n\n            Reader, Writer must be factory functions or classes\n            providing the StreamReader, StreamWriter interface resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        return self.reader.read(size)\n\n    def readline(self, size=None):\n\n        return self.reader.readline(size)\n\n    def readlines(self, sizehint=None):\n\n        return self.reader.readlines(sizehint)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        return next(self.reader)\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        return self.writer.writelines(list)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        self.reader.reset()\n        if whence == 0 and offset == 0:\n            self.writer.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    # these are needed to make \"with StreamReaderWriter(...)\" work properly\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n###\n\nclass StreamRecoder:\n\n    \"\"\" StreamRecoder instances translate data from one encoding to another.\n\n        They use the complete set of APIs returned by the\n        codecs.lookup() function to implement their task.\n\n        Data written to the StreamRecoder is first decoded into an\n        intermediate format (depending on the \"decode\" codec) and then\n        written to the underlying stream using an instance of the provided\n        Writer class.\n\n        In the other direction, data is read from the underlying stream using\n        a Reader instance and then encoded and returned to the caller.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    data_encoding = 'unknown'\n    file_encoding = 'unknown'\n\n    def __init__(self, stream, encode, decode, Reader, Writer,\n                 errors='strict'):\n\n        \"\"\" Creates a StreamRecoder instance which implements a two-way\n            conversion: encode and decode work on the frontend (the\n            data visible to .read() and .write()) while Reader and Writer\n            work on the backend (the data in stream).\n\n            You can use these objects to do transparent\n            transcodings from e.g. latin-1 to utf-8 and back.\n\n            stream must be a file-like object.\n\n            encode and decode must adhere to the Codec interface; Reader and\n            Writer must be factory functions or classes providing the\n            StreamReader and StreamWriter interfaces resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.encode = encode\n        self.decode = decode\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        data = self.reader.read(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readline(self, size=None):\n\n        if size is None:\n            data = self.reader.readline()\n        else:\n            data = self.reader.readline(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readlines(self, sizehint=None):\n\n        data = self.reader.read()\n        data, bytesencoded = self.encode(data, self.errors)\n        return data.splitlines(keepends=True)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        data = next(self.reader)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        data = b''.join(list)\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def seek(self, offset, whence=0):\n        # Seeks must be propagated to both the readers and writers\n        # as they might need to reset their internal buffers.\n        self.reader.seek(offset, whence)\n        self.writer.seek(offset, whence)\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n### Shortcuts\n\ndef open(filename, mode='r', encoding=None, errors='strict', buffering=-1):\n\n    \"\"\" Open an encoded file using the given mode and return\n        a wrapped version providing transparent encoding/decoding.\n\n        Note: The wrapped version will only accept the object format\n        defined by the codecs, i.e. Unicode objects for most builtin\n        codecs. Output is also codec dependent and will usually be\n        Unicode as well.\n\n        If encoding is not None, then the\n        underlying encoded files are always opened in binary mode.\n        The default file mode is 'r', meaning to open the file in read mode.\n\n        encoding specifies the encoding which is to be used for the\n        file.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        buffering has the same meaning as for the builtin open() API.\n        It defaults to -1 which means that the default buffer size will\n        be used.\n\n        The returned wrapped file object provides an extra attribute\n        .encoding which allows querying the used encoding. This\n        attribute is only available if an encoding was specified as\n        parameter.\n\n    \"\"\"\n    if encoding is not None and \\\n       'b' not in mode:\n        # Force opening of the file in binary mode\n        mode = mode + 'b'\n    file = builtins.open(filename, mode, buffering)\n    if encoding is None:\n        return file\n\n    try:\n        info = lookup(encoding)\n        srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)\n        # Add attributes to simplify introspection\n        srw.encoding = encoding\n        return srw\n    except:\n        file.close()\n        raise\n\ndef EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):\n\n    \"\"\" Return a wrapped version of file which provides transparent\n        encoding translation.\n\n        Data written to the wrapped file is decoded according\n        to the given data_encoding and then encoded to the underlying\n        file using file_encoding. The intermediate data type\n        will usually be Unicode but depends on the specified codecs.\n\n        Bytes read from the file are decoded using file_encoding and then\n        passed back to the caller encoded using data_encoding.\n\n        If file_encoding is not given, it defaults to data_encoding.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        The returned wrapped file object provides two extra attributes\n        .data_encoding and .file_encoding which reflect the given\n        parameters of the same name. The attributes can be used for\n        introspection by Python programs.\n\n    \"\"\"\n    if file_encoding is None:\n        file_encoding = data_encoding\n    data_info = lookup(data_encoding)\n    file_info = lookup(file_encoding)\n    sr = StreamRecoder(file, data_info.encode, data_info.decode,\n                       file_info.streamreader, file_info.streamwriter, errors)\n    # Add attributes to simplify introspection\n    sr.data_encoding = data_encoding\n    sr.file_encoding = file_encoding\n    return sr\n\n### Helpers for codec lookup\n\ndef getencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its encoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).encode\n\ndef getdecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its decoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).decode\n\ndef getincrementalencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalEncoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental encoder.\n\n    \"\"\"\n    encoder = lookup(encoding).incrementalencoder\n    if encoder is None:\n        raise LookupError(encoding)\n    return encoder\n\ndef getincrementaldecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalDecoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental decoder.\n\n    \"\"\"\n    decoder = lookup(encoding).incrementaldecoder\n    if decoder is None:\n        raise LookupError(encoding)\n    return decoder\n\ndef getreader(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamReader class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamreader\n\ndef getwriter(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamWriter class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamwriter\n\ndef iterencode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Encoding iterator.\n\n    Encodes the input strings from the iterator using an IncrementalEncoder.\n\n    errors and kwargs are passed through to the IncrementalEncoder\n    constructor.\n    \"\"\"\n    encoder = getincrementalencoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = encoder.encode(input)\n        if output:\n            yield output\n    output = encoder.encode(\"\", True)\n    if output:\n        yield output\n\ndef iterdecode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Decoding iterator.\n\n    Decodes the input strings from the iterator using an IncrementalDecoder.\n\n    errors and kwargs are passed through to the IncrementalDecoder\n    constructor.\n    \"\"\"\n    decoder = getincrementaldecoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = decoder.decode(input)\n        if output:\n            yield output\n    output = decoder.decode(b\"\", True)\n    if output:\n        yield output\n\n### Helpers for charmap-based codecs\n\ndef make_identity_dict(rng):\n\n    \"\"\" make_identity_dict(rng) -> dict\n\n        Return a dictionary where elements of the rng sequence are\n        mapped to themselves.\n\n    \"\"\"\n    return {i:i for i in rng}\n\ndef make_encoding_map(decoding_map):\n\n    \"\"\" Creates an encoding map from a decoding map.\n\n        If a target mapping in the decoding map occurs multiple\n        times, then that target is mapped to None (undefined mapping),\n        causing an exception when encountered by the charmap codec\n        during translation.\n\n        One example where this happens is cp875.py which decodes\n        multiple character to \\\\u001a.\n\n    \"\"\"\n    m = {}\n    for k,v in decoding_map.items():\n        if not v in m:\n            m[v] = k\n        else:\n            m[v] = None\n    return m\n\n### error handlers\n\ntry:\n    strict_errors = lookup_error(\"strict\")\n    ignore_errors = lookup_error(\"ignore\")\n    replace_errors = lookup_error(\"replace\")\n    xmlcharrefreplace_errors = lookup_error(\"xmlcharrefreplace\")\n    backslashreplace_errors = lookup_error(\"backslashreplace\")\n    namereplace_errors = lookup_error(\"namereplace\")\nexcept LookupError:\n    # In --disable-unicode builds, these error handler are missing\n    strict_errors = None\n    ignore_errors = None\n    replace_errors = None\n    xmlcharrefreplace_errors = None\n    backslashreplace_errors = None\n    namereplace_errors = None\n\n# Tell modulefinder that using codecs probably needs the encodings\n# package\n_false = 0\nif _false:\n    import encodings\n", 1132], "C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py": ["\"\"\" Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py.\n\n\"\"\"#\"\n\nimport codecs\n\n### Codec APIs\n\nclass Codec(codecs.Codec):\n\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\n\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\n\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\n\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\n\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n\n### encodings module API\n\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1252',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )\n\n\n### Decoding Table\n\ndecoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE\n    '\\t'       #  0x09 -> HORIZONTAL TABULATION\n    '\\n'       #  0x0A -> LINE FEED\n    '\\x0b'     #  0x0B -> VERTICAL TABULATION\n    '\\x0c'     #  0x0C -> FORM FEED\n    '\\r'       #  0x0D -> CARRIAGE RETURN\n    '\\x0e'     #  0x0E -> SHIFT OUT\n    '\\x0f'     #  0x0F -> SHIFT IN\n    '\\x10'     #  0x10 -> DATA LINK ESCAPE\n    '\\x11'     #  0x11 -> DEVICE CONTROL ONE\n    '\\x12'     #  0x12 -> DEVICE CONTROL TWO\n    '\\x13'     #  0x13 -> DEVICE CONTROL THREE\n    '\\x14'     #  0x14 -> DEVICE CONTROL FOUR\n    '\\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE\n    '\\x16'     #  0x16 -> SYNCHRONOUS IDLE\n    '\\x17'     #  0x17 -> END OF TRANSMISSION BLOCK\n    '\\x18'     #  0x18 -> CANCEL\n    '\\x19'     #  0x19 -> END OF MEDIUM\n    '\\x1a'     #  0x1A -> SUBSTITUTE\n    '\\x1b'     #  0x1B -> ESCAPE\n    '\\x1c'     #  0x1C -> FILE SEPARATOR\n    '\\x1d'     #  0x1D -> GROUP SEPARATOR\n    '\\x1e'     #  0x1E -> RECORD SEPARATOR\n    '\\x1f'     #  0x1F -> UNIT SEPARATOR\n    ' '        #  0x20 -> SPACE\n    '!'        #  0x21 -> EXCLAMATION MARK\n    '\"'        #  0x22 -> QUOTATION MARK\n    '#'        #  0x23 -> NUMBER SIGN\n    '$'        #  0x24 -> DOLLAR SIGN\n    '%'        #  0x25 -> PERCENT SIGN\n    '&'        #  0x26 -> AMPERSAND\n    \"'\"        #  0x27 -> APOSTROPHE\n    '('        #  0x28 -> LEFT PARENTHESIS\n    ')'        #  0x29 -> RIGHT PARENTHESIS\n    '*'        #  0x2A -> ASTERISK\n    '+'        #  0x2B -> PLUS SIGN\n    ','        #  0x2C -> COMMA\n    '-'        #  0x2D -> HYPHEN-MINUS\n    '.'        #  0x2E -> FULL STOP\n    '/'        #  0x2F -> SOLIDUS\n    '0'        #  0x30 -> DIGIT ZERO\n    '1'        #  0x31 -> DIGIT ONE\n    '2'        #  0x32 -> DIGIT TWO\n    '3'        #  0x33 -> DIGIT THREE\n    '4'        #  0x34 -> DIGIT FOUR\n    '5'        #  0x35 -> DIGIT FIVE\n    '6'        #  0x36 -> DIGIT SIX\n    '7'        #  0x37 -> DIGIT SEVEN\n    '8'        #  0x38 -> DIGIT EIGHT\n    '9'        #  0x39 -> DIGIT NINE\n    ':'        #  0x3A -> COLON\n    ';'        #  0x3B -> SEMICOLON\n    '<'        #  0x3C -> LESS-THAN SIGN\n    '='        #  0x3D -> EQUALS SIGN\n    '>'        #  0x3E -> GREATER-THAN SIGN\n    '?'        #  0x3F -> QUESTION MARK\n    '@'        #  0x40 -> COMMERCIAL AT\n    'A'        #  0x41 -> LATIN CAPITAL LETTER A\n    'B'        #  0x42 -> LATIN CAPITAL LETTER B\n    'C'        #  0x43 -> LATIN CAPITAL LETTER C\n    'D'        #  0x44 -> LATIN CAPITAL LETTER D\n    'E'        #  0x45 -> LATIN CAPITAL LETTER E\n    'F'        #  0x46 -> LATIN CAPITAL LETTER F\n    'G'        #  0x47 -> LATIN CAPITAL LETTER G\n    'H'        #  0x48 -> LATIN CAPITAL LETTER H\n    'I'        #  0x49 -> LATIN CAPITAL LETTER I\n    'J'        #  0x4A -> LATIN CAPITAL LETTER J\n    'K'        #  0x4B -> LATIN CAPITAL LETTER K\n    'L'        #  0x4C -> LATIN CAPITAL LETTER L\n    'M'        #  0x4D -> LATIN CAPITAL LETTER M\n    'N'        #  0x4E -> LATIN CAPITAL LETTER N\n    'O'        #  0x4F -> LATIN CAPITAL LETTER O\n    'P'        #  0x50 -> LATIN CAPITAL LETTER P\n    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q\n    'R'        #  0x52 -> LATIN CAPITAL LETTER R\n    'S'        #  0x53 -> LATIN CAPITAL LETTER S\n    'T'        #  0x54 -> LATIN CAPITAL LETTER T\n    'U'        #  0x55 -> LATIN CAPITAL LETTER U\n    'V'        #  0x56 -> LATIN CAPITAL LETTER V\n    'W'        #  0x57 -> LATIN CAPITAL LETTER W\n    'X'        #  0x58 -> LATIN CAPITAL LETTER X\n    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y\n    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z\n    '['        #  0x5B -> LEFT SQUARE BRACKET\n    '\\\\'       #  0x5C -> REVERSE SOLIDUS\n    ']'        #  0x5D -> RIGHT SQUARE BRACKET\n    '^'        #  0x5E -> CIRCUMFLEX ACCENT\n    '_'        #  0x5F -> LOW LINE\n    '`'        #  0x60 -> GRAVE ACCENT\n    'a'        #  0x61 -> LATIN SMALL LETTER A\n    'b'        #  0x62 -> LATIN SMALL LETTER B\n    'c'        #  0x63 -> LATIN SMALL LETTER C\n    'd'        #  0x64 -> LATIN SMALL LETTER D\n    'e'        #  0x65 -> LATIN SMALL LETTER E\n    'f'        #  0x66 -> LATIN SMALL LETTER F\n    'g'        #  0x67 -> LATIN SMALL LETTER G\n    'h'        #  0x68 -> LATIN SMALL LETTER H\n    'i'        #  0x69 -> LATIN SMALL LETTER I\n    'j'        #  0x6A -> LATIN SMALL LETTER J\n    'k'        #  0x6B -> LATIN SMALL LETTER K\n    'l'        #  0x6C -> LATIN SMALL LETTER L\n    'm'        #  0x6D -> LATIN SMALL LETTER M\n    'n'        #  0x6E -> LATIN SMALL LETTER N\n    'o'        #  0x6F -> LATIN SMALL LETTER O\n    'p'        #  0x70 -> LATIN SMALL LETTER P\n    'q'        #  0x71 -> LATIN SMALL LETTER Q\n    'r'        #  0x72 -> LATIN SMALL LETTER R\n    's'        #  0x73 -> LATIN SMALL LETTER S\n    't'        #  0x74 -> LATIN SMALL LETTER T\n    'u'        #  0x75 -> LATIN SMALL LETTER U\n    'v'        #  0x76 -> LATIN SMALL LETTER V\n    'w'        #  0x77 -> LATIN SMALL LETTER W\n    'x'        #  0x78 -> LATIN SMALL LETTER X\n    'y'        #  0x79 -> LATIN SMALL LETTER Y\n    'z'        #  0x7A -> LATIN SMALL LETTER Z\n    '{'        #  0x7B -> LEFT CURLY BRACKET\n    '|'        #  0x7C -> VERTICAL LINE\n    '}'        #  0x7D -> RIGHT CURLY BRACKET\n    '~'        #  0x7E -> TILDE\n    '\\x7f'     #  0x7F -> DELETE\n    '\\u20ac'   #  0x80 -> EURO SIGN\n    '\\ufffe'   #  0x81 -> UNDEFINED\n    '\\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK\n    '\\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK\n    '\\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK\n    '\\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS\n    '\\u2020'   #  0x86 -> DAGGER\n    '\\u2021'   #  0x87 -> DOUBLE DAGGER\n    '\\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT\n    '\\u2030'   #  0x89 -> PER MILLE SIGN\n    '\\u0160'   #  0x8A -> LATIN CAPITAL LETTER S WITH CARON\n    '\\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK\n    '\\u0152'   #  0x8C -> LATIN CAPITAL LIGATURE OE\n    '\\ufffe'   #  0x8D -> UNDEFINED\n    '\\u017d'   #  0x8E -> LATIN CAPITAL LETTER Z WITH CARON\n    '\\ufffe'   #  0x8F -> UNDEFINED\n    '\\ufffe'   #  0x90 -> UNDEFINED\n    '\\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK\n    '\\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK\n    '\\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK\n    '\\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK\n    '\\u2022'   #  0x95 -> BULLET\n    '\\u2013'   #  0x96 -> EN DASH\n    '\\u2014'   #  0x97 -> EM DASH\n    '\\u02dc'   #  0x98 -> SMALL TILDE\n    '\\u2122'   #  0x99 -> TRADE MARK SIGN\n    '\\u0161'   #  0x9A -> LATIN SMALL LETTER S WITH CARON\n    '\\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK\n    '\\u0153'   #  0x9C -> LATIN SMALL LIGATURE OE\n    '\\ufffe'   #  0x9D -> UNDEFINED\n    '\\u017e'   #  0x9E -> LATIN SMALL LETTER Z WITH CARON\n    '\\u0178'   #  0x9F -> LATIN CAPITAL LETTER Y WITH DIAERESIS\n    '\\xa0'     #  0xA0 -> NO-BREAK SPACE\n    '\\xa1'     #  0xA1 -> INVERTED EXCLAMATION MARK\n    '\\xa2'     #  0xA2 -> CENT SIGN\n    '\\xa3'     #  0xA3 -> POUND SIGN\n    '\\xa4'     #  0xA4 -> CURRENCY SIGN\n    '\\xa5'     #  0xA5 -> YEN SIGN\n    '\\xa6'     #  0xA6 -> BROKEN BAR\n    '\\xa7'     #  0xA7 -> SECTION SIGN\n    '\\xa8'     #  0xA8 -> DIAERESIS\n    '\\xa9'     #  0xA9 -> COPYRIGHT SIGN\n    '\\xaa'     #  0xAA -> FEMININE ORDINAL INDICATOR\n    '\\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\n    '\\xac'     #  0xAC -> NOT SIGN\n    '\\xad'     #  0xAD -> SOFT HYPHEN\n    '\\xae'     #  0xAE -> REGISTERED SIGN\n    '\\xaf'     #  0xAF -> MACRON\n    '\\xb0'     #  0xB0 -> DEGREE SIGN\n    '\\xb1'     #  0xB1 -> PLUS-MINUS SIGN\n    '\\xb2'     #  0xB2 -> SUPERSCRIPT TWO\n    '\\xb3'     #  0xB3 -> SUPERSCRIPT THREE\n    '\\xb4'     #  0xB4 -> ACUTE ACCENT\n    '\\xb5'     #  0xB5 -> MICRO SIGN\n    '\\xb6'     #  0xB6 -> PILCROW SIGN\n    '\\xb7'     #  0xB7 -> MIDDLE DOT\n    '\\xb8'     #  0xB8 -> CEDILLA\n    '\\xb9'     #  0xB9 -> SUPERSCRIPT ONE\n    '\\xba'     #  0xBA -> MASCULINE ORDINAL INDICATOR\n    '\\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\n    '\\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER\n    '\\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF\n    '\\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS\n    '\\xbf'     #  0xBF -> INVERTED QUESTION MARK\n    '\\xc0'     #  0xC0 -> LATIN CAPITAL LETTER A WITH GRAVE\n    '\\xc1'     #  0xC1 -> LATIN CAPITAL LETTER A WITH ACUTE\n    '\\xc2'     #  0xC2 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX\n    '\\xc3'     #  0xC3 -> LATIN CAPITAL LETTER A WITH TILDE\n    '\\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS\n    '\\xc5'     #  0xC5 -> LATIN CAPITAL LETTER A WITH RING ABOVE\n    '\\xc6'     #  0xC6 -> LATIN CAPITAL LETTER AE\n    '\\xc7'     #  0xC7 -> LATIN CAPITAL LETTER C WITH CEDILLA\n    '\\xc8'     #  0xC8 -> LATIN CAPITAL LETTER E WITH GRAVE\n    '\\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE\n    '\\xca'     #  0xCA -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX\n    '\\xcb'     #  0xCB -> LATIN CAPITAL LETTER E WITH DIAERESIS\n    '\\xcc'     #  0xCC -> LATIN CAPITAL LETTER I WITH GRAVE\n    '\\xcd'     #  0xCD -> LATIN CAPITAL LETTER I WITH ACUTE\n    '\\xce'     #  0xCE -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX\n    '\\xcf'     #  0xCF -> LATIN CAPITAL LETTER I WITH DIAERESIS\n    '\\xd0'     #  0xD0 -> LATIN CAPITAL LETTER ETH\n    '\\xd1'     #  0xD1 -> LATIN CAPITAL LETTER N WITH TILDE\n    '\\xd2'     #  0xD2 -> LATIN CAPITAL LETTER O WITH GRAVE\n    '\\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE\n    '\\xd4'     #  0xD4 -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX\n    '\\xd5'     #  0xD5 -> LATIN CAPITAL LETTER O WITH TILDE\n    '\\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS\n    '\\xd7'     #  0xD7 -> MULTIPLICATION SIGN\n    '\\xd8'     #  0xD8 -> LATIN CAPITAL LETTER O WITH STROKE\n    '\\xd9'     #  0xD9 -> LATIN CAPITAL LETTER U WITH GRAVE\n    '\\xda'     #  0xDA -> LATIN CAPITAL LETTER U WITH ACUTE\n    '\\xdb'     #  0xDB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX\n    '\\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS\n    '\\xdd'     #  0xDD -> LATIN CAPITAL LETTER Y WITH ACUTE\n    '\\xde'     #  0xDE -> LATIN CAPITAL LETTER THORN\n    '\\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S\n    '\\xe0'     #  0xE0 -> LATIN SMALL LETTER A WITH GRAVE\n    '\\xe1'     #  0xE1 -> LATIN SMALL LETTER A WITH ACUTE\n    '\\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX\n    '\\xe3'     #  0xE3 -> LATIN SMALL LETTER A WITH TILDE\n    '\\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS\n    '\\xe5'     #  0xE5 -> LATIN SMALL LETTER A WITH RING ABOVE\n    '\\xe6'     #  0xE6 -> LATIN SMALL LETTER AE\n    '\\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA\n    '\\xe8'     #  0xE8 -> LATIN SMALL LETTER E WITH GRAVE\n    '\\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE\n    '\\xea'     #  0xEA -> LATIN SMALL LETTER E WITH CIRCUMFLEX\n    '\\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS\n    '\\xec'     #  0xEC -> LATIN SMALL LETTER I WITH GRAVE\n    '\\xed'     #  0xED -> LATIN SMALL LETTER I WITH ACUTE\n    '\\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX\n    '\\xef'     #  0xEF -> LATIN SMALL LETTER I WITH DIAERESIS\n    '\\xf0'     #  0xF0 -> LATIN SMALL LETTER ETH\n    '\\xf1'     #  0xF1 -> LATIN SMALL LETTER N WITH TILDE\n    '\\xf2'     #  0xF2 -> LATIN SMALL LETTER O WITH GRAVE\n    '\\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE\n    '\\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX\n    '\\xf5'     #  0xF5 -> LATIN SMALL LETTER O WITH TILDE\n    '\\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS\n    '\\xf7'     #  0xF7 -> DIVISION SIGN\n    '\\xf8'     #  0xF8 -> LATIN SMALL LETTER O WITH STROKE\n    '\\xf9'     #  0xF9 -> LATIN SMALL LETTER U WITH GRAVE\n    '\\xfa'     #  0xFA -> LATIN SMALL LETTER U WITH ACUTE\n    '\\xfb'     #  0xFB -> LATIN SMALL LETTER U WITH CIRCUMFLEX\n    '\\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS\n    '\\xfd'     #  0xFD -> LATIN SMALL LETTER Y WITH ACUTE\n    '\\xfe'     #  0xFE -> LATIN SMALL LETTER THORN\n    '\\xff'     #  0xFF -> LATIN SMALL LETTER Y WITH DIAERESIS\n)\n\n### Encoding table\nencoding_table=codecs.charmap_build(decoding_table)\n", 307], "C:\\Programming\\Python313\\Lib\\re\\_compiler.py": ["#\n# Secret Labs' Regular Expression Engine\n#\n# convert template to internal format\n#\n# Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n#\n# See the __init__.py file for information on usage and redistribution.\n#\n\n\"\"\"Internal support module for sre\"\"\"\n\nimport _sre\nfrom . import _parser\nfrom ._constants import *\nfrom ._casefix import _EXTRA_CASES\n\nassert _sre.MAGIC == MAGIC, \"SRE module mismatch\"\n\n_LITERAL_CODES = {LITERAL, NOT_LITERAL}\n_SUCCESS_CODES = {SUCCESS, FAILURE}\n_ASSERT_CODES = {ASSERT, ASSERT_NOT}\n_UNIT_CODES = _LITERAL_CODES | {ANY, IN}\n\n_REPEATING_CODES = {\n    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),\n    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),\n    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),\n}\n\ndef _combine_flags(flags, add_flags, del_flags,\n                   TYPE_FLAGS=_parser.TYPE_FLAGS):\n    if add_flags & TYPE_FLAGS:\n        flags &= ~TYPE_FLAGS\n    return (flags | add_flags) & ~del_flags\n\ndef _compile(code, pattern, flags):\n    # internal: compile a (sub)pattern\n    emit = code.append\n    _len = len\n    LITERAL_CODES = _LITERAL_CODES\n    REPEATING_CODES = _REPEATING_CODES\n    SUCCESS_CODES = _SUCCESS_CODES\n    ASSERT_CODES = _ASSERT_CODES\n    iscased = None\n    tolower = None\n    fixes = None\n    if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:\n        if flags & SRE_FLAG_UNICODE:\n            iscased = _sre.unicode_iscased\n            tolower = _sre.unicode_tolower\n            fixes = _EXTRA_CASES\n        else:\n            iscased = _sre.ascii_iscased\n            tolower = _sre.ascii_tolower\n    for op, av in pattern:\n        if op in LITERAL_CODES:\n            if not flags & SRE_FLAG_IGNORECASE:\n                emit(op)\n                emit(av)\n            elif flags & SRE_FLAG_LOCALE:\n                emit(OP_LOCALE_IGNORE[op])\n                emit(av)\n            elif not iscased(av):\n                emit(op)\n                emit(av)\n            else:\n                lo = tolower(av)\n                if not fixes:  # ascii\n                    emit(OP_IGNORE[op])\n                    emit(lo)\n                elif lo not in fixes:\n                    emit(OP_UNICODE_IGNORE[op])\n                    emit(lo)\n                else:\n                    emit(IN_UNI_IGNORE)\n                    skip = _len(code); emit(0)\n                    if op is NOT_LITERAL:\n                        emit(NEGATE)\n                    for k in (lo,) + fixes[lo]:\n                        emit(LITERAL)\n                        emit(k)\n                    emit(FAILURE)\n                    code[skip] = _len(code) - skip\n        elif op is IN:\n            charset, hascased = _optimize_charset(av, iscased, tolower, fixes)\n            if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:\n                emit(IN_LOC_IGNORE)\n            elif not hascased:\n                emit(IN)\n            elif not fixes:  # ascii\n                emit(IN_IGNORE)\n            else:\n                emit(IN_UNI_IGNORE)\n            skip = _len(code); emit(0)\n            _compile_charset(charset, flags, code)\n            code[skip] = _len(code) - skip\n        elif op is ANY:\n            if flags & SRE_FLAG_DOTALL:\n                emit(ANY_ALL)\n            else:\n                emit(ANY)\n        elif op in REPEATING_CODES:\n            if _simple(av[2]):\n                emit(REPEATING_CODES[op][2])\n                skip = _len(code); emit(0)\n                emit(av[0])\n                emit(av[1])\n                _compile(code, av[2], flags)\n                emit(SUCCESS)\n                code[skip] = _len(code) - skip\n            else:\n                emit(REPEATING_CODES[op][0])\n                skip = _len(code); emit(0)\n                emit(av[0])\n                emit(av[1])\n                _compile(code, av[2], flags)\n                code[skip] = _len(code) - skip\n                emit(REPEATING_CODES[op][1])\n        elif op is SUBPATTERN:\n            group, add_flags, del_flags, p = av\n            if group:\n                emit(MARK)\n                emit((group-1)*2)\n            # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))\n            _compile(code, p, _combine_flags(flags, add_flags, del_flags))\n            if group:\n                emit(MARK)\n                emit((group-1)*2+1)\n        elif op is ATOMIC_GROUP:\n            # Atomic Groups are handled by starting with an Atomic\n            # Group op code, then putting in the atomic group pattern\n            # and finally a success op code to tell any repeat\n            # operations within the Atomic Group to stop eating and\n            # pop their stack if they reach it\n            emit(ATOMIC_GROUP)\n            skip = _len(code); emit(0)\n            _compile(code, av, flags)\n            emit(SUCCESS)\n            code[skip] = _len(code) - skip\n        elif op in SUCCESS_CODES:\n            emit(op)\n        elif op in ASSERT_CODES:\n            emit(op)\n            skip = _len(code); emit(0)\n            if av[0] >= 0:\n                emit(0) # look ahead\n            else:\n                lo, hi = av[1].getwidth()\n                if lo > MAXCODE:\n                    raise error(\"looks too much behind\")\n                if lo != hi:\n                    raise PatternError(\"look-behind requires fixed-width pattern\")\n                emit(lo) # look behind\n            _compile(code, av[1], flags)\n            emit(SUCCESS)\n            code[skip] = _len(code) - skip\n        elif op is AT:\n            emit(op)\n            if flags & SRE_FLAG_MULTILINE:\n                av = AT_MULTILINE.get(av, av)\n            if flags & SRE_FLAG_LOCALE:\n                av = AT_LOCALE.get(av, av)\n            elif flags & SRE_FLAG_UNICODE:\n                av = AT_UNICODE.get(av, av)\n            emit(av)\n        elif op is BRANCH:\n            emit(op)\n            tail = []\n            tailappend = tail.append\n            for av in av[1]:\n                skip = _len(code); emit(0)\n                # _compile_info(code, av, flags)\n                _compile(code, av, flags)\n                emit(JUMP)\n                tailappend(_len(code)); emit(0)\n                code[skip] = _len(code) - skip\n            emit(FAILURE) # end of branch\n            for tail in tail:\n                code[tail] = _len(code) - tail\n        elif op is CATEGORY:\n            emit(op)\n            if flags & SRE_FLAG_LOCALE:\n                av = CH_LOCALE[av]\n            elif flags & SRE_FLAG_UNICODE:\n                av = CH_UNICODE[av]\n            emit(av)\n        elif op is GROUPREF:\n            if not flags & SRE_FLAG_IGNORECASE:\n                emit(op)\n            elif flags & SRE_FLAG_LOCALE:\n                emit(GROUPREF_LOC_IGNORE)\n            elif not fixes:  # ascii\n                emit(GROUPREF_IGNORE)\n            else:\n                emit(GROUPREF_UNI_IGNORE)\n            emit(av-1)\n        elif op is GROUPREF_EXISTS:\n            emit(op)\n            emit(av[0]-1)\n            skipyes = _len(code); emit(0)\n            _compile(code, av[1], flags)\n            if av[2]:\n                emit(JUMP)\n                skipno = _len(code); emit(0)\n                code[skipyes] = _len(code) - skipyes + 1\n                _compile(code, av[2], flags)\n                code[skipno] = _len(code) - skipno\n            else:\n                code[skipyes] = _len(code) - skipyes + 1\n        else:\n            raise PatternError(f\"internal: unsupported operand type {op!r}\")\n\ndef _compile_charset(charset, flags, code):\n    # compile charset subprogram\n    emit = code.append\n    for op, av in charset:\n        emit(op)\n        if op is NEGATE:\n            pass\n        elif op is LITERAL:\n            emit(av)\n        elif op is RANGE or op is RANGE_UNI_IGNORE:\n            emit(av[0])\n            emit(av[1])\n        elif op is CHARSET:\n            code.extend(av)\n        elif op is BIGCHARSET:\n            code.extend(av)\n        elif op is CATEGORY:\n            if flags & SRE_FLAG_LOCALE:\n                emit(CH_LOCALE[av])\n            elif flags & SRE_FLAG_UNICODE:\n                emit(CH_UNICODE[av])\n            else:\n                emit(av)\n        else:\n            raise PatternError(f\"internal: unsupported set operator {op!r}\")\n    emit(FAILURE)\n\ndef _optimize_charset(charset, iscased=None, fixup=None, fixes=None):\n    # internal: optimize character set\n    out = []\n    tail = []\n    charmap = bytearray(256)\n    hascased = False\n    for op, av in charset:\n        while True:\n            try:\n                if op is LITERAL:\n                    if fixup: # IGNORECASE and not LOCALE\n                        av = fixup(av)\n                        charmap[av] = 1\n                        if fixes and av in fixes:\n                            for k in fixes[av]:\n                                charmap[k] = 1\n                        if not hascased and iscased(av):\n                            hascased = True\n                    else:\n                        charmap[av] = 1\n                elif op is RANGE:\n                    r = range(av[0], av[1]+1)\n                    if fixup: # IGNORECASE and not LOCALE\n                        if fixes:\n                            for i in map(fixup, r):\n                                charmap[i] = 1\n                                if i in fixes:\n                                    for k in fixes[i]:\n                                        charmap[k] = 1\n                        else:\n                            for i in map(fixup, r):\n                                charmap[i] = 1\n                        if not hascased:\n                            hascased = any(map(iscased, r))\n                    else:\n                        for i in r:\n                            charmap[i] = 1\n                elif op is NEGATE:\n                    out.append((op, av))\n                else:\n                    tail.append((op, av))\n            except IndexError:\n                if len(charmap) == 256:\n                    # character set contains non-UCS1 character codes\n                    charmap += b'\\0' * 0xff00\n                    continue\n                # Character set contains non-BMP character codes.\n                # For range, all BMP characters in the range are already\n                # proceeded.\n                if fixup: # IGNORECASE and not LOCALE\n                    # For now, IN_UNI_IGNORE+LITERAL and\n                    # IN_UNI_IGNORE+RANGE_UNI_IGNORE work for all non-BMP\n                    # characters, because two characters (at least one of\n                    # which is not in the BMP) match case-insensitively\n                    # if and only if:\n                    # 1) c1.lower() == c2.lower()\n                    # 2) c1.lower() == c2 or c1.lower().upper() == c2\n                    # Also, both c.lower() and c.lower().upper() are single\n                    # characters for every non-BMP character.\n                    if op is RANGE:\n                        if fixes: # not ASCII\n                            op = RANGE_UNI_IGNORE\n                        hascased = True\n                    else:\n                        assert op is LITERAL\n                        if not hascased and iscased(av):\n                            hascased = True\n                tail.append((op, av))\n            break\n\n    # compress character map\n    runs = []\n    q = 0\n    while True:\n        p = charmap.find(1, q)\n        if p < 0:\n            break\n        if len(runs) >= 2:\n            runs = None\n            break\n        q = charmap.find(0, p)\n        if q < 0:\n            runs.append((p, len(charmap)))\n            break\n        runs.append((p, q))\n    if runs is not None:\n        # use literal/range\n        for p, q in runs:\n            if q - p == 1:\n                out.append((LITERAL, p))\n            else:\n                out.append((RANGE, (p, q - 1)))\n        out += tail\n        # if the case was changed or new representation is more compact\n        if hascased or len(out) < len(charset):\n            return out, hascased\n        # else original character set is good enough\n        return charset, hascased\n\n    # use bitmap\n    if len(charmap) == 256:\n        data = _mk_bitmap(charmap)\n        out.append((CHARSET, data))\n        out += tail\n        return out, hascased\n\n    # To represent a big charset, first a bitmap of all characters in the\n    # set is constructed. Then, this bitmap is sliced into chunks of 256\n    # characters, duplicate chunks are eliminated, and each chunk is\n    # given a number. In the compiled expression, the charset is\n    # represented by a 32-bit word sequence, consisting of one word for\n    # the number of different chunks, a sequence of 256 bytes (64 words)\n    # of chunk numbers indexed by their original chunk position, and a\n    # sequence of 256-bit chunks (8 words each).\n\n    # Compression is normally good: in a typical charset, large ranges of\n    # Unicode will be either completely excluded (e.g. if only cyrillic\n    # letters are to be matched), or completely included (e.g. if large\n    # subranges of Kanji match). These ranges will be represented by\n    # chunks of all one-bits or all zero-bits.\n\n    # Matching can be also done efficiently: the more significant byte of\n    # the Unicode character is an index into the chunk number, and the\n    # less significant byte is a bit index in the chunk (just like the\n    # CHARSET matching).\n\n    charmap = bytes(charmap) # should be hashable\n    comps = {}\n    mapping = bytearray(256)\n    block = 0\n    data = bytearray()\n    for i in range(0, 65536, 256):\n        chunk = charmap[i: i + 256]\n        if chunk in comps:\n            mapping[i // 256] = comps[chunk]\n        else:\n            mapping[i // 256] = comps[chunk] = block\n            block += 1\n            data += chunk\n    data = _mk_bitmap(data)\n    data[0:0] = [block] + _bytes_to_codes(mapping)\n    out.append((BIGCHARSET, data))\n    out += tail\n    return out, hascased\n\n_CODEBITS = _sre.CODESIZE * 8\nMAXCODE = (1 << _CODEBITS) - 1\n_BITS_TRANS = b'0' + b'1' * 255\ndef _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):\n    s = bits.translate(_BITS_TRANS)[::-1]\n    return [_int(s[i - _CODEBITS: i], 2)\n            for i in range(len(s), 0, -_CODEBITS)]\n\ndef _bytes_to_codes(b):\n    # Convert block indices to word array\n    a = memoryview(b).cast('I')\n    assert a.itemsize == _sre.CODESIZE\n    assert len(a) * a.itemsize == len(b)\n    return a.tolist()\n\ndef _simple(p):\n    # check if this subpattern is a \"simple\" operator\n    if len(p) != 1:\n        return False\n    op, av = p[0]\n    if op is SUBPATTERN:\n        return av[0] is None and _simple(av[-1])\n    return op in _UNIT_CODES\n\ndef _generate_overlap_table(prefix):\n    \"\"\"\n    Generate an overlap table for the following prefix.\n    An overlap table is a table of the same size as the prefix which\n    informs about the potential self-overlap for each index in the prefix:\n    - if overlap[i] == 0, prefix[i:] can't overlap prefix[0:...]\n    - if overlap[i] == k with 0 < k <= i, prefix[i-k+1:i+1] overlaps with\n      prefix[0:k]\n    \"\"\"\n    table = [0] * len(prefix)\n    for i in range(1, len(prefix)):\n        idx = table[i - 1]\n        while prefix[i] != prefix[idx]:\n            if idx == 0:\n                table[i] = 0\n                break\n            idx = table[idx - 1]\n        else:\n            table[i] = idx + 1\n    return table\n\ndef _get_iscased(flags):\n    if not flags & SRE_FLAG_IGNORECASE:\n        return None\n    elif flags & SRE_FLAG_UNICODE:\n        return _sre.unicode_iscased\n    else:\n        return _sre.ascii_iscased\n\ndef _get_literal_prefix(pattern, flags):\n    # look for literal prefix\n    prefix = []\n    prefixappend = prefix.append\n    prefix_skip = None\n    iscased = _get_iscased(flags)\n    for op, av in pattern.data:\n        if op is LITERAL:\n            if iscased and iscased(av):\n                break\n            prefixappend(av)\n        elif op is SUBPATTERN:\n            group, add_flags, del_flags, p = av\n            flags1 = _combine_flags(flags, add_flags, del_flags)\n            if flags1 & SRE_FLAG_IGNORECASE and flags1 & SRE_FLAG_LOCALE:\n                break\n            prefix1, prefix_skip1, got_all = _get_literal_prefix(p, flags1)\n            if prefix_skip is None:\n                if group is not None:\n                    prefix_skip = len(prefix)\n                elif prefix_skip1 is not None:\n                    prefix_skip = len(prefix) + prefix_skip1\n            prefix.extend(prefix1)\n            if not got_all:\n                break\n        else:\n            break\n    else:\n        return prefix, prefix_skip, True\n    return prefix, prefix_skip, False\n\ndef _get_charset_prefix(pattern, flags):\n    while True:\n        if not pattern.data:\n            return None\n        op, av = pattern.data[0]\n        if op is not SUBPATTERN:\n            break\n        group, add_flags, del_flags, pattern = av\n        flags = _combine_flags(flags, add_flags, del_flags)\n        if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:\n            return None\n\n    iscased = _get_iscased(flags)\n    if op is LITERAL:\n        if iscased and iscased(av):\n            return None\n        return [(op, av)]\n    elif op is BRANCH:\n        charset = []\n        charsetappend = charset.append\n        for p in av[1]:\n            if not p:\n                return None\n            op, av = p[0]\n            if op is LITERAL and not (iscased and iscased(av)):\n                charsetappend((op, av))\n            else:\n                return None\n        return charset\n    elif op is IN:\n        charset = av\n        if iscased:\n            for op, av in charset:\n                if op is LITERAL:\n                    if iscased(av):\n                        return None\n                elif op is RANGE:\n                    if av[1] > 0xffff:\n                        return None\n                    if any(map(iscased, range(av[0], av[1]+1))):\n                        return None\n        return charset\n    return None\n\ndef _compile_info(code, pattern, flags):\n    # internal: compile an info block.  in the current version,\n    # this contains min/max pattern width, and an optional literal\n    # prefix or a character map\n    lo, hi = pattern.getwidth()\n    if hi > MAXCODE:\n        hi = MAXCODE\n    if lo == 0:\n        code.extend([INFO, 4, 0, lo, hi])\n        return\n    # look for a literal prefix\n    prefix = []\n    prefix_skip = 0\n    charset = [] # not used\n    if not (flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE):\n        # look for literal prefix\n        prefix, prefix_skip, got_all = _get_literal_prefix(pattern, flags)\n        # if no prefix, look for charset prefix\n        if not prefix:\n            charset = _get_charset_prefix(pattern, flags)\n##     if prefix:\n##         print(\"*** PREFIX\", prefix, prefix_skip)\n##     if charset:\n##         print(\"*** CHARSET\", charset)\n    # add an info block\n    emit = code.append\n    emit(INFO)\n    skip = len(code); emit(0)\n    # literal flag\n    mask = 0\n    if prefix:\n        mask = SRE_INFO_PREFIX\n        if prefix_skip is None and got_all:\n            mask = mask | SRE_INFO_LITERAL\n    elif charset:\n        mask = mask | SRE_INFO_CHARSET\n    emit(mask)\n    # pattern length\n    if lo < MAXCODE:\n        emit(lo)\n    else:\n        emit(MAXCODE)\n        prefix = prefix[:MAXCODE]\n    emit(hi)\n    # add literal prefix\n    if prefix:\n        emit(len(prefix)) # length\n        if prefix_skip is None:\n            prefix_skip =  len(prefix)\n        emit(prefix_skip) # skip\n        code.extend(prefix)\n        # generate overlap table\n        code.extend(_generate_overlap_table(prefix))\n    elif charset:\n        charset, hascased = _optimize_charset(charset)\n        assert not hascased\n        _compile_charset(charset, flags, code)\n    code[skip] = len(code) - skip\n\ndef isstring(obj):\n    return isinstance(obj, (str, bytes))\n\ndef _code(p, flags):\n\n    flags = p.state.flags | flags\n    code = []\n\n    # compile info block\n    _compile_info(code, p, flags)\n\n    # compile the pattern\n    _compile(code, p.data, flags)\n\n    code.append(SUCCESS)\n\n    return code\n\ndef _hex_code(code):\n    return '[%s]' % ', '.join('%#0*x' % (_sre.CODESIZE*2+2, x) for x in code)\n\ndef dis(code):\n    import sys\n\n    labels = set()\n    level = 0\n    offset_width = len(str(len(code) - 1))\n\n    def dis_(start, end):\n        def print_(*args, to=None):\n            if to is not None:\n                labels.add(to)\n                args += ('(to %d)' % (to,),)\n            print('%*d%s ' % (offset_width, start, ':' if start in labels else '.'),\n                  end='  '*(level-1))\n            print(*args)\n\n        def print_2(*args):\n            print(end=' '*(offset_width + 2*level))\n            print(*args)\n\n        nonlocal level\n        level += 1\n        i = start\n        while i < end:\n            start = i\n            op = code[i]\n            i += 1\n            op = OPCODES[op]\n            if op in (SUCCESS, FAILURE, ANY, ANY_ALL,\n                      MAX_UNTIL, MIN_UNTIL, NEGATE):\n                print_(op)\n            elif op in (LITERAL, NOT_LITERAL,\n                        LITERAL_IGNORE, NOT_LITERAL_IGNORE,\n                        LITERAL_UNI_IGNORE, NOT_LITERAL_UNI_IGNORE,\n                        LITERAL_LOC_IGNORE, NOT_LITERAL_LOC_IGNORE):\n                arg = code[i]\n                i += 1\n                print_(op, '%#02x (%r)' % (arg, chr(arg)))\n            elif op is AT:\n                arg = code[i]\n                i += 1\n                arg = str(ATCODES[arg])\n                assert arg[:3] == 'AT_'\n                print_(op, arg[3:])\n            elif op is CATEGORY:\n                arg = code[i]\n                i += 1\n                arg = str(CHCODES[arg])\n                assert arg[:9] == 'CATEGORY_'\n                print_(op, arg[9:])\n            elif op in (IN, IN_IGNORE, IN_UNI_IGNORE, IN_LOC_IGNORE):\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                dis_(i+1, i+skip)\n                i += skip\n            elif op in (RANGE, RANGE_UNI_IGNORE):\n                lo, hi = code[i: i+2]\n                i += 2\n                print_(op, '%#02x %#02x (%r-%r)' % (lo, hi, chr(lo), chr(hi)))\n            elif op is CHARSET:\n                print_(op, _hex_code(code[i: i + 256//_CODEBITS]))\n                i += 256//_CODEBITS\n            elif op is BIGCHARSET:\n                arg = code[i]\n                i += 1\n                mapping = list(b''.join(x.to_bytes(_sre.CODESIZE, sys.byteorder)\n                                        for x in code[i: i + 256//_sre.CODESIZE]))\n                print_(op, arg, mapping)\n                i += 256//_sre.CODESIZE\n                level += 1\n                for j in range(arg):\n                    print_2(_hex_code(code[i: i + 256//_CODEBITS]))\n                    i += 256//_CODEBITS\n                level -= 1\n            elif op in (MARK, GROUPREF, GROUPREF_IGNORE, GROUPREF_UNI_IGNORE,\n                        GROUPREF_LOC_IGNORE):\n                arg = code[i]\n                i += 1\n                print_(op, arg)\n            elif op is JUMP:\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                i += 1\n            elif op is BRANCH:\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                while skip:\n                    dis_(i+1, i+skip)\n                    i += skip\n                    start = i\n                    skip = code[i]\n                    if skip:\n                        print_('branch', skip, to=i+skip)\n                    else:\n                        print_(FAILURE)\n                i += 1\n            elif op in (REPEAT, REPEAT_ONE, MIN_REPEAT_ONE,\n                        POSSESSIVE_REPEAT, POSSESSIVE_REPEAT_ONE):\n                skip, min, max = code[i: i+3]\n                if max == MAXREPEAT:\n                    max = 'MAXREPEAT'\n                print_(op, skip, min, max, to=i+skip)\n                dis_(i+3, i+skip)\n                i += skip\n            elif op is GROUPREF_EXISTS:\n                arg, skip = code[i: i+2]\n                print_(op, arg, skip, to=i+skip)\n                i += 2\n            elif op in (ASSERT, ASSERT_NOT):\n                skip, arg = code[i: i+2]\n                print_(op, skip, arg, to=i+skip)\n                dis_(i+2, i+skip)\n                i += skip\n            elif op is ATOMIC_GROUP:\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                dis_(i+1, i+skip)\n                i += skip\n            elif op is INFO:\n                skip, flags, min, max = code[i: i+4]\n                if max == MAXREPEAT:\n                    max = 'MAXREPEAT'\n                print_(op, skip, bin(flags), min, max, to=i+skip)\n                start = i+4\n                if flags & SRE_INFO_PREFIX:\n                    prefix_len, prefix_skip = code[i+4: i+6]\n                    print_2('  prefix_skip', prefix_skip)\n                    start = i + 6\n                    prefix = code[start: start+prefix_len]\n                    print_2('  prefix',\n                            '[%s]' % ', '.join('%#02x' % x for x in prefix),\n                            '(%r)' % ''.join(map(chr, prefix)))\n                    start += prefix_len\n                    print_2('  overlap', code[start: start+prefix_len])\n                    start += prefix_len\n                if flags & SRE_INFO_CHARSET:\n                    level += 1\n                    print_2('in')\n                    dis_(start, i+skip)\n                    level -= 1\n                i += skip\n            else:\n                raise ValueError(op)\n\n        level -= 1\n\n    dis_(0, len(code))\n\n\ndef compile(p, flags=0):\n    # internal: convert pattern list to internal format\n\n    if isstring(p):\n        pattern = p\n        p = _parser.parse(p, flags)\n    else:\n        pattern = None\n\n    code = _code(p, flags)\n\n    if flags & SRE_FLAG_DEBUG:\n        print()\n        dis(code)\n\n    # map in either direction\n    groupindex = p.state.groupdict\n    indexgroup = [None] * p.state.groups\n    for k, i in groupindex.items():\n        indexgroup[i] = k\n\n    return _sre.compile(\n        pattern, flags | p.state.flags, code,\n        p.state.groups-1,\n        groupindex, tuple(indexgroup)\n        )\n", 768], "C:\\Programming\\Python313\\Lib\\re\\_parser.py": ["#\n# Secret Labs' Regular Expression Engine\n#\n# convert re-style regular expression to sre pattern\n#\n# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.\n#\n# See the __init__.py file for information on usage and redistribution.\n#\n\n\"\"\"Internal support module for sre\"\"\"\n\n# XXX: show string offset and offending character for all errors\n\nfrom ._constants import *\n\nSPECIAL_CHARS = \".\\\\[{()*+?^$|\"\nREPEAT_CHARS = \"*+?{\"\n\nDIGITS = frozenset(\"0123456789\")\n\nOCTDIGITS = frozenset(\"01234567\")\nHEXDIGITS = frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\n\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),\n    r\"\\v\": (LITERAL, ord(\"\\v\")),\n    r\"\\\\\": (LITERAL, ord(\"\\\\\"))\n}\n\nCATEGORIES = {\n    r\"\\A\": (AT, AT_BEGINNING_STRING), # start of string\n    r\"\\b\": (AT, AT_BOUNDARY),\n    r\"\\B\": (AT, AT_NON_BOUNDARY),\n    r\"\\d\": (IN, [(CATEGORY, CATEGORY_DIGIT)]),\n    r\"\\D\": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),\n    r\"\\s\": (IN, [(CATEGORY, CATEGORY_SPACE)]),\n    r\"\\S\": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),\n    r\"\\w\": (IN, [(CATEGORY, CATEGORY_WORD)]),\n    r\"\\W\": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),\n    r\"\\Z\": (AT, AT_END_STRING), # end of string\n}\n\nFLAGS = {\n    # standard flags\n    \"i\": SRE_FLAG_IGNORECASE,\n    \"L\": SRE_FLAG_LOCALE,\n    \"m\": SRE_FLAG_MULTILINE,\n    \"s\": SRE_FLAG_DOTALL,\n    \"x\": SRE_FLAG_VERBOSE,\n    # extensions\n    \"a\": SRE_FLAG_ASCII,\n    \"u\": SRE_FLAG_UNICODE,\n}\n\nTYPE_FLAGS = SRE_FLAG_ASCII | SRE_FLAG_LOCALE | SRE_FLAG_UNICODE\nGLOBAL_FLAGS = SRE_FLAG_DEBUG\n\n# Maximal value returned by SubPattern.getwidth().\n# Must be larger than MAXREPEAT, MAXCODE and sys.maxsize.\nMAXWIDTH = 1 << 64\n\nclass State:\n    # keeps track of state for parsing\n    def __init__(self):\n        self.flags = 0\n        self.groupdict = {}\n        self.groupwidths = [None]  # group 0\n        self.lookbehindgroups = None\n        self.grouprefpos = {}\n    @property\n    def groups(self):\n        return len(self.groupwidths)\n    def opengroup(self, name=None):\n        gid = self.groups\n        self.groupwidths.append(None)\n        if self.groups > MAXGROUPS:\n            raise error(\"too many groups\")\n        if name is not None:\n            ogid = self.groupdict.get(name, None)\n            if ogid is not None:\n                raise error(\"redefinition of group name %r as group %d; \"\n                            \"was group %d\" % (name, gid,  ogid))\n            self.groupdict[name] = gid\n        return gid\n    def closegroup(self, gid, p):\n        self.groupwidths[gid] = p.getwidth()\n    def checkgroup(self, gid):\n        return gid < self.groups and self.groupwidths[gid] is not None\n\n    def checklookbehindgroup(self, gid, source):\n        if self.lookbehindgroups is not None:\n            if not self.checkgroup(gid):\n                raise source.error('cannot refer to an open group')\n            if gid >= self.lookbehindgroups:\n                raise source.error('cannot refer to group defined in the same '\n                                   'lookbehind subpattern')\n\nclass SubPattern:\n    # a subpattern, in intermediate form\n    def __init__(self, state, data=None):\n        self.state = state\n        if data is None:\n            data = []\n        self.data = data\n        self.width = None\n\n    def dump(self, level=0):\n        seqtypes = (tuple, list)\n        for op, av in self.data:\n            print(level*\"  \" + str(op), end='')\n            if op is IN:\n                # member sublanguage\n                print()\n                for op, a in av:\n                    print((level+1)*\"  \" + str(op), a)\n            elif op is BRANCH:\n                print()\n                for i, a in enumerate(av[1]):\n                    if i:\n                        print(level*\"  \" + \"OR\")\n                    a.dump(level+1)\n            elif op is GROUPREF_EXISTS:\n                condgroup, item_yes, item_no = av\n                print('', condgroup)\n                item_yes.dump(level+1)\n                if item_no:\n                    print(level*\"  \" + \"ELSE\")\n                    item_no.dump(level+1)\n            elif isinstance(av, SubPattern):\n                print()\n                av.dump(level+1)\n            elif isinstance(av, seqtypes):\n                nl = False\n                for a in av:\n                    if isinstance(a, SubPattern):\n                        if not nl:\n                            print()\n                        a.dump(level+1)\n                        nl = True\n                    else:\n                        if not nl:\n                            print(' ', end='')\n                        print(a, end='')\n                        nl = False\n                if not nl:\n                    print()\n            else:\n                print('', av)\n    def __repr__(self):\n        return repr(self.data)\n    def __len__(self):\n        return len(self.data)\n    def __delitem__(self, index):\n        del self.data[index]\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return SubPattern(self.state, self.data[index])\n        return self.data[index]\n    def __setitem__(self, index, code):\n        self.data[index] = code\n    def insert(self, index, code):\n        self.data.insert(index, code)\n    def append(self, code):\n        self.data.append(code)\n    def getwidth(self):\n        # determine the width (min, max) for this subpattern\n        if self.width is not None:\n            return self.width\n        lo = hi = 0\n        for op, av in self.data:\n            if op is BRANCH:\n                i = MAXWIDTH\n                j = 0\n                for av in av[1]:\n                    l, h = av.getwidth()\n                    i = min(i, l)\n                    j = max(j, h)\n                lo = lo + i\n                hi = hi + j\n            elif op is ATOMIC_GROUP:\n                i, j = av.getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op is SUBPATTERN:\n                i, j = av[-1].getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op in _REPEATCODES:\n                i, j = av[2].getwidth()\n                lo = lo + i * av[0]\n                if av[1] == MAXREPEAT and j:\n                    hi = MAXWIDTH\n                else:\n                    hi = hi + j * av[1]\n            elif op in _UNITCODES:\n                lo = lo + 1\n                hi = hi + 1\n            elif op is GROUPREF:\n                i, j = self.state.groupwidths[av]\n                lo = lo + i\n                hi = hi + j\n            elif op is GROUPREF_EXISTS:\n                i, j = av[1].getwidth()\n                if av[2] is not None:\n                    l, h = av[2].getwidth()\n                    i = min(i, l)\n                    j = max(j, h)\n                else:\n                    i = 0\n                lo = lo + i\n                hi = hi + j\n            elif op is SUCCESS:\n                break\n        self.width = min(lo, MAXWIDTH), min(hi, MAXWIDTH)\n        return self.width\n\nclass Tokenizer:\n    def __init__(self, string):\n        self.istext = isinstance(string, str)\n        self.string = string\n        if not self.istext:\n            string = str(string, 'latin1')\n        self.decoded_string = string\n        self.index = 0\n        self.next = None\n        self.__next()\n    def __next(self):\n        index = self.index\n        try:\n            char = self.decoded_string[index]\n        except IndexError:\n            self.next = None\n            return\n        if char == \"\\\\\":\n            index += 1\n            try:\n                char += self.decoded_string[index]\n            except IndexError:\n                raise error(\"bad escape (end of pattern)\",\n                            self.string, len(self.string) - 1) from None\n        self.index = index + 1\n        self.next = char\n    def match(self, char):\n        if char == self.next:\n            self.__next()\n            return True\n        return False\n    def get(self):\n        this = self.next\n        self.__next()\n        return this\n    def getwhile(self, n, charset):\n        result = ''\n        for _ in range(n):\n            c = self.next\n            if c not in charset:\n                break\n            result += c\n            self.__next()\n        return result\n    def getuntil(self, terminator, name):\n        result = ''\n        while True:\n            c = self.next\n            self.__next()\n            if c is None:\n                if not result:\n                    raise self.error(\"missing \" + name)\n                raise self.error(\"missing %s, unterminated name\" % terminator,\n                                 len(result))\n            if c == terminator:\n                if not result:\n                    raise self.error(\"missing \" + name, 1)\n                break\n            result += c\n        return result\n    @property\n    def pos(self):\n        return self.index - len(self.next or '')\n    def tell(self):\n        return self.index - len(self.next or '')\n    def seek(self, index):\n        self.index = index\n        self.__next()\n\n    def error(self, msg, offset=0):\n        if not self.istext:\n            msg = msg.encode('ascii', 'backslashreplace').decode('ascii')\n        return error(msg, self.string, self.tell() - offset)\n\n    def checkgroupname(self, name, offset):\n        if not (self.istext or name.isascii()):\n            msg = \"bad character in group name %a\" % name\n            raise self.error(msg, len(name) + offset)\n        if not name.isidentifier():\n            msg = \"bad character in group name %r\" % name\n            raise self.error(msg, len(name) + offset)\n\ndef _class_escape(source, escape):\n    # handle escape code inside character class\n    code = ESCAPES.get(escape)\n    if code:\n        return code\n    code = CATEGORIES.get(escape)\n    if code and code[0] is IN:\n        return code\n    try:\n        c = escape[1:2]\n        if c == \"x\":\n            # hexadecimal escape (exactly two digits)\n            escape += source.getwhile(2, HEXDIGITS)\n            if len(escape) != 4:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"u\" and source.istext:\n            # unicode escape (exactly four digits)\n            escape += source.getwhile(4, HEXDIGITS)\n            if len(escape) != 6:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"U\" and source.istext:\n            # unicode escape (exactly eight digits)\n            escape += source.getwhile(8, HEXDIGITS)\n            if len(escape) != 10:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            c = int(escape[2:], 16)\n            chr(c) # raise ValueError for invalid code\n            return LITERAL, c\n        elif c == \"N\" and source.istext:\n            import unicodedata\n            # named unicode escape e.g. \\N{EM DASH}\n            if not source.match('{'):\n                raise source.error(\"missing {\")\n            charname = source.getuntil('}', 'character name')\n            try:\n                c = ord(unicodedata.lookup(charname))\n            except (KeyError, TypeError):\n                raise source.error(\"undefined character name %r\" % charname,\n                                   len(charname) + len(r'\\N{}')) from None\n            return LITERAL, c\n        elif c in OCTDIGITS:\n            # octal escape (up to three digits)\n            escape += source.getwhile(2, OCTDIGITS)\n            c = int(escape[1:], 8)\n            if c > 0o377:\n                raise source.error('octal escape value %s outside of '\n                                   'range 0-0o377' % escape, len(escape))\n            return LITERAL, c\n        elif c in DIGITS:\n            raise ValueError\n        if len(escape) == 2:\n            if c in ASCIILETTERS:\n                raise source.error('bad escape %s' % escape, len(escape))\n            return LITERAL, ord(escape[1])\n    except ValueError:\n        pass\n    raise source.error(\"bad escape %s\" % escape, len(escape))\n\ndef _escape(source, escape, state):\n    # handle escape code in expression\n    code = CATEGORIES.get(escape)\n    if code:\n        return code\n    code = ESCAPES.get(escape)\n    if code:\n        return code\n    try:\n        c = escape[1:2]\n        if c == \"x\":\n            # hexadecimal escape\n            escape += source.getwhile(2, HEXDIGITS)\n            if len(escape) != 4:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"u\" and source.istext:\n            # unicode escape (exactly four digits)\n            escape += source.getwhile(4, HEXDIGITS)\n            if len(escape) != 6:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"U\" and source.istext:\n            # unicode escape (exactly eight digits)\n            escape += source.getwhile(8, HEXDIGITS)\n            if len(escape) != 10:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            c = int(escape[2:], 16)\n            chr(c) # raise ValueError for invalid code\n            return LITERAL, c\n        elif c == \"N\" and source.istext:\n            import unicodedata\n            # named unicode escape e.g. \\N{EM DASH}\n            if not source.match('{'):\n                raise source.error(\"missing {\")\n            charname = source.getuntil('}', 'character name')\n            try:\n                c = ord(unicodedata.lookup(charname))\n            except (KeyError, TypeError):\n                raise source.error(\"undefined character name %r\" % charname,\n                                   len(charname) + len(r'\\N{}')) from None\n            return LITERAL, c\n        elif c == \"0\":\n            # octal escape\n            escape += source.getwhile(2, OCTDIGITS)\n            return LITERAL, int(escape[1:], 8)\n        elif c in DIGITS:\n            # octal escape *or* decimal group reference (sigh)\n            if source.next in DIGITS:\n                escape += source.get()\n                if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and\n                    source.next in OCTDIGITS):\n                    # got three octal digits; this is an octal escape\n                    escape += source.get()\n                    c = int(escape[1:], 8)\n                    if c > 0o377:\n                        raise source.error('octal escape value %s outside of '\n                                           'range 0-0o377' % escape,\n                                           len(escape))\n                    return LITERAL, c\n            # not an octal escape, so this is a group reference\n            group = int(escape[1:])\n            if group < state.groups:\n                if not state.checkgroup(group):\n                    raise source.error(\"cannot refer to an open group\",\n                                       len(escape))\n                state.checklookbehindgroup(group, source)\n                return GROUPREF, group\n            raise source.error(\"invalid group reference %d\" % group, len(escape) - 1)\n        if len(escape) == 2:\n            if c in ASCIILETTERS:\n                raise source.error(\"bad escape %s\" % escape, len(escape))\n            return LITERAL, ord(escape[1])\n    except ValueError:\n        pass\n    raise source.error(\"bad escape %s\" % escape, len(escape))\n\ndef _uniq(items):\n    return list(dict.fromkeys(items))\n\ndef _parse_sub(source, state, verbose, nested):\n    # parse an alternation: a|b|c\n\n    items = []\n    itemsappend = items.append\n    sourcematch = source.match\n    start = source.tell()\n    while True:\n        itemsappend(_parse(source, state, verbose, nested + 1,\n                           not nested and not items))\n        if not sourcematch(\"|\"):\n            break\n        if not nested:\n            verbose = state.flags & SRE_FLAG_VERBOSE\n\n    if len(items) == 1:\n        return items[0]\n\n    subpattern = SubPattern(state)\n\n    # check if all items share a common prefix\n    while True:\n        prefix = None\n        for item in items:\n            if not item:\n                break\n            if prefix is None:\n                prefix = item[0]\n            elif item[0] != prefix:\n                break\n        else:\n            # all subitems start with a common \"prefix\".\n            # move it out of the branch\n            for item in items:\n                del item[0]\n            subpattern.append(prefix)\n            continue # check next one\n        break\n\n    # check if the branch can be replaced by a character set\n    set = []\n    for item in items:\n        if len(item) != 1:\n            break\n        op, av = item[0]\n        if op is LITERAL:\n            set.append((op, av))\n        elif op is IN and av[0][0] is not NEGATE:\n            set.extend(av)\n        else:\n            break\n    else:\n        # we can store this as a character set instead of a\n        # branch (the compiler may optimize this even more)\n        subpattern.append((IN, _uniq(set)))\n        return subpattern\n\n    subpattern.append((BRANCH, (None, items)))\n    return subpattern\n\ndef _parse(source, state, verbose, nested, first=False):\n    # parse a simple pattern\n    subpattern = SubPattern(state)\n\n    # precompute constants into local variables\n    subpatternappend = subpattern.append\n    sourceget = source.get\n    sourcematch = source.match\n    _len = len\n    _ord = ord\n\n    while True:\n\n        this = source.next\n        if this is None:\n            break # end of pattern\n        if this in \"|)\":\n            break # end of subpattern\n        sourceget()\n\n        if verbose:\n            # skip whitespace and comments\n            if this in WHITESPACE:\n                continue\n            if this == \"#\":\n                while True:\n                    this = sourceget()\n                    if this is None or this == \"\\n\":\n                        break\n                continue\n\n        if this[0] == \"\\\\\":\n            code = _escape(source, this, state)\n            subpatternappend(code)\n\n        elif this not in SPECIAL_CHARS:\n            subpatternappend((LITERAL, _ord(this)))\n\n        elif this == \"[\":\n            here = source.tell() - 1\n            # character set\n            set = []\n            setappend = set.append\n##          if sourcematch(\":\"):\n##              pass # handle character classes\n            if source.next == '[':\n                import warnings\n                warnings.warn(\n                    'Possible nested set at position %d' % source.tell(),\n                    FutureWarning, stacklevel=nested + 6\n                )\n            negate = sourcematch(\"^\")\n            # check remaining characters\n            while True:\n                this = sourceget()\n                if this is None:\n                    raise source.error(\"unterminated character set\",\n                                       source.tell() - here)\n                if this == \"]\" and set:\n                    break\n                elif this[0] == \"\\\\\":\n                    code1 = _class_escape(source, this)\n                else:\n                    if set and this in '-&~|' and source.next == this:\n                        import warnings\n                        warnings.warn(\n                            'Possible set %s at position %d' % (\n                                'difference' if this == '-' else\n                                'intersection' if this == '&' else\n                                'symmetric difference' if this == '~' else\n                                'union',\n                                source.tell() - 1),\n                            FutureWarning, stacklevel=nested + 6\n                        )\n                    code1 = LITERAL, _ord(this)\n                if sourcematch(\"-\"):\n                    # potential range\n                    that = sourceget()\n                    if that is None:\n                        raise source.error(\"unterminated character set\",\n                                           source.tell() - here)\n                    if that == \"]\":\n                        if code1[0] is IN:\n                            code1 = code1[1][0]\n                        setappend(code1)\n                        setappend((LITERAL, _ord(\"-\")))\n                        break\n                    if that[0] == \"\\\\\":\n                        code2 = _class_escape(source, that)\n                    else:\n                        if that == '-':\n                            import warnings\n                            warnings.warn(\n                                'Possible set difference at position %d' % (\n                                    source.tell() - 2),\n                                FutureWarning, stacklevel=nested + 6\n                            )\n                        code2 = LITERAL, _ord(that)\n                    if code1[0] != LITERAL or code2[0] != LITERAL:\n                        msg = \"bad character range %s-%s\" % (this, that)\n                        raise source.error(msg, len(this) + 1 + len(that))\n                    lo = code1[1]\n                    hi = code2[1]\n                    if hi < lo:\n                        msg = \"bad character range %s-%s\" % (this, that)\n                        raise source.error(msg, len(this) + 1 + len(that))\n                    setappend((RANGE, (lo, hi)))\n                else:\n                    if code1[0] is IN:\n                        code1 = code1[1][0]\n                    setappend(code1)\n\n            set = _uniq(set)\n            # XXX: <fl> should move set optimization to compiler!\n            if _len(set) == 1 and set[0][0] is LITERAL:\n                # optimization\n                if negate:\n                    subpatternappend((NOT_LITERAL, set[0][1]))\n                else:\n                    subpatternappend(set[0])\n            else:\n                if negate:\n                    set.insert(0, (NEGATE, None))\n                # charmap optimization can't be added here because\n                # global flags still are not known\n                subpatternappend((IN, set))\n\n        elif this in REPEAT_CHARS:\n            # repeat previous item\n            here = source.tell()\n            if this == \"?\":\n                min, max = 0, 1\n            elif this == \"*\":\n                min, max = 0, MAXREPEAT\n\n            elif this == \"+\":\n                min, max = 1, MAXREPEAT\n            elif this == \"{\":\n                if source.next == \"}\":\n                    subpatternappend((LITERAL, _ord(this)))\n                    continue\n\n                min, max = 0, MAXREPEAT\n                lo = hi = \"\"\n                while source.next in DIGITS:\n                    lo += sourceget()\n                if sourcematch(\",\"):\n                    while source.next in DIGITS:\n                        hi += sourceget()\n                else:\n                    hi = lo\n                if not sourcematch(\"}\"):\n                    subpatternappend((LITERAL, _ord(this)))\n                    source.seek(here)\n                    continue\n\n                if lo:\n                    min = int(lo)\n                    if min >= MAXREPEAT:\n                        raise OverflowError(\"the repetition number is too large\")\n                if hi:\n                    max = int(hi)\n                    if max >= MAXREPEAT:\n                        raise OverflowError(\"the repetition number is too large\")\n                    if max < min:\n                        raise source.error(\"min repeat greater than max repeat\",\n                                           source.tell() - here)\n            else:\n                raise AssertionError(\"unsupported quantifier %r\" % (char,))\n            # figure out which item to repeat\n            if subpattern:\n                item = subpattern[-1:]\n            else:\n                item = None\n            if not item or item[0][0] is AT:\n                raise source.error(\"nothing to repeat\",\n                                   source.tell() - here + len(this))\n            if item[0][0] in _REPEATCODES:\n                raise source.error(\"multiple repeat\",\n                                   source.tell() - here + len(this))\n            if item[0][0] is SUBPATTERN:\n                group, add_flags, del_flags, p = item[0][1]\n                if group is None and not add_flags and not del_flags:\n                    item = p\n            if sourcematch(\"?\"):\n                # Non-Greedy Match\n                subpattern[-1] = (MIN_REPEAT, (min, max, item))\n            elif sourcematch(\"+\"):\n                # Possessive Match (Always Greedy)\n                subpattern[-1] = (POSSESSIVE_REPEAT, (min, max, item))\n            else:\n                # Greedy Match\n                subpattern[-1] = (MAX_REPEAT, (min, max, item))\n\n        elif this == \".\":\n            subpatternappend((ANY, None))\n\n        elif this == \"(\":\n            start = source.tell() - 1\n            capture = True\n            atomic = False\n            name = None\n            add_flags = 0\n            del_flags = 0\n            if sourcematch(\"?\"):\n                # options\n                char = sourceget()\n                if char is None:\n                    raise source.error(\"unexpected end of pattern\")\n                if char == \"P\":\n                    # python extensions\n                    if sourcematch(\"<\"):\n                        # named group: skip forward to end of name\n                        name = source.getuntil(\">\", \"group name\")\n                        source.checkgroupname(name, 1)\n                    elif sourcematch(\"=\"):\n                        # named backreference\n                        name = source.getuntil(\")\", \"group name\")\n                        source.checkgroupname(name, 1)\n                        gid = state.groupdict.get(name)\n                        if gid is None:\n                            msg = \"unknown group name %r\" % name\n                            raise source.error(msg, len(name) + 1)\n                        if not state.checkgroup(gid):\n                            raise source.error(\"cannot refer to an open group\",\n                                               len(name) + 1)\n                        state.checklookbehindgroup(gid, source)\n                        subpatternappend((GROUPREF, gid))\n                        continue\n\n                    else:\n                        char = sourceget()\n                        if char is None:\n                            raise source.error(\"unexpected end of pattern\")\n                        raise source.error(\"unknown extension ?P\" + char,\n                                           len(char) + 2)\n                elif char == \":\":\n                    # non-capturing group\n                    capture = False\n                elif char == \"#\":\n                    # comment\n                    while True:\n                        if source.next is None:\n                            raise source.error(\"missing ), unterminated comment\",\n                                               source.tell() - start)\n                        if sourceget() == \")\":\n                            break\n                    continue\n\n                elif char in \"=!<\":\n                    # lookahead assertions\n                    dir = 1\n                    if char == \"<\":\n                        char = sourceget()\n                        if char is None:\n                            raise source.error(\"unexpected end of pattern\")\n                        if char not in \"=!\":\n                            raise source.error(\"unknown extension ?<\" + char,\n                                               len(char) + 2)\n                        dir = -1 # lookbehind\n                        lookbehindgroups = state.lookbehindgroups\n                        if lookbehindgroups is None:\n                            state.lookbehindgroups = state.groups\n                    p = _parse_sub(source, state, verbose, nested + 1)\n                    if dir < 0:\n                        if lookbehindgroups is None:\n                            state.lookbehindgroups = None\n                    if not sourcematch(\")\"):\n                        raise source.error(\"missing ), unterminated subpattern\",\n                                           source.tell() - start)\n                    if char == \"=\":\n                        subpatternappend((ASSERT, (dir, p)))\n                    elif p:\n                        subpatternappend((ASSERT_NOT, (dir, p)))\n                    else:\n                        subpatternappend((FAILURE, ()))\n                    continue\n\n                elif char == \"(\":\n                    # conditional backreference group\n                    condname = source.getuntil(\")\", \"group name\")\n                    if not (condname.isdecimal() and condname.isascii()):\n                        source.checkgroupname(condname, 1)\n                        condgroup = state.groupdict.get(condname)\n                        if condgroup is None:\n                            msg = \"unknown group name %r\" % condname\n                            raise source.error(msg, len(condname) + 1)\n                    else:\n                        condgroup = int(condname)\n                        if not condgroup:\n                            raise source.error(\"bad group number\",\n                                               len(condname) + 1)\n                        if condgroup >= MAXGROUPS:\n                            msg = \"invalid group reference %d\" % condgroup\n                            raise source.error(msg, len(condname) + 1)\n                        if condgroup not in state.grouprefpos:\n                            state.grouprefpos[condgroup] = (\n                                source.tell() - len(condname) - 1\n                            )\n                        if not (condname.isdecimal() and condname.isascii()):\n                            import warnings\n                            warnings.warn(\n                                \"bad character in group name %s at position %d\" %\n                                (repr(condname) if source.istext else ascii(condname),\n                                 source.tell() - len(condname) - 1),\n                                DeprecationWarning, stacklevel=nested + 6\n                            )\n                    state.checklookbehindgroup(condgroup, source)\n                    item_yes = _parse(source, state, verbose, nested + 1)\n                    if source.match(\"|\"):\n                        item_no = _parse(source, state, verbose, nested + 1)\n                        if source.next == \"|\":\n                            raise source.error(\"conditional backref with more than two branches\")\n                    else:\n                        item_no = None\n                    if not source.match(\")\"):\n                        raise source.error(\"missing ), unterminated subpattern\",\n                                           source.tell() - start)\n                    subpatternappend((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))\n                    continue\n\n                elif char == \">\":\n                    # non-capturing, atomic group\n                    capture = False\n                    atomic = True\n                elif char in FLAGS or char == \"-\":\n                    # flags\n                    flags = _parse_flags(source, state, char)\n                    if flags is None:  # global flags\n                        if not first or subpattern:\n                            raise source.error('global flags not at the start '\n                                               'of the expression',\n                                               source.tell() - start)\n                        verbose = state.flags & SRE_FLAG_VERBOSE\n                        continue\n\n                    add_flags, del_flags = flags\n                    capture = False\n                else:\n                    raise source.error(\"unknown extension ?\" + char,\n                                       len(char) + 1)\n\n            # parse group contents\n            if capture:\n                try:\n                    group = state.opengroup(name)\n                except error as err:\n                    raise source.error(err.msg, len(name) + 1) from None\n            else:\n                group = None\n            sub_verbose = ((verbose or (add_flags & SRE_FLAG_VERBOSE)) and\n                           not (del_flags & SRE_FLAG_VERBOSE))\n            p = _parse_sub(source, state, sub_verbose, nested + 1)\n            if not source.match(\")\"):\n                raise source.error(\"missing ), unterminated subpattern\",\n                                   source.tell() - start)\n            if group is not None:\n                state.closegroup(group, p)\n            if atomic:\n                assert group is None\n                subpatternappend((ATOMIC_GROUP, p))\n            else:\n                subpatternappend((SUBPATTERN, (group, add_flags, del_flags, p)))\n\n        elif this == \"^\":\n            subpatternappend((AT, AT_BEGINNING))\n\n        elif this == \"$\":\n            subpatternappend((AT, AT_END))\n\n        else:\n            raise AssertionError(\"unsupported special character %r\" % (char,))\n\n    # unpack non-capturing groups\n    for i in range(len(subpattern))[::-1]:\n        op, av = subpattern[i]\n        if op is SUBPATTERN:\n            group, add_flags, del_flags, p = av\n            if group is None and not add_flags and not del_flags:\n                subpattern[i: i+1] = p\n\n    return subpattern\n\ndef _parse_flags(source, state, char):\n    sourceget = source.get\n    add_flags = 0\n    del_flags = 0\n    if char != \"-\":\n        while True:\n            flag = FLAGS[char]\n            if source.istext:\n                if char == 'L':\n                    msg = \"bad inline flags: cannot use 'L' flag with a str pattern\"\n                    raise source.error(msg)\n            else:\n                if char == 'u':\n                    msg = \"bad inline flags: cannot use 'u' flag with a bytes pattern\"\n                    raise source.error(msg)\n            add_flags |= flag\n            if (flag & TYPE_FLAGS) and (add_flags & TYPE_FLAGS) != flag:\n                msg = \"bad inline flags: flags 'a', 'u' and 'L' are incompatible\"\n                raise source.error(msg)\n            char = sourceget()\n            if char is None:\n                raise source.error(\"missing -, : or )\")\n            if char in \")-:\":\n                break\n            if char not in FLAGS:\n                msg = \"unknown flag\" if char.isalpha() else \"missing -, : or )\"\n                raise source.error(msg, len(char))\n    if char == \")\":\n        state.flags |= add_flags\n        return None\n    if add_flags & GLOBAL_FLAGS:\n        raise source.error(\"bad inline flags: cannot turn on global flag\", 1)\n    if char == \"-\":\n        char = sourceget()\n        if char is None:\n            raise source.error(\"missing flag\")\n        if char not in FLAGS:\n            msg = \"unknown flag\" if char.isalpha() else \"missing flag\"\n            raise source.error(msg, len(char))\n        while True:\n            flag = FLAGS[char]\n            if flag & TYPE_FLAGS:\n                msg = \"bad inline flags: cannot turn off flags 'a', 'u' and 'L'\"\n                raise source.error(msg)\n            del_flags |= flag\n            char = sourceget()\n            if char is None:\n                raise source.error(\"missing :\")\n            if char == \":\":\n                break\n            if char not in FLAGS:\n                msg = \"unknown flag\" if char.isalpha() else \"missing :\"\n                raise source.error(msg, len(char))\n    assert char == \":\"\n    if del_flags & GLOBAL_FLAGS:\n        raise source.error(\"bad inline flags: cannot turn off global flag\", 1)\n    if add_flags & del_flags:\n        raise source.error(\"bad inline flags: flag turned on and off\", 1)\n    return add_flags, del_flags\n\ndef fix_flags(src, flags):\n    # Check and fix flags according to the type of pattern (str or bytes)\n    if isinstance(src, str):\n        if flags & SRE_FLAG_LOCALE:\n            raise ValueError(\"cannot use LOCALE flag with a str pattern\")\n        if not flags & SRE_FLAG_ASCII:\n            flags |= SRE_FLAG_UNICODE\n        elif flags & SRE_FLAG_UNICODE:\n            raise ValueError(\"ASCII and UNICODE flags are incompatible\")\n    else:\n        if flags & SRE_FLAG_UNICODE:\n            raise ValueError(\"cannot use UNICODE flag with a bytes pattern\")\n        if flags & SRE_FLAG_LOCALE and flags & SRE_FLAG_ASCII:\n            raise ValueError(\"ASCII and LOCALE flags are incompatible\")\n    return flags\n\ndef parse(str, flags=0, state=None):\n    # parse 're' pattern into list of (opcode, argument) tuples\n\n    source = Tokenizer(str)\n\n    if state is None:\n        state = State()\n    state.flags = flags\n    state.str = str\n\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n    p.state.flags = fix_flags(str, p.state.flags)\n\n    if source.next is not None:\n        assert source.next == \")\"\n        raise source.error(\"unbalanced parenthesis\")\n\n    for g in p.state.grouprefpos:\n        if g >= p.state.groups:\n            msg = \"invalid group reference %d\" % g\n            raise error(msg, str, p.state.grouprefpos[g])\n\n    if flags & SRE_FLAG_DEBUG:\n        p.dump()\n\n    return p\n\ndef parse_template(source, pattern):\n    # parse 're' replacement string into list of literals and\n    # group references\n    s = Tokenizer(source)\n    sget = s.get\n    result = []\n    literal = []\n    lappend = literal.append\n    def addliteral():\n        if s.istext:\n            result.append(''.join(literal))\n        else:\n            # The tokenizer implicitly decodes bytes objects as latin-1, we must\n            # therefore re-encode the final representation.\n            result.append(''.join(literal).encode('latin-1'))\n        del literal[:]\n    def addgroup(index, pos):\n        if index > pattern.groups:\n            raise s.error(\"invalid group reference %d\" % index, pos)\n        addliteral()\n        result.append(index)\n    groupindex = pattern.groupindex\n    while True:\n        this = sget()\n        if this is None:\n            break # end of replacement string\n        if this[0] == \"\\\\\":\n            # group\n            c = this[1]\n            if c == \"g\":\n                if not s.match(\"<\"):\n                    raise s.error(\"missing <\")\n                name = s.getuntil(\">\", \"group name\")\n                if not (name.isdecimal() and name.isascii()):\n                    s.checkgroupname(name, 1)\n                    try:\n                        index = groupindex[name]\n                    except KeyError:\n                        raise IndexError(\"unknown group name %r\" % name) from None\n                else:\n                    index = int(name)\n                    if index >= MAXGROUPS:\n                        raise s.error(\"invalid group reference %d\" % index,\n                                      len(name) + 1)\n                    if not (name.isdecimal() and name.isascii()):\n                        import warnings\n                        warnings.warn(\n                            \"bad character in group name %s at position %d\" %\n                            (repr(name) if s.istext else ascii(name),\n                             s.tell() - len(name) - 1),\n                            DeprecationWarning, stacklevel=5\n                        )\n                addgroup(index, len(name) + 1)\n            elif c == \"0\":\n                if s.next in OCTDIGITS:\n                    this += sget()\n                    if s.next in OCTDIGITS:\n                        this += sget()\n                lappend(chr(int(this[1:], 8) & 0xff))\n            elif c in DIGITS:\n                isoctal = False\n                if s.next in DIGITS:\n                    this += sget()\n                    if (c in OCTDIGITS and this[2] in OCTDIGITS and\n                        s.next in OCTDIGITS):\n                        this += sget()\n                        isoctal = True\n                        c = int(this[1:], 8)\n                        if c > 0o377:\n                            raise s.error('octal escape value %s outside of '\n                                          'range 0-0o377' % this, len(this))\n                        lappend(chr(c))\n                if not isoctal:\n                    addgroup(int(this[1:]), len(this) - 1)\n            else:\n                try:\n                    this = chr(ESCAPES[this][1])\n                except KeyError:\n                    if c in ASCIILETTERS:\n                        raise s.error('bad escape %s' % this, len(this)) from None\n                lappend(this)\n        else:\n            lappend(this)\n    addliteral()\n    return result\n", 1081], "C:\\Programming\\Python313\\Lib\\enum.py": ["import sys\nimport builtins as bltns\nfrom functools import partial\nfrom types import MappingProxyType, DynamicClassAttribute\n\n\n__all__ = [\n        'EnumType', 'EnumMeta', 'EnumDict',\n        'Enum', 'IntEnum', 'StrEnum', 'Flag', 'IntFlag', 'ReprEnum',\n        'auto', 'unique', 'property', 'verify', 'member', 'nonmember',\n        'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',\n        'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',\n        'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',\n        'pickle_by_global_name', 'pickle_by_enum_name',\n        ]\n\n\n# Dummy value for Enum and Flag as there are explicit checks for them\n# before they have been created.\n# This is also why there are checks in EnumType like `if Enum is not None`\nEnum = Flag = EJECT = _stdlib_enums = ReprEnum = None\n\nclass nonmember(object):\n    \"\"\"\n    Protects item from becoming an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\nclass member(object):\n    \"\"\"\n    Forces item to become an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\ndef _is_descriptor(obj):\n    \"\"\"\n    Returns True if obj is a descriptor, False otherwise.\n    \"\"\"\n    return not isinstance(obj, partial) and (\n            hasattr(obj, '__get__') or\n            hasattr(obj, '__set__') or\n            hasattr(obj, '__delete__')\n            )\n\ndef _is_dunder(name):\n    \"\"\"\n    Returns True if a __dunder__ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 4 and\n            name[:2] == name[-2:] == '__' and\n            name[2] != '_' and\n            name[-3] != '_'\n            )\n\ndef _is_sunder(name):\n    \"\"\"\n    Returns True if a _sunder_ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 2 and\n            name[0] == name[-1] == '_' and\n            name[1] != '_' and\n            name[-2] != '_'\n            )\n\ndef _is_internal_class(cls_name, obj):\n    # do not use `re` as `re` imports `enum`\n    if not isinstance(obj, type):\n        return False\n    qualname = getattr(obj, '__qualname__', '')\n    s_pattern = cls_name + '.' + getattr(obj, '__name__', '')\n    e_pattern = '.' + s_pattern\n    return qualname == s_pattern or qualname.endswith(e_pattern)\n\ndef _is_private(cls_name, name):\n    # do not use `re` as `re` imports `enum`\n    pattern = '_%s__' % (cls_name, )\n    pat_len = len(pattern)\n    if (\n            len(name) > pat_len\n            and name.startswith(pattern)\n            and (name[-1] != '_' or name[-2] != '_')\n        ):\n        return True\n    else:\n        return False\n\ndef _is_single_bit(num):\n    \"\"\"\n    True if only one bit set in num (should be an int)\n    \"\"\"\n    if num == 0:\n        return False\n    num &= num - 1\n    return num == 0\n\ndef _make_class_unpicklable(obj):\n    \"\"\"\n    Make the given obj un-picklable.\n\n    obj should be either a dictionary, or an Enum\n    \"\"\"\n    def _break_on_call_reduce(self, proto):\n        raise TypeError('%r cannot be pickled' % self)\n    if isinstance(obj, dict):\n        obj['__reduce_ex__'] = _break_on_call_reduce\n        obj['__module__'] = '<unknown>'\n    else:\n        setattr(obj, '__reduce_ex__', _break_on_call_reduce)\n        setattr(obj, '__module__', '<unknown>')\n\ndef _iter_bits_lsb(num):\n    # num must be a positive integer\n    original = num\n    if isinstance(num, Enum):\n        num = num.value\n    if num < 0:\n        raise ValueError('%r is not a positive integer' % original)\n    while num:\n        b = num & (~num + 1)\n        yield b\n        num ^= b\n\ndef show_flag_values(value):\n    return list(_iter_bits_lsb(value))\n\ndef bin(num, max_bits=None):\n    \"\"\"\n    Like built-in bin(), except negative values are represented in\n    twos-compliment, and the leading bit always indicates sign\n    (0=positive, 1=negative).\n\n    >>> bin(10)\n    '0b0 1010'\n    >>> bin(~10)   # ~10 is -11\n    '0b1 0101'\n    \"\"\"\n\n    ceiling = 2 ** (num).bit_length()\n    if num >= 0:\n        s = bltns.bin(num + ceiling).replace('1', '0', 1)\n    else:\n        s = bltns.bin(~num ^ (ceiling - 1) + ceiling)\n    sign = s[:3]\n    digits = s[3:]\n    if max_bits is not None:\n        if len(digits) < max_bits:\n            digits = (sign[-1] * max_bits + digits)[-max_bits:]\n    return \"%s %s\" % (sign, digits)\n\ndef _dedent(text):\n    \"\"\"\n    Like textwrap.dedent.  Rewritten because we cannot import textwrap.\n    \"\"\"\n    lines = text.split('\\n')\n    for i, ch in enumerate(lines[0]):\n        if ch != ' ':\n            break\n    for j, l in enumerate(lines):\n        lines[j] = l[i:]\n    return '\\n'.join(lines)\n\nclass _not_given:\n    def __repr__(self):\n        return('<not given>')\n_not_given = _not_given()\n\nclass _auto_null:\n    def __repr__(self):\n        return '_auto_null'\n_auto_null = _auto_null()\n\nclass auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    def __init__(self, value=_auto_null):\n        self.value = value\n\n    def __repr__(self):\n        return \"auto(%r)\" % self.value\n\nclass property(DynamicClassAttribute):\n    \"\"\"\n    This is a descriptor, used to define attributes that act differently\n    when accessed through an enum member and through an enum class.\n    Instance access is the same as property(), but access to an attribute\n    through the enum class will instead look in the class' _member_map_ for\n    a corresponding enum member.\n    \"\"\"\n\n    member = None\n    _attr_type = None\n    _cls_type = None\n\n    def __get__(self, instance, ownerclass=None):\n        if instance is None:\n            if self.member is not None:\n                return self.member\n            else:\n                raise AttributeError(\n                        '%r has no attribute %r' % (ownerclass, self.name)\n                        )\n        if self.fget is not None:\n            # use previous enum.property\n            return self.fget(instance)\n        elif self._attr_type == 'attr':\n            # look up previous attibute\n            return getattr(self._cls_type, self.name)\n        elif self._attr_type == 'desc':\n            # use previous descriptor\n            return getattr(instance._value_, self.name)\n        # look for a member by this name.\n        try:\n            return ownerclass._member_map_[self.name]\n        except KeyError:\n            raise AttributeError(\n                    '%r has no attribute %r' % (ownerclass, self.name)\n                    ) from None\n\n    def __set__(self, instance, value):\n        if self.fset is not None:\n            return self.fset(instance, value)\n        raise AttributeError(\n                \"<enum %r> cannot set attribute %r\" % (self.clsname, self.name)\n                )\n\n    def __delete__(self, instance):\n        if self.fdel is not None:\n            return self.fdel(instance)\n        raise AttributeError(\n                \"<enum %r> cannot delete attribute %r\" % (self.clsname, self.name)\n                )\n\n    def __set_name__(self, ownerclass, name):\n        self.name = name\n        self.clsname = ownerclass.__name__\n\n\nclass _proto_member:\n    \"\"\"\n    intermediate step for enum members between class execution and final creation\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value\n\n    def __set_name__(self, enum_class, member_name):\n        \"\"\"\n        convert each quasi-member into an instance of the new enum class\n        \"\"\"\n        # first step: remove ourself from enum_class\n        delattr(enum_class, member_name)\n        # second step: create member based on enum_class\n        value = self.value\n        if not isinstance(value, tuple):\n            args = (value, )\n        else:\n            args = value\n        if enum_class._member_type_ is tuple:   # special case for tuple enums\n            args = (args, )     # wrap it one more time\n        if not enum_class._use_args_:\n            enum_member = enum_class._new_member_(enum_class)\n        else:\n            enum_member = enum_class._new_member_(enum_class, *args)\n        if not hasattr(enum_member, '_value_'):\n            if enum_class._member_type_ is object:\n                enum_member._value_ = value\n            else:\n                try:\n                    enum_member._value_ = enum_class._member_type_(*args)\n                except Exception as exc:\n                    new_exc = TypeError(\n                            '_value_ not set in __new__, unable to create it'\n                            )\n                    new_exc.__cause__ = exc\n                    raise new_exc\n        value = enum_member._value_\n        enum_member._name_ = member_name\n        enum_member.__objclass__ = enum_class\n        enum_member.__init__(*args)\n        enum_member._sort_order_ = len(enum_class._member_names_)\n\n        if Flag is not None and issubclass(enum_class, Flag):\n            if isinstance(value, int):\n                enum_class._flag_mask_ |= value\n                if _is_single_bit(value):\n                    enum_class._singles_mask_ |= value\n            enum_class._all_bits_ = 2 ** ((enum_class._flag_mask_).bit_length()) - 1\n\n        # If another member with the same value was already defined, the\n        # new member becomes an alias to the existing one.\n        try:\n            try:\n                # try to do a fast lookup to avoid the quadratic loop\n                enum_member = enum_class._value2member_map_[value]\n            except TypeError:\n                for name, canonical_member in enum_class._member_map_.items():\n                    if canonical_member._value_ == value:\n                        enum_member = canonical_member\n                        break\n                else:\n                    raise KeyError\n        except KeyError:\n            # this could still be an alias if the value is multi-bit and the\n            # class is a flag class\n            if (\n                    Flag is None\n                    or not issubclass(enum_class, Flag)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n            elif (\n                    Flag is not None\n                    and issubclass(enum_class, Flag)\n                    and isinstance(value, int)\n                    and _is_single_bit(value)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n\n        enum_class._add_member_(member_name, enum_member)\n        try:\n            # This may fail if value is not hashable. We can't add the value\n            # to the map, and by-value lookups for this value will be\n            # linear.\n            enum_class._value2member_map_.setdefault(value, enum_member)\n            if value not in enum_class._hashable_values_:\n                enum_class._hashable_values_.append(value)\n        except TypeError:\n            # keep track of the value in a list so containment checks are quick\n            enum_class._unhashable_values_.append(value)\n            enum_class._unhashable_values_map_.setdefault(member_name, []).append(value)\n\n\nclass EnumDict(dict):\n    \"\"\"\n    Track enum member order and ensure member names are not reused.\n\n    EnumType will use the names found in self._member_names as the\n    enumeration member names.\n    \"\"\"\n    def __init__(self, cls_name=None):\n        super().__init__()\n        self._member_names = {} # use a dict -- faster look-up than a list, and keeps insertion order since 3.7\n        self._last_values = []\n        self._ignore = []\n        self._auto_called = False\n        self._cls_name = cls_name\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Changes anything not dundered or not a descriptor.\n\n        If an enum member name is used twice, an error is raised; duplicate\n        values are not checked for.\n\n        Single underscore (sunder) names are reserved.\n        \"\"\"\n        if self._cls_name is not None and _is_private(self._cls_name, key):\n            # do nothing, name will be a normal attribute\n            pass\n        elif _is_sunder(key):\n            if key not in (\n                    '_order_',\n                    '_generate_next_value_', '_numeric_repr_', '_missing_', '_ignore_',\n                    '_iter_member_', '_iter_member_by_value_', '_iter_member_by_def_',\n                    '_add_alias_', '_add_value_alias_',\n                    # While not in use internally, those are common for pretty\n                    # printing and thus excluded from Enum's reservation of\n                    # _sunder_ names\n                    ) and not key.startswith('_repr_'):\n                raise ValueError(\n                        '_sunder_ names, such as %r, are reserved for future Enum use'\n                        % (key, )\n                        )\n            if key == '_generate_next_value_':\n                # check if members already defined as auto()\n                if self._auto_called:\n                    raise TypeError(\"_generate_next_value_ must be defined before members\")\n                _gnv = value.__func__ if isinstance(value, staticmethod) else value\n                setattr(self, '_generate_next_value', _gnv)\n            elif key == '_ignore_':\n                if isinstance(value, str):\n                    value = value.replace(',',' ').split()\n                else:\n                    value = list(value)\n                self._ignore = value\n                already = set(value) & set(self._member_names)\n                if already:\n                    raise ValueError(\n                            '_ignore_ cannot specify already set names: %r'\n                            % (already, )\n                            )\n        elif _is_dunder(key):\n            if key == '__order__':\n                key = '_order_'\n        elif key in self._member_names:\n            # descriptor overwriting an enum?\n            raise TypeError('%r already defined as %r' % (key, self[key]))\n        elif key in self._ignore:\n            pass\n        elif isinstance(value, nonmember):\n            # unwrap value here; it won't be processed by the below `else`\n            value = value.value\n        elif isinstance(value, partial):\n            import warnings\n            warnings.warn('functools.partial will be a method descriptor '\n                          'in future Python versions; wrap it in '\n                          'enum.member() if you want to preserve the '\n                          'old behavior', FutureWarning, stacklevel=2)\n        elif _is_descriptor(value):\n            pass\n        elif self._cls_name is not None and _is_internal_class(self._cls_name, value):\n            # do nothing, name will be a normal attribute\n            pass\n        else:\n            if key in self:\n                # enum overwriting a descriptor?\n                raise TypeError('%r already defined as %r' % (key, self[key]))\n            elif isinstance(value, member):\n                # unwrap value here -- it will become a member\n                value = value.value\n            non_auto_store = True\n            single = False\n            if isinstance(value, auto):\n                single = True\n                value = (value, )\n            if isinstance(value, tuple) and any(isinstance(v, auto) for v in value):\n                # insist on an actual tuple, no subclasses, in keeping with only supporting\n                # top-level auto() usage (not contained in any other data structure)\n                auto_valued = []\n                t = type(value)\n                for v in value:\n                    if isinstance(v, auto):\n                        non_auto_store = False\n                        if v.value == _auto_null:\n                            v.value = self._generate_next_value(\n                                    key, 1, len(self._member_names), self._last_values[:],\n                                    )\n                            self._auto_called = True\n                        v = v.value\n                        self._last_values.append(v)\n                    auto_valued.append(v)\n                if single:\n                    value = auto_valued[0]\n                else:\n                    try:\n                        # accepts iterable as multiple arguments?\n                        value = t(auto_valued)\n                    except TypeError:\n                        # then pass them in singly\n                        value = t(*auto_valued)\n            self._member_names[key] = None\n            if non_auto_store:\n                self._last_values.append(value)\n        super().__setitem__(key, value)\n\n    @property\n    def member_names(self):\n        return list(self._member_names)\n\n    def update(self, members, **more_members):\n        try:\n            for name in members.keys():\n                self[name] = members[name]\n        except AttributeError:\n            for name, value in members:\n                self[name] = value\n        for name, value in more_members.items():\n            self[name] = value\n\n_EnumDict = EnumDict        # keep private name for backwards compatibility\n\n\nclass EnumType(type):\n    \"\"\"\n    Metaclass for Enum\n    \"\"\"\n\n    @classmethod\n    def __prepare__(metacls, cls, bases, **kwds):\n        # check that previous enum members do not exist\n        metacls._check_for_existing_members_(cls, bases)\n        # create the namespace dict\n        enum_dict = EnumDict(cls)\n        # inherit previous flags and _generate_next_value_ function\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        if first_enum is not None:\n            enum_dict['_generate_next_value_'] = getattr(\n                    first_enum, '_generate_next_value_', None,\n                    )\n        return enum_dict\n\n    def __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds):\n        # an Enum class is final once enumeration items have been defined; it\n        # cannot be mixed with other types (int, float, etc.) if it has an\n        # inherited __new__ unless a new __new__ is defined (or the resulting\n        # class will fail).\n        #\n        if _simple:\n            return super().__new__(metacls, cls, bases, classdict, **kwds)\n        #\n        # remove any keys listed in _ignore_\n        classdict.setdefault('_ignore_', []).append('_ignore_')\n        ignore = classdict['_ignore_']\n        for key in ignore:\n            classdict.pop(key, None)\n        #\n        # grab member names\n        member_names = classdict._member_names\n        #\n        # check for illegal enum names (any others?)\n        invalid_names = set(member_names) & {'mro', ''}\n        if invalid_names:\n            raise ValueError('invalid enum member name(s) %s'  % (\n                    ','.join(repr(n) for n in invalid_names)\n                    ))\n        #\n        # adjust the sunders\n        _order_ = classdict.pop('_order_', None)\n        _gnv = classdict.get('_generate_next_value_')\n        if _gnv is not None and type(_gnv) is not staticmethod:\n            _gnv = staticmethod(_gnv)\n        # convert to normal dict\n        classdict = dict(classdict.items())\n        if _gnv is not None:\n            classdict['_generate_next_value_'] = _gnv\n        #\n        # data type of member and the controlling Enum class\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        __new__, save_new, use_args = metacls._find_new_(\n                classdict, member_type, first_enum,\n                )\n        classdict['_new_member_'] = __new__\n        classdict['_use_args_'] = use_args\n        #\n        # convert future enum members into temporary _proto_members\n        for name in member_names:\n            value = classdict[name]\n            classdict[name] = _proto_member(value)\n        #\n        # house-keeping structures\n        classdict['_member_names_'] = []\n        classdict['_member_map_'] = {}\n        classdict['_value2member_map_'] = {}\n        classdict['_hashable_values_'] = []          # for comparing with non-hashable types\n        classdict['_unhashable_values_'] = []       # e.g. frozenset() with set()\n        classdict['_unhashable_values_map_'] = {}\n        classdict['_member_type_'] = member_type\n        # now set the __repr__ for the value\n        classdict['_value_repr_'] = metacls._find_data_repr_(cls, bases)\n        #\n        # Flag structures (will be removed if final class is not a Flag\n        classdict['_boundary_'] = (\n                boundary\n                or getattr(first_enum, '_boundary_', None)\n                )\n        classdict['_flag_mask_'] = 0\n        classdict['_singles_mask_'] = 0\n        classdict['_all_bits_'] = 0\n        classdict['_inverted_'] = None\n        try:\n            classdict['_%s__in_progress' % cls] = True\n            enum_class = super().__new__(metacls, cls, bases, classdict, **kwds)\n            classdict['_%s__in_progress' % cls] = False\n            delattr(enum_class, '_%s__in_progress' % cls)\n        except Exception as e:\n            # since 3.12 the note \"Error calling __set_name__ on '_proto_member' instance ...\"\n            # is tacked on to the error instead of raising a RuntimeError, so discard it\n            if hasattr(e, '__notes__'):\n                del e.__notes__\n            raise\n        # update classdict with any changes made by __init_subclass__\n        classdict.update(enum_class.__dict__)\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        #\n        # Also, special handling for ReprEnum\n        if ReprEnum is not None and ReprEnum in bases:\n            if member_type is object:\n                raise TypeError(\n                        'ReprEnum subclasses must be mixed with a data type (i.e.'\n                        ' int, str, float, etc.)'\n                        )\n            if '__format__' not in classdict:\n                enum_class.__format__ = member_type.__format__\n                classdict['__format__'] = enum_class.__format__\n            if '__str__' not in classdict:\n                method = member_type.__str__\n                if method is object.__str__:\n                    # if member_type does not define __str__, object.__str__ will use\n                    # its __repr__ instead, so we'll also use its __repr__\n                    method = member_type.__repr__\n                enum_class.__str__ = method\n                classdict['__str__'] = enum_class.__str__\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in classdict:\n                # check for mixin overrides before replacing\n                enum_method = getattr(first_enum, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        #\n        # for Flag, add __or__, __and__, __xor__, and __invert__\n        if Flag is not None and issubclass(enum_class, Flag):\n            for name in (\n                    '__or__', '__and__', '__xor__',\n                    '__ror__', '__rand__', '__rxor__',\n                    '__invert__'\n                ):\n                if name not in classdict:\n                    enum_method = getattr(Flag, name)\n                    setattr(enum_class, name, enum_method)\n                    classdict[name] = enum_method\n        #\n        # replace any other __new__ with our own (as long as Enum is not None,\n        # anyway) -- again, this is to support pickle\n        if Enum is not None:\n            # if the user defined their own __new__, save it before it gets\n            # clobbered in case they subclass later\n            if save_new:\n                enum_class.__new_member__ = __new__\n            enum_class.__new__ = Enum.__new__\n        #\n        # py3 support for definition order (helps keep py2/py3 code in sync)\n        #\n        # _order_ checking is spread out into three/four steps\n        # - if enum_class is a Flag:\n        #   - remove any non-single-bit flags from _order_\n        # - remove any aliases from _order_\n        # - check that _order_ and _member_names_ match\n        #\n        # step 1: ensure we have a list\n        if _order_ is not None:\n            if isinstance(_order_, str):\n                _order_ = _order_.replace(',', ' ').split()\n        #\n        # remove Flag structures if final class is not a Flag\n        if (\n                Flag is None and cls != 'Flag'\n                or Flag is not None and not issubclass(enum_class, Flag)\n            ):\n            delattr(enum_class, '_boundary_')\n            delattr(enum_class, '_flag_mask_')\n            delattr(enum_class, '_singles_mask_')\n            delattr(enum_class, '_all_bits_')\n            delattr(enum_class, '_inverted_')\n        elif Flag is not None and issubclass(enum_class, Flag):\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n            if _order_:\n                # _order_ step 2: remove any items from _order_ that are not single-bit\n                _order_ = [\n                        o\n                        for o in _order_\n                        if o not in enum_class._member_map_ or _is_single_bit(enum_class[o]._value_)\n                        ]\n        #\n        if _order_:\n            # _order_ step 3: remove aliases from _order_\n            _order_ = [\n                    o\n                    for o in _order_\n                    if (\n                        o not in enum_class._member_map_\n                        or\n                        (o in enum_class._member_map_ and o in enum_class._member_names_)\n                        )]\n            # _order_ step 4: verify that _order_ and _member_names_ match\n            if _order_ != enum_class._member_names_:\n                raise TypeError(\n                        'member order does not match _order_:\\n  %r\\n  %r'\n                        % (enum_class._member_names_, _order_)\n                        )\n        #\n        return enum_class\n\n    def __bool__(cls):\n        \"\"\"\n        classes/types should always be True.\n        \"\"\"\n        return True\n\n    def __call__(cls, value, names=_not_given, *values, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Either returns an existing member, or creates a new enum class.\n\n        This method is used both when an enum class is given a value to match\n        to an enumeration member (i.e. Color(3)) and for the functional API\n        (i.e. Color = Enum('Color', names='RED GREEN BLUE')).\n\n        The value lookup branch is chosen if the enum is final.\n\n        When used for the functional API:\n\n        `value` will be the name of the new class.\n\n        `names` should be either a string of white-space/comma delimited names\n        (values will start at `start`), or an iterator/mapping of name, value pairs.\n\n        `module` should be set to the module this class is being created in;\n        if it is not set, an attempt to find that module will be made, but if\n        it fails the class will not be picklable.\n\n        `qualname` should be set to the actual location this class can be found\n        at in its module; by default it is set to the global scope.  If this is\n        not correct, unpickling will fail in some circumstances.\n\n        `type`, if set, will be mixed in as the first base class.\n        \"\"\"\n        if cls._member_map_:\n            # simple value lookup if members exist\n            if names is not _not_given:\n                value = (value, names) + values\n            return cls.__new__(cls, value)\n        # otherwise, functional API: we're creating a new Enum type\n        if names is _not_given and type is None:\n            # no body? no data-type? possibly wrong usage\n            raise TypeError(\n                    f\"{cls} has no members; specify `names=()` if you meant to create a new, empty, enum\"\n                    )\n        return cls._create_(\n                class_name=value,\n                names=None if names is _not_given else names,\n                module=module,\n                qualname=qualname,\n                type=type,\n                start=start,\n                boundary=boundary,\n                )\n\n    def __contains__(cls, value):\n        \"\"\"Return True if `value` is in `cls`.\n\n        `value` is in `cls` if:\n        1) `value` is a member of `cls`, or\n        2) `value` is the value of one of the `cls`'s members.\n        \"\"\"\n        if isinstance(value, cls):\n            return True\n        try:\n            return value in cls._value2member_map_\n        except TypeError:\n            return (\n                    value in cls._unhashable_values_    # both structures are lists\n                    or value in cls._hashable_values_\n                    )\n\n    def __delattr__(cls, attr):\n        # nicer error message when someone tries to delete an attribute\n        # (see issue19025).\n        if attr in cls._member_map_:\n            raise AttributeError(\"%r cannot delete member %r.\" % (cls.__name__, attr))\n        super().__delattr__(attr)\n\n    def __dir__(cls):\n        interesting = set([\n                '__class__', '__contains__', '__doc__', '__getitem__',\n                '__iter__', '__len__', '__members__', '__module__',\n                '__name__', '__qualname__',\n                ]\n                + cls._member_names_\n                )\n        if cls._new_member_ is not object.__new__:\n            interesting.add('__new__')\n        if cls.__init_subclass__ is not object.__init_subclass__:\n            interesting.add('__init_subclass__')\n        if cls._member_type_ is object:\n            return sorted(interesting)\n        else:\n            # return whatever mixed-in data type has\n            return sorted(set(dir(cls._member_type_)) | interesting)\n\n    def __getitem__(cls, name):\n        \"\"\"\n        Return the member matching `name`.\n        \"\"\"\n        return cls._member_map_[name]\n\n    def __iter__(cls):\n        \"\"\"\n        Return members in definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in cls._member_names_)\n\n    def __len__(cls):\n        \"\"\"\n        Return the number of members (no aliases)\n        \"\"\"\n        return len(cls._member_names_)\n\n    @bltns.property\n    def __members__(cls):\n        \"\"\"\n        Returns a mapping of member name->value.\n\n        This mapping lists all enum members, including aliases. Note that this\n        is a read-only view of the internal mapping.\n        \"\"\"\n        return MappingProxyType(cls._member_map_)\n\n    def __repr__(cls):\n        if Flag is not None and issubclass(cls, Flag):\n            return \"<flag %r>\" % cls.__name__\n        else:\n            return \"<enum %r>\" % cls.__name__\n\n    def __reversed__(cls):\n        \"\"\"\n        Return members in reverse definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in reversed(cls._member_names_))\n\n    def __setattr__(cls, name, value):\n        \"\"\"\n        Block attempts to reassign Enum members.\n\n        A simple assignment to the class namespace only changes one of the\n        several possible ways to get an Enum member from the Enum class,\n        resulting in an inconsistent Enumeration.\n        \"\"\"\n        member_map = cls.__dict__.get('_member_map_', {})\n        if name in member_map:\n            raise AttributeError('cannot reassign member %r' % (name, ))\n        super().__setattr__(name, value)\n\n    def _create_(cls, class_name, names, *, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Convenience method to create a new Enum class.\n\n        `names` can be:\n\n        * A string containing member names, separated either with spaces or\n          commas.  Values are incremented by 1 from `start`.\n        * An iterable of member names.  Values are incremented by 1 from `start`.\n        * An iterable of (member name, value) pairs.\n        * A mapping of member name -> value pairs.\n        \"\"\"\n        metacls = cls.__class__\n        bases = (cls, ) if type is None else (type, cls)\n        _, first_enum = cls._get_mixins_(class_name, bases)\n        classdict = metacls.__prepare__(class_name, bases)\n\n        # special processing needed for names?\n        if isinstance(names, str):\n            names = names.replace(',', ' ').split()\n        if isinstance(names, (tuple, list)) and names and isinstance(names[0], str):\n            original_names, names = names, []\n            last_values = []\n            for count, name in enumerate(original_names):\n                value = first_enum._generate_next_value_(name, start, count, last_values[:])\n                last_values.append(value)\n                names.append((name, value))\n        if names is None:\n            names = ()\n\n        # Here, names is either an iterable of (name, value) or a mapping.\n        for item in names:\n            if isinstance(item, str):\n                member_name, member_value = item, names[item]\n            else:\n                member_name, member_value = item\n            classdict[member_name] = member_value\n\n        if module is None:\n            try:\n                module = sys._getframemodulename(2)\n            except AttributeError:\n                # Fall back on _getframe if _getframemodulename is missing\n                try:\n                    module = sys._getframe(2).f_globals['__name__']\n                except (AttributeError, ValueError, KeyError):\n                    pass\n        if module is None:\n            _make_class_unpicklable(classdict)\n        else:\n            classdict['__module__'] = module\n        if qualname is not None:\n            classdict['__qualname__'] = qualname\n\n        return metacls.__new__(metacls, class_name, bases, classdict, boundary=boundary)\n\n    def _convert_(cls, name, module, filter, source=None, *, boundary=None, as_global=False):\n        \"\"\"\n        Create a new Enum subclass that replaces a collection of global constants\n        \"\"\"\n        # convert all constants from source (or module) that pass filter() to\n        # a new Enum called name, and export the enum and its members back to\n        # module;\n        # also, replace the __reduce_ex__ method so unpickling works in\n        # previous Python versions\n        module_globals = sys.modules[module].__dict__\n        if source:\n            source = source.__dict__\n        else:\n            source = module_globals\n        # _value2member_map_ is populated in the same order every time\n        # for a consistent reverse mapping of number to name when there\n        # are multiple names for the same number.\n        members = [\n                (name, value)\n                for name, value in source.items()\n                if filter(name)]\n        try:\n            # sort by value\n            members.sort(key=lambda t: (t[1], t[0]))\n        except TypeError:\n            # unless some values aren't comparable, in which case sort by name\n            members.sort(key=lambda t: t[0])\n        body = {t[0]: t[1] for t in members}\n        body['__module__'] = module\n        tmp_cls = type(name, (object, ), body)\n        cls = _simple_enum(etype=cls, boundary=boundary or KEEP)(tmp_cls)\n        if as_global:\n            global_enum(cls)\n        else:\n            sys.modules[cls.__module__].__dict__.update(cls.__members__)\n        module_globals[name] = cls\n        return cls\n\n    @classmethod\n    def _check_for_existing_members_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if isinstance(base, EnumType) and base._member_names_:\n                    raise TypeError(\n                            \"<enum %r> cannot extend %r\"\n                            % (class_name, base)\n                            )\n\n    @classmethod\n    def _get_mixins_(mcls, class_name, bases):\n        \"\"\"\n        Returns the type for creating enum members, and the first inherited\n        enum class.\n\n        bases: the tuple of bases that was given to __new__\n        \"\"\"\n        if not bases:\n            return object, Enum\n        # ensure final parent class is an Enum derivative, find any concrete\n        # data type, and check that Enum has no members\n        first_enum = bases[-1]\n        if not isinstance(first_enum, EnumType):\n            raise TypeError(\"new enumerations should be created as \"\n                    \"`EnumName([mixin_type, ...] [data_type,] enum_type)`\")\n        member_type = mcls._find_data_type_(class_name, bases) or object\n        return member_type, first_enum\n\n    @classmethod\n    def _find_data_repr_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if base is object:\n                    continue\n                elif isinstance(base, EnumType):\n                    # if we hit an Enum, use it's _value_repr_\n                    return base._value_repr_\n                elif '__repr__' in base.__dict__:\n                    # this is our data repr\n                    # double-check if a dataclass with a default __repr__\n                    if (\n                            '__dataclass_fields__' in base.__dict__\n                            and '__dataclass_params__' in base.__dict__\n                            and base.__dict__['__dataclass_params__'].repr\n                        ):\n                        return _dataclass_repr\n                    else:\n                        return base.__dict__['__repr__']\n        return None\n\n    @classmethod\n    def _find_data_type_(mcls, class_name, bases):\n        # a datatype has a __new__ method, or a __dataclass_fields__ attribute\n        data_types = set()\n        base_chain = set()\n        for chain in bases:\n            candidate = None\n            for base in chain.__mro__:\n                base_chain.add(base)\n                if base is object:\n                    continue\n                elif isinstance(base, EnumType):\n                    if base._member_type_ is not object:\n                        data_types.add(base._member_type_)\n                        break\n                elif '__new__' in base.__dict__ or '__dataclass_fields__' in base.__dict__:\n                    data_types.add(candidate or base)\n                    break\n                else:\n                    candidate = candidate or base\n        if len(data_types) > 1:\n            raise TypeError('too many data types for %r: %r' % (class_name, data_types))\n        elif data_types:\n            return data_types.pop()\n        else:\n            return None\n\n    @classmethod\n    def _find_new_(mcls, classdict, member_type, first_enum):\n        \"\"\"\n        Returns the __new__ to be used for creating the enum members.\n\n        classdict: the class dictionary given to __new__\n        member_type: the data type whose __new__ will be used by default\n        first_enum: enumeration to check for an overriding __new__\n        \"\"\"\n        # now find the correct __new__, checking to see of one was defined\n        # by the user; also check earlier enum classes in case a __new__ was\n        # saved as __new_member__\n        __new__ = classdict.get('__new__', None)\n\n        # should __new__ be saved as __new_member__ later?\n        save_new = first_enum is not None and __new__ is not None\n\n        if __new__ is None:\n            # check all possibles for __new_member__ before falling back to\n            # __new__\n            for method in ('__new_member__', '__new__'):\n                for possible in (member_type, first_enum):\n                    target = getattr(possible, method, None)\n                    if target not in {\n                            None,\n                            None.__new__,\n                            object.__new__,\n                            Enum.__new__,\n                            }:\n                        __new__ = target\n                        break\n                if __new__ is not None:\n                    break\n            else:\n                __new__ = object.__new__\n\n        # if a non-object.__new__ is used then whatever value/tuple was\n        # assigned to the enum member name will be passed to __new__ and to the\n        # new enum member's __init__\n        if first_enum is None or __new__ in (Enum.__new__, object.__new__):\n            use_args = False\n        else:\n            use_args = True\n        return __new__, save_new, use_args\n\n    def _add_member_(cls, name, member):\n        # _value_ structures are not updated\n        if name in cls._member_map_:\n            if cls._member_map_[name] is not member:\n                raise NameError('%r is already bound: %r' % (name, cls._member_map_[name]))\n            return\n        #\n        # if necessary, get redirect in place and then add it to _member_map_\n        found_descriptor = None\n        descriptor_type = None\n        class_type = None\n        for base in cls.__mro__[1:]:\n            attr = base.__dict__.get(name)\n            if attr is not None:\n                if isinstance(attr, (property, DynamicClassAttribute)):\n                    found_descriptor = attr\n                    class_type = base\n                    descriptor_type = 'enum'\n                    break\n                elif _is_descriptor(attr):\n                    found_descriptor = attr\n                    descriptor_type = descriptor_type or 'desc'\n                    class_type = class_type or base\n                    continue\n                else:\n                    descriptor_type = 'attr'\n                    class_type = base\n        if found_descriptor:\n            redirect = property()\n            redirect.member = member\n            redirect.__set_name__(cls, name)\n            if descriptor_type in ('enum', 'desc'):\n                # earlier descriptor found; copy fget, fset, fdel to this one.\n                redirect.fget = getattr(found_descriptor, 'fget', None)\n                redirect._get = getattr(found_descriptor, '__get__', None)\n                redirect.fset = getattr(found_descriptor, 'fset', None)\n                redirect._set = getattr(found_descriptor, '__set__', None)\n                redirect.fdel = getattr(found_descriptor, 'fdel', None)\n                redirect._del = getattr(found_descriptor, '__delete__', None)\n            redirect._attr_type = descriptor_type\n            redirect._cls_type = class_type\n            setattr(cls, name, redirect)\n        else:\n            setattr(cls, name, member)\n        # now add to _member_map_ (even aliases)\n        cls._member_map_[name] = member\n\nEnumMeta = EnumType         # keep EnumMeta name for backwards compatibility\n\n\nclass Enum(metaclass=EnumType):\n    \"\"\"\n    Create a collection of name/value pairs.\n\n    Example enumeration:\n\n    >>> class Color(Enum):\n    ...     RED = 1\n    ...     BLUE = 2\n    ...     GREEN = 3\n\n    Access them by:\n\n    - attribute access:\n\n      >>> Color.RED\n      <Color.RED: 1>\n\n    - value lookup:\n\n      >>> Color(1)\n      <Color.RED: 1>\n\n    - name lookup:\n\n      >>> Color['RED']\n      <Color.RED: 1>\n\n    Enumerations can be iterated over, and know how many members they have:\n\n    >>> len(Color)\n    3\n\n    >>> list(Color)\n    [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\n    Methods can be added to enumerations, and members can have their own\n    attributes -- see the documentation for details.\n    \"\"\"\n\n    @classmethod\n    def __signature__(cls):\n        if cls._member_names_:\n            return '(*values)'\n        else:\n            return '(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)'\n\n    def __new__(cls, value):\n        # all enum instances are actually created during class construction\n        # without calling this method; this method is called by the metaclass'\n        # __call__ (i.e. Color(3) ), and by pickle\n        if type(value) is cls:\n            # For lookups like Color(Color.RED)\n            return value\n        # by-value search for a matching enum member\n        # see if it's in the reverse mapping (for hashable values)\n        try:\n            return cls._value2member_map_[value]\n        except KeyError:\n            # Not found, no need to do long O(n) search\n            pass\n        except TypeError:\n            # not there, now do long search -- O(n) behavior\n            for name, unhashable_values in cls._unhashable_values_map_.items():\n                if value in unhashable_values:\n                    return cls[name]\n            for name, member in cls._member_map_.items():\n                if value == member._value_:\n                    return cls[name]\n        # still not found -- verify that members exist, in-case somebody got here mistakenly\n        # (such as via super when trying to override __new__)\n        if not cls._member_map_:\n            if getattr(cls, '_%s__in_progress' % cls.__name__, False):\n                raise TypeError('do not use `super().__new__; call the appropriate __new__ directly') from None\n            raise TypeError(\"%r has no members defined\" % cls)\n        #\n        # still not found -- try _missing_ hook\n        try:\n            exc = None\n            result = cls._missing_(value)\n        except Exception as e:\n            exc = e\n            result = None\n        try:\n            if isinstance(result, cls):\n                return result\n            elif (\n                    Flag is not None and issubclass(cls, Flag)\n                    and cls._boundary_ is EJECT and isinstance(result, int)\n                ):\n                return result\n            else:\n                ve_exc = ValueError(\"%r is not a valid %s\" % (value, cls.__qualname__))\n                if result is None and exc is None:\n                    raise ve_exc\n                elif exc is None:\n                    exc = TypeError(\n                            'error in %s._missing_: returned %r instead of None or a valid member'\n                            % (cls.__name__, result)\n                            )\n                if not isinstance(exc, ValueError):\n                    exc.__context__ = ve_exc\n                raise exc\n        finally:\n            # ensure all variables that could hold an exception are destroyed\n            exc = None\n            ve_exc = None\n\n    def __init__(self, *args, **kwds):\n        pass\n\n    def _add_alias_(self, name):\n        self.__class__._add_member_(name, self)\n\n    def _add_value_alias_(self, value):\n        cls = self.__class__\n        try:\n            if value in cls._value2member_map_:\n                if cls._value2member_map_[value] is not self:\n                    raise ValueError('%r is already bound: %r' % (value, cls._value2member_map_[value]))\n                return\n        except TypeError:\n            # unhashable value, do long search\n            for m in cls._member_map_.values():\n                if m._value_ == value:\n                    if m is not self:\n                        raise ValueError('%r is already bound: %r' % (value, cls._value2member_map_[value]))\n                    return\n        try:\n            # This may fail if value is not hashable. We can't add the value\n            # to the map, and by-value lookups for this value will be\n            # linear.\n            cls._value2member_map_.setdefault(value, self)\n            cls._hashable_values_.append(value)\n        except TypeError:\n            # keep track of the value in a list so containment checks are quick\n            cls._unhashable_values_.append(value)\n            cls._unhashable_values_map_.setdefault(self.name, []).append(value)\n\n    @staticmethod\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the list of values assigned\n        \"\"\"\n        if not last_values:\n            return start\n        try:\n            last_value = sorted(last_values).pop()\n        except TypeError:\n            raise TypeError('unable to sort non-numeric values') from None\n        try:\n            return last_value + 1\n        except TypeError:\n            raise TypeError('unable to increment %r' % (last_value, )) from None\n\n    @classmethod\n    def _missing_(cls, value):\n        return None\n\n    def __repr__(self):\n        v_repr = self.__class__._value_repr_ or repr\n        return \"<%s.%s: %s>\" % (self.__class__.__name__, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        return \"%s.%s\" % (self.__class__.__name__, self._name_, )\n\n    def __dir__(self):\n        \"\"\"\n        Returns public methods and other interesting attributes.\n        \"\"\"\n        interesting = set()\n        if self.__class__._member_type_ is not object:\n            interesting = set(object.__dir__(self))\n        for name in getattr(self, '__dict__', []):\n            if name[0] != '_' and name not in self._member_map_:\n                interesting.add(name)\n        for cls in self.__class__.mro():\n            for name, obj in cls.__dict__.items():\n                if name[0] == '_':\n                    continue\n                if isinstance(obj, property):\n                    # that's an enum.property\n                    if obj.fget is not None or name not in self._member_map_:\n                        interesting.add(name)\n                    else:\n                        # in case it was added by `dir(self)`\n                        interesting.discard(name)\n                elif name not in self._member_map_:\n                    interesting.add(name)\n        names = sorted(\n                set(['__class__', '__doc__', '__eq__', '__hash__', '__module__'])\n                | interesting\n                )\n        return names\n\n    def __format__(self, format_spec):\n        return str.__format__(str(self), format_spec)\n\n    def __hash__(self):\n        return hash(self._name_)\n\n    def __reduce_ex__(self, proto):\n        return self.__class__, (self._value_, )\n\n    def __deepcopy__(self,memo):\n        return self\n\n    def __copy__(self):\n        return self\n\n    # enum.property is used to provide access to the `name` and\n    # `value` attributes of enum members while keeping some measure of\n    # protection from modification, while still allowing for an enumeration\n    # to have members named `name` and `value`.  This works because each\n    # instance of enum.property saves its companion member, which it returns\n    # on class lookup; on instance lookup it either executes a provided function\n    # or raises an AttributeError.\n\n    @property\n    def name(self):\n        \"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    @property\n    def value(self):\n        \"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n\nclass ReprEnum(Enum):\n    \"\"\"\n    Only changes the repr(), leaving str() and format() to the mixed-in type.\n    \"\"\"\n\n\nclass IntEnum(int, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) ints\n    \"\"\"\n\n\nclass StrEnum(str, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) strings\n    \"\"\"\n\n    def __new__(cls, *values):\n        \"values must already be of type `str`\"\n        if len(values) > 3:\n            raise TypeError('too many arguments for str(): %r' % (values, ))\n        if len(values) == 1:\n            # it must be a string\n            if not isinstance(values[0], str):\n                raise TypeError('%r is not a string' % (values[0], ))\n        if len(values) >= 2:\n            # check that encoding argument is a string\n            if not isinstance(values[1], str):\n                raise TypeError('encoding must be a string, not %r' % (values[1], ))\n        if len(values) == 3:\n            # check that errors argument is a string\n            if not isinstance(values[2], str):\n                raise TypeError('errors must be a string, not %r' % (values[2]))\n        value = str(*values)\n        member = str.__new__(cls, value)\n        member._value_ = value\n        return member\n\n    @staticmethod\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Return the lower-cased version of the member name.\n        \"\"\"\n        return name.lower()\n\n\ndef pickle_by_global_name(self, proto):\n    # should not be used with Flag-type enums\n    return self.name\n_reduce_ex_by_global_name = pickle_by_global_name\n\ndef pickle_by_enum_name(self, proto):\n    # should not be used with Flag-type enums\n    return getattr, (self.__class__, self._name_)\n\nclass FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled\n    \"strict\" -> error is raised             [default for Flag]\n    \"conform\" -> extra bits are discarded\n    \"eject\" -> lose flag status\n    \"keep\" -> keep flag status and all bits [default for IntFlag]\n    \"\"\"\n    STRICT = auto()\n    CONFORM = auto()\n    EJECT = auto()\n    KEEP = auto()\nSTRICT, CONFORM, EJECT, KEEP = FlagBoundary\n\n\nclass Flag(Enum, boundary=STRICT):\n    \"\"\"\n    Support for flags\n    \"\"\"\n\n    _numeric_repr_ = repr\n\n    @staticmethod\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the last value assigned or None\n        \"\"\"\n        if not count:\n            return start if start is not None else 1\n        last_value = max(last_values)\n        try:\n            high_bit = _high_bit(last_value)\n        except Exception:\n            raise TypeError('invalid flag value %r' % last_value) from None\n        return 2 ** (high_bit+1)\n\n    @classmethod\n    def _iter_member_by_value_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition (i.e. increasing value) order.\n        \"\"\"\n        for val in _iter_bits_lsb(value & cls._flag_mask_):\n            yield cls._value2member_map_.get(val)\n\n    _iter_member_ = _iter_member_by_value_\n\n    @classmethod\n    def _iter_member_by_def_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition order.\n        \"\"\"\n        yield from sorted(\n                cls._iter_member_by_value_(value),\n                key=lambda m: m._sort_order_,\n                )\n\n    @classmethod\n    def _missing_(cls, value):\n        \"\"\"\n        Create a composite member containing all canonical members present in `value`.\n\n        If non-member values are present, result depends on `_boundary_` setting.\n        \"\"\"\n        if not isinstance(value, int):\n            raise ValueError(\n                    \"%r is not a valid %s\" % (value, cls.__qualname__)\n                    )\n        # check boundaries\n        # - value must be in range (e.g. -16 <-> +15, i.e. ~15 <-> 15)\n        # - value must not include any skipped flags (e.g. if bit 2 is not\n        #   defined, then 0d10 is invalid)\n        flag_mask = cls._flag_mask_\n        singles_mask = cls._singles_mask_\n        all_bits = cls._all_bits_\n        neg_value = None\n        if (\n                not ~all_bits <= value <= all_bits\n                or value & (all_bits ^ flag_mask)\n            ):\n            if cls._boundary_ is STRICT:\n                max_bits = max(value.bit_length(), flag_mask.bit_length())\n                raise ValueError(\n                        \"%r invalid value %r\\n    given %s\\n  allowed %s\" % (\n                            cls, value, bin(value, max_bits), bin(flag_mask, max_bits),\n                            ))\n            elif cls._boundary_ is CONFORM:\n                value = value & flag_mask\n            elif cls._boundary_ is EJECT:\n                return value\n            elif cls._boundary_ is KEEP:\n                if value < 0:\n                    value = (\n                            max(all_bits+1, 2**(value.bit_length()))\n                            + value\n                            )\n            else:\n                raise ValueError(\n                        '%r unknown flag boundary %r' % (cls, cls._boundary_, )\n                        )\n        if value < 0:\n            neg_value = value\n            value = all_bits + 1 + value\n        # get members and unknown\n        unknown = value & ~flag_mask\n        aliases = value & ~singles_mask\n        member_value = value & singles_mask\n        if unknown and cls._boundary_ is not KEEP:\n            raise ValueError(\n                    '%s(%r) -->  unknown values %r [%s]'\n                    % (cls.__name__, value, unknown, bin(unknown))\n                    )\n        # normal Flag?\n        if cls._member_type_ is object:\n            # construct a singleton enum pseudo-member\n            pseudo_member = object.__new__(cls)\n        else:\n            pseudo_member = cls._member_type_.__new__(cls, value)\n        if not hasattr(pseudo_member, '_value_'):\n            pseudo_member._value_ = value\n        if member_value or aliases:\n            members = []\n            combined_value = 0\n            for m in cls._iter_member_(member_value):\n                members.append(m)\n                combined_value |= m._value_\n            if aliases:\n                value = member_value | aliases\n                for n, pm in cls._member_map_.items():\n                    if pm not in members and pm._value_ and pm._value_ & value == pm._value_:\n                        members.append(pm)\n                        combined_value |= pm._value_\n            unknown = value ^ combined_value\n            pseudo_member._name_ = '|'.join([m._name_ for m in members])\n            if not combined_value:\n                pseudo_member._name_ = None\n            elif unknown and cls._boundary_ is STRICT:\n                raise ValueError('%r: no members with value %r' % (cls, unknown))\n            elif unknown:\n                pseudo_member._name_ += '|%s' % cls._numeric_repr_(unknown)\n        else:\n            pseudo_member._name_ = None\n        # use setdefault in case another thread already created a composite\n        # with this value\n        # note: zero is a special case -- always add it\n        pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)\n        if neg_value is not None:\n            cls._value2member_map_[neg_value] = pseudo_member\n        return pseudo_member\n\n    def __contains__(self, other):\n        \"\"\"\n        Returns True if self has at least the same flags set as other.\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise TypeError(\n                \"unsupported operand type(s) for 'in': %r and %r\" % (\n                    type(other).__qualname__, self.__class__.__qualname__))\n        return other._value_ & self._value_ == other._value_\n\n    def __iter__(self):\n        \"\"\"\n        Returns flags in definition order.\n        \"\"\"\n        yield from self._iter_member_(self._value_)\n\n    def __len__(self):\n        return self._value_.bit_count()\n\n    def __repr__(self):\n        cls_name = self.__class__.__name__\n        v_repr = self.__class__._value_repr_ or repr\n        if self._name_ is None:\n            return \"<%s: %s>\" % (cls_name, v_repr(self._value_))\n        else:\n            return \"<%s.%s: %s>\" % (cls_name, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        cls_name = self.__class__.__name__\n        if self._name_ is None:\n            return '%s(%r)' % (cls_name, self._value_)\n        else:\n            return \"%s.%s\" % (cls_name, self._name_)\n\n    def __bool__(self):\n        return bool(self._value_)\n\n    def _get_value(self, flag):\n        if isinstance(flag, self.__class__):\n            return flag._value_\n        elif self._member_type_ is not object and isinstance(flag, self._member_type_):\n            return flag\n        return NotImplemented\n\n    def __or__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with |\")\n        value = self._value_\n        return self.__class__(value | other_value)\n\n    def __and__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with &\")\n        value = self._value_\n        return self.__class__(value & other_value)\n\n    def __xor__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with ^\")\n        value = self._value_\n        return self.__class__(value ^ other_value)\n\n    def __invert__(self):\n        if self._get_value(self) is None:\n            raise TypeError(f\"'{self}' cannot be inverted\")\n\n        if self._inverted_ is None:\n            if self._boundary_ in (EJECT, KEEP):\n                self._inverted_ = self.__class__(~self._value_)\n            else:\n                self._inverted_ = self.__class__(self._singles_mask_ & ~self._value_)\n        return self._inverted_\n\n    __rand__ = __and__\n    __ror__ = __or__\n    __rxor__ = __xor__\n\n\nclass IntFlag(int, ReprEnum, Flag, boundary=KEEP):\n    \"\"\"\n    Support for integer-based Flags\n    \"\"\"\n\n\ndef _high_bit(value):\n    \"\"\"\n    returns index of highest bit, or -1 if value is zero or negative\n    \"\"\"\n    return value.bit_length() - 1\n\ndef unique(enumeration):\n    \"\"\"\n    Class decorator for enumerations ensuring unique member values.\n    \"\"\"\n    duplicates = []\n    for name, member in enumeration.__members__.items():\n        if name != member.name:\n            duplicates.append((name, member.name))\n    if duplicates:\n        alias_details = ', '.join(\n                [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n        raise ValueError('duplicate values found in %r: %s' %\n                (enumeration, alias_details))\n    return enumeration\n\ndef _dataclass_repr(self):\n    dcf = self.__dataclass_fields__\n    return ', '.join(\n            '%s=%r' % (k, getattr(self, k))\n            for k in dcf.keys()\n            if dcf[k].repr\n            )\n\ndef global_enum_repr(self):\n    \"\"\"\n    use module.enum_name instead of class.enum_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    return '%s.%s' % (module, self._name_)\n\ndef global_flag_repr(self):\n    \"\"\"\n    use module.flag_name instead of class.flag_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    cls_name = self.__class__.__name__\n    if self._name_ is None:\n        return \"%s.%s(%r)\" % (module, cls_name, self._value_)\n    if _is_single_bit(self._value_):\n        return '%s.%s' % (module, self._name_)\n    if self._boundary_ is not FlagBoundary.KEEP:\n        return '|'.join(['%s.%s' % (module, name) for name in self.name.split('|')])\n    else:\n        name = []\n        for n in self._name_.split('|'):\n            if n[0].isdigit():\n                name.append(n)\n            else:\n                name.append('%s.%s' % (module, n))\n        return '|'.join(name)\n\ndef global_str(self):\n    \"\"\"\n    use enum_name instead of class.enum_name\n    \"\"\"\n    if self._name_ is None:\n        cls_name = self.__class__.__name__\n        return \"%s(%r)\" % (cls_name, self._value_)\n    else:\n        return self._name_\n\ndef global_enum(cls, update_str=False):\n    \"\"\"\n    decorator that makes the repr() of an enum member reference its module\n    instead of its class; also exports all members to the enum's module's\n    global namespace\n    \"\"\"\n    if issubclass(cls, Flag):\n        cls.__repr__ = global_flag_repr\n    else:\n        cls.__repr__ = global_enum_repr\n    if not issubclass(cls, ReprEnum) or update_str:\n        cls.__str__ = global_str\n    sys.modules[cls.__module__].__dict__.update(cls.__members__)\n    return cls\n\ndef _simple_enum(etype=Enum, *, boundary=None, use_args=None):\n    \"\"\"\n    Class decorator that converts a normal class into an :class:`Enum`.  No\n    safety checks are done, and some advanced behavior (such as\n    :func:`__init_subclass__`) is not available.  Enum creation can be faster\n    using :func:`_simple_enum`.\n\n        >>> from enum import Enum, _simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> Color\n        <enum 'Color'>\n    \"\"\"\n    def convert_class(cls):\n        nonlocal use_args\n        cls_name = cls.__name__\n        if use_args is None:\n            use_args = etype._use_args_\n        __new__ = cls.__dict__.get('__new__')\n        if __new__ is not None:\n            new_member = __new__.__func__\n        else:\n            new_member = etype._member_type_.__new__\n        attrs = {}\n        body = {}\n        if __new__ is not None:\n            body['__new_member__'] = new_member\n        body['_new_member_'] = new_member\n        body['_use_args_'] = use_args\n        body['_generate_next_value_'] = gnv = etype._generate_next_value_\n        body['_member_names_'] = member_names = []\n        body['_member_map_'] = member_map = {}\n        body['_value2member_map_'] = value2member_map = {}\n        body['_hashable_values_'] = hashable_values = []\n        body['_unhashable_values_'] = unhashable_values = []\n        body['_unhashable_values_map_'] = {}\n        body['_member_type_'] = member_type = etype._member_type_\n        body['_value_repr_'] = etype._value_repr_\n        if issubclass(etype, Flag):\n            body['_boundary_'] = boundary or etype._boundary_\n            body['_flag_mask_'] = None\n            body['_all_bits_'] = None\n            body['_singles_mask_'] = None\n            body['_inverted_'] = None\n            body['__or__'] = Flag.__or__\n            body['__xor__'] = Flag.__xor__\n            body['__and__'] = Flag.__and__\n            body['__ror__'] = Flag.__ror__\n            body['__rxor__'] = Flag.__rxor__\n            body['__rand__'] = Flag.__rand__\n            body['__invert__'] = Flag.__invert__\n        for name, obj in cls.__dict__.items():\n            if name in ('__dict__', '__weakref__'):\n                continue\n            if _is_dunder(name) or _is_private(cls_name, name) or _is_sunder(name) or _is_descriptor(obj):\n                body[name] = obj\n            else:\n                attrs[name] = obj\n        if cls.__dict__.get('__doc__') is None:\n            body['__doc__'] = 'An enumeration.'\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        enum_class = type(cls_name, (etype, ), body, boundary=boundary, _simple=True)\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in body:\n                # check for mixin overrides before replacing\n                enum_method = getattr(etype, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        gnv_last_values = []\n        if issubclass(enum_class, Flag):\n            # Flag / IntFlag\n            single_bits = multi_bits = 0\n            for name, value in attrs.items():\n                if isinstance(value, auto) and auto.value is _auto_null:\n                    value = gnv(name, 1, len(member_names), gnv_last_values)\n                # create basic member (possibly isolate value for alias check)\n                if use_args:\n                    if not isinstance(value, tuple):\n                        value = (value, )\n                    member = new_member(enum_class, *value)\n                    value = value[0]\n                else:\n                    member = new_member(enum_class)\n                if __new__ is None:\n                    member._value_ = value\n                # now check if alias\n                try:\n                    contained = value2member_map.get(member._value_)\n                except TypeError:\n                    contained = None\n                    if member._value_ in unhashable_values or member.value in hashable_values:\n                        for m in enum_class:\n                            if m._value_ == member._value_:\n                                contained = m\n                                break\n                if contained is not None:\n                    # an alias to an existing member\n                    contained._add_alias_(name)\n                else:\n                    # finish creating member\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    member._sort_order_ = len(member_names)\n                    if name not in ('name', 'value'):\n                        setattr(enum_class, name, member)\n                        member_map[name] = member\n                    else:\n                        enum_class._add_member_(name, member)\n                    value2member_map[value] = member\n                    hashable_values.append(value)\n                    if _is_single_bit(value):\n                        # not a multi-bit alias, record in _member_names_ and _flag_mask_\n                        member_names.append(name)\n                        single_bits |= value\n                    else:\n                        multi_bits |= value\n                    gnv_last_values.append(value)\n            enum_class._flag_mask_ = single_bits | multi_bits\n            enum_class._singles_mask_ = single_bits\n            enum_class._all_bits_ = 2 ** ((single_bits|multi_bits).bit_length()) - 1\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n        else:\n            # Enum / IntEnum / StrEnum\n            for name, value in attrs.items():\n                if isinstance(value, auto):\n                    if value.value is _auto_null:\n                        value.value = gnv(name, 1, len(member_names), gnv_last_values)\n                    value = value.value\n                # create basic member (possibly isolate value for alias check)\n                if use_args:\n                    if not isinstance(value, tuple):\n                        value = (value, )\n                    member = new_member(enum_class, *value)\n                    value = value[0]\n                else:\n                    member = new_member(enum_class)\n                if __new__ is None:\n                    member._value_ = value\n                # now check if alias\n                try:\n                    contained = value2member_map.get(member._value_)\n                except TypeError:\n                    contained = None\n                    if member._value_ in unhashable_values or member._value_ in hashable_values:\n                        for m in enum_class:\n                            if m._value_ == member._value_:\n                                contained = m\n                                break\n                if contained is not None:\n                    # an alias to an existing member\n                    contained._add_alias_(name)\n                else:\n                    # finish creating member\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    member._sort_order_ = len(member_names)\n                    if name not in ('name', 'value'):\n                        setattr(enum_class, name, member)\n                        member_map[name] = member\n                    else:\n                        enum_class._add_member_(name, member)\n                    member_names.append(name)\n                    gnv_last_values.append(value)\n                    try:\n                        # This may fail if value is not hashable. We can't add the value\n                        # to the map, and by-value lookups for this value will be\n                        # linear.\n                        enum_class._value2member_map_.setdefault(value, member)\n                        if value not in hashable_values:\n                            hashable_values.append(value)\n                    except TypeError:\n                        # keep track of the value in a list so containment checks are quick\n                        enum_class._unhashable_values_.append(value)\n                        enum_class._unhashable_values_map_.setdefault(name, []).append(value)\n        if '__new__' in body:\n            enum_class.__new_member__ = enum_class.__new__\n        enum_class.__new__ = Enum.__new__\n        return enum_class\n    return convert_class\n\n@_simple_enum(StrEnum)\nclass EnumCheck:\n    \"\"\"\n    various conditions to check an enumeration for\n    \"\"\"\n    CONTINUOUS = \"no skipped integer values\"\n    NAMED_FLAGS = \"multi-flag aliases may not contain unnamed flags\"\n    UNIQUE = \"one name per value\"\nCONTINUOUS, NAMED_FLAGS, UNIQUE = EnumCheck\n\n\nclass verify:\n    \"\"\"\n    Check an enumeration for various constraints. (see EnumCheck)\n    \"\"\"\n    def __init__(self, *checks):\n        self.checks = checks\n    def __call__(self, enumeration):\n        checks = self.checks\n        cls_name = enumeration.__name__\n        if Flag is not None and issubclass(enumeration, Flag):\n            enum_type = 'flag'\n        elif issubclass(enumeration, Enum):\n            enum_type = 'enum'\n        else:\n            raise TypeError(\"the 'verify' decorator only works with Enum and Flag\")\n        for check in checks:\n            if check is UNIQUE:\n                # check for duplicate names\n                duplicates = []\n                for name, member in enumeration.__members__.items():\n                    if name != member.name:\n                        duplicates.append((name, member.name))\n                if duplicates:\n                    alias_details = ', '.join(\n                            [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n                    raise ValueError('aliases found in %r: %s' %\n                            (enumeration, alias_details))\n            elif check is CONTINUOUS:\n                values = set(e.value for e in enumeration)\n                if len(values) < 2:\n                    continue\n                low, high = min(values), max(values)\n                missing = []\n                if enum_type == 'flag':\n                    # check for powers of two\n                    for i in range(_high_bit(low)+1, _high_bit(high)):\n                        if 2**i not in values:\n                            missing.append(2**i)\n                elif enum_type == 'enum':\n                    # check for powers of one\n                    for i in range(low+1, high):\n                        if i not in values:\n                            missing.append(i)\n                else:\n                    raise Exception('verify: unknown type %r' % enum_type)\n                if missing:\n                    raise ValueError(('invalid %s %r: missing values %s' % (\n                            enum_type, cls_name, ', '.join((str(m) for m in missing)))\n                            )[:256])\n                            # limit max length to protect against DOS attacks\n            elif check is NAMED_FLAGS:\n                # examine each alias and check for unnamed flags\n                member_names = enumeration._member_names_\n                member_values = [m.value for m in enumeration]\n                missing_names = []\n                missing_value = 0\n                for name, alias in enumeration._member_map_.items():\n                    if name in member_names:\n                        # not an alias\n                        continue\n                    if alias.value < 0:\n                        # negative numbers are not checked\n                        continue\n                    values = list(_iter_bits_lsb(alias.value))\n                    missed = [v for v in values if v not in member_values]\n                    if missed:\n                        missing_names.append(name)\n                        for val in missed:\n                            missing_value |= val\n                if missing_names:\n                    if len(missing_names) == 1:\n                        alias = 'alias %s is missing' % missing_names[0]\n                    else:\n                        alias = 'aliases %s and %s are missing' % (\n                                ', '.join(missing_names[:-1]), missing_names[-1]\n                                )\n                    if _is_single_bit(missing_value):\n                        value = 'value 0x%x' % missing_value\n                    else:\n                        value = 'combined values of 0x%x' % missing_value\n                    raise ValueError(\n                            'invalid Flag %r: %s %s [use enum.show_flag_values(value) for details]'\n                            % (cls_name, alias, value)\n                            )\n        return enumeration\n\ndef _test_simple_enum(checked_enum, simple_enum):\n    \"\"\"\n    A function that can be used to test an enum created with :func:`_simple_enum`\n    against the version created by subclassing :class:`Enum`::\n\n        >>> from enum import Enum, _simple_enum, _test_simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> class CheckedColor(Enum):\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> _test_simple_enum(CheckedColor, Color)\n\n    If differences are found, a :exc:`TypeError` is raised.\n    \"\"\"\n    failed = []\n    if checked_enum.__dict__ != simple_enum.__dict__:\n        checked_dict = checked_enum.__dict__\n        checked_keys = list(checked_dict.keys())\n        simple_dict = simple_enum.__dict__\n        simple_keys = list(simple_dict.keys())\n        member_names = set(\n                list(checked_enum._member_map_.keys())\n                + list(simple_enum._member_map_.keys())\n                )\n        for key in set(checked_keys + simple_keys):\n            if key in ('__module__', '_member_map_', '_value2member_map_', '__doc__',\n                       '__static_attributes__', '__firstlineno__'):\n                # keys known to be different, or very long\n                continue\n            elif key in member_names:\n                # members are checked below\n                continue\n            elif key not in simple_keys:\n                failed.append(\"missing key: %r\" % (key, ))\n            elif key not in checked_keys:\n                failed.append(\"extra key:   %r\" % (key, ))\n            else:\n                checked_value = checked_dict[key]\n                simple_value = simple_dict[key]\n                if callable(checked_value) or isinstance(checked_value, bltns.property):\n                    continue\n                if key == '__doc__':\n                    # remove all spaces/tabs\n                    compressed_checked_value = checked_value.replace(' ','').replace('\\t','')\n                    compressed_simple_value = simple_value.replace(' ','').replace('\\t','')\n                    if compressed_checked_value != compressed_simple_value:\n                        failed.append(\"%r:\\n         %s\\n         %s\" % (\n                                key,\n                                \"checked -> %r\" % (checked_value, ),\n                                \"simple  -> %r\" % (simple_value, ),\n                                ))\n                elif checked_value != simple_value:\n                    failed.append(\"%r:\\n         %s\\n         %s\" % (\n                            key,\n                            \"checked -> %r\" % (checked_value, ),\n                            \"simple  -> %r\" % (simple_value, ),\n                            ))\n        failed.sort()\n        for name in member_names:\n            failed_member = []\n            if name not in simple_keys:\n                failed.append('missing member from simple enum: %r' % name)\n            elif name not in checked_keys:\n                failed.append('extra member in simple enum: %r' % name)\n            else:\n                checked_member_dict = checked_enum[name].__dict__\n                checked_member_keys = list(checked_member_dict.keys())\n                simple_member_dict = simple_enum[name].__dict__\n                simple_member_keys = list(simple_member_dict.keys())\n                for key in set(checked_member_keys + simple_member_keys):\n                    if key in ('__module__', '__objclass__', '_inverted_'):\n                        # keys known to be different or absent\n                        continue\n                    elif key not in simple_member_keys:\n                        failed_member.append(\"missing key %r not in the simple enum member %r\" % (key, name))\n                    elif key not in checked_member_keys:\n                        failed_member.append(\"extra key %r in simple enum member %r\" % (key, name))\n                    else:\n                        checked_value = checked_member_dict[key]\n                        simple_value = simple_member_dict[key]\n                        if checked_value != simple_value:\n                            failed_member.append(\"%r:\\n         %s\\n         %s\" % (\n                                    key,\n                                    \"checked member -> %r\" % (checked_value, ),\n                                    \"simple member  -> %r\" % (simple_value, ),\n                                    ))\n            if failed_member:\n                failed.append('%r member mismatch:\\n      %s' % (\n                        name, '\\n      '.join(failed_member),\n                        ))\n        for method in (\n                '__str__', '__repr__', '__reduce_ex__', '__format__',\n                '__getnewargs_ex__', '__getnewargs__', '__reduce_ex__', '__reduce__'\n            ):\n            if method in simple_keys and method in checked_keys:\n                # cannot compare functions, and it exists in both, so we're good\n                continue\n            elif method not in simple_keys and method not in checked_keys:\n                # method is inherited -- check it out\n                checked_method = getattr(checked_enum, method, None)\n                simple_method = getattr(simple_enum, method, None)\n                if hasattr(checked_method, '__func__'):\n                    checked_method = checked_method.__func__\n                    simple_method = simple_method.__func__\n                if checked_method != simple_method:\n                    failed.append(\"%r:  %-30s %s\" % (\n                            method,\n                            \"checked -> %r\" % (checked_method, ),\n                            \"simple -> %r\" % (simple_method, ),\n                            ))\n            else:\n                # if the method existed in only one of the enums, it will have been caught\n                # in the first checks above\n                pass\n    if failed:\n        raise TypeError('enum mismatch:\\n   %s' % '\\n   '.join(failed))\n\ndef _old_convert_(etype, name, module, filter, source=None, *, boundary=None):\n    \"\"\"\n    Create a new Enum subclass that replaces a collection of global constants\n    \"\"\"\n    # convert all constants from source (or module) that pass filter() to\n    # a new Enum called name, and export the enum and its members back to\n    # module;\n    # also, replace the __reduce_ex__ method so unpickling works in\n    # previous Python versions\n    module_globals = sys.modules[module].__dict__\n    if source:\n        source = source.__dict__\n    else:\n        source = module_globals\n    # _value2member_map_ is populated in the same order every time\n    # for a consistent reverse mapping of number to name when there\n    # are multiple names for the same number.\n    members = [\n            (name, value)\n            for name, value in source.items()\n            if filter(name)]\n    try:\n        # sort by value\n        members.sort(key=lambda t: (t[1], t[0]))\n    except TypeError:\n        # unless some values aren't comparable, in which case sort by name\n        members.sort(key=lambda t: t[0])\n    cls = etype(name, members, module=module, boundary=boundary or KEEP)\n    return cls\n\n_stdlib_enums = IntEnum, StrEnum, IntFlag\n", 2177], "C:\\Programming\\Python313\\Lib\\re\\__init__.py": ["#\n# Secret Labs' Regular Expression Engine\n#\n# re-compatible interface for the sre matching engine\n#\n# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.\n#\n# This version of the SRE library can be redistributed under CNRI's\n# Python 1.6 license.  For any other use, please contact Secret Labs\n# AB (info@pythonware.com).\n#\n# Portions of this engine have been developed in cooperation with\n# CNRI.  Hewlett-Packard provided funding for 1.6 integration and\n# other compatibility work.\n#\n\nr\"\"\"Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) The letters set the corresponding flags defined below.\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode whitespace characters.\n    \\S       Matches any non-whitespace character; equivalent to [^\\s].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match     Match a regular expression pattern to the beginning of a string.\n    fullmatch Match a regular expression pattern to all of a string.\n    search    Search a string for the presence of a pattern.\n    sub       Substitute occurrences of a pattern found in a string.\n    subn      Same as sub, but also return the number of substitutions made.\n    split     Split a string by the occurrences of a pattern.\n    findall   Find all occurrences of a pattern in a string.\n    finditer  Return an iterator yielding a Match object for each match.\n    compile   Compile a pattern into a Pattern object.\n    purge     Clear the regular expression cache.\n    escape    Backslash all non-alphanumerics in a string.\n\nEach function other than purge and escape can take an optional 'flags' argument\nconsisting of one or more of the following module constants, joined by \"|\".\nA, L, and U are mutually exclusive.\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines exception 'PatternError', aliased to 'error' for\nbackward compatibility.\n\n\"\"\"\n\nimport enum\nfrom . import _compiler, _parser\nimport functools\nimport _sre\n\n\n# public symbols\n__all__ = [\n    \"match\", \"fullmatch\", \"search\", \"sub\", \"subn\", \"split\",\n    \"findall\", \"finditer\", \"compile\", \"purge\", \"escape\",\n    \"error\", \"Pattern\", \"Match\", \"A\", \"I\", \"L\", \"M\", \"S\", \"X\", \"U\",\n    \"ASCII\", \"IGNORECASE\", \"LOCALE\", \"MULTILINE\", \"DOTALL\", \"VERBOSE\",\n    \"UNICODE\", \"NOFLAG\", \"RegexFlag\", \"PatternError\"\n]\n\n__version__ = \"2.2.1\"\n\n@enum.global_enum\n@enum._simple_enum(enum.IntFlag, boundary=enum.KEEP)\nclass RegexFlag:\n    NOFLAG = 0\n    ASCII = A = _compiler.SRE_FLAG_ASCII # assume ascii \"locale\"\n    IGNORECASE = I = _compiler.SRE_FLAG_IGNORECASE # ignore case\n    LOCALE = L = _compiler.SRE_FLAG_LOCALE # assume current 8-bit locale\n    UNICODE = U = _compiler.SRE_FLAG_UNICODE # assume unicode \"locale\"\n    MULTILINE = M = _compiler.SRE_FLAG_MULTILINE # make anchors look for newline\n    DOTALL = S = _compiler.SRE_FLAG_DOTALL # make dot match newline\n    VERBOSE = X = _compiler.SRE_FLAG_VERBOSE # ignore whitespace and comments\n    # sre extensions (experimental, don't rely on these)\n    DEBUG = _compiler.SRE_FLAG_DEBUG # dump pattern after compilation\n    __str__ = object.__str__\n    _numeric_repr_ = hex\n\n# sre exception\nPatternError = error = _compiler.PatternError\n\n# --------------------------------------------------------------------\n# public interface\n\ndef match(pattern, string, flags=0):\n    \"\"\"Try to apply the pattern at the start of the string, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).match(string)\n\ndef fullmatch(pattern, string, flags=0):\n    \"\"\"Try to apply the pattern to all of the string, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).fullmatch(string)\n\ndef search(pattern, string, flags=0):\n    \"\"\"Scan through string looking for a match to the pattern, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).search(string)\n\nclass _ZeroSentinel(int):\n    pass\n_zero_sentinel = _ZeroSentinel()\n\ndef sub(pattern, repl, string, *args, count=_zero_sentinel, flags=_zero_sentinel):\n    \"\"\"Return the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in string by the\n    replacement repl.  repl can be either a string or a callable;\n    if a string, backslash escapes in it are processed.  If it is\n    a callable, it's passed the Match object and must return\n    a replacement string to be used.\"\"\"\n    if args:\n        if count is not _zero_sentinel:\n            raise TypeError(\"sub() got multiple values for argument 'count'\")\n        count, *args = args\n        if args:\n            if flags is not _zero_sentinel:\n                raise TypeError(\"sub() got multiple values for argument 'flags'\")\n            flags, *args = args\n            if args:\n                raise TypeError(\"sub() takes from 3 to 5 positional arguments \"\n                                \"but %d were given\" % (5 + len(args)))\n\n        import warnings\n        warnings.warn(\n            \"'count' is passed as positional argument\",\n            DeprecationWarning, stacklevel=2\n        )\n\n    return _compile(pattern, flags).sub(repl, string, count)\nsub.__text_signature__ = '(pattern, repl, string, count=0, flags=0)'\n\ndef subn(pattern, repl, string, *args, count=_zero_sentinel, flags=_zero_sentinel):\n    \"\"\"Return a 2-tuple containing (new_string, number).\n    new_string is the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in the source\n    string by the replacement repl.  number is the number of\n    substitutions that were made. repl can be either a string or a\n    callable; if a string, backslash escapes in it are processed.\n    If it is a callable, it's passed the Match object and must\n    return a replacement string to be used.\"\"\"\n    if args:\n        if count is not _zero_sentinel:\n            raise TypeError(\"subn() got multiple values for argument 'count'\")\n        count, *args = args\n        if args:\n            if flags is not _zero_sentinel:\n                raise TypeError(\"subn() got multiple values for argument 'flags'\")\n            flags, *args = args\n            if args:\n                raise TypeError(\"subn() takes from 3 to 5 positional arguments \"\n                                \"but %d were given\" % (5 + len(args)))\n\n        import warnings\n        warnings.warn(\n            \"'count' is passed as positional argument\",\n            DeprecationWarning, stacklevel=2\n        )\n\n    return _compile(pattern, flags).subn(repl, string, count)\nsubn.__text_signature__ = '(pattern, repl, string, count=0, flags=0)'\n\ndef split(pattern, string, *args, maxsplit=_zero_sentinel, flags=_zero_sentinel):\n    \"\"\"Split the source string by the occurrences of the pattern,\n    returning a list containing the resulting substrings.  If\n    capturing parentheses are used in pattern, then the text of all\n    groups in the pattern are also returned as part of the resulting\n    list.  If maxsplit is nonzero, at most maxsplit splits occur,\n    and the remainder of the string is returned as the final element\n    of the list.\"\"\"\n    if args:\n        if maxsplit is not _zero_sentinel:\n            raise TypeError(\"split() got multiple values for argument 'maxsplit'\")\n        maxsplit, *args = args\n        if args:\n            if flags is not _zero_sentinel:\n                raise TypeError(\"split() got multiple values for argument 'flags'\")\n            flags, *args = args\n            if args:\n                raise TypeError(\"split() takes from 2 to 4 positional arguments \"\n                                \"but %d were given\" % (4 + len(args)))\n\n        import warnings\n        warnings.warn(\n            \"'maxsplit' is passed as positional argument\",\n            DeprecationWarning, stacklevel=2\n        )\n\n    return _compile(pattern, flags).split(string, maxsplit)\nsplit.__text_signature__ = '(pattern, string, maxsplit=0, flags=0)'\n\ndef findall(pattern, string, flags=0):\n    \"\"\"Return a list of all non-overlapping matches in the string.\n\n    If one or more capturing groups are present in the pattern, return\n    a list of groups; this will be a list of tuples if the pattern\n    has more than one group.\n\n    Empty matches are included in the result.\"\"\"\n    return _compile(pattern, flags).findall(string)\n\ndef finditer(pattern, string, flags=0):\n    \"\"\"Return an iterator over all non-overlapping matches in the\n    string.  For each match, the iterator returns a Match object.\n\n    Empty matches are included in the result.\"\"\"\n    return _compile(pattern, flags).finditer(string)\n\ndef compile(pattern, flags=0):\n    \"Compile a regular expression pattern, returning a Pattern object.\"\n    return _compile(pattern, flags)\n\ndef purge():\n    \"Clear the regular expression caches\"\n    _cache.clear()\n    _cache2.clear()\n    _compile_template.cache_clear()\n\n\n# SPECIAL_CHARS\n# closing ')', '}' and ']'\n# '-' (a range in character set)\n# '&', '~', (extended character set operations)\n# '#' (comment) and WHITESPACE (ignored) in verbose mode\n_special_chars_map = {i: '\\\\' + chr(i) for i in b'()[]{}?*+-|^$\\\\.&~# \\t\\n\\r\\v\\f'}\n\ndef escape(pattern):\n    \"\"\"\n    Escape special characters in a string.\n    \"\"\"\n    if isinstance(pattern, str):\n        return pattern.translate(_special_chars_map)\n    else:\n        pattern = str(pattern, 'latin1')\n        return pattern.translate(_special_chars_map).encode('latin1')\n\nPattern = type(_compiler.compile('', 0))\nMatch = type(_compiler.compile('', 0).match(''))\n\n# --------------------------------------------------------------------\n# internals\n\n# Use the fact that dict keeps the insertion order.\n# _cache2 uses the simple FIFO policy which has better latency.\n# _cache uses the LRU policy which has better hit rate.\n_cache = {}  # LRU\n_cache2 = {}  # FIFO\n_MAXCACHE = 512\n_MAXCACHE2 = 256\nassert _MAXCACHE2 < _MAXCACHE\n\ndef _compile(pattern, flags):\n    # internal: compile pattern\n    if isinstance(flags, RegexFlag):\n        flags = flags.value\n    try:\n        return _cache2[type(pattern), pattern, flags]\n    except KeyError:\n        pass\n\n    key = (type(pattern), pattern, flags)\n    # Item in _cache should be moved to the end if found.\n    p = _cache.pop(key, None)\n    if p is None:\n        if isinstance(pattern, Pattern):\n            if flags:\n                raise ValueError(\n                    \"cannot process flags argument with a compiled pattern\")\n            return pattern\n        if not _compiler.isstring(pattern):\n            raise TypeError(\"first argument must be string or compiled pattern\")\n        p = _compiler.compile(pattern, flags)\n        if flags & DEBUG:\n            return p\n        if len(_cache) >= _MAXCACHE:\n            # Drop the least recently used item.\n            # next(iter(_cache)) is known to have linear amortized time,\n            # but it is used here to avoid a dependency from using OrderedDict.\n            # For the small _MAXCACHE value it doesn't make much of a difference.\n            try:\n                del _cache[next(iter(_cache))]\n            except (StopIteration, RuntimeError, KeyError):\n                pass\n    # Append to the end.\n    _cache[key] = p\n\n    if len(_cache2) >= _MAXCACHE2:\n        # Drop the oldest item.\n        try:\n            del _cache2[next(iter(_cache2))]\n        except (StopIteration, RuntimeError, KeyError):\n            pass\n    _cache2[key] = p\n    return p\n\n@functools.lru_cache(_MAXCACHE)\ndef _compile_template(pattern, repl):\n    # internal: compile replacement pattern\n    return _sre.template(pattern, _parser.parse_template(repl, pattern))\n\n# register myself for pickling\n\nimport copyreg\n\ndef _pickle(p):\n    return _compile, (p.pattern, p.flags)\n\ncopyreg.pickle(Pattern, _pickle, _compile)\n\n# --------------------------------------------------------------------\n# experimental stuff (see python-dev discussions for details)\n\nclass Scanner:\n    def __init__(self, lexicon, flags=0):\n        from ._constants import BRANCH, SUBPATTERN\n        if isinstance(flags, RegexFlag):\n            flags = flags.value\n        self.lexicon = lexicon\n        # combine phrases into a compound pattern\n        p = []\n        s = _parser.State()\n        s.flags = flags\n        for phrase, action in lexicon:\n            gid = s.opengroup()\n            p.append(_parser.SubPattern(s, [\n                (SUBPATTERN, (gid, 0, 0, _parser.parse(phrase, flags))),\n                ]))\n            s.closegroup(gid, p[-1])\n        p = _parser.SubPattern(s, [(BRANCH, (None, p))])\n        self.scanner = _compiler.compile(p)\n    def scan(self, string):\n        result = []\n        append = result.append\n        match = self.scanner.scanner(string).match\n        i = 0\n        while True:\n            m = match()\n            if not m:\n                break\n            j = m.end()\n            if i == j:\n                break\n            action = self.lexicon[m.lastindex-1][1]\n            if callable(action):\n                self.match = m\n                action = action(self, m.group())\n            if action is not None:\n                append(action)\n            i = j\n        return result, string[i:]\n", 428], "C:\\Programming\\Python313\\Lib\\functools.py": ["\"\"\"functools.py - Tools for working with functions and callable objects\n\"\"\"\n# Python module wrapper for _functools C module\n# to allow utilities written in Python to be added\n# to the functools module.\n# Written by Nick Coghlan <ncoghlan at gmail.com>,\n# Raymond Hettinger <python at rcn.com>,\n# and \u0141ukasz Langa <lukasz at langa.pl>.\n#   Copyright (C) 2006-2013 Python Software Foundation.\n# See C source code for _functools credits/copyright\n\n__all__ = ['update_wrapper', 'wraps', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES',\n           'total_ordering', 'cache', 'cmp_to_key', 'lru_cache', 'reduce',\n           'partial', 'partialmethod', 'singledispatch', 'singledispatchmethod',\n           'cached_property']\n\nfrom abc import get_cache_token\nfrom collections import namedtuple\n# import types, weakref  # Deferred to single_dispatch()\nfrom reprlib import recursive_repr\nfrom _thread import RLock\n\n# Avoid importing types, so we can speedup import time\nGenericAlias = type(list[int])\n\n################################################################################\n### update_wrapper() and wraps() decorator\n################################################################################\n\n# update_wrapper() and wraps() are tools to help write\n# wrapper functions that can handle naive introspection\n\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n                       '__annotations__', '__type_params__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)\n       updated is a tuple naming the attributes of the wrapper that\n       are updated with the corresponding attribute from the wrapped\n       function (defaults to functools.WRAPPER_UPDATES)\n    \"\"\"\n    for attr in assigned:\n        try:\n            value = getattr(wrapped, attr)\n        except AttributeError:\n            pass\n        else:\n            setattr(wrapper, attr, value)\n    for attr in updated:\n        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n    # Issue #17482: set __wrapped__ last so we don't inadvertently copy it\n    # from the wrapped function when updating __dict__\n    wrapper.__wrapped__ = wrapped\n    # Return the wrapper so this can be used as a decorator via partial()\n    return wrapper\n\ndef wraps(wrapped,\n          assigned = WRAPPER_ASSIGNMENTS,\n          updated = WRAPPER_UPDATES):\n    \"\"\"Decorator factory to apply update_wrapper() to a wrapper function\n\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    \"\"\"\n    return partial(update_wrapper, wrapped=wrapped,\n                   assigned=assigned, updated=updated)\n\n\n################################################################################\n### total_ordering class decorator\n################################################################################\n\n# The total ordering functions all invoke the root magic method directly\n# rather than using the corresponding operator.  This avoids possible\n# infinite recursion that could occur when the operator dispatch logic\n# detects a NotImplemented result and then calls a reflected method.\n\ndef _gt_from_lt(self, other):\n    'Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).'\n    op_result = type(self).__lt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result and self != other\n\ndef _le_from_lt(self, other):\n    'Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).'\n    op_result = type(self).__lt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result or self == other\n\ndef _ge_from_lt(self, other):\n    'Return a >= b.  Computed by @total_ordering from (not a < b).'\n    op_result = type(self).__lt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\ndef _ge_from_le(self, other):\n    'Return a >= b.  Computed by @total_ordering from (not a <= b) or (a == b).'\n    op_result = type(self).__le__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result or self == other\n\ndef _lt_from_le(self, other):\n    'Return a < b.  Computed by @total_ordering from (a <= b) and (a != b).'\n    op_result = type(self).__le__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result and self != other\n\ndef _gt_from_le(self, other):\n    'Return a > b.  Computed by @total_ordering from (not a <= b).'\n    op_result = type(self).__le__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\ndef _lt_from_gt(self, other):\n    'Return a < b.  Computed by @total_ordering from (not a > b) and (a != b).'\n    op_result = type(self).__gt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result and self != other\n\ndef _ge_from_gt(self, other):\n    'Return a >= b.  Computed by @total_ordering from (a > b) or (a == b).'\n    op_result = type(self).__gt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result or self == other\n\ndef _le_from_gt(self, other):\n    'Return a <= b.  Computed by @total_ordering from (not a > b).'\n    op_result = type(self).__gt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\ndef _le_from_ge(self, other):\n    'Return a <= b.  Computed by @total_ordering from (not a >= b) or (a == b).'\n    op_result = type(self).__ge__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result or self == other\n\ndef _gt_from_ge(self, other):\n    'Return a > b.  Computed by @total_ordering from (a >= b) and (a != b).'\n    op_result = type(self).__ge__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result and self != other\n\ndef _lt_from_ge(self, other):\n    'Return a < b.  Computed by @total_ordering from (not a >= b).'\n    op_result = type(self).__ge__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\n_convert = {\n    '__lt__': [('__gt__', _gt_from_lt),\n               ('__le__', _le_from_lt),\n               ('__ge__', _ge_from_lt)],\n    '__le__': [('__ge__', _ge_from_le),\n               ('__lt__', _lt_from_le),\n               ('__gt__', _gt_from_le)],\n    '__gt__': [('__lt__', _lt_from_gt),\n               ('__ge__', _ge_from_gt),\n               ('__le__', _le_from_gt)],\n    '__ge__': [('__le__', _le_from_ge),\n               ('__gt__', _gt_from_ge),\n               ('__lt__', _lt_from_ge)]\n}\n\ndef total_ordering(cls):\n    \"\"\"Class decorator that fills in missing ordering methods\"\"\"\n    # Find user-defined comparisons (not those inherited from object).\n    roots = {op for op in _convert if getattr(cls, op, None) is not getattr(object, op, None)}\n    if not roots:\n        raise ValueError('must define at least one ordering operation: < > <= >=')\n    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__\n    for opname, opfunc in _convert[root]:\n        if opname not in roots:\n            opfunc.__name__ = opname\n            setattr(cls, opname, opfunc)\n    return cls\n\n\n################################################################################\n### cmp_to_key() function converter\n################################################################################\n\ndef cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n    class K(object):\n        __slots__ = ['obj']\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n        __hash__ = None\n    return K\n\ntry:\n    from _functools import cmp_to_key\nexcept ImportError:\n    pass\n\n\n################################################################################\n### reduce() sequence to a single item\n################################################################################\n\n_initial_missing = object()\n\ndef reduce(function, sequence, initial=_initial_missing):\n    \"\"\"\n    reduce(function, iterable[, initial], /) -> value\n\n    Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    This effectively reduces the iterable to a single value.  If initial is present,\n    it is placed before the items of the iterable in the calculation, and serves as\n    a default when the iterable is empty.\n\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])\n    calculates ((((1 + 2) + 3) + 4) + 5).\n    \"\"\"\n\n    it = iter(sequence)\n\n    if initial is _initial_missing:\n        try:\n            value = next(it)\n        except StopIteration:\n            raise TypeError(\n                \"reduce() of empty iterable with no initial value\") from None\n    else:\n        value = initial\n\n    for element in it:\n        value = function(value, element)\n\n    return value\n\ntry:\n    from _functools import reduce\nexcept ImportError:\n    pass\n\n\n################################################################################\n### partial() argument application\n################################################################################\n\n# Purely functional, no descriptor behaviour\nclass partial:\n    \"\"\"New function with partial application of the given arguments\n    and keywords.\n    \"\"\"\n\n    __slots__ = \"func\", \"args\", \"keywords\", \"__dict__\", \"__weakref__\"\n\n    def __new__(cls, func, /, *args, **keywords):\n        if not callable(func):\n            raise TypeError(\"the first argument must be callable\")\n\n        if isinstance(func, partial):\n            args = func.args + args\n            keywords = {**func.keywords, **keywords}\n            func = func.func\n\n        self = super(partial, cls).__new__(cls)\n\n        self.func = func\n        self.args = args\n        self.keywords = keywords\n        return self\n\n    def __call__(self, /, *args, **keywords):\n        keywords = {**self.keywords, **keywords}\n        return self.func(*self.args, *args, **keywords)\n\n    @recursive_repr()\n    def __repr__(self):\n        cls = type(self)\n        qualname = cls.__qualname__\n        module = cls.__module__\n        args = [repr(self.func)]\n        args.extend(repr(x) for x in self.args)\n        args.extend(f\"{k}={v!r}\" for (k, v) in self.keywords.items())\n        return f\"{module}.{qualname}({', '.join(args)})\"\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        import warnings\n        warnings.warn('functools.partial will be a method descriptor in '\n                      'future Python versions; wrap it in staticmethod() '\n                      'if you want to preserve the old behavior',\n                      FutureWarning, 2)\n        return self\n\n    def __reduce__(self):\n        return type(self), (self.func,), (self.func, self.args,\n               self.keywords or None, self.__dict__ or None)\n\n    def __setstate__(self, state):\n        if not isinstance(state, tuple):\n            raise TypeError(\"argument to __setstate__ must be a tuple\")\n        if len(state) != 4:\n            raise TypeError(f\"expected 4 items in state, got {len(state)}\")\n        func, args, kwds, namespace = state\n        if (not callable(func) or not isinstance(args, tuple) or\n           (kwds is not None and not isinstance(kwds, dict)) or\n           (namespace is not None and not isinstance(namespace, dict))):\n            raise TypeError(\"invalid partial state\")\n\n        args = tuple(args) # just in case it's a subclass\n        if kwds is None:\n            kwds = {}\n        elif type(kwds) is not dict: # XXX does it need to be *exactly* dict?\n            kwds = dict(kwds)\n        if namespace is None:\n            namespace = {}\n\n        self.__dict__ = namespace\n        self.func = func\n        self.args = args\n        self.keywords = kwds\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\ntry:\n    from _functools import partial\nexcept ImportError:\n    pass\n\n# Descriptor version\nclass partialmethod(object):\n    \"\"\"Method descriptor with partial application of the given arguments\n    and keywords.\n\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    \"\"\"\n\n    def __init__(self, func, /, *args, **keywords):\n        if not callable(func) and not hasattr(func, \"__get__\"):\n            raise TypeError(\"{!r} is not callable or a descriptor\"\n                                 .format(func))\n\n        # func could be a descriptor like classmethod which isn't callable,\n        # so we can't inherit from partial (it verifies func is callable)\n        if isinstance(func, partialmethod):\n            # flattening is mandatory in order to place cls/self before all\n            # other arguments\n            # it's also more efficient since only one function will be called\n            self.func = func.func\n            self.args = func.args + args\n            self.keywords = {**func.keywords, **keywords}\n        else:\n            self.func = func\n            self.args = args\n            self.keywords = keywords\n\n    def __repr__(self):\n        cls = type(self)\n        module = cls.__module__\n        qualname = cls.__qualname__\n        args = [repr(self.func)]\n        args.extend(map(repr, self.args))\n        args.extend(f\"{k}={v!r}\" for k, v in self.keywords.items())\n        return f\"{module}.{qualname}({', '.join(args)})\"\n\n    def _make_unbound_method(self):\n        def _method(cls_or_self, /, *args, **keywords):\n            keywords = {**self.keywords, **keywords}\n            return self.func(cls_or_self, *self.args, *args, **keywords)\n        _method.__isabstractmethod__ = self.__isabstractmethod__\n        _method.__partialmethod__ = self\n        return _method\n\n    def __get__(self, obj, cls=None):\n        get = getattr(self.func, \"__get__\", None)\n        result = None\n        if get is not None and not isinstance(self.func, partial):\n            new_func = get(obj, cls)\n            if new_func is not self.func:\n                # Assume __get__ returning something new indicates the\n                # creation of an appropriate callable\n                result = partial(new_func, *self.args, **self.keywords)\n                try:\n                    result.__self__ = new_func.__self__\n                except AttributeError:\n                    pass\n        if result is None:\n            # If the underlying descriptor didn't do anything, treat this\n            # like an instance method\n            result = self._make_unbound_method().__get__(obj, cls)\n        return result\n\n    @property\n    def __isabstractmethod__(self):\n        return getattr(self.func, \"__isabstractmethod__\", False)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\n# Helper functions\n\ndef _unwrap_partial(func):\n    while isinstance(func, partial):\n        func = func.func\n    return func\n\ndef _unwrap_partialmethod(func):\n    prev = None\n    while func is not prev:\n        prev = func\n        while isinstance(getattr(func, \"__partialmethod__\", None), partialmethod):\n            func = func.__partialmethod__\n        while isinstance(func, partialmethod):\n            func = getattr(func, 'func')\n        func = _unwrap_partial(func)\n    return func\n\n################################################################################\n### LRU Cache function decorator\n################################################################################\n\n_CacheInfo = namedtuple(\"CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"])\n\nclass _HashedSeq(list):\n    \"\"\" This class guarantees that hash() will be called no more than once\n        per element.  This is important because the lru_cache() will hash\n        the key multiple times on a cache miss.\n\n    \"\"\"\n\n    __slots__ = 'hashvalue'\n\n    def __init__(self, tup, hash=hash):\n        self[:] = tup\n        self.hashvalue = hash(tup)\n\n    def __hash__(self):\n        return self.hashvalue\n\ndef _make_key(args, kwds, typed,\n             kwd_mark = (object(),),\n             fasttypes = {int, str},\n             tuple=tuple, type=type, len=len):\n    \"\"\"Make a cache key from optionally typed positional and keyword arguments\n\n    The key is constructed in a way that is flat as possible rather than\n    as a nested structure that would take more memory.\n\n    If there is only a single argument and its data type is known to cache\n    its hash value, then that argument is returned without a wrapper.  This\n    saves space and improves lookup speed.\n\n    \"\"\"\n    # All of code below relies on kwds preserving the order input by the user.\n    # Formerly, we sorted() the kwds before looping.  The new way is *much*\n    # faster; however, it means that f(x=1, y=2) will now be treated as a\n    # distinct call from f(y=2, x=1) which will be cached separately.\n    key = args\n    if kwds:\n        key += kwd_mark\n        for item in kwds.items():\n            key += item\n    if typed:\n        key += tuple(type(v) for v in args)\n        if kwds:\n            key += tuple(type(v) for v in kwds.values())\n    elif len(key) == 1 and type(key[0]) in fasttypes:\n        return key[0]\n    return _HashedSeq(key)\n\ndef lru_cache(maxsize=128, typed=False):\n    \"\"\"Least-recently-used cache decorator.\n\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(decimal.Decimal(\"3.0\")) and f(3.0) will be treated as\n    distinct calls with distinct results. Some types such as str and int may\n    be cached separately even when typed is false.\n\n    Arguments to the cached function must be hashable.\n\n    View the cache statistics named tuple (hits, misses, maxsize, currsize)\n    with f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n\n    See:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n\n    \"\"\"\n\n    # Users should only access the lru_cache through its public API:\n    #       cache_info, cache_clear, and f.__wrapped__\n    # The internals of the lru_cache are encapsulated for thread safety and\n    # to allow the implementation to change (including a possible C version).\n\n    if isinstance(maxsize, int):\n        # Negative maxsize is treated as 0\n        if maxsize < 0:\n            maxsize = 0\n    elif callable(maxsize) and isinstance(typed, bool):\n        # The user_function was passed in directly via the maxsize argument\n        user_function, maxsize = maxsize, 128\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n    elif maxsize is not None:\n        raise TypeError(\n            'Expected first argument to be an integer, a callable, or None')\n\n    def decorating_function(user_function):\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n\n    return decorating_function\n\ndef _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):\n    # Constants shared by all lru cache instances:\n    sentinel = object()          # unique object used to signal cache misses\n    make_key = _make_key         # build a key from the function arguments\n    PREV, NEXT, KEY, RESULT = 0, 1, 2, 3   # names for the link fields\n\n    cache = {}\n    hits = misses = 0\n    full = False\n    cache_get = cache.get    # bound method to lookup a key or return None\n    cache_len = cache.__len__  # get cache size without calling len()\n    lock = RLock()           # because linkedlist updates aren't threadsafe\n    root = []                # root of the circular doubly linked list\n    root[:] = [root, root, None, None]     # initialize by pointing to self\n\n    if maxsize == 0:\n\n        def wrapper(*args, **kwds):\n            # No caching -- just a statistics update\n            nonlocal misses\n            misses += 1\n            result = user_function(*args, **kwds)\n            return result\n\n    elif maxsize is None:\n\n        def wrapper(*args, **kwds):\n            # Simple caching without ordering or size limit\n            nonlocal hits, misses\n            key = make_key(args, kwds, typed)\n            result = cache_get(key, sentinel)\n            if result is not sentinel:\n                hits += 1\n                return result\n            misses += 1\n            result = user_function(*args, **kwds)\n            cache[key] = result\n            return result\n\n    else:\n\n        def wrapper(*args, **kwds):\n            # Size limited caching that tracks accesses by recency\n            nonlocal root, hits, misses, full\n            key = make_key(args, kwds, typed)\n            with lock:\n                link = cache_get(key)\n                if link is not None:\n                    # Move the link to the front of the circular queue\n                    link_prev, link_next, _key, result = link\n                    link_prev[NEXT] = link_next\n                    link_next[PREV] = link_prev\n                    last = root[PREV]\n                    last[NEXT] = root[PREV] = link\n                    link[PREV] = last\n                    link[NEXT] = root\n                    hits += 1\n                    return result\n                misses += 1\n            result = user_function(*args, **kwds)\n            with lock:\n                if key in cache:\n                    # Getting here means that this same key was added to the\n                    # cache while the lock was released.  Since the link\n                    # update is already done, we need only return the\n                    # computed result and update the count of misses.\n                    pass\n                elif full:\n                    # Use the old root to store the new key and result.\n                    oldroot = root\n                    oldroot[KEY] = key\n                    oldroot[RESULT] = result\n                    # Empty the oldest link and make it the new root.\n                    # Keep a reference to the old key and old result to\n                    # prevent their ref counts from going to zero during the\n                    # update. That will prevent potentially arbitrary object\n                    # clean-up code (i.e. __del__) from running while we're\n                    # still adjusting the links.\n                    root = oldroot[NEXT]\n                    oldkey = root[KEY]\n                    oldresult = root[RESULT]\n                    root[KEY] = root[RESULT] = None\n                    # Now update the cache dictionary.\n                    del cache[oldkey]\n                    # Save the potentially reentrant cache[key] assignment\n                    # for last, after the root and links have been put in\n                    # a consistent state.\n                    cache[key] = oldroot\n                else:\n                    # Put result in a new link at the front of the queue.\n                    last = root[PREV]\n                    link = [last, root, key, result]\n                    last[NEXT] = root[PREV] = cache[key] = link\n                    # Use the cache_len bound method instead of the len() function\n                    # which could potentially be wrapped in an lru_cache itself.\n                    full = (cache_len() >= maxsize)\n            return result\n\n    def cache_info():\n        \"\"\"Report cache statistics\"\"\"\n        with lock:\n            return _CacheInfo(hits, misses, maxsize, cache_len())\n\n    def cache_clear():\n        \"\"\"Clear the cache and cache statistics\"\"\"\n        nonlocal hits, misses, full\n        with lock:\n            cache.clear()\n            root[:] = [root, root, None, None]\n            hits = misses = 0\n            full = False\n\n    wrapper.cache_info = cache_info\n    wrapper.cache_clear = cache_clear\n    return wrapper\n\ntry:\n    from _functools import _lru_cache_wrapper\nexcept ImportError:\n    pass\n\n\n################################################################################\n### cache -- simplified access to the infinity cache\n################################################################################\n\ndef cache(user_function, /):\n    'Simple lightweight unbounded cache.  Sometimes called \"memoize\".'\n    return lru_cache(maxsize=None)(user_function)\n\n\n################################################################################\n### singledispatch() - single-dispatch generic function decorator\n################################################################################\n\ndef _c3_merge(sequences):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n\n    Adapted from https://docs.python.org/3/howto/mro.html.\n\n    \"\"\"\n    result = []\n    while True:\n        sequences = [s for s in sequences if s]   # purge empty sequences\n        if not sequences:\n            return result\n        for s1 in sequences:   # find merge candidates among seq heads\n            candidate = s1[0]\n            for s2 in sequences:\n                if candidate in s2[1:]:\n                    candidate = None\n                    break      # reject the current head, it appears later\n            else:\n                break\n        if candidate is None:\n            raise RuntimeError(\"Inconsistent hierarchy\")\n        result.append(candidate)\n        # remove the chosen candidate\n        for seq in sequences:\n            if seq[0] == candidate:\n                del seq[0]\n\ndef _c3_mro(cls, abcs=None):\n    \"\"\"Computes the method resolution order using extended C3 linearization.\n\n    If no *abcs* are given, the algorithm works exactly like the built-in C3\n    linearization used for method resolution.\n\n    If given, *abcs* is a list of abstract base classes that should be inserted\n    into the resulting MRO. Unrelated ABCs are ignored and don't end up in the\n    result. The algorithm inserts ABCs where their functionality is introduced,\n    i.e. issubclass(cls, abc) returns True for the class itself but returns\n    False for all its direct base classes. Implicit ABCs for a given class\n    (either registered or inferred from the presence of a special method like\n    __len__) are inserted directly after the last ABC explicitly listed in the\n    MRO of said class. If two implicit ABCs end up next to each other in the\n    resulting MRO, their ordering depends on the order of types in *abcs*.\n\n    \"\"\"\n    for i, base in enumerate(reversed(cls.__bases__)):\n        if hasattr(base, '__abstractmethods__'):\n            boundary = len(cls.__bases__) - i\n            break   # Bases up to the last explicit ABC are considered first.\n    else:\n        boundary = 0\n    abcs = list(abcs) if abcs else []\n    explicit_bases = list(cls.__bases__[:boundary])\n    abstract_bases = []\n    other_bases = list(cls.__bases__[boundary:])\n    for base in abcs:\n        if issubclass(cls, base) and not any(\n                issubclass(b, base) for b in cls.__bases__\n            ):\n            # If *cls* is the class that introduces behaviour described by\n            # an ABC *base*, insert said ABC to its MRO.\n            abstract_bases.append(base)\n    for base in abstract_bases:\n        abcs.remove(base)\n    explicit_c3_mros = [_c3_mro(base, abcs=abcs) for base in explicit_bases]\n    abstract_c3_mros = [_c3_mro(base, abcs=abcs) for base in abstract_bases]\n    other_c3_mros = [_c3_mro(base, abcs=abcs) for base in other_bases]\n    return _c3_merge(\n        [[cls]] +\n        explicit_c3_mros + abstract_c3_mros + other_c3_mros +\n        [explicit_bases] + [abstract_bases] + [other_bases]\n    )\n\ndef _compose_mro(cls, types):\n    \"\"\"Calculates the method resolution order for a given class *cls*.\n\n    Includes relevant abstract base classes (with their respective bases) from\n    the *types* iterable. Uses a modified C3 linearization algorithm.\n\n    \"\"\"\n    bases = set(cls.__mro__)\n    # Remove entries which are already present in the __mro__ or unrelated.\n    def is_related(typ):\n        return (typ not in bases and hasattr(typ, '__mro__')\n                                 and not isinstance(typ, GenericAlias)\n                                 and issubclass(cls, typ))\n    types = [n for n in types if is_related(n)]\n    # Remove entries which are strict bases of other entries (they will end up\n    # in the MRO anyway.\n    def is_strict_base(typ):\n        for other in types:\n            if typ != other and typ in other.__mro__:\n                return True\n        return False\n    types = [n for n in types if not is_strict_base(n)]\n    # Subclasses of the ABCs in *types* which are also implemented by\n    # *cls* can be used to stabilize ABC ordering.\n    type_set = set(types)\n    mro = []\n    for typ in types:\n        found = []\n        for sub in typ.__subclasses__():\n            if sub not in bases and issubclass(cls, sub):\n                found.append([s for s in sub.__mro__ if s in type_set])\n        if not found:\n            mro.append(typ)\n            continue\n        # Favor subclasses with the biggest number of useful bases\n        found.sort(key=len, reverse=True)\n        for sub in found:\n            for subcls in sub:\n                if subcls not in mro:\n                    mro.append(subcls)\n    return _c3_mro(cls, abcs=mro)\n\ndef _find_impl(cls, registry):\n    \"\"\"Returns the best matching implementation from *registry* for type *cls*.\n\n    Where there is no registered implementation for a specific type, its method\n    resolution order is used to find a more generic implementation.\n\n    Note: if *registry* does not contain an implementation for the base\n    *object* type, this function may return None.\n\n    \"\"\"\n    mro = _compose_mro(cls, registry.keys())\n    match = None\n    for t in mro:\n        if match is not None:\n            # If *match* is an implicit ABC but there is another unrelated,\n            # equally matching implicit ABC, refuse the temptation to guess.\n            if (t in registry and t not in cls.__mro__\n                              and match not in cls.__mro__\n                              and not issubclass(match, t)):\n                raise RuntimeError(\"Ambiguous dispatch: {} or {}\".format(\n                    match, t))\n            break\n        if t in registry:\n            match = t\n    return registry.get(match)\n\ndef singledispatch(func):\n    \"\"\"Single-dispatch generic function decorator.\n\n    Transforms a function into a generic function, which can have different\n    behaviours depending upon the type of its first argument. The decorated\n    function acts as the default implementation, and additional\n    implementations can be registered using the register() attribute of the\n    generic function.\n    \"\"\"\n    # There are many programs that use functools without singledispatch, so we\n    # trade-off making singledispatch marginally slower for the benefit of\n    # making start-up of such applications slightly faster.\n    import types, weakref\n\n    registry = {}\n    dispatch_cache = weakref.WeakKeyDictionary()\n    cache_token = None\n\n    def dispatch(cls):\n        \"\"\"generic_func.dispatch(cls) -> <function implementation>\n\n        Runs the dispatch algorithm to return the best available implementation\n        for the given *cls* registered on *generic_func*.\n\n        \"\"\"\n        nonlocal cache_token\n        if cache_token is not None:\n            current_token = get_cache_token()\n            if cache_token != current_token:\n                dispatch_cache.clear()\n                cache_token = current_token\n        try:\n            impl = dispatch_cache[cls]\n        except KeyError:\n            try:\n                impl = registry[cls]\n            except KeyError:\n                impl = _find_impl(cls, registry)\n            dispatch_cache[cls] = impl\n        return impl\n\n    def _is_union_type(cls):\n        from typing import get_origin, Union\n        return get_origin(cls) in {Union, types.UnionType}\n\n    def _is_valid_dispatch_type(cls):\n        if isinstance(cls, type):\n            return True\n        from typing import get_args\n        return (_is_union_type(cls) and\n                all(isinstance(arg, type) for arg in get_args(cls)))\n\n    def register(cls, func=None):\n        \"\"\"generic_func.register(cls, func) -> func\n\n        Registers a new implementation for the given *cls* on a *generic_func*.\n\n        \"\"\"\n        nonlocal cache_token\n        if _is_valid_dispatch_type(cls):\n            if func is None:\n                return lambda f: register(cls, f)\n        else:\n            if func is not None:\n                raise TypeError(\n                    f\"Invalid first argument to `register()`. \"\n                    f\"{cls!r} is not a class or union type.\"\n                )\n            ann = getattr(cls, '__annotations__', {})\n            if not ann:\n                raise TypeError(\n                    f\"Invalid first argument to `register()`: {cls!r}. \"\n                    f\"Use either `@register(some_class)` or plain `@register` \"\n                    f\"on an annotated function.\"\n                )\n            func = cls\n\n            # only import typing if annotation parsing is necessary\n            from typing import get_type_hints\n            argname, cls = next(iter(get_type_hints(func).items()))\n            if not _is_valid_dispatch_type(cls):\n                if _is_union_type(cls):\n                    raise TypeError(\n                        f\"Invalid annotation for {argname!r}. \"\n                        f\"{cls!r} not all arguments are classes.\"\n                    )\n                else:\n                    raise TypeError(\n                        f\"Invalid annotation for {argname!r}. \"\n                        f\"{cls!r} is not a class.\"\n                    )\n\n        if _is_union_type(cls):\n            from typing import get_args\n\n            for arg in get_args(cls):\n                registry[arg] = func\n        else:\n            registry[cls] = func\n        if cache_token is None and hasattr(cls, '__abstractmethods__'):\n            cache_token = get_cache_token()\n        dispatch_cache.clear()\n        return func\n\n    def wrapper(*args, **kw):\n        if not args:\n            raise TypeError(f'{funcname} requires at least '\n                            '1 positional argument')\n        return dispatch(args[0].__class__)(*args, **kw)\n\n    funcname = getattr(func, '__name__', 'singledispatch function')\n    registry[object] = func\n    wrapper.register = register\n    wrapper.dispatch = dispatch\n    wrapper.registry = types.MappingProxyType(registry)\n    wrapper._clear_cache = dispatch_cache.clear\n    update_wrapper(wrapper, func)\n    return wrapper\n\n\n# Descriptor version\nclass singledispatchmethod:\n    \"\"\"Single-dispatch generic method descriptor.\n\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    \"\"\"\n\n    def __init__(self, func):\n        if not callable(func) and not hasattr(func, \"__get__\"):\n            raise TypeError(f\"{func!r} is not callable or a descriptor\")\n\n        self.dispatcher = singledispatch(func)\n        self.func = func\n\n        import weakref # see comment in singledispatch function\n        self._method_cache = weakref.WeakKeyDictionary()\n\n    def register(self, cls, method=None):\n        \"\"\"generic_method.register(cls, func) -> func\n\n        Registers a new implementation for the given *cls* on a *generic_method*.\n        \"\"\"\n        return self.dispatcher.register(cls, func=method)\n\n    def __get__(self, obj, cls=None):\n        if self._method_cache is not None:\n            try:\n                _method = self._method_cache[obj]\n            except TypeError:\n                self._method_cache = None\n            except KeyError:\n                pass\n            else:\n                return _method\n\n        dispatch = self.dispatcher.dispatch\n        funcname = getattr(self.func, '__name__', 'singledispatchmethod method')\n        def _method(*args, **kwargs):\n            if not args:\n                raise TypeError(f'{funcname} requires at least '\n                                '1 positional argument')\n            return dispatch(args[0].__class__).__get__(obj, cls)(*args, **kwargs)\n\n        _method.__isabstractmethod__ = self.__isabstractmethod__\n        _method.register = self.register\n        update_wrapper(_method, self.func)\n\n        if self._method_cache is not None:\n            self._method_cache[obj] = _method\n\n        return _method\n\n    @property\n    def __isabstractmethod__(self):\n        return getattr(self.func, '__isabstractmethod__', False)\n\n\n################################################################################\n### cached_property() - property result cached as instance attribute\n################################################################################\n\n_NOT_FOUND = object()\n\nclass cached_property:\n    def __init__(self, func):\n        self.func = func\n        self.attrname = None\n        self.__doc__ = func.__doc__\n        self.__module__ = func.__module__\n\n    def __set_name__(self, owner, name):\n        if self.attrname is None:\n            self.attrname = name\n        elif name != self.attrname:\n            raise TypeError(\n                \"Cannot assign the same cached_property to two different names \"\n                f\"({self.attrname!r} and {name!r}).\"\n            )\n\n    def __get__(self, instance, owner=None):\n        if instance is None:\n            return self\n        if self.attrname is None:\n            raise TypeError(\n                \"Cannot use cached_property instance without calling __set_name__ on it.\")\n        try:\n            cache = instance.__dict__\n        except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)\n            msg = (\n                f\"No '__dict__' attribute on {type(instance).__name__!r} \"\n                f\"instance to cache {self.attrname!r} property.\"\n            )\n            raise TypeError(msg) from None\n        val = cache.get(self.attrname, _NOT_FOUND)\n        if val is _NOT_FOUND:\n            val = self.func(instance)\n            try:\n                cache[self.attrname] = val\n            except TypeError:\n                msg = (\n                    f\"The '__dict__' attribute on {type(instance).__name__!r} instance \"\n                    f\"does not support item assignment for caching {self.attrname!r} property.\"\n                )\n                raise TypeError(msg) from None\n        return val\n\n    __class_getitem__ = classmethod(GenericAlias)\n", 1053], "C:\\Programming\\Python313\\Lib\\contextlib.py": ["\"\"\"Utilities for with-statement contexts.  See PEP 343.\"\"\"\nimport abc\nimport os\nimport sys\nimport _collections_abc\nfrom collections import deque\nfrom functools import wraps\nfrom types import MethodType, GenericAlias\n\n__all__ = [\"asynccontextmanager\", \"contextmanager\", \"closing\", \"nullcontext\",\n           \"AbstractContextManager\", \"AbstractAsyncContextManager\",\n           \"AsyncExitStack\", \"ContextDecorator\", \"ExitStack\",\n           \"redirect_stdout\", \"redirect_stderr\", \"suppress\", \"aclosing\",\n           \"chdir\"]\n\n\nclass AbstractContextManager(abc.ABC):\n\n    \"\"\"An abstract base class for context managers.\"\"\"\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n    __slots__ = ()\n\n    def __enter__(self):\n        \"\"\"Return `self` upon entering the runtime context.\"\"\"\n        return self\n\n    @abc.abstractmethod\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Raise any exception triggered within the runtime context.\"\"\"\n        return None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AbstractContextManager:\n            return _collections_abc._check_methods(C, \"__enter__\", \"__exit__\")\n        return NotImplemented\n\n\nclass AbstractAsyncContextManager(abc.ABC):\n\n    \"\"\"An abstract base class for asynchronous context managers.\"\"\"\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n    __slots__ = ()\n\n    async def __aenter__(self):\n        \"\"\"Return `self` upon entering the runtime context.\"\"\"\n        return self\n\n    @abc.abstractmethod\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        \"\"\"Raise any exception triggered within the runtime context.\"\"\"\n        return None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AbstractAsyncContextManager:\n            return _collections_abc._check_methods(C, \"__aenter__\",\n                                                   \"__aexit__\")\n        return NotImplemented\n\n\nclass ContextDecorator(object):\n    \"A base class or mixin that enables context managers to work as decorators.\"\n\n    def _recreate_cm(self):\n        \"\"\"Return a recreated instance of self.\n\n        Allows an otherwise one-shot context manager like\n        _GeneratorContextManager to support use as\n        a decorator via implicit recreation.\n\n        This is a private interface just for _GeneratorContextManager.\n        See issue #11647 for details.\n        \"\"\"\n        return self\n\n    def __call__(self, func):\n        @wraps(func)\n        def inner(*args, **kwds):\n            with self._recreate_cm():\n                return func(*args, **kwds)\n        return inner\n\n\nclass AsyncContextDecorator(object):\n    \"A base class or mixin that enables async context managers to work as decorators.\"\n\n    def _recreate_cm(self):\n        \"\"\"Return a recreated instance of self.\n        \"\"\"\n        return self\n\n    def __call__(self, func):\n        @wraps(func)\n        async def inner(*args, **kwds):\n            async with self._recreate_cm():\n                return await func(*args, **kwds)\n        return inner\n\n\nclass _GeneratorContextManagerBase:\n    \"\"\"Shared functionality for @contextmanager and @asynccontextmanager.\"\"\"\n\n    def __init__(self, func, args, kwds):\n        self.gen = func(*args, **kwds)\n        self.func, self.args, self.kwds = func, args, kwds\n        # Issue 19330: ensure context manager instances have good docstrings\n        doc = getattr(func, \"__doc__\", None)\n        if doc is None:\n            doc = type(self).__doc__\n        self.__doc__ = doc\n        # Unfortunately, this still doesn't provide good help output when\n        # inspecting the created context manager instances, since pydoc\n        # currently bypasses the instance docstring and shows the docstring\n        # for the class instead.\n        # See http://bugs.python.org/issue19404 for more details.\n\n    def _recreate_cm(self):\n        # _GCMB instances are one-shot context managers, so the\n        # CM must be recreated each time a decorated function is\n        # called\n        return self.__class__(self.func, self.args, self.kwds)\n\n\nclass _GeneratorContextManager(\n    _GeneratorContextManagerBase,\n    AbstractContextManager,\n    ContextDecorator,\n):\n    \"\"\"Helper for @contextmanager decorator.\"\"\"\n\n    def __enter__(self):\n        # do not keep args and kwds alive unnecessarily\n        # they are only needed for recreation, which is not possible anymore\n        del self.args, self.kwds, self.func\n        try:\n            return next(self.gen)\n        except StopIteration:\n            raise RuntimeError(\"generator didn't yield\") from None\n\n    def __exit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                try:\n                    raise RuntimeError(\"generator didn't stop\")\n                finally:\n                    self.gen.close()\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n                self.gen.throw(value)\n            except StopIteration as exc:\n                # Suppress StopIteration *unless* it's the same exception that\n                # was passed to throw().  This prevents a StopIteration\n                # raised inside the \"with\" statement from being suppressed.\n                return exc is not value\n            except RuntimeError as exc:\n                # Don't re-raise the passed in exception. (issue27122)\n                if exc is value:\n                    exc.__traceback__ = traceback\n                    return False\n                # Avoid suppressing if a StopIteration exception\n                # was passed to throw() and later wrapped into a RuntimeError\n                # (see PEP 479 for sync generators; async generators also\n                # have this behavior). But do this only if the exception wrapped\n                # by the RuntimeError is actually Stop(Async)Iteration (see\n                # issue29692).\n                if (\n                    isinstance(value, StopIteration)\n                    and exc.__cause__ is value\n                ):\n                    value.__traceback__ = traceback\n                    return False\n                raise\n            except BaseException as exc:\n                # only re-raise if it's *not* the exception that was\n                # passed to throw(), because __exit__() must not raise\n                # an exception unless __exit__() itself failed.  But throw()\n                # has to raise the exception to signal propagation, so this\n                # fixes the impedance mismatch between the throw() protocol\n                # and the __exit__() protocol.\n                if exc is not value:\n                    raise\n                exc.__traceback__ = traceback\n                return False\n            try:\n                raise RuntimeError(\"generator didn't stop after throw()\")\n            finally:\n                self.gen.close()\n\nclass _AsyncGeneratorContextManager(\n    _GeneratorContextManagerBase,\n    AbstractAsyncContextManager,\n    AsyncContextDecorator,\n):\n    \"\"\"Helper for @asynccontextmanager decorator.\"\"\"\n\n    async def __aenter__(self):\n        # do not keep args and kwds alive unnecessarily\n        # they are only needed for recreation, which is not possible anymore\n        del self.args, self.kwds, self.func\n        try:\n            return await anext(self.gen)\n        except StopAsyncIteration:\n            raise RuntimeError(\"generator didn't yield\") from None\n\n    async def __aexit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                await anext(self.gen)\n            except StopAsyncIteration:\n                return False\n            else:\n                try:\n                    raise RuntimeError(\"generator didn't stop\")\n                finally:\n                    await self.gen.aclose()\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n                await self.gen.athrow(value)\n            except StopAsyncIteration as exc:\n                # Suppress StopIteration *unless* it's the same exception that\n                # was passed to throw().  This prevents a StopIteration\n                # raised inside the \"with\" statement from being suppressed.\n                return exc is not value\n            except RuntimeError as exc:\n                # Don't re-raise the passed in exception. (issue27122)\n                if exc is value:\n                    exc.__traceback__ = traceback\n                    return False\n                # Avoid suppressing if a Stop(Async)Iteration exception\n                # was passed to athrow() and later wrapped into a RuntimeError\n                # (see PEP 479 for sync generators; async generators also\n                # have this behavior). But do this only if the exception wrapped\n                # by the RuntimeError is actually Stop(Async)Iteration (see\n                # issue29692).\n                if (\n                    isinstance(value, (StopIteration, StopAsyncIteration))\n                    and exc.__cause__ is value\n                ):\n                    value.__traceback__ = traceback\n                    return False\n                raise\n            except BaseException as exc:\n                # only re-raise if it's *not* the exception that was\n                # passed to throw(), because __exit__() must not raise\n                # an exception unless __exit__() itself failed.  But throw()\n                # has to raise the exception to signal propagation, so this\n                # fixes the impedance mismatch between the throw() protocol\n                # and the __exit__() protocol.\n                if exc is not value:\n                    raise\n                exc.__traceback__ = traceback\n                return False\n            try:\n                raise RuntimeError(\"generator didn't stop after athrow()\")\n            finally:\n                await self.gen.aclose()\n\n\ndef contextmanager(func):\n    \"\"\"@contextmanager decorator.\n\n    Typical usage:\n\n        @contextmanager\n        def some_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        with some_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>\n    \"\"\"\n    @wraps(func)\n    def helper(*args, **kwds):\n        return _GeneratorContextManager(func, args, kwds)\n    return helper\n\n\ndef asynccontextmanager(func):\n    \"\"\"@asynccontextmanager decorator.\n\n    Typical usage:\n\n        @asynccontextmanager\n        async def some_async_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        async with some_async_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>\n    \"\"\"\n    @wraps(func)\n    def helper(*args, **kwds):\n        return _AsyncGeneratorContextManager(func, args, kwds)\n    return helper\n\n\nclass closing(AbstractContextManager):\n    \"\"\"Context to automatically close something at the end of a block.\n\n    Code like this:\n\n        with closing(<module>.open(<arguments>)) as f:\n            <block>\n\n    is equivalent to this:\n\n        f = <module>.open(<arguments>)\n        try:\n            <block>\n        finally:\n            f.close()\n\n    \"\"\"\n    def __init__(self, thing):\n        self.thing = thing\n    def __enter__(self):\n        return self.thing\n    def __exit__(self, *exc_info):\n        self.thing.close()\n\n\nclass aclosing(AbstractAsyncContextManager):\n    \"\"\"Async context manager for safely finalizing an asynchronously cleaned-up\n    resource such as an async generator, calling its ``aclose()`` method.\n\n    Code like this:\n\n        async with aclosing(<module>.fetch(<arguments>)) as agen:\n            <block>\n\n    is equivalent to this:\n\n        agen = <module>.fetch(<arguments>)\n        try:\n            <block>\n        finally:\n            await agen.aclose()\n\n    \"\"\"\n    def __init__(self, thing):\n        self.thing = thing\n    async def __aenter__(self):\n        return self.thing\n    async def __aexit__(self, *exc_info):\n        await self.thing.aclose()\n\n\nclass _RedirectStream(AbstractContextManager):\n\n    _stream = None\n\n    def __init__(self, new_target):\n        self._new_target = new_target\n        # We use a list of old targets to make this CM re-entrant\n        self._old_targets = []\n\n    def __enter__(self):\n        self._old_targets.append(getattr(sys, self._stream))\n        setattr(sys, self._stream, self._new_target)\n        return self._new_target\n\n    def __exit__(self, exctype, excinst, exctb):\n        setattr(sys, self._stream, self._old_targets.pop())\n\n\nclass redirect_stdout(_RedirectStream):\n    \"\"\"Context manager for temporarily redirecting stdout to another file.\n\n        # How to send help() to stderr\n        with redirect_stdout(sys.stderr):\n            help(dir)\n\n        # How to write help() to a file\n        with open('help.txt', 'w') as f:\n            with redirect_stdout(f):\n                help(pow)\n    \"\"\"\n\n    _stream = \"stdout\"\n\n\nclass redirect_stderr(_RedirectStream):\n    \"\"\"Context manager for temporarily redirecting stderr to another file.\"\"\"\n\n    _stream = \"stderr\"\n\n\nclass suppress(AbstractContextManager):\n    \"\"\"Context manager to suppress specified exceptions\n\n    After the exception is suppressed, execution proceeds with the next\n    statement following the with statement.\n\n         with suppress(FileNotFoundError):\n             os.remove(somefile)\n         # Execution still resumes here if the file was already removed\n    \"\"\"\n\n    def __init__(self, *exceptions):\n        self._exceptions = exceptions\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exctype, excinst, exctb):\n        # Unlike isinstance and issubclass, CPython exception handling\n        # currently only looks at the concrete type hierarchy (ignoring\n        # the instance and subclass checking hooks). While Guido considers\n        # that a bug rather than a feature, it's a fairly hard one to fix\n        # due to various internal implementation details. suppress provides\n        # the simpler issubclass based semantics, rather than trying to\n        # exactly reproduce the limitations of the CPython interpreter.\n        #\n        # See http://bugs.python.org/issue12029 for more details\n        if exctype is None:\n            return\n        if issubclass(exctype, self._exceptions):\n            return True\n        if issubclass(exctype, BaseExceptionGroup):\n            match, rest = excinst.split(self._exceptions)\n            if rest is None:\n                return True\n            raise rest\n        return False\n\n\nclass _BaseExitStack:\n    \"\"\"A base class for ExitStack and AsyncExitStack.\"\"\"\n\n    @staticmethod\n    def _create_exit_wrapper(cm, cm_exit):\n        return MethodType(cm_exit, cm)\n\n    @staticmethod\n    def _create_cb_wrapper(callback, /, *args, **kwds):\n        def _exit_wrapper(exc_type, exc, tb):\n            callback(*args, **kwds)\n        return _exit_wrapper\n\n    def __init__(self):\n        self._exit_callbacks = deque()\n\n    def pop_all(self):\n        \"\"\"Preserve the context stack by transferring it to a new instance.\"\"\"\n        new_stack = type(self)()\n        new_stack._exit_callbacks = self._exit_callbacks\n        self._exit_callbacks = deque()\n        return new_stack\n\n    def push(self, exit):\n        \"\"\"Registers a callback with the standard __exit__ method signature.\n\n        Can suppress exceptions the same way __exit__ method can.\n        Also accepts any object with an __exit__ method (registering a call\n        to the method instead of the object itself).\n        \"\"\"\n        # We use an unbound method rather than a bound method to follow\n        # the standard lookup behaviour for special methods.\n        _cb_type = type(exit)\n\n        try:\n            exit_method = _cb_type.__exit__\n        except AttributeError:\n            # Not a context manager, so assume it's a callable.\n            self._push_exit_callback(exit)\n        else:\n            self._push_cm_exit(exit, exit_method)\n        return exit  # Allow use as a decorator.\n\n    def enter_context(self, cm):\n        \"\"\"Enters the supplied context manager.\n\n        If successful, also pushes its __exit__ method as a callback and\n        returns the result of the __enter__ method.\n        \"\"\"\n        # We look up the special methods on the type to match the with\n        # statement.\n        cls = type(cm)\n        try:\n            _enter = cls.__enter__\n            _exit = cls.__exit__\n        except AttributeError:\n            raise TypeError(f\"'{cls.__module__}.{cls.__qualname__}' object does \"\n                            f\"not support the context manager protocol\") from None\n        result = _enter(cm)\n        self._push_cm_exit(cm, _exit)\n        return result\n\n    def callback(self, callback, /, *args, **kwds):\n        \"\"\"Registers an arbitrary callback and arguments.\n\n        Cannot suppress exceptions.\n        \"\"\"\n        _exit_wrapper = self._create_cb_wrapper(callback, *args, **kwds)\n\n        # We changed the signature, so using @wraps is not appropriate, but\n        # setting __wrapped__ may still help with introspection.\n        _exit_wrapper.__wrapped__ = callback\n        self._push_exit_callback(_exit_wrapper)\n        return callback  # Allow use as a decorator\n\n    def _push_cm_exit(self, cm, cm_exit):\n        \"\"\"Helper to correctly register callbacks to __exit__ methods.\"\"\"\n        _exit_wrapper = self._create_exit_wrapper(cm, cm_exit)\n        self._push_exit_callback(_exit_wrapper, True)\n\n    def _push_exit_callback(self, callback, is_sync=True):\n        self._exit_callbacks.append((is_sync, callback))\n\n\n# Inspired by discussions on http://bugs.python.org/issue13585\nclass ExitStack(_BaseExitStack, AbstractContextManager):\n    \"\"\"Context manager for dynamic management of a stack of exit callbacks.\n\n    For example:\n        with ExitStack() as stack:\n            files = [stack.enter_context(open(fname)) for fname in filenames]\n            # All opened files will automatically be closed at the end of\n            # the with statement, even if attempts to open files later\n            # in the list raise an exception.\n    \"\"\"\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc_details):\n        exc = exc_details[1]\n        received_exc = exc is not None\n\n        # We manipulate the exception state so it behaves as though\n        # we were actually nesting multiple with statements\n        frame_exc = sys.exception()\n        def _fix_exception_context(new_exc, old_exc):\n            # Context may not be correct, so find the end of the chain\n            while 1:\n                exc_context = new_exc.__context__\n                if exc_context is None or exc_context is old_exc:\n                    # Context is already set correctly (see issue 20317)\n                    return\n                if exc_context is frame_exc:\n                    break\n                new_exc = exc_context\n            # Change the end of the chain to point to the exception\n            # we expect it to reference\n            new_exc.__context__ = old_exc\n\n        # Callbacks are invoked in LIFO order to match the behaviour of\n        # nested context managers\n        suppressed_exc = False\n        pending_raise = False\n        while self._exit_callbacks:\n            is_sync, cb = self._exit_callbacks.pop()\n            assert is_sync\n            try:\n                if exc is None:\n                    exc_details = None, None, None\n                else:\n                    exc_details = type(exc), exc, exc.__traceback__\n                if cb(*exc_details):\n                    suppressed_exc = True\n                    pending_raise = False\n                    exc = None\n            except BaseException as new_exc:\n                # simulate the stack of exceptions by setting the context\n                _fix_exception_context(new_exc, exc)\n                pending_raise = True\n                exc = new_exc\n\n        if pending_raise:\n            try:\n                # bare \"raise exc\" replaces our carefully\n                # set-up context\n                fixed_ctx = exc.__context__\n                raise exc\n            except BaseException:\n                exc.__context__ = fixed_ctx\n                raise\n        return received_exc and suppressed_exc\n\n    def close(self):\n        \"\"\"Immediately unwind the context stack.\"\"\"\n        self.__exit__(None, None, None)\n\n\n# Inspired by discussions on https://bugs.python.org/issue29302\nclass AsyncExitStack(_BaseExitStack, AbstractAsyncContextManager):\n    \"\"\"Async context manager for dynamic management of a stack of exit\n    callbacks.\n\n    For example:\n        async with AsyncExitStack() as stack:\n            connections = [await stack.enter_async_context(get_connection())\n                for i in range(5)]\n            # All opened connections will automatically be released at the\n            # end of the async with statement, even if attempts to open a\n            # connection later in the list raise an exception.\n    \"\"\"\n\n    @staticmethod\n    def _create_async_exit_wrapper(cm, cm_exit):\n        return MethodType(cm_exit, cm)\n\n    @staticmethod\n    def _create_async_cb_wrapper(callback, /, *args, **kwds):\n        async def _exit_wrapper(exc_type, exc, tb):\n            await callback(*args, **kwds)\n        return _exit_wrapper\n\n    async def enter_async_context(self, cm):\n        \"\"\"Enters the supplied async context manager.\n\n        If successful, also pushes its __aexit__ method as a callback and\n        returns the result of the __aenter__ method.\n        \"\"\"\n        cls = type(cm)\n        try:\n            _enter = cls.__aenter__\n            _exit = cls.__aexit__\n        except AttributeError:\n            raise TypeError(f\"'{cls.__module__}.{cls.__qualname__}' object does \"\n                            f\"not support the asynchronous context manager protocol\"\n                           ) from None\n        result = await _enter(cm)\n        self._push_async_cm_exit(cm, _exit)\n        return result\n\n    def push_async_exit(self, exit):\n        \"\"\"Registers a coroutine function with the standard __aexit__ method\n        signature.\n\n        Can suppress exceptions the same way __aexit__ method can.\n        Also accepts any object with an __aexit__ method (registering a call\n        to the method instead of the object itself).\n        \"\"\"\n        _cb_type = type(exit)\n        try:\n            exit_method = _cb_type.__aexit__\n        except AttributeError:\n            # Not an async context manager, so assume it's a coroutine function\n            self._push_exit_callback(exit, False)\n        else:\n            self._push_async_cm_exit(exit, exit_method)\n        return exit  # Allow use as a decorator\n\n    def push_async_callback(self, callback, /, *args, **kwds):\n        \"\"\"Registers an arbitrary coroutine function and arguments.\n\n        Cannot suppress exceptions.\n        \"\"\"\n        _exit_wrapper = self._create_async_cb_wrapper(callback, *args, **kwds)\n\n        # We changed the signature, so using @wraps is not appropriate, but\n        # setting __wrapped__ may still help with introspection.\n        _exit_wrapper.__wrapped__ = callback\n        self._push_exit_callback(_exit_wrapper, False)\n        return callback  # Allow use as a decorator\n\n    async def aclose(self):\n        \"\"\"Immediately unwind the context stack.\"\"\"\n        await self.__aexit__(None, None, None)\n\n    def _push_async_cm_exit(self, cm, cm_exit):\n        \"\"\"Helper to correctly register coroutine function to __aexit__\n        method.\"\"\"\n        _exit_wrapper = self._create_async_exit_wrapper(cm, cm_exit)\n        self._push_exit_callback(_exit_wrapper, False)\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, *exc_details):\n        exc = exc_details[1]\n        received_exc = exc is not None\n\n        # We manipulate the exception state so it behaves as though\n        # we were actually nesting multiple with statements\n        frame_exc = sys.exception()\n        def _fix_exception_context(new_exc, old_exc):\n            # Context may not be correct, so find the end of the chain\n            while 1:\n                exc_context = new_exc.__context__\n                if exc_context is None or exc_context is old_exc:\n                    # Context is already set correctly (see issue 20317)\n                    return\n                if exc_context is frame_exc:\n                    break\n                new_exc = exc_context\n            # Change the end of the chain to point to the exception\n            # we expect it to reference\n            new_exc.__context__ = old_exc\n\n        # Callbacks are invoked in LIFO order to match the behaviour of\n        # nested context managers\n        suppressed_exc = False\n        pending_raise = False\n        while self._exit_callbacks:\n            is_sync, cb = self._exit_callbacks.pop()\n            try:\n                if exc is None:\n                    exc_details = None, None, None\n                else:\n                    exc_details = type(exc), exc, exc.__traceback__\n                if is_sync:\n                    cb_suppress = cb(*exc_details)\n                else:\n                    cb_suppress = await cb(*exc_details)\n\n                if cb_suppress:\n                    suppressed_exc = True\n                    pending_raise = False\n                    exc = None\n            except BaseException as new_exc:\n                # simulate the stack of exceptions by setting the context\n                _fix_exception_context(new_exc, exc)\n                pending_raise = True\n                exc = new_exc\n\n        if pending_raise:\n            try:\n                # bare \"raise exc\" replaces our carefully\n                # set-up context\n                fixed_ctx = exc.__context__\n                raise exc\n            except BaseException:\n                exc.__context__ = fixed_ctx\n                raise\n        return received_exc and suppressed_exc\n\n\nclass nullcontext(AbstractContextManager, AbstractAsyncContextManager):\n    \"\"\"Context manager that does no additional processing.\n\n    Used as a stand-in for a normal context manager, when a particular\n    block of code is only sometimes used with a normal context manager:\n\n    cm = optional_cm if condition else nullcontext()\n    with cm:\n        # Perform operation, using optional_cm if condition is True\n    \"\"\"\n\n    def __init__(self, enter_result=None):\n        self.enter_result = enter_result\n\n    def __enter__(self):\n        return self.enter_result\n\n    def __exit__(self, *excinfo):\n        pass\n\n    async def __aenter__(self):\n        return self.enter_result\n\n    async def __aexit__(self, *excinfo):\n        pass\n\n\nclass chdir(AbstractContextManager):\n    \"\"\"Non thread-safe context manager to change the current working directory.\"\"\"\n\n    def __init__(self, path):\n        self.path = path\n        self._old_cwd = []\n\n    def __enter__(self):\n        self._old_cwd.append(os.getcwd())\n        os.chdir(self.path)\n\n    def __exit__(self, *excinfo):\n        os.chdir(self._old_cwd.pop())\n", 814], "C:\\Programming\\Python313\\Lib\\_collections_abc.py": ["# Copyright 2007 Google, Inc. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nUnit tests are in test_collections.\n\"\"\"\n\n############ Maintenance notes #########################################\n#\n# ABCs are different from other standard library modules in that they\n# specify compliance tests.  In general, once an ABC has been published,\n# new methods (either abstract or concrete) cannot be added.\n#\n# Though classes that inherit from an ABC would automatically receive a\n# new mixin method, registered classes would become non-compliant and\n# violate the contract promised by ``isinstance(someobj, SomeABC)``.\n#\n# Though irritating, the correct procedure for adding new abstract or\n# mixin methods is to create a new ABC as a subclass of the previous\n# ABC.  For example, union(), intersection(), and difference() cannot\n# be added to Set but could go into a new ABC that extends Set.\n#\n# Because they are so hard to change, new ABCs should have their APIs\n# carefully thought through prior to publication.\n#\n# Since ABCMeta only checks for the presence of methods, it is possible\n# to alter the signature of a method by adding optional arguments\n# or changing parameters names.  This is still a bit dubious but at\n# least it won't cause isinstance() to return an incorrect result.\n#\n#\n#######################################################################\n\nfrom abc import ABCMeta, abstractmethod\nimport sys\n\nGenericAlias = type(list[int])\nEllipsisType = type(...)\ndef _f(): pass\nFunctionType = type(_f)\ndel _f\n\n__all__ = [\"Awaitable\", \"Coroutine\",\n           \"AsyncIterable\", \"AsyncIterator\", \"AsyncGenerator\",\n           \"Hashable\", \"Iterable\", \"Iterator\", \"Generator\", \"Reversible\",\n           \"Sized\", \"Container\", \"Callable\", \"Collection\",\n           \"Set\", \"MutableSet\",\n           \"Mapping\", \"MutableMapping\",\n           \"MappingView\", \"KeysView\", \"ItemsView\", \"ValuesView\",\n           \"Sequence\", \"MutableSequence\",\n           \"ByteString\", \"Buffer\",\n           ]\n\n# This module has been renamed from collections.abc to _collections_abc to\n# speed up interpreter startup. Some of the types such as MutableMapping are\n# required early but collections module imports a lot of other modules.\n# See issue #19218\n__name__ = \"collections.abc\"\n\n# Private list of types that we want to register with the various ABCs\n# so that they will pass tests like:\n#       it = iter(somebytearray)\n#       assert isinstance(it, Iterable)\n# Note:  in other implementations, these types might not be distinct\n# and they may have their own implementation specific types that\n# are not included on this list.\nbytes_iterator = type(iter(b''))\nbytearray_iterator = type(iter(bytearray()))\n#callable_iterator = ???\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ndef _get_framelocalsproxy():\n    return type(sys._getframe().f_locals)\nframelocalsproxy = _get_framelocalsproxy()\ndel _get_framelocalsproxy\ngenerator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass\n_coro = _coro()\ncoroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning\ndel _coro\n## asynchronous generator ##\nasync def _ag(): yield\n_ag = _ag()\nasync_generator = type(_ag)\ndel _ag\n\n\n### ONE-TRICK PONIES ###\n\ndef _check_methods(C, *methods):\n    mro = C.__mro__\n    for method in methods:\n        for B in mro:\n            if method in B.__dict__:\n                if B.__dict__[method] is None:\n                    return NotImplemented\n                break\n        else:\n            return NotImplemented\n    return True\n\nclass Hashable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __hash__(self):\n        return 0\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Hashable:\n            return _check_methods(C, \"__hash__\")\n        return NotImplemented\n\n\nclass Awaitable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __await__(self):\n        yield\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Awaitable:\n            return _check_methods(C, \"__await__\")\n        return NotImplemented\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass Coroutine(Awaitable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def send(self, value):\n        \"\"\"Send a value into the coroutine.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        raise StopIteration\n\n    @abstractmethod\n    def throw(self, typ, val=None, tb=None):\n        \"\"\"Raise an exception in the coroutine.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        if val is None:\n            if tb is None:\n                raise typ\n            val = typ()\n        if tb is not None:\n            val = val.with_traceback(tb)\n        raise val\n\n    def close(self):\n        \"\"\"Raise GeneratorExit inside coroutine.\n        \"\"\"\n        try:\n            self.throw(GeneratorExit)\n        except (GeneratorExit, StopIteration):\n            pass\n        else:\n            raise RuntimeError(\"coroutine ignored GeneratorExit\")\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Coroutine:\n            return _check_methods(C, '__await__', 'send', 'throw', 'close')\n        return NotImplemented\n\n\nCoroutine.register(coroutine)\n\n\nclass AsyncIterable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __aiter__(self):\n        return AsyncIterator()\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncIterable:\n            return _check_methods(C, \"__aiter__\")\n        return NotImplemented\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass AsyncIterator(AsyncIterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    async def __anext__(self):\n        \"\"\"Return the next item or raise StopAsyncIteration when exhausted.\"\"\"\n        raise StopAsyncIteration\n\n    def __aiter__(self):\n        return self\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncIterator:\n            return _check_methods(C, \"__anext__\", \"__aiter__\")\n        return NotImplemented\n\n\nclass AsyncGenerator(AsyncIterator):\n\n    __slots__ = ()\n\n    async def __anext__(self):\n        \"\"\"Return the next item from the asynchronous generator.\n        When exhausted, raise StopAsyncIteration.\n        \"\"\"\n        return await self.asend(None)\n\n    @abstractmethod\n    async def asend(self, value):\n        \"\"\"Send a value into the asynchronous generator.\n        Return next yielded value or raise StopAsyncIteration.\n        \"\"\"\n        raise StopAsyncIteration\n\n    @abstractmethod\n    async def athrow(self, typ, val=None, tb=None):\n        \"\"\"Raise an exception in the asynchronous generator.\n        Return next yielded value or raise StopAsyncIteration.\n        \"\"\"\n        if val is None:\n            if tb is None:\n                raise typ\n            val = typ()\n        if tb is not None:\n            val = val.with_traceback(tb)\n        raise val\n\n    async def aclose(self):\n        \"\"\"Raise GeneratorExit inside coroutine.\n        \"\"\"\n        try:\n            await self.athrow(GeneratorExit)\n        except (GeneratorExit, StopAsyncIteration):\n            pass\n        else:\n            raise RuntimeError(\"asynchronous generator ignored GeneratorExit\")\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncGenerator:\n            return _check_methods(C, '__aiter__', '__anext__',\n                                  'asend', 'athrow', 'aclose')\n        return NotImplemented\n\n\nAsyncGenerator.register(async_generator)\n\n\nclass Iterable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __iter__(self):\n        while False:\n            yield None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterable:\n            return _check_methods(C, \"__iter__\")\n        return NotImplemented\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass Iterator(Iterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __next__(self):\n        'Return the next item from the iterator. When exhausted, raise StopIteration'\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterator:\n            return _check_methods(C, '__iter__', '__next__')\n        return NotImplemented\n\n\nIterator.register(bytes_iterator)\nIterator.register(bytearray_iterator)\n#Iterator.register(callable_iterator)\nIterator.register(dict_keyiterator)\nIterator.register(dict_valueiterator)\nIterator.register(dict_itemiterator)\nIterator.register(list_iterator)\nIterator.register(list_reverseiterator)\nIterator.register(range_iterator)\nIterator.register(longrange_iterator)\nIterator.register(set_iterator)\nIterator.register(str_iterator)\nIterator.register(tuple_iterator)\nIterator.register(zip_iterator)\n\n\nclass Reversible(Iterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __reversed__(self):\n        while False:\n            yield None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Reversible:\n            return _check_methods(C, \"__reversed__\", \"__iter__\")\n        return NotImplemented\n\n\nclass Generator(Iterator):\n\n    __slots__ = ()\n\n    def __next__(self):\n        \"\"\"Return the next item from the generator.\n        When exhausted, raise StopIteration.\n        \"\"\"\n        return self.send(None)\n\n    @abstractmethod\n    def send(self, value):\n        \"\"\"Send a value into the generator.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        raise StopIteration\n\n    @abstractmethod\n    def throw(self, typ, val=None, tb=None):\n        \"\"\"Raise an exception in the generator.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        if val is None:\n            if tb is None:\n                raise typ\n            val = typ()\n        if tb is not None:\n            val = val.with_traceback(tb)\n        raise val\n\n    def close(self):\n        \"\"\"Raise GeneratorExit inside generator.\n        \"\"\"\n        try:\n            self.throw(GeneratorExit)\n        except (GeneratorExit, StopIteration):\n            pass\n        else:\n            raise RuntimeError(\"generator ignored GeneratorExit\")\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Generator:\n            return _check_methods(C, '__iter__', '__next__',\n                                  'send', 'throw', 'close')\n        return NotImplemented\n\n\nGenerator.register(generator)\n\n\nclass Sized(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __len__(self):\n        return 0\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Sized:\n            return _check_methods(C, \"__len__\")\n        return NotImplemented\n\n\nclass Container(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __contains__(self, x):\n        return False\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Container:\n            return _check_methods(C, \"__contains__\")\n        return NotImplemented\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass Collection(Sized, Iterable, Container):\n\n    __slots__ = ()\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Collection:\n            return _check_methods(C,  \"__len__\", \"__iter__\", \"__contains__\")\n        return NotImplemented\n\n\nclass Buffer(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __buffer__(self, flags: int, /) -> memoryview:\n        raise NotImplementedError\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Buffer:\n            return _check_methods(C, \"__buffer__\")\n        return NotImplemented\n\n\nclass _CallableGenericAlias(GenericAlias):\n    \"\"\" Represent `Callable[argtypes, resulttype]`.\n\n    This sets ``__args__`` to a tuple containing the flattened ``argtypes``\n    followed by ``resulttype``.\n\n    Example: ``Callable[[int, str], float]`` sets ``__args__`` to\n    ``(int, str, float)``.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(cls, origin, args):\n        if not (isinstance(args, tuple) and len(args) == 2):\n            raise TypeError(\n                \"Callable must be used as Callable[[arg, ...], result].\")\n        t_args, t_result = args\n        if isinstance(t_args, (tuple, list)):\n            args = (*t_args, t_result)\n        elif not _is_param_expr(t_args):\n            raise TypeError(f\"Expected a list of types, an ellipsis, \"\n                            f\"ParamSpec, or Concatenate. Got {t_args}\")\n        return super().__new__(cls, origin, args)\n\n    def __repr__(self):\n        if len(self.__args__) == 2 and _is_param_expr(self.__args__[0]):\n            return super().__repr__()\n        return (f'collections.abc.Callable'\n                f'[[{\", \".join([_type_repr(a) for a in self.__args__[:-1]])}], '\n                f'{_type_repr(self.__args__[-1])}]')\n\n    def __reduce__(self):\n        args = self.__args__\n        if not (len(args) == 2 and _is_param_expr(args[0])):\n            args = list(args[:-1]), args[-1]\n        return _CallableGenericAlias, (Callable, args)\n\n    def __getitem__(self, item):\n        # Called during TypeVar substitution, returns the custom subclass\n        # rather than the default types.GenericAlias object.  Most of the\n        # code is copied from typing's _GenericAlias and the builtin\n        # types.GenericAlias.\n        if not isinstance(item, tuple):\n            item = (item,)\n\n        new_args = super().__getitem__(item).__args__\n\n        # args[0] occurs due to things like Z[[int, str, bool]] from PEP 612\n        if not isinstance(new_args[0], (tuple, list)):\n            t_result = new_args[-1]\n            t_args = new_args[:-1]\n            new_args = (t_args, t_result)\n        return _CallableGenericAlias(Callable, tuple(new_args))\n\ndef _is_param_expr(obj):\n    \"\"\"Checks if obj matches either a list of types, ``...``, ``ParamSpec`` or\n    ``_ConcatenateGenericAlias`` from typing.py\n    \"\"\"\n    if obj is Ellipsis:\n        return True\n    if isinstance(obj, list):\n        return True\n    obj = type(obj)\n    names = ('ParamSpec', '_ConcatenateGenericAlias')\n    return obj.__module__ == 'typing' and any(obj.__name__ == name for name in names)\n\ndef _type_repr(obj):\n    \"\"\"Return the repr() of an object, special-casing types (internal helper).\n\n    Copied from :mod:`typing` since collections.abc\n    shouldn't depend on that module.\n    (Keep this roughly in sync with the typing version.)\n    \"\"\"\n    if isinstance(obj, type):\n        if obj.__module__ == 'builtins':\n            return obj.__qualname__\n        return f'{obj.__module__}.{obj.__qualname__}'\n    if obj is Ellipsis:\n        return '...'\n    if isinstance(obj, FunctionType):\n        return obj.__name__\n    return repr(obj)\n\n\nclass Callable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __call__(self, *args, **kwds):\n        return False\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Callable:\n            return _check_methods(C, \"__call__\")\n        return NotImplemented\n\n    __class_getitem__ = classmethod(_CallableGenericAlias)\n\n\n### SETS ###\n\n\nclass Set(Collection):\n    \"\"\"A set is a finite, iterable container.\n\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__ and __len__.\n\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), redefine __le__ and __ge__,\n    then the other operations will automatically follow suit.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __le__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(self) > len(other):\n            return False\n        for elem in self:\n            if elem not in other:\n                return False\n        return True\n\n    def __lt__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(self) < len(other) and self.__le__(other)\n\n    def __gt__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(self) > len(other) and self.__ge__(other)\n\n    def __ge__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(self) < len(other):\n            return False\n        for elem in other:\n            if elem not in self:\n                return False\n        return True\n\n    def __eq__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(self) == len(other) and self.__le__(other)\n\n    @classmethod\n    def _from_iterable(cls, it):\n        '''Construct an instance of the class from any iterable input.\n\n        Must override this method if the class constructor signature\n        does not accept an iterable for an input.\n        '''\n        return cls(it)\n\n    def __and__(self, other):\n        if not isinstance(other, Iterable):\n            return NotImplemented\n        return self._from_iterable(value for value in other if value in self)\n\n    __rand__ = __and__\n\n    def isdisjoint(self, other):\n        'Return True if two sets have a null intersection.'\n        for value in other:\n            if value in self:\n                return False\n        return True\n\n    def __or__(self, other):\n        if not isinstance(other, Iterable):\n            return NotImplemented\n        chain = (e for s in (self, other) for e in s)\n        return self._from_iterable(chain)\n\n    __ror__ = __or__\n\n    def __sub__(self, other):\n        if not isinstance(other, Set):\n            if not isinstance(other, Iterable):\n                return NotImplemented\n            other = self._from_iterable(other)\n        return self._from_iterable(value for value in self\n                                   if value not in other)\n\n    def __rsub__(self, other):\n        if not isinstance(other, Set):\n            if not isinstance(other, Iterable):\n                return NotImplemented\n            other = self._from_iterable(other)\n        return self._from_iterable(value for value in other\n                                   if value not in self)\n\n    def __xor__(self, other):\n        if not isinstance(other, Set):\n            if not isinstance(other, Iterable):\n                return NotImplemented\n            other = self._from_iterable(other)\n        return (self - other) | (other - self)\n\n    __rxor__ = __xor__\n\n    def _hash(self):\n        \"\"\"Compute the hash value of a set.\n\n        Note that we don't define __hash__: not all sets are hashable.\n        But if you define a hashable set type, its __hash__ should\n        call this function.\n\n        This must be compatible __eq__.\n\n        All sets ought to compare equal if they contain the same\n        elements, regardless of how they are implemented, and\n        regardless of the order of the elements; so there's not much\n        freedom for __eq__ or __hash__.  We match the algorithm used\n        by the built-in frozenset type.\n        \"\"\"\n        MAX = sys.maxsize\n        MASK = 2 * MAX + 1\n        n = len(self)\n        h = 1927868237 * (n + 1)\n        h &= MASK\n        for x in self:\n            hx = hash(x)\n            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167\n            h &= MASK\n        h ^= (h >> 11) ^ (h >> 25)\n        h = h * 69069 + 907133923\n        h &= MASK\n        if h > MAX:\n            h -= MASK + 1\n        if h == -1:\n            h = 590923713\n        return h\n\n\nSet.register(frozenset)\n\n\nclass MutableSet(Set):\n    \"\"\"A mutable set is a finite, iterable container.\n\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__, __len__,\n    add(), and discard().\n\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), all you have to do is redefine __le__ and\n    then the other operations will automatically follow suit.\n    \"\"\"\n\n    __slots__ = ()\n\n    @abstractmethod\n    def add(self, value):\n        \"\"\"Add an element.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def discard(self, value):\n        \"\"\"Remove an element.  Do not raise an exception if absent.\"\"\"\n        raise NotImplementedError\n\n    def remove(self, value):\n        \"\"\"Remove an element. If not a member, raise a KeyError.\"\"\"\n        if value not in self:\n            raise KeyError(value)\n        self.discard(value)\n\n    def pop(self):\n        \"\"\"Return the popped value.  Raise KeyError if empty.\"\"\"\n        it = iter(self)\n        try:\n            value = next(it)\n        except StopIteration:\n            raise KeyError from None\n        self.discard(value)\n        return value\n\n    def clear(self):\n        \"\"\"This is slow (creates N new iterators!) but effective.\"\"\"\n        try:\n            while True:\n                self.pop()\n        except KeyError:\n            pass\n\n    def __ior__(self, it):\n        for value in it:\n            self.add(value)\n        return self\n\n    def __iand__(self, it):\n        for value in (self - it):\n            self.discard(value)\n        return self\n\n    def __ixor__(self, it):\n        if it is self:\n            self.clear()\n        else:\n            if not isinstance(it, Set):\n                it = self._from_iterable(it)\n            for value in it:\n                if value in self:\n                    self.discard(value)\n                else:\n                    self.add(value)\n        return self\n\n    def __isub__(self, it):\n        if it is self:\n            self.clear()\n        else:\n            for value in it:\n                self.discard(value)\n        return self\n\n\nMutableSet.register(set)\n\n\n### MAPPINGS ###\n\nclass Mapping(Collection):\n    \"\"\"A Mapping is a generic container for associating key/value\n    pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __iter__, and __len__.\n    \"\"\"\n\n    __slots__ = ()\n\n    # Tell ABCMeta.__new__ that this class should have TPFLAGS_MAPPING set.\n    __abc_tpflags__ = 1 << 6 # Py_TPFLAGS_MAPPING\n\n    @abstractmethod\n    def __getitem__(self, key):\n        raise KeyError\n\n    def get(self, key, default=None):\n        'D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.'\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __contains__(self, key):\n        try:\n            self[key]\n        except KeyError:\n            return False\n        else:\n            return True\n\n    def keys(self):\n        \"D.keys() -> a set-like object providing a view on D's keys\"\n        return KeysView(self)\n\n    def items(self):\n        \"D.items() -> a set-like object providing a view on D's items\"\n        return ItemsView(self)\n\n    def values(self):\n        \"D.values() -> an object providing a view on D's values\"\n        return ValuesView(self)\n\n    def __eq__(self, other):\n        if not isinstance(other, Mapping):\n            return NotImplemented\n        return dict(self.items()) == dict(other.items())\n\n    __reversed__ = None\n\nMapping.register(mappingproxy)\nMapping.register(framelocalsproxy)\n\n\nclass MappingView(Sized):\n\n    __slots__ = '_mapping',\n\n    def __init__(self, mapping):\n        self._mapping = mapping\n\n    def __len__(self):\n        return len(self._mapping)\n\n    def __repr__(self):\n        return '{0.__class__.__name__}({0._mapping!r})'.format(self)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass KeysView(MappingView, Set):\n\n    __slots__ = ()\n\n    @classmethod\n    def _from_iterable(cls, it):\n        return set(it)\n\n    def __contains__(self, key):\n        return key in self._mapping\n\n    def __iter__(self):\n        yield from self._mapping\n\n\nKeysView.register(dict_keys)\n\n\nclass ItemsView(MappingView, Set):\n\n    __slots__ = ()\n\n    @classmethod\n    def _from_iterable(cls, it):\n        return set(it)\n\n    def __contains__(self, item):\n        key, value = item\n        try:\n            v = self._mapping[key]\n        except KeyError:\n            return False\n        else:\n            return v is value or v == value\n\n    def __iter__(self):\n        for key in self._mapping:\n            yield (key, self._mapping[key])\n\n\nItemsView.register(dict_items)\n\n\nclass ValuesView(MappingView, Collection):\n\n    __slots__ = ()\n\n    def __contains__(self, value):\n        for key in self._mapping:\n            v = self._mapping[key]\n            if v is value or v == value:\n                return True\n        return False\n\n    def __iter__(self):\n        for key in self._mapping:\n            yield self._mapping[key]\n\n\nValuesView.register(dict_values)\n\n\nclass MutableMapping(Mapping):\n    \"\"\"A MutableMapping is a generic container for associating\n    key/value pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __setitem__, __delitem__,\n    __iter__, and __len__.\n    \"\"\"\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __setitem__(self, key, value):\n        raise KeyError\n\n    @abstractmethod\n    def __delitem__(self, key):\n        raise KeyError\n\n    __marker = object()\n\n    def pop(self, key, default=__marker):\n        '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n          If key is not found, d is returned if given, otherwise KeyError is raised.\n        '''\n        try:\n            value = self[key]\n        except KeyError:\n            if default is self.__marker:\n                raise\n            return default\n        else:\n            del self[key]\n            return value\n\n    def popitem(self):\n        '''D.popitem() -> (k, v), remove and return some (key, value) pair\n           as a 2-tuple; but raise KeyError if D is empty.\n        '''\n        try:\n            key = next(iter(self))\n        except StopIteration:\n            raise KeyError from None\n        value = self[key]\n        del self[key]\n        return key, value\n\n    def clear(self):\n        'D.clear() -> None.  Remove all items from D.'\n        try:\n            while True:\n                self.popitem()\n        except KeyError:\n            pass\n\n    def update(self, other=(), /, **kwds):\n        ''' D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n            If E present and has a .keys() method, does:     for k in E.keys(): D[k] = E[k]\n            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n            In either case, this is followed by: for k, v in F.items(): D[k] = v\n        '''\n        if isinstance(other, Mapping):\n            for key in other:\n                self[key] = other[key]\n        elif hasattr(other, \"keys\"):\n            for key in other.keys():\n                self[key] = other[key]\n        else:\n            for key, value in other:\n                self[key] = value\n        for key, value in kwds.items():\n            self[key] = value\n\n    def setdefault(self, key, default=None):\n        'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D'\n        try:\n            return self[key]\n        except KeyError:\n            self[key] = default\n        return default\n\n\nMutableMapping.register(dict)\n\n\n### SEQUENCES ###\n\nclass Sequence(Reversible, Collection):\n    \"\"\"All the operations on a read-only sequence.\n\n    Concrete subclasses must override __new__ or __init__,\n    __getitem__, and __len__.\n    \"\"\"\n\n    __slots__ = ()\n\n    # Tell ABCMeta.__new__ that this class should have TPFLAGS_SEQUENCE set.\n    __abc_tpflags__ = 1 << 5 # Py_TPFLAGS_SEQUENCE\n\n    @abstractmethod\n    def __getitem__(self, index):\n        raise IndexError\n\n    def __iter__(self):\n        i = 0\n        try:\n            while True:\n                v = self[i]\n                yield v\n                i += 1\n        except IndexError:\n            return\n\n    def __contains__(self, value):\n        for v in self:\n            if v is value or v == value:\n                return True\n        return False\n\n    def __reversed__(self):\n        for i in reversed(range(len(self))):\n            yield self[i]\n\n    def index(self, value, start=0, stop=None):\n        '''S.index(value, [start, [stop]]) -> integer -- return first index of value.\n           Raises ValueError if the value is not present.\n\n           Supporting start and stop arguments is optional, but\n           recommended.\n        '''\n        if start is not None and start < 0:\n            start = max(len(self) + start, 0)\n        if stop is not None and stop < 0:\n            stop += len(self)\n\n        i = start\n        while stop is None or i < stop:\n            try:\n                v = self[i]\n            except IndexError:\n                break\n            if v is value or v == value:\n                return i\n            i += 1\n        raise ValueError\n\n    def count(self, value):\n        'S.count(value) -> integer -- return number of occurrences of value'\n        return sum(1 for v in self if v is value or v == value)\n\nSequence.register(tuple)\nSequence.register(str)\nSequence.register(range)\nSequence.register(memoryview)\n\nclass _DeprecateByteStringMeta(ABCMeta):\n    def __new__(cls, name, bases, namespace, **kwargs):\n        if name != \"ByteString\":\n            import warnings\n\n            warnings._deprecated(\n                \"collections.abc.ByteString\",\n                remove=(3, 14),\n            )\n        return super().__new__(cls, name, bases, namespace, **kwargs)\n\n    def __instancecheck__(cls, instance):\n        import warnings\n\n        warnings._deprecated(\n            \"collections.abc.ByteString\",\n            remove=(3, 14),\n        )\n        return super().__instancecheck__(instance)\n\nclass ByteString(Sequence, metaclass=_DeprecateByteStringMeta):\n    \"\"\"This unifies bytes and bytearray.\n\n    XXX Should add all their methods.\n    \"\"\"\n\n    __slots__ = ()\n\nByteString.register(bytes)\nByteString.register(bytearray)\n\n\nclass MutableSequence(Sequence):\n    \"\"\"All the operations on a read-write sequence.\n\n    Concrete subclasses must provide __new__ or __init__,\n    __getitem__, __setitem__, __delitem__, __len__, and insert().\n    \"\"\"\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __setitem__(self, index, value):\n        raise IndexError\n\n    @abstractmethod\n    def __delitem__(self, index):\n        raise IndexError\n\n    @abstractmethod\n    def insert(self, index, value):\n        'S.insert(index, value) -- insert value before index'\n        raise IndexError\n\n    def append(self, value):\n        'S.append(value) -- append value to the end of the sequence'\n        self.insert(len(self), value)\n\n    def clear(self):\n        'S.clear() -> None -- remove all items from S'\n        try:\n            while True:\n                self.pop()\n        except IndexError:\n            pass\n\n    def reverse(self):\n        'S.reverse() -- reverse *IN PLACE*'\n        n = len(self)\n        for i in range(n//2):\n            self[i], self[n-i-1] = self[n-i-1], self[i]\n\n    def extend(self, values):\n        'S.extend(iterable) -- extend sequence by appending elements from the iterable'\n        if values is self:\n            values = list(values)\n        for v in values:\n            self.append(v)\n\n    def pop(self, index=-1):\n        '''S.pop([index]) -> item -- remove and return item at index (default last).\n           Raise IndexError if list is empty or index is out of range.\n        '''\n        v = self[index]\n        del self[index]\n        return v\n\n    def remove(self, value):\n        '''S.remove(value) -- remove first occurrence of value.\n           Raise ValueError if the value is not present.\n        '''\n        del self[self.index(value)]\n\n    def __iadd__(self, values):\n        self.extend(values)\n        return self\n\n\nMutableSequence.register(list)\nMutableSequence.register(bytearray)  # Multiply inheriting, see ByteString\n", 1178], "C:\\Programming\\Python313\\Lib\\os.py": ["r\"\"\"OS routines for NT or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix or nt, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix' or 'nt'\n  - os.curdir is a string representing the current directory (always '.')\n  - os.pardir is a string representing the parent directory (always '..')\n  - os.sep is the (or a most common) pathname separator ('/' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).\n\"\"\"\n\n#'\nimport abc\nimport sys\nimport stat as st\n\nfrom _collections_abc import _check_methods\n\nGenericAlias = type(list[int])\n\n_names = sys.builtin_module_names\n\n# Note:  more names are added to __all__ later.\n__all__ = [\"altsep\", \"curdir\", \"pardir\", \"sep\", \"pathsep\", \"linesep\",\n           \"defpath\", \"name\", \"path\", \"devnull\", \"SEEK_SET\", \"SEEK_CUR\",\n           \"SEEK_END\", \"fsencode\", \"fsdecode\", \"get_exec_path\", \"fdopen\",\n           \"extsep\"]\n\ndef _exists(name):\n    return name in globals()\n\ndef _get_exports_list(module):\n    try:\n        return list(module.__all__)\n    except AttributeError:\n        return [n for n in dir(module) if n[0] != '_']\n\n# Any new dependencies of the os module and/or changes in path separator\n# requires updating importlib as well.\nif 'posix' in _names:\n    name = 'posix'\n    linesep = '\\n'\n    from posix import *\n    try:\n        from posix import _exit\n        __all__.append('_exit')\n    except ImportError:\n        pass\n    import posixpath as path\n\n    try:\n        from posix import _have_functions\n    except ImportError:\n        pass\n\n    import posix\n    __all__.extend(_get_exports_list(posix))\n    del posix\n\nelif 'nt' in _names:\n    name = 'nt'\n    linesep = '\\r\\n'\n    from nt import *\n    try:\n        from nt import _exit\n        __all__.append('_exit')\n    except ImportError:\n        pass\n    import ntpath as path\n\n    import nt\n    __all__.extend(_get_exports_list(nt))\n    del nt\n\n    try:\n        from nt import _have_functions\n    except ImportError:\n        pass\n\nelse:\n    raise ImportError('no os specific module found')\n\nsys.modules['os.path'] = path\nfrom os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,\n    devnull)\n\ndel _names\n\n\nif _exists(\"_have_functions\"):\n    _globals = globals()\n    def _add(str, fn):\n        if (fn in _globals) and (str in _have_functions):\n            _set.add(_globals[fn])\n\n    _set = set()\n    _add(\"HAVE_FACCESSAT\",  \"access\")\n    _add(\"HAVE_FCHMODAT\",   \"chmod\")\n    _add(\"HAVE_FCHOWNAT\",   \"chown\")\n    _add(\"HAVE_FSTATAT\",    \"stat\")\n    _add(\"HAVE_FUTIMESAT\",  \"utime\")\n    _add(\"HAVE_LINKAT\",     \"link\")\n    _add(\"HAVE_MKDIRAT\",    \"mkdir\")\n    _add(\"HAVE_MKFIFOAT\",   \"mkfifo\")\n    _add(\"HAVE_MKNODAT\",    \"mknod\")\n    _add(\"HAVE_OPENAT\",     \"open\")\n    _add(\"HAVE_READLINKAT\", \"readlink\")\n    _add(\"HAVE_RENAMEAT\",   \"rename\")\n    _add(\"HAVE_SYMLINKAT\",  \"symlink\")\n    _add(\"HAVE_UNLINKAT\",   \"unlink\")\n    _add(\"HAVE_UNLINKAT\",   \"rmdir\")\n    _add(\"HAVE_UTIMENSAT\",  \"utime\")\n    supports_dir_fd = _set\n\n    _set = set()\n    _add(\"HAVE_FACCESSAT\",  \"access\")\n    supports_effective_ids = _set\n\n    _set = set()\n    _add(\"HAVE_FCHDIR\",     \"chdir\")\n    _add(\"HAVE_FCHMOD\",     \"chmod\")\n    _add(\"MS_WINDOWS\",      \"chmod\")\n    _add(\"HAVE_FCHOWN\",     \"chown\")\n    _add(\"HAVE_FDOPENDIR\",  \"listdir\")\n    _add(\"HAVE_FDOPENDIR\",  \"scandir\")\n    _add(\"HAVE_FEXECVE\",    \"execve\")\n    _set.add(stat) # fstat always works\n    _add(\"HAVE_FTRUNCATE\",  \"truncate\")\n    _add(\"HAVE_FUTIMENS\",   \"utime\")\n    _add(\"HAVE_FUTIMES\",    \"utime\")\n    _add(\"HAVE_FPATHCONF\",  \"pathconf\")\n    if _exists(\"statvfs\") and _exists(\"fstatvfs\"): # mac os x10.3\n        _add(\"HAVE_FSTATVFS\", \"statvfs\")\n    supports_fd = _set\n\n    _set = set()\n    _add(\"HAVE_FACCESSAT\",  \"access\")\n    # Some platforms don't support lchmod().  Often the function exists\n    # anyway, as a stub that always returns ENOSUP or perhaps EOPNOTSUPP.\n    # (No, I don't know why that's a good design.)  ./configure will detect\n    # this and reject it--so HAVE_LCHMOD still won't be defined on such\n    # platforms.  This is Very Helpful.\n    #\n    # However, sometimes platforms without a working lchmod() *do* have\n    # fchmodat().  (Examples: Linux kernel 3.2 with glibc 2.15,\n    # OpenIndiana 3.x.)  And fchmodat() has a flag that theoretically makes\n    # it behave like lchmod().  So in theory it would be a suitable\n    # replacement for lchmod().  But when lchmod() doesn't work, fchmodat()'s\n    # flag doesn't work *either*.  Sadly ./configure isn't sophisticated\n    # enough to detect this condition--it only determines whether or not\n    # fchmodat() minimally works.\n    #\n    # Therefore we simply ignore fchmodat() when deciding whether or not\n    # os.chmod supports follow_symlinks.  Just checking lchmod() is\n    # sufficient.  After all--if you have a working fchmodat(), your\n    # lchmod() almost certainly works too.\n    #\n    # _add(\"HAVE_FCHMODAT\",   \"chmod\")\n    _add(\"HAVE_FCHOWNAT\",   \"chown\")\n    _add(\"HAVE_FSTATAT\",    \"stat\")\n    _add(\"HAVE_LCHFLAGS\",   \"chflags\")\n    _add(\"HAVE_LCHMOD\",     \"chmod\")\n    _add(\"MS_WINDOWS\",      \"chmod\")\n    if _exists(\"lchown\"): # mac os x10.3\n        _add(\"HAVE_LCHOWN\", \"chown\")\n    _add(\"HAVE_LINKAT\",     \"link\")\n    _add(\"HAVE_LUTIMES\",    \"utime\")\n    _add(\"HAVE_LSTAT\",      \"stat\")\n    _add(\"HAVE_FSTATAT\",    \"stat\")\n    _add(\"HAVE_UTIMENSAT\",  \"utime\")\n    _add(\"MS_WINDOWS\",      \"stat\")\n    supports_follow_symlinks = _set\n\n    del _set\n    del _have_functions\n    del _globals\n    del _add\n\n\n# Python uses fixed values for the SEEK_ constants; they are mapped\n# to native constants if necessary in posixmodule.c\n# Other possible SEEK values are directly imported from posixmodule.c\nSEEK_SET = 0\nSEEK_CUR = 1\nSEEK_END = 2\n\n# Super directory utilities.\n# (Inspired by Eric Raymond; the doc strings are mostly his)\n\ndef makedirs(name, mode=0o777, exist_ok=False):\n    \"\"\"makedirs(name [, mode=0o777][, exist_ok=False])\n\n    Super-mkdir; create a leaf directory and all intermediate ones.  Works like\n    mkdir, except that any intermediate path segment (not just the rightmost)\n    will be created if it does not exist. If the target directory already\n    exists, raise an OSError if exist_ok is False. Otherwise no exception is\n    raised.  This is recursive.\n\n    \"\"\"\n    head, tail = path.split(name)\n    if not tail:\n        head, tail = path.split(head)\n    if head and tail and not path.exists(head):\n        try:\n            makedirs(head, exist_ok=exist_ok)\n        except FileExistsError:\n            # Defeats race condition when another thread created the path\n            pass\n        cdir = curdir\n        if isinstance(tail, bytes):\n            cdir = bytes(curdir, 'ASCII')\n        if tail == cdir:           # xxx/newdir/. exists if xxx/newdir exists\n            return\n    try:\n        mkdir(name, mode)\n    except OSError:\n        # Cannot rely on checking for EEXIST, since the operating system\n        # could give priority to other errors like EACCES or EROFS\n        if not exist_ok or not path.isdir(name):\n            raise\n\ndef removedirs(name):\n    \"\"\"removedirs(name)\n\n    Super-rmdir; remove a leaf directory and all empty intermediate\n    ones.  Works like rmdir except that, if the leaf directory is\n    successfully removed, directories corresponding to rightmost path\n    segments will be pruned away until either the whole path is\n    consumed or an error occurs.  Errors during this latter phase are\n    ignored -- they generally mean that a directory was not empty.\n\n    \"\"\"\n    rmdir(name)\n    head, tail = path.split(name)\n    if not tail:\n        head, tail = path.split(head)\n    while head and tail:\n        try:\n            rmdir(head)\n        except OSError:\n            break\n        head, tail = path.split(head)\n\ndef renames(old, new):\n    \"\"\"renames(old, new)\n\n    Super-rename; create directories as necessary and delete any left\n    empty.  Works like rename, except creation of any intermediate\n    directories needed to make the new pathname good is attempted\n    first.  After the rename, directories corresponding to rightmost\n    path segments of the old name will be pruned until either the\n    whole path is consumed or a nonempty directory is found.\n\n    Note: this function can fail with the new directory structure made\n    if you lack permissions needed to unlink the leaf directory or\n    file.\n\n    \"\"\"\n    head, tail = path.split(new)\n    if head and tail and not path.exists(head):\n        makedirs(head)\n    rename(old, new)\n    head, tail = path.split(old)\n    if head and tail:\n        try:\n            removedirs(head)\n        except OSError:\n            pass\n\n__all__.extend([\"makedirs\", \"removedirs\", \"renames\"])\n\n# Private sentinel that makes walk() classify all symlinks and junctions as\n# regular files.\n_walk_symlinks_as_files = object()\n\ndef walk(top, topdown=True, onerror=None, followlinks=False):\n    \"\"\"Directory tree generator.\n\n    For each directory in the directory tree rooted at top (including top\n    itself, but excluding '.' and '..'), yields a 3-tuple\n\n        dirpath, dirnames, filenames\n\n    dirpath is a string, the path to the directory.  dirnames is a list of\n    the names of the subdirectories in dirpath (including symlinks to directories,\n    and excluding '.' and '..').\n    filenames is a list of the names of the non-directory files in dirpath.\n    Note that the names in the lists are just names, with no path components.\n    To get a full path (which begins with top) to a file or directory in\n    dirpath, do os.path.join(dirpath, name).\n\n    If optional arg 'topdown' is true or not specified, the triple for a\n    directory is generated before the triples for any of its subdirectories\n    (directories are generated top down).  If topdown is false, the triple\n    for a directory is generated after the triples for all of its\n    subdirectories (directories are generated bottom up).\n\n    When topdown is true, the caller can modify the dirnames list in-place\n    (e.g., via del or slice assignment), and walk will only recurse into the\n    subdirectories whose names remain in dirnames; this can be used to prune the\n    search, or to impose a specific order of visiting.  Modifying dirnames when\n    topdown is false has no effect on the behavior of os.walk(), since the\n    directories in dirnames have already been generated by the time dirnames\n    itself is generated. No matter the value of topdown, the list of\n    subdirectories is retrieved before the tuples for the directory and its\n    subdirectories are generated.\n\n    By default errors from the os.scandir() call are ignored.  If\n    optional arg 'onerror' is specified, it should be a function; it\n    will be called with one argument, an OSError instance.  It can\n    report the error to continue with the walk, or raise the exception\n    to abort the walk.  Note that the filename is available as the\n    filename attribute of the exception object.\n\n    By default, os.walk does not follow symbolic links to subdirectories on\n    systems that support them.  In order to get this functionality, set the\n    optional argument 'followlinks' to true.\n\n    Caution:  if you pass a relative pathname for top, don't change the\n    current working directory between resumptions of walk.  walk never\n    changes the current directory, and assumes that the client doesn't\n    either.\n\n    Example:\n\n    import os\n    from os.path import join, getsize\n    for root, dirs, files in os.walk('python/Lib/email'):\n        print(root, \"consumes \")\n        print(sum(getsize(join(root, name)) for name in files), end=\" \")\n        print(\"bytes in\", len(files), \"non-directory files\")\n        if 'CVS' in dirs:\n            dirs.remove('CVS')  # don't visit CVS directories\n\n    \"\"\"\n    sys.audit(\"os.walk\", top, topdown, onerror, followlinks)\n\n    stack = [fspath(top)]\n    islink, join = path.islink, path.join\n    while stack:\n        top = stack.pop()\n        if isinstance(top, tuple):\n            yield top\n            continue\n\n        dirs = []\n        nondirs = []\n        walk_dirs = []\n\n        # We may not have read permission for top, in which case we can't\n        # get a list of the files the directory contains.\n        # We suppress the exception here, rather than blow up for a\n        # minor reason when (say) a thousand readable directories are still\n        # left to visit.\n        try:\n            scandir_it = scandir(top)\n        except OSError as error:\n            if onerror is not None:\n                onerror(error)\n            continue\n\n        cont = False\n        with scandir_it:\n            while True:\n                try:\n                    try:\n                        entry = next(scandir_it)\n                    except StopIteration:\n                        break\n                except OSError as error:\n                    if onerror is not None:\n                        onerror(error)\n                    cont = True\n                    break\n\n                try:\n                    if followlinks is _walk_symlinks_as_files:\n                        is_dir = entry.is_dir(follow_symlinks=False) and not entry.is_junction()\n                    else:\n                        is_dir = entry.is_dir()\n                except OSError:\n                    # If is_dir() raises an OSError, consider the entry not to\n                    # be a directory, same behaviour as os.path.isdir().\n                    is_dir = False\n\n                if is_dir:\n                    dirs.append(entry.name)\n                else:\n                    nondirs.append(entry.name)\n\n                if not topdown and is_dir:\n                    # Bottom-up: traverse into sub-directory, but exclude\n                    # symlinks to directories if followlinks is False\n                    if followlinks:\n                        walk_into = True\n                    else:\n                        try:\n                            is_symlink = entry.is_symlink()\n                        except OSError:\n                            # If is_symlink() raises an OSError, consider the\n                            # entry not to be a symbolic link, same behaviour\n                            # as os.path.islink().\n                            is_symlink = False\n                        walk_into = not is_symlink\n\n                    if walk_into:\n                        walk_dirs.append(entry.path)\n        if cont:\n            continue\n\n        if topdown:\n            # Yield before sub-directory traversal if going top down\n            yield top, dirs, nondirs\n            # Traverse into sub-directories\n            for dirname in reversed(dirs):\n                new_path = join(top, dirname)\n                # bpo-23605: os.path.islink() is used instead of caching\n                # entry.is_symlink() result during the loop on os.scandir() because\n                # the caller can replace the directory entry during the \"yield\"\n                # above.\n                if followlinks or not islink(new_path):\n                    stack.append(new_path)\n        else:\n            # Yield after sub-directory traversal if going bottom up\n            stack.append((top, dirs, nondirs))\n            # Traverse into sub-directories\n            for new_path in reversed(walk_dirs):\n                stack.append(new_path)\n\n__all__.append(\"walk\")\n\nif {open, stat} <= supports_dir_fd and {scandir, stat} <= supports_fd:\n\n    def fwalk(top=\".\", topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None):\n        \"\"\"Directory tree generator.\n\n        This behaves exactly like walk(), except that it yields a 4-tuple\n\n            dirpath, dirnames, filenames, dirfd\n\n        `dirpath`, `dirnames` and `filenames` are identical to walk() output,\n        and `dirfd` is a file descriptor referring to the directory `dirpath`.\n\n        The advantage of fwalk() over walk() is that it's safe against symlink\n        races (when follow_symlinks is False).\n\n        If dir_fd is not None, it should be a file descriptor open to a directory,\n          and top should be relative; top will then be relative to that directory.\n          (dir_fd is always supported for fwalk.)\n\n        Caution:\n        Since fwalk() yields file descriptors, those are only valid until the\n        next iteration step, so you should dup() them if you want to keep them\n        for a longer period.\n\n        Example:\n\n        import os\n        for root, dirs, files, rootfd in os.fwalk('python/Lib/email'):\n            print(root, \"consumes\", end=\"\")\n            print(sum(os.stat(name, dir_fd=rootfd).st_size for name in files),\n                  end=\"\")\n            print(\"bytes in\", len(files), \"non-directory files\")\n            if 'CVS' in dirs:\n                dirs.remove('CVS')  # don't visit CVS directories\n        \"\"\"\n        sys.audit(\"os.fwalk\", top, topdown, onerror, follow_symlinks, dir_fd)\n        top = fspath(top)\n        stack = [(_fwalk_walk, (True, dir_fd, top, top, None))]\n        isbytes = isinstance(top, bytes)\n        try:\n            while stack:\n                yield from _fwalk(stack, isbytes, topdown, onerror, follow_symlinks)\n        finally:\n            # Close any file descriptors still on the stack.\n            while stack:\n                action, value = stack.pop()\n                if action == _fwalk_close:\n                    close(value)\n\n    # Each item in the _fwalk() stack is a pair (action, args).\n    _fwalk_walk = 0  # args: (isroot, dirfd, toppath, topname, entry)\n    _fwalk_yield = 1  # args: (toppath, dirnames, filenames, topfd)\n    _fwalk_close = 2  # args: dirfd\n\n    def _fwalk(stack, isbytes, topdown, onerror, follow_symlinks):\n        # Note: This uses O(depth of the directory tree) file descriptors: if\n        # necessary, it can be adapted to only require O(1) FDs, see issue\n        # #13734.\n\n        action, value = stack.pop()\n        if action == _fwalk_close:\n            close(value)\n            return\n        elif action == _fwalk_yield:\n            yield value\n            return\n        assert action == _fwalk_walk\n        isroot, dirfd, toppath, topname, entry = value\n        try:\n            if not follow_symlinks:\n                # Note: To guard against symlink races, we use the standard\n                # lstat()/open()/fstat() trick.\n                if entry is None:\n                    orig_st = stat(topname, follow_symlinks=False, dir_fd=dirfd)\n                else:\n                    orig_st = entry.stat(follow_symlinks=False)\n            topfd = open(topname, O_RDONLY | O_NONBLOCK, dir_fd=dirfd)\n        except OSError as err:\n            if isroot:\n                raise\n            if onerror is not None:\n                onerror(err)\n            return\n        stack.append((_fwalk_close, topfd))\n        if not follow_symlinks:\n            if isroot and not st.S_ISDIR(orig_st.st_mode):\n                return\n            if not path.samestat(orig_st, stat(topfd)):\n                return\n\n        scandir_it = scandir(topfd)\n        dirs = []\n        nondirs = []\n        entries = None if topdown or follow_symlinks else []\n        for entry in scandir_it:\n            name = entry.name\n            if isbytes:\n                name = fsencode(name)\n            try:\n                if entry.is_dir():\n                    dirs.append(name)\n                    if entries is not None:\n                        entries.append(entry)\n                else:\n                    nondirs.append(name)\n            except OSError:\n                try:\n                    # Add dangling symlinks, ignore disappeared files\n                    if entry.is_symlink():\n                        nondirs.append(name)\n                except OSError:\n                    pass\n\n        if topdown:\n            yield toppath, dirs, nondirs, topfd\n        else:\n            stack.append((_fwalk_yield, (toppath, dirs, nondirs, topfd)))\n\n        toppath = path.join(toppath, toppath[:0])  # Add trailing slash.\n        if entries is None:\n            stack.extend(\n                (_fwalk_walk, (False, topfd, toppath + name, name, None))\n                for name in dirs[::-1])\n        else:\n            stack.extend(\n                (_fwalk_walk, (False, topfd, toppath + name, name, entry))\n                for name, entry in zip(dirs[::-1], entries[::-1]))\n\n    __all__.append(\"fwalk\")\n\ndef execl(file, *args):\n    \"\"\"execl(file, *args)\n\n    Execute the executable file with argument list args, replacing the\n    current process. \"\"\"\n    execv(file, args)\n\ndef execle(file, *args):\n    \"\"\"execle(file, *args, env)\n\n    Execute the executable file with argument list args and\n    environment env, replacing the current process. \"\"\"\n    env = args[-1]\n    execve(file, args[:-1], env)\n\ndef execlp(file, *args):\n    \"\"\"execlp(file, *args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process. \"\"\"\n    execvp(file, args)\n\ndef execlpe(file, *args):\n    \"\"\"execlpe(file, *args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env, replacing the current\n    process. \"\"\"\n    env = args[-1]\n    execvpe(file, args[:-1], env)\n\ndef execvp(file, args):\n    \"\"\"execvp(file, args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process.\n    args may be a list or tuple of strings. \"\"\"\n    _execvpe(file, args)\n\ndef execvpe(file, args, env):\n    \"\"\"execvpe(file, args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env, replacing the\n    current process.\n    args may be a list or tuple of strings. \"\"\"\n    _execvpe(file, args, env)\n\n__all__.extend([\"execl\",\"execle\",\"execlp\",\"execlpe\",\"execvp\",\"execvpe\"])\n\ndef _execvpe(file, args, env=None):\n    if env is not None:\n        exec_func = execve\n        argrest = (args, env)\n    else:\n        exec_func = execv\n        argrest = (args,)\n        env = environ\n\n    if path.dirname(file):\n        exec_func(file, *argrest)\n        return\n    saved_exc = None\n    path_list = get_exec_path(env)\n    if name != 'nt':\n        file = fsencode(file)\n        path_list = map(fsencode, path_list)\n    for dir in path_list:\n        fullname = path.join(dir, file)\n        try:\n            exec_func(fullname, *argrest)\n        except (FileNotFoundError, NotADirectoryError) as e:\n            last_exc = e\n        except OSError as e:\n            last_exc = e\n            if saved_exc is None:\n                saved_exc = e\n    if saved_exc is not None:\n        raise saved_exc\n    raise last_exc\n\n\ndef get_exec_path(env=None):\n    \"\"\"Returns the sequence of directories that will be searched for the\n    named executable (similar to a shell) when launching a process.\n\n    *env* must be an environment variable dict or None.  If *env* is None,\n    os.environ will be used.\n    \"\"\"\n    # Use a local import instead of a global import to limit the number of\n    # modules loaded at startup: the os module is always loaded at startup by\n    # Python. It may also avoid a bootstrap issue.\n    import warnings\n\n    if env is None:\n        env = environ\n\n    # {b'PATH': ...}.get('PATH') and {'PATH': ...}.get(b'PATH') emit a\n    # BytesWarning when using python -b or python -bb: ignore the warning\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", BytesWarning)\n\n        try:\n            path_list = env.get('PATH')\n        except TypeError:\n            path_list = None\n\n        if supports_bytes_environ:\n            try:\n                path_listb = env[b'PATH']\n            except (KeyError, TypeError):\n                pass\n            else:\n                if path_list is not None:\n                    raise ValueError(\n                        \"env cannot contain 'PATH' and b'PATH' keys\")\n                path_list = path_listb\n\n            if path_list is not None and isinstance(path_list, bytes):\n                path_list = fsdecode(path_list)\n\n    if path_list is None:\n        path_list = defpath\n    return path_list.split(pathsep)\n\n\n# Change environ to automatically call putenv() and unsetenv()\nfrom _collections_abc import MutableMapping, Mapping\n\nclass _Environ(MutableMapping):\n    def __init__(self, data, encodekey, decodekey, encodevalue, decodevalue):\n        self.encodekey = encodekey\n        self.decodekey = decodekey\n        self.encodevalue = encodevalue\n        self.decodevalue = decodevalue\n        self._data = data\n\n    def __getitem__(self, key):\n        try:\n            value = self._data[self.encodekey(key)]\n        except KeyError:\n            # raise KeyError with the original key value\n            raise KeyError(key) from None\n        return self.decodevalue(value)\n\n    def __setitem__(self, key, value):\n        key = self.encodekey(key)\n        value = self.encodevalue(value)\n        putenv(key, value)\n        self._data[key] = value\n\n    def __delitem__(self, key):\n        encodedkey = self.encodekey(key)\n        unsetenv(encodedkey)\n        try:\n            del self._data[encodedkey]\n        except KeyError:\n            # raise KeyError with the original key value\n            raise KeyError(key) from None\n\n    def __iter__(self):\n        # list() from dict object is an atomic operation\n        keys = list(self._data)\n        for key in keys:\n            yield self.decodekey(key)\n\n    def __len__(self):\n        return len(self._data)\n\n    def __repr__(self):\n        formatted_items = \", \".join(\n            f\"{self.decodekey(key)!r}: {self.decodevalue(value)!r}\"\n            for key, value in self._data.items()\n        )\n        return f\"environ({{{formatted_items}}})\"\n\n    def copy(self):\n        return dict(self)\n\n    def setdefault(self, key, value):\n        if key not in self:\n            self[key] = value\n        return self[key]\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def __or__(self, other):\n        if not isinstance(other, Mapping):\n            return NotImplemented\n        new = dict(self)\n        new.update(other)\n        return new\n\n    def __ror__(self, other):\n        if not isinstance(other, Mapping):\n            return NotImplemented\n        new = dict(other)\n        new.update(self)\n        return new\n\ndef _createenviron():\n    if name == 'nt':\n        # Where Env Var Names Must Be UPPERCASE\n        def check_str(value):\n            if not isinstance(value, str):\n                raise TypeError(\"str expected, not %s\" % type(value).__name__)\n            return value\n        encode = check_str\n        decode = str\n        def encodekey(key):\n            return encode(key).upper()\n        data = {}\n        for key, value in environ.items():\n            data[encodekey(key)] = value\n    else:\n        # Where Env Var Names Can Be Mixed Case\n        encoding = sys.getfilesystemencoding()\n        def encode(value):\n            if not isinstance(value, str):\n                raise TypeError(\"str expected, not %s\" % type(value).__name__)\n            return value.encode(encoding, 'surrogateescape')\n        def decode(value):\n            return value.decode(encoding, 'surrogateescape')\n        encodekey = encode\n        data = environ\n    return _Environ(data,\n        encodekey, decode,\n        encode, decode)\n\n# unicode environ\nenviron = _createenviron()\ndel _createenviron\n\n\ndef getenv(key, default=None):\n    \"\"\"Get an environment variable, return None if it doesn't exist.\n    The optional second argument can specify an alternate default.\n    key, default and the result are str.\"\"\"\n    return environ.get(key, default)\n\nsupports_bytes_environ = (name != 'nt')\n__all__.extend((\"getenv\", \"supports_bytes_environ\"))\n\nif supports_bytes_environ:\n    def _check_bytes(value):\n        if not isinstance(value, bytes):\n            raise TypeError(\"bytes expected, not %s\" % type(value).__name__)\n        return value\n\n    # bytes environ\n    environb = _Environ(environ._data,\n        _check_bytes, bytes,\n        _check_bytes, bytes)\n    del _check_bytes\n\n    def getenvb(key, default=None):\n        \"\"\"Get an environment variable, return None if it doesn't exist.\n        The optional second argument can specify an alternate default.\n        key, default and the result are bytes.\"\"\"\n        return environb.get(key, default)\n\n    __all__.extend((\"environb\", \"getenvb\"))\n\ndef _fscodec():\n    encoding = sys.getfilesystemencoding()\n    errors = sys.getfilesystemencodeerrors()\n\n    def fsencode(filename):\n        \"\"\"Encode filename (an os.PathLike, bytes, or str) to the filesystem\n        encoding with 'surrogateescape' error handler, return bytes unchanged.\n        On Windows, use 'strict' error handler if the file system encoding is\n        'mbcs' (which is the default encoding).\n        \"\"\"\n        filename = fspath(filename)  # Does type-checking of `filename`.\n        if isinstance(filename, str):\n            return filename.encode(encoding, errors)\n        else:\n            return filename\n\n    def fsdecode(filename):\n        \"\"\"Decode filename (an os.PathLike, bytes, or str) from the filesystem\n        encoding with 'surrogateescape' error handler, return str unchanged. On\n        Windows, use 'strict' error handler if the file system encoding is\n        'mbcs' (which is the default encoding).\n        \"\"\"\n        filename = fspath(filename)  # Does type-checking of `filename`.\n        if isinstance(filename, bytes):\n            return filename.decode(encoding, errors)\n        else:\n            return filename\n\n    return fsencode, fsdecode\n\nfsencode, fsdecode = _fscodec()\ndel _fscodec\n\n# Supply spawn*() (probably only for Unix)\nif _exists(\"fork\") and not _exists(\"spawnv\") and _exists(\"execv\"):\n\n    P_WAIT = 0\n    P_NOWAIT = P_NOWAITO = 1\n\n    __all__.extend([\"P_WAIT\", \"P_NOWAIT\", \"P_NOWAITO\"])\n\n    # XXX Should we support P_DETACH?  I suppose it could fork()**2\n    # and close the std I/O streams.  Also, P_OVERLAY is the same\n    # as execv*()?\n\n    def _spawnvef(mode, file, args, env, func):\n        # Internal helper; func is the exec*() function to use\n        if not isinstance(args, (tuple, list)):\n            raise TypeError('argv must be a tuple or a list')\n        if not args or not args[0]:\n            raise ValueError('argv first element cannot be empty')\n        pid = fork()\n        if not pid:\n            # Child\n            try:\n                if env is None:\n                    func(file, args)\n                else:\n                    func(file, args, env)\n            except:\n                _exit(127)\n        else:\n            # Parent\n            if mode == P_NOWAIT:\n                return pid # Caller is responsible for waiting!\n            while 1:\n                wpid, sts = waitpid(pid, 0)\n                if WIFSTOPPED(sts):\n                    continue\n\n                return waitstatus_to_exitcode(sts)\n\n    def spawnv(mode, file, args):\n        \"\"\"spawnv(mode, file, args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, None, execv)\n\n    def spawnve(mode, file, args, env):\n        \"\"\"spawnve(mode, file, args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nspecified environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, env, execve)\n\n    # Note: spawnvp[e] isn't currently supported on Windows\n\n    def spawnvp(mode, file, args):\n        \"\"\"spawnvp(mode, file, args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, None, execvp)\n\n    def spawnvpe(mode, file, args, env):\n        \"\"\"spawnvpe(mode, file, args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, env, execvpe)\n\n\n    __all__.extend([\"spawnv\", \"spawnve\", \"spawnvp\", \"spawnvpe\"])\n\n\nif _exists(\"spawnv\"):\n    # These aren't supplied by the basic Windows code\n    # but can be easily implemented in Python\n\n    def spawnl(mode, file, *args):\n        \"\"\"spawnl(mode, file, *args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return spawnv(mode, file, args)\n\n    def spawnle(mode, file, *args):\n        \"\"\"spawnle(mode, file, *args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nsupplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        env = args[-1]\n        return spawnve(mode, file, args[:-1], env)\n\n\n    __all__.extend([\"spawnl\", \"spawnle\"])\n\n\nif _exists(\"spawnvp\"):\n    # At the moment, Windows doesn't implement spawnvp[e],\n    # so it won't have spawnlp[e] either.\n    def spawnlp(mode, file, *args):\n        \"\"\"spawnlp(mode, file, *args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return spawnvp(mode, file, args)\n\n    def spawnlpe(mode, file, *args):\n        \"\"\"spawnlpe(mode, file, *args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        env = args[-1]\n        return spawnvpe(mode, file, args[:-1], env)\n\n\n    __all__.extend([\"spawnlp\", \"spawnlpe\"])\n\n# VxWorks has no user space shell provided. As a result, running\n# command in a shell can't be supported.\nif sys.platform != 'vxworks':\n    # Supply os.popen()\n    def popen(cmd, mode=\"r\", buffering=-1):\n        if not isinstance(cmd, str):\n            raise TypeError(\"invalid cmd type (%s, expected string)\" % type(cmd))\n        if mode not in (\"r\", \"w\"):\n            raise ValueError(\"invalid mode %r\" % mode)\n        if buffering == 0 or buffering is None:\n            raise ValueError(\"popen() does not support unbuffered streams\")\n        import subprocess\n        if mode == \"r\":\n            proc = subprocess.Popen(cmd,\n                                    shell=True, text=True,\n                                    stdout=subprocess.PIPE,\n                                    bufsize=buffering)\n            return _wrap_close(proc.stdout, proc)\n        else:\n            proc = subprocess.Popen(cmd,\n                                    shell=True, text=True,\n                                    stdin=subprocess.PIPE,\n                                    bufsize=buffering)\n            return _wrap_close(proc.stdin, proc)\n\n    # Helper for popen() -- a proxy for a file whose close waits for the process\n    class _wrap_close:\n        def __init__(self, stream, proc):\n            self._stream = stream\n            self._proc = proc\n        def close(self):\n            self._stream.close()\n            returncode = self._proc.wait()\n            if returncode == 0:\n                return None\n            if name == 'nt':\n                return returncode\n            else:\n                return returncode << 8  # Shift left to match old behavior\n        def __enter__(self):\n            return self\n        def __exit__(self, *args):\n            self.close()\n        def __getattr__(self, name):\n            return getattr(self._stream, name)\n        def __iter__(self):\n            return iter(self._stream)\n\n    __all__.append(\"popen\")\n\n# Supply os.fdopen()\ndef fdopen(fd, mode=\"r\", buffering=-1, encoding=None, *args, **kwargs):\n    if not isinstance(fd, int):\n        raise TypeError(\"invalid fd type (%s, expected integer)\" % type(fd))\n    import io\n    if \"b\" not in mode:\n        encoding = io.text_encoding(encoding)\n    return io.open(fd, mode, buffering, encoding, *args, **kwargs)\n\n\n# For testing purposes, make sure the function is available when the C\n# implementation exists.\ndef _fspath(path):\n    \"\"\"Return the path representation of a path-like object.\n\n    If str or bytes is passed in, it is returned unchanged. Otherwise the\n    os.PathLike interface is used to get the path representation. If the\n    path representation is not str or bytes, TypeError is raised. If the\n    provided path is not str, bytes, or os.PathLike, TypeError is raised.\n    \"\"\"\n    if isinstance(path, (str, bytes)):\n        return path\n\n    # Work from the object's type to match method resolution of other magic\n    # methods.\n    path_type = type(path)\n    try:\n        path_repr = path_type.__fspath__(path)\n    except AttributeError:\n        if hasattr(path_type, '__fspath__'):\n            raise\n        else:\n            raise TypeError(\"expected str, bytes or os.PathLike object, \"\n                            \"not \" + path_type.__name__)\n    except TypeError:\n        if path_type.__fspath__ is None:\n            raise TypeError(\"expected str, bytes or os.PathLike object, \"\n                            \"not \" + path_type.__name__) from None\n        else:\n            raise\n    if isinstance(path_repr, (str, bytes)):\n        return path_repr\n    else:\n        raise TypeError(\"expected {}.__fspath__() to return str or bytes, \"\n                        \"not {}\".format(path_type.__name__,\n                                        type(path_repr).__name__))\n\n# If there is no C implementation, make the pure Python version the\n# implementation as transparently as possible.\nif not _exists('fspath'):\n    fspath = _fspath\n    fspath.__name__ = \"fspath\"\n\n\nclass PathLike(abc.ABC):\n\n    \"\"\"Abstract base class for implementing the file system path protocol.\"\"\"\n\n    __slots__ = ()\n\n    @abc.abstractmethod\n    def __fspath__(self):\n        \"\"\"Return the file system path representation of the object.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def __subclasshook__(cls, subclass):\n        if cls is PathLike:\n            return _check_methods(subclass, '__fspath__')\n        return NotImplemented\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nif name == 'nt':\n    class _AddedDllDirectory:\n        def __init__(self, path, cookie, remove_dll_directory):\n            self.path = path\n            self._cookie = cookie\n            self._remove_dll_directory = remove_dll_directory\n        def close(self):\n            self._remove_dll_directory(self._cookie)\n            self.path = None\n        def __enter__(self):\n            return self\n        def __exit__(self, *args):\n            self.close()\n        def __repr__(self):\n            if self.path:\n                return \"<AddedDllDirectory({!r})>\".format(self.path)\n            return \"<AddedDllDirectory()>\"\n\n    def add_dll_directory(path):\n        \"\"\"Add a path to the DLL search path.\n\n        This search path is used when resolving dependencies for imported\n        extension modules (the module itself is resolved through sys.path),\n        and also by ctypes.\n\n        Remove the directory by calling close() on the returned object or\n        using it in a with statement.\n        \"\"\"\n        import nt\n        cookie = nt._add_dll_directory(path)\n        return _AddedDllDirectory(\n            path,\n            cookie,\n            nt._remove_dll_directory\n        )\n\n\nif _exists('sched_getaffinity') and sys._get_cpu_count_config() < 0:\n    def process_cpu_count():\n        \"\"\"\n        Get the number of CPUs of the current process.\n\n        Return the number of logical CPUs usable by the calling thread of the\n        current process. Return None if indeterminable.\n        \"\"\"\n        return len(sched_getaffinity(0))\nelse:\n    # Just an alias to cpu_count() (same docstring)\n    process_cpu_count = cpu_count\n", 1183], "C:\\Programming\\Python313\\Lib\\abc.py": ["# Copyright 2007 Google, Inc. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\n\ndef abstractmethod(funcobj):\n    \"\"\"A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, arg1, arg2, argN):\n                ...\n    \"\"\"\n    funcobj.__isabstractmethod__ = True\n    return funcobj\n\n\nclass abstractclassmethod(classmethod):\n    \"\"\"A decorator indicating abstract classmethods.\n\n    Deprecated, use 'classmethod' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @classmethod\n            @abstractmethod\n            def my_abstract_classmethod(cls, ...):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractstaticmethod(staticmethod):\n    \"\"\"A decorator indicating abstract staticmethods.\n\n    Deprecated, use 'staticmethod' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @staticmethod\n            @abstractmethod\n            def my_abstract_staticmethod(...):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractproperty(property):\n    \"\"\"A decorator indicating abstract properties.\n\n    Deprecated, use 'property' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @property\n            @abstractmethod\n            def my_abstract_property(self):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n\ntry:\n    from _abc import (get_cache_token, _abc_init, _abc_register,\n                      _abc_instancecheck, _abc_subclasscheck, _get_dump,\n                      _reset_registry, _reset_caches)\nexcept ImportError:\n    from _py_abc import ABCMeta, get_cache_token\n    ABCMeta.__module__ = 'abc'\nelse:\n    class ABCMeta(type):\n        \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n\n        Use this metaclass to create an ABC.  An ABC can be subclassed\n        directly, and then acts as a mix-in class.  You can also register\n        unrelated concrete classes (even built-in classes) and unrelated\n        ABCs as 'virtual subclasses' -- these and their descendants will\n        be considered subclasses of the registering ABC by the built-in\n        issubclass() function, but the registering ABC won't show up in\n        their MRO (Method Resolution Order) nor will method\n        implementations defined by the registering ABC be callable (not\n        even via super()).\n        \"\"\"\n        def __new__(mcls, name, bases, namespace, /, **kwargs):\n            cls = super().__new__(mcls, name, bases, namespace, **kwargs)\n            _abc_init(cls)\n            return cls\n\n        def register(cls, subclass):\n            \"\"\"Register a virtual subclass of an ABC.\n\n            Returns the subclass, to allow usage as a class decorator.\n            \"\"\"\n            return _abc_register(cls, subclass)\n\n        def __instancecheck__(cls, instance):\n            \"\"\"Override for isinstance(instance, cls).\"\"\"\n            return _abc_instancecheck(cls, instance)\n\n        def __subclasscheck__(cls, subclass):\n            \"\"\"Override for issubclass(subclass, cls).\"\"\"\n            return _abc_subclasscheck(cls, subclass)\n\n        def _dump_registry(cls, file=None):\n            \"\"\"Debug helper to print the ABC registry.\"\"\"\n            print(f\"Class: {cls.__module__}.{cls.__qualname__}\", file=file)\n            print(f\"Inv. counter: {get_cache_token()}\", file=file)\n            (_abc_registry, _abc_cache, _abc_negative_cache,\n             _abc_negative_cache_version) = _get_dump(cls)\n            print(f\"_abc_registry: {_abc_registry!r}\", file=file)\n            print(f\"_abc_cache: {_abc_cache!r}\", file=file)\n            print(f\"_abc_negative_cache: {_abc_negative_cache!r}\", file=file)\n            print(f\"_abc_negative_cache_version: {_abc_negative_cache_version!r}\",\n                  file=file)\n\n        def _abc_registry_clear(cls):\n            \"\"\"Clear the registry (for debugging or testing).\"\"\"\n            _reset_registry(cls)\n\n        def _abc_caches_clear(cls):\n            \"\"\"Clear the caches (for debugging or testing).\"\"\"\n            _reset_caches(cls)\n\n\ndef update_abstractmethods(cls):\n    \"\"\"Recalculate the set of abstract methods of an abstract class.\n\n    If a class has had one of its abstract methods implemented after the\n    class was created, the method will not be considered implemented until\n    this function is called. Alternatively, if a new abstract method has been\n    added to the class, it will only be considered an abstract method of the\n    class after this function is called.\n\n    This function should be called before any use is made of the class,\n    usually in class decorators that add methods to the subject class.\n\n    Returns cls, to allow usage as a class decorator.\n\n    If cls is not an instance of ABCMeta, does nothing.\n    \"\"\"\n    if not hasattr(cls, '__abstractmethods__'):\n        # We check for __abstractmethods__ here because cls might by a C\n        # implementation or a python implementation (especially during\n        # testing), and we want to handle both cases.\n        return cls\n\n    abstracts = set()\n    # Check the existing abstract methods of the parents, keep only the ones\n    # that are not implemented.\n    for scls in cls.__bases__:\n        for name in getattr(scls, '__abstractmethods__', ()):\n            value = getattr(cls, name, None)\n            if getattr(value, \"__isabstractmethod__\", False):\n                abstracts.add(name)\n    # Also add any other newly added abstract methods.\n    for name, value in cls.__dict__.items():\n        if getattr(value, \"__isabstractmethod__\", False):\n            abstracts.add(name)\n    cls.__abstractmethods__ = frozenset(abstracts)\n    return cls\n\n\nclass ABC(metaclass=ABCMeta):\n    \"\"\"Helper class that provides a standard way to create an ABC using\n    inheritance.\n    \"\"\"\n    __slots__ = ()\n", 188], "C:\\Programming\\Python313\\Lib\\collections\\__init__.py": ["'''This module implements specialized container datatypes providing\nalternatives to Python's general purpose built-in containers, dict,\nlist, set, and tuple.\n\n* namedtuple   factory function for creating tuple subclasses with named fields\n* deque        list-like container with fast appends and pops on either end\n* ChainMap     dict-like class for creating a single view of multiple mappings\n* Counter      dict subclass for counting hashable objects\n* OrderedDict  dict subclass that remembers the order entries were added\n* defaultdict  dict subclass that calls a factory function to supply missing values\n* UserDict     wrapper around dictionary objects for easier dict subclassing\n* UserList     wrapper around list objects for easier list subclassing\n* UserString   wrapper around string objects for easier string subclassing\n\n'''\n\n__all__ = [\n    'ChainMap',\n    'Counter',\n    'OrderedDict',\n    'UserDict',\n    'UserList',\n    'UserString',\n    'defaultdict',\n    'deque',\n    'namedtuple',\n]\n\nimport _collections_abc\nimport sys as _sys\n\n_sys.modules['collections.abc'] = _collections_abc\nabc = _collections_abc\n\nfrom itertools import chain as _chain\nfrom itertools import repeat as _repeat\nfrom itertools import starmap as _starmap\nfrom keyword import iskeyword as _iskeyword\nfrom operator import eq as _eq\nfrom operator import itemgetter as _itemgetter\nfrom reprlib import recursive_repr as _recursive_repr\nfrom _weakref import proxy as _proxy\n\ntry:\n    from _collections import deque\nexcept ImportError:\n    pass\nelse:\n    _collections_abc.MutableSequence.register(deque)\n\ntry:\n    from _collections import _deque_iterator\nexcept ImportError:\n    pass\n\ntry:\n    from _collections import defaultdict\nexcept ImportError:\n    pass\n\n\n################################################################################\n### OrderedDict\n################################################################################\n\nclass _OrderedDictKeysView(_collections_abc.KeysView):\n\n    def __reversed__(self):\n        yield from reversed(self._mapping)\n\nclass _OrderedDictItemsView(_collections_abc.ItemsView):\n\n    def __reversed__(self):\n        for key in reversed(self._mapping):\n            yield (key, self._mapping[key])\n\nclass _OrderedDictValuesView(_collections_abc.ValuesView):\n\n    def __reversed__(self):\n        for key in reversed(self._mapping):\n            yield self._mapping[key]\n\nclass _Link(object):\n    __slots__ = 'prev', 'next', 'key', '__weakref__'\n\nclass OrderedDict(dict):\n    'Dictionary that remembers insertion order'\n    # An inherited dict maps keys to values.\n    # The inherited dict provides __getitem__, __len__, __contains__, and get.\n    # The remaining methods are order-aware.\n    # Big-O running times for all methods are the same as regular dictionaries.\n\n    # The internal self.__map dict maps keys to links in a doubly linked list.\n    # The circular doubly linked list starts and ends with a sentinel element.\n    # The sentinel element never gets deleted (this simplifies the algorithm).\n    # The sentinel is in self.__hardroot with a weakref proxy in self.__root.\n    # The prev links are weakref proxies (to prevent circular references).\n    # Individual links are kept alive by the hard reference in self.__map.\n    # Those hard references disappear when a key is deleted from an OrderedDict.\n\n    def __new__(cls, /, *args, **kwds):\n        \"Create the ordered dict object and set up the underlying structures.\"\n        self = dict.__new__(cls)\n        self.__hardroot = _Link()\n        self.__root = root = _proxy(self.__hardroot)\n        root.prev = root.next = root\n        self.__map = {}\n        return self\n\n    def __init__(self, other=(), /, **kwds):\n        '''Initialize an ordered dictionary.  The signature is the same as\n        regular dictionaries.  Keyword argument order is preserved.\n        '''\n        self.__update(other, **kwds)\n\n    def __setitem__(self, key, value,\n                    dict_setitem=dict.__setitem__, proxy=_proxy, Link=_Link):\n        'od.__setitem__(i, y) <==> od[i]=y'\n        # Setting a new item creates a new link at the end of the linked list,\n        # and the inherited dictionary is updated with the new key/value pair.\n        if key not in self:\n            self.__map[key] = link = Link()\n            root = self.__root\n            last = root.prev\n            link.prev, link.next, link.key = last, root, key\n            last.next = link\n            root.prev = proxy(link)\n        dict_setitem(self, key, value)\n\n    def __delitem__(self, key, dict_delitem=dict.__delitem__):\n        'od.__delitem__(y) <==> del od[y]'\n        # Deleting an existing item uses self.__map to find the link which gets\n        # removed by updating the links in the predecessor and successor nodes.\n        dict_delitem(self, key)\n        link = self.__map.pop(key)\n        link_prev = link.prev\n        link_next = link.next\n        link_prev.next = link_next\n        link_next.prev = link_prev\n        link.prev = None\n        link.next = None\n\n    def __iter__(self):\n        'od.__iter__() <==> iter(od)'\n        # Traverse the linked list in order.\n        root = self.__root\n        curr = root.next\n        while curr is not root:\n            yield curr.key\n            curr = curr.next\n\n    def __reversed__(self):\n        'od.__reversed__() <==> reversed(od)'\n        # Traverse the linked list in reverse order.\n        root = self.__root\n        curr = root.prev\n        while curr is not root:\n            yield curr.key\n            curr = curr.prev\n\n    def clear(self):\n        'od.clear() -> None.  Remove all items from od.'\n        root = self.__root\n        root.prev = root.next = root\n        self.__map.clear()\n        dict.clear(self)\n\n    def popitem(self, last=True):\n        '''Remove and return a (key, value) pair from the dictionary.\n\n        Pairs are returned in LIFO order if last is true or FIFO order if false.\n        '''\n        if not self:\n            raise KeyError('dictionary is empty')\n        root = self.__root\n        if last:\n            link = root.prev\n            link_prev = link.prev\n            link_prev.next = root\n            root.prev = link_prev\n        else:\n            link = root.next\n            link_next = link.next\n            root.next = link_next\n            link_next.prev = root\n        key = link.key\n        del self.__map[key]\n        value = dict.pop(self, key)\n        return key, value\n\n    def move_to_end(self, key, last=True):\n        '''Move an existing element to the end (or beginning if last is false).\n\n        Raise KeyError if the element does not exist.\n        '''\n        link = self.__map[key]\n        link_prev = link.prev\n        link_next = link.next\n        soft_link = link_next.prev\n        link_prev.next = link_next\n        link_next.prev = link_prev\n        root = self.__root\n        if last:\n            last = root.prev\n            link.prev = last\n            link.next = root\n            root.prev = soft_link\n            last.next = link\n        else:\n            first = root.next\n            link.prev = root\n            link.next = first\n            first.prev = soft_link\n            root.next = link\n\n    def __sizeof__(self):\n        sizeof = _sys.getsizeof\n        n = len(self) + 1                       # number of links including root\n        size = sizeof(self.__dict__)            # instance dictionary\n        size += sizeof(self.__map) * 2          # internal dict and inherited dict\n        size += sizeof(self.__hardroot) * n     # link objects\n        size += sizeof(self.__root) * n         # proxy objects\n        return size\n\n    update = __update = _collections_abc.MutableMapping.update\n\n    def keys(self):\n        \"D.keys() -> a set-like object providing a view on D's keys\"\n        return _OrderedDictKeysView(self)\n\n    def items(self):\n        \"D.items() -> a set-like object providing a view on D's items\"\n        return _OrderedDictItemsView(self)\n\n    def values(self):\n        \"D.values() -> an object providing a view on D's values\"\n        return _OrderedDictValuesView(self)\n\n    __ne__ = _collections_abc.MutableMapping.__ne__\n\n    __marker = object()\n\n    def pop(self, key, default=__marker):\n        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding\n        value.  If key is not found, d is returned if given, otherwise KeyError\n        is raised.\n\n        '''\n        marker = self.__marker\n        result = dict.pop(self, key, marker)\n        if result is not marker:\n            # The same as in __delitem__().\n            link = self.__map.pop(key)\n            link_prev = link.prev\n            link_next = link.next\n            link_prev.next = link_next\n            link_next.prev = link_prev\n            link.prev = None\n            link.next = None\n            return result\n        if default is marker:\n            raise KeyError(key)\n        return default\n\n    def setdefault(self, key, default=None):\n        '''Insert key with a value of default if key is not in the dictionary.\n\n        Return the value for key if key is in the dictionary, else default.\n        '''\n        if key in self:\n            return self[key]\n        self[key] = default\n        return default\n\n    @_recursive_repr()\n    def __repr__(self):\n        'od.__repr__() <==> repr(od)'\n        if not self:\n            return '%s()' % (self.__class__.__name__,)\n        return '%s(%r)' % (self.__class__.__name__, dict(self.items()))\n\n    def __reduce__(self):\n        'Return state information for pickling'\n        state = self.__getstate__()\n        if state:\n            if isinstance(state, tuple):\n                state, slots = state\n            else:\n                slots = {}\n            state = state.copy()\n            slots = slots.copy()\n            for k in vars(OrderedDict()):\n                state.pop(k, None)\n                slots.pop(k, None)\n            if slots:\n                state = state, slots\n            else:\n                state = state or None\n        return self.__class__, (), state, None, iter(self.items())\n\n    def copy(self):\n        'od.copy() -> a shallow copy of od'\n        return self.__class__(self)\n\n    @classmethod\n    def fromkeys(cls, iterable, value=None):\n        '''Create a new ordered dictionary with keys from iterable and values set to value.\n        '''\n        self = cls()\n        for key in iterable:\n            self[key] = value\n        return self\n\n    def __eq__(self, other):\n        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive\n        while comparison to a regular mapping is order-insensitive.\n\n        '''\n        if isinstance(other, OrderedDict):\n            return dict.__eq__(self, other) and all(map(_eq, self, other))\n        return dict.__eq__(self, other)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def __or__(self, other):\n        if not isinstance(other, dict):\n            return NotImplemented\n        new = self.__class__(self)\n        new.update(other)\n        return new\n\n    def __ror__(self, other):\n        if not isinstance(other, dict):\n            return NotImplemented\n        new = self.__class__(other)\n        new.update(self)\n        return new\n\n\ntry:\n    from _collections import OrderedDict\nexcept ImportError:\n    # Leave the pure Python version in place.\n    pass\n\n\n################################################################################\n### namedtuple\n################################################################################\n\ntry:\n    from _collections import _tuplegetter\nexcept ImportError:\n    _tuplegetter = lambda index, doc: property(_itemgetter(index), doc=doc)\n\ndef namedtuple(typename, field_names, *, rename=False, defaults=None, module=None):\n    \"\"\"Returns a new subclass of tuple with named fields.\n\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n\n    \"\"\"\n\n    # Validate the field names.  At the user's option, either generate an error\n    # message or automatically replace the field name with a valid name.\n    if isinstance(field_names, str):\n        field_names = field_names.replace(',', ' ').split()\n    field_names = list(map(str, field_names))\n    typename = _sys.intern(str(typename))\n\n    if rename:\n        seen = set()\n        for index, name in enumerate(field_names):\n            if (not name.isidentifier()\n                or _iskeyword(name)\n                or name.startswith('_')\n                or name in seen):\n                field_names[index] = f'_{index}'\n            seen.add(name)\n\n    for name in [typename] + field_names:\n        if type(name) is not str:\n            raise TypeError('Type names and field names must be strings')\n        if not name.isidentifier():\n            raise ValueError('Type names and field names must be valid '\n                             f'identifiers: {name!r}')\n        if _iskeyword(name):\n            raise ValueError('Type names and field names cannot be a '\n                             f'keyword: {name!r}')\n\n    seen = set()\n    for name in field_names:\n        if name.startswith('_') and not rename:\n            raise ValueError('Field names cannot start with an underscore: '\n                             f'{name!r}')\n        if name in seen:\n            raise ValueError(f'Encountered duplicate field name: {name!r}')\n        seen.add(name)\n\n    field_defaults = {}\n    if defaults is not None:\n        defaults = tuple(defaults)\n        if len(defaults) > len(field_names):\n            raise TypeError('Got more default values than field names')\n        field_defaults = dict(reversed(list(zip(reversed(field_names),\n                                                reversed(defaults)))))\n\n    # Variables used in the methods and docstrings\n    field_names = tuple(map(_sys.intern, field_names))\n    num_fields = len(field_names)\n    arg_list = ', '.join(field_names)\n    if num_fields == 1:\n        arg_list += ','\n    repr_fmt = '(' + ', '.join(f'{name}=%r' for name in field_names) + ')'\n    tuple_new = tuple.__new__\n    _dict, _tuple, _len, _map, _zip = dict, tuple, len, map, zip\n\n    # Create all the named tuple methods to be added to the class namespace\n\n    namespace = {\n        '_tuple_new': tuple_new,\n        '__builtins__': {},\n        '__name__': f'namedtuple_{typename}',\n    }\n    code = f'lambda _cls, {arg_list}: _tuple_new(_cls, ({arg_list}))'\n    __new__ = eval(code, namespace)\n    __new__.__name__ = '__new__'\n    __new__.__doc__ = f'Create new instance of {typename}({arg_list})'\n    if defaults is not None:\n        __new__.__defaults__ = defaults\n\n    @classmethod\n    def _make(cls, iterable):\n        result = tuple_new(cls, iterable)\n        if _len(result) != num_fields:\n            raise TypeError(f'Expected {num_fields} arguments, got {len(result)}')\n        return result\n\n    _make.__func__.__doc__ = (f'Make a new {typename} object from a sequence '\n                              'or iterable')\n\n    def _replace(self, /, **kwds):\n        result = self._make(_map(kwds.pop, field_names, self))\n        if kwds:\n            raise TypeError(f'Got unexpected field names: {list(kwds)!r}')\n        return result\n\n    _replace.__doc__ = (f'Return a new {typename} object replacing specified '\n                        'fields with new values')\n\n    def __repr__(self):\n        'Return a nicely formatted representation string'\n        return self.__class__.__name__ + repr_fmt % self\n\n    def _asdict(self):\n        'Return a new dict which maps field names to their values.'\n        return _dict(_zip(self._fields, self))\n\n    def __getnewargs__(self):\n        'Return self as a plain tuple.  Used by copy and pickle.'\n        return _tuple(self)\n\n    # Modify function metadata to help with introspection and debugging\n    for method in (\n        __new__,\n        _make.__func__,\n        _replace,\n        __repr__,\n        _asdict,\n        __getnewargs__,\n    ):\n        method.__qualname__ = f'{typename}.{method.__name__}'\n\n    # Build-up the class namespace dictionary\n    # and use type() to build the result class\n    class_namespace = {\n        '__doc__': f'{typename}({arg_list})',\n        '__slots__': (),\n        '_fields': field_names,\n        '_field_defaults': field_defaults,\n        '__new__': __new__,\n        '_make': _make,\n        '__replace__': _replace,\n        '_replace': _replace,\n        '__repr__': __repr__,\n        '_asdict': _asdict,\n        '__getnewargs__': __getnewargs__,\n        '__match_args__': field_names,\n    }\n    for index, name in enumerate(field_names):\n        doc = _sys.intern(f'Alias for field number {index}')\n        class_namespace[name] = _tuplegetter(index, doc)\n\n    result = type(typename, (tuple,), class_namespace)\n\n    # For pickling to work, the __module__ variable needs to be set to the frame\n    # where the named tuple is created.  Bypass this step in environments where\n    # sys._getframe is not defined (Jython for example) or sys._getframe is not\n    # defined for arguments greater than 0 (IronPython), or where the user has\n    # specified a particular module.\n    if module is None:\n        try:\n            module = _sys._getframemodulename(1) or '__main__'\n        except AttributeError:\n            try:\n                module = _sys._getframe(1).f_globals.get('__name__', '__main__')\n            except (AttributeError, ValueError):\n                pass\n    if module is not None:\n        result.__module__ = module\n\n    return result\n\n\n########################################################################\n###  Counter\n########################################################################\n\ndef _count_elements(mapping, iterable):\n    'Tally elements from the iterable.'\n    mapping_get = mapping.get\n    for elem in iterable:\n        mapping[elem] = mapping_get(elem, 0) + 1\n\ntry:                                    # Load C helper function if available\n    from _collections import _count_elements\nexcept ImportError:\n    pass\n\nclass Counter(dict):\n    '''Dict subclass for counting hashable items.  Sometimes called a bag\n    or multiset.  Elements are stored as dictionary keys and their counts\n    are stored as dictionary values.\n\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\n\n    >>> c.most_common(3)                # three most common elements\n    [('a', 5), ('b', 4), ('c', 3)]\n    >>> sorted(c)                       # list all unique elements\n    ['a', 'b', 'c', 'd', 'e']\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\n    'aaaaabbbbcccdde'\n    >>> sum(c.values())                 # total of all counts\n    15\n\n    >>> c['a']                          # count of letter 'a'\n    5\n    >>> for elem in 'shazam':           # update counts from an iterable\n    ...     c[elem] += 1                # by adding 1 to each element's count\n    >>> c['a']                          # now there are seven 'a'\n    7\n    >>> del c['b']                      # remove all 'b'\n    >>> c['b']                          # now there are zero 'b'\n    0\n\n    >>> d = Counter('simsalabim')       # make another counter\n    >>> c.update(d)                     # add in the second counter\n    >>> c['a']                          # now there are nine 'a'\n    9\n\n    >>> c.clear()                       # empty the counter\n    >>> c\n    Counter()\n\n    Note:  If a count is set to zero or reduced to zero, it will remain\n    in the counter until the entry is deleted or the counter is cleared:\n\n    >>> c = Counter('aaabbc')\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\n    [('a', 3), ('c', 1), ('b', 0)]\n\n    '''\n    # References:\n    #   http://en.wikipedia.org/wiki/Multiset\n    #   http://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html\n    #   http://www.demo2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm\n    #   http://code.activestate.com/recipes/259174/\n    #   Knuth, TAOCP Vol. II section 4.6.3\n\n    def __init__(self, iterable=None, /, **kwds):\n        '''Create a new, empty Counter object.  And if given, count elements\n        from an input iterable.  Or, initialize the count from another mapping\n        of elements to their counts.\n\n        >>> c = Counter()                           # a new, empty counter\n        >>> c = Counter('gallahad')                 # a new counter from an iterable\n        >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping\n        >>> c = Counter(a=4, b=2)                   # a new counter from keyword args\n\n        '''\n        super().__init__()\n        self.update(iterable, **kwds)\n\n    def __missing__(self, key):\n        'The count of elements not in the Counter is zero.'\n        # Needed so that self[missing_item] does not raise KeyError\n        return 0\n\n    def total(self):\n        'Sum of the counts'\n        return sum(self.values())\n\n    def most_common(self, n=None):\n        '''List the n most common elements and their counts from the most\n        common to the least.  If n is None, then list all element counts.\n\n        >>> Counter('abracadabra').most_common(3)\n        [('a', 5), ('b', 2), ('r', 2)]\n\n        '''\n        # Emulate Bag.sortedByCount from Smalltalk\n        if n is None:\n            return sorted(self.items(), key=_itemgetter(1), reverse=True)\n\n        # Lazy import to speedup Python startup time\n        import heapq\n        return heapq.nlargest(n, self.items(), key=_itemgetter(1))\n\n    def elements(self):\n        '''Iterator over elements repeating each as many times as its count.\n\n        >>> c = Counter('ABCABC')\n        >>> sorted(c.elements())\n        ['A', 'A', 'B', 'B', 'C', 'C']\n\n        Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1\n\n        >>> import math\n        >>> prime_factors = Counter({2: 2, 3: 3, 17: 1})\n        >>> math.prod(prime_factors.elements())\n        1836\n\n        Note, if an element's count has been set to zero or is a negative\n        number, elements() will ignore it.\n\n        '''\n        # Emulate Bag.do from Smalltalk and Multiset.begin from C++.\n        return _chain.from_iterable(_starmap(_repeat, self.items()))\n\n    # Override dict methods where necessary\n\n    @classmethod\n    def fromkeys(cls, iterable, v=None):\n        # There is no equivalent method for counters because the semantics\n        # would be ambiguous in cases such as Counter.fromkeys('aaabbc', v=2).\n        # Initializing counters to zero values isn't necessary because zero\n        # is already the default value for counter lookups.  Initializing\n        # to one is easily accomplished with Counter(set(iterable)).  For\n        # more exotic cases, create a dictionary first using a dictionary\n        # comprehension or dict.fromkeys().\n        raise NotImplementedError(\n            'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n\n    def update(self, iterable=None, /, **kwds):\n        '''Like dict.update() but add counts instead of replacing them.\n\n        Source can be an iterable, a dictionary, or another Counter instance.\n\n        >>> c = Counter('which')\n        >>> c.update('witch')           # add elements from another iterable\n        >>> d = Counter('watch')\n        >>> c.update(d)                 # add elements from another counter\n        >>> c['h']                      # four 'h' in which, witch, and watch\n        4\n\n        '''\n        # The regular dict.update() operation makes no sense here because the\n        # replace behavior results in some of the original untouched counts\n        # being mixed-in with all of the other counts for a mismash that\n        # doesn't have a straight-forward interpretation in most counting\n        # contexts.  Instead, we implement straight-addition.  Both the inputs\n        # and outputs are allowed to contain zero and negative counts.\n\n        if iterable is not None:\n            if isinstance(iterable, _collections_abc.Mapping):\n                if self:\n                    self_get = self.get\n                    for elem, count in iterable.items():\n                        self[elem] = count + self_get(elem, 0)\n                else:\n                    # fast path when counter is empty\n                    super().update(iterable)\n            else:\n                _count_elements(self, iterable)\n        if kwds:\n            self.update(kwds)\n\n    def subtract(self, iterable=None, /, **kwds):\n        '''Like dict.update() but subtracts counts instead of replacing them.\n        Counts can be reduced below zero.  Both the inputs and outputs are\n        allowed to contain zero and negative counts.\n\n        Source can be an iterable, a dictionary, or another Counter instance.\n\n        >>> c = Counter('which')\n        >>> c.subtract('witch')             # subtract elements from another iterable\n        >>> c.subtract(Counter('watch'))    # subtract elements from another counter\n        >>> c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch\n        0\n        >>> c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch\n        -1\n\n        '''\n        if iterable is not None:\n            self_get = self.get\n            if isinstance(iterable, _collections_abc.Mapping):\n                for elem, count in iterable.items():\n                    self[elem] = self_get(elem, 0) - count\n            else:\n                for elem in iterable:\n                    self[elem] = self_get(elem, 0) - 1\n        if kwds:\n            self.subtract(kwds)\n\n    def copy(self):\n        'Return a shallow copy.'\n        return self.__class__(self)\n\n    def __reduce__(self):\n        return self.__class__, (dict(self),)\n\n    def __delitem__(self, elem):\n        'Like dict.__delitem__() but does not raise KeyError for missing values.'\n        if elem in self:\n            super().__delitem__(elem)\n\n    def __repr__(self):\n        if not self:\n            return f'{self.__class__.__name__}()'\n        try:\n            # dict() preserves the ordering returned by most_common()\n            d = dict(self.most_common())\n        except TypeError:\n            # handle case where values are not orderable\n            d = dict(self)\n        return f'{self.__class__.__name__}({d!r})'\n\n    # Multiset-style mathematical operations discussed in:\n    #       Knuth TAOCP Volume II section 4.6.3 exercise 19\n    #       and at http://en.wikipedia.org/wiki/Multiset\n    #\n    # Outputs guaranteed to only include positive counts.\n    #\n    # To strip negative and zero counts, add-in an empty counter:\n    #       c += Counter()\n    #\n    # Results are ordered according to when an element is first\n    # encountered in the left operand and then by the order\n    # encountered in the right operand.\n    #\n    # When the multiplicities are all zero or one, multiset operations\n    # are guaranteed to be equivalent to the corresponding operations\n    # for regular sets.\n    #     Given counter multisets such as:\n    #         cp = Counter(a=1, b=0, c=1)\n    #         cq = Counter(c=1, d=0, e=1)\n    #     The corresponding regular sets would be:\n    #         sp = {'a', 'c'}\n    #         sq = {'c', 'e'}\n    #     All of the following relations would hold:\n    #         set(cp + cq) == sp | sq\n    #         set(cp - cq) == sp - sq\n    #         set(cp | cq) == sp | sq\n    #         set(cp & cq) == sp & sq\n    #         (cp == cq) == (sp == sq)\n    #         (cp != cq) == (sp != sq)\n    #         (cp <= cq) == (sp <= sq)\n    #         (cp < cq) == (sp < sq)\n    #         (cp >= cq) == (sp >= sq)\n    #         (cp > cq) == (sp > sq)\n\n    def __eq__(self, other):\n        'True if all counts agree. Missing counts are treated as zero.'\n        if not isinstance(other, Counter):\n            return NotImplemented\n        return all(self[e] == other[e] for c in (self, other) for e in c)\n\n    def __ne__(self, other):\n        'True if any counts disagree. Missing counts are treated as zero.'\n        if not isinstance(other, Counter):\n            return NotImplemented\n        return not self == other\n\n    def __le__(self, other):\n        'True if all counts in self are a subset of those in other.'\n        if not isinstance(other, Counter):\n            return NotImplemented\n        return all(self[e] <= other[e] for c in (self, other) for e in c)\n\n    def __lt__(self, other):\n        'True if all counts in self are a proper subset of those in other.'\n        if not isinstance(other, Counter):\n            return NotImplemented\n        return self <= other and self != other\n\n    def __ge__(self, other):\n        'True if all counts in self are a superset of those in other.'\n        if not isinstance(other, Counter):\n            return NotImplemented\n        return all(self[e] >= other[e] for c in (self, other) for e in c)\n\n    def __gt__(self, other):\n        'True if all counts in self are a proper superset of those in other.'\n        if not isinstance(other, Counter):\n            return NotImplemented\n        return self >= other and self != other\n\n    def __add__(self, other):\n        '''Add counts from two counters.\n\n        >>> Counter('abbb') + Counter('bcc')\n        Counter({'b': 4, 'c': 2, 'a': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem, count in self.items():\n            newcount = count + other[elem]\n            if newcount > 0:\n                result[elem] = newcount\n        for elem, count in other.items():\n            if elem not in self and count > 0:\n                result[elem] = count\n        return result\n\n    def __sub__(self, other):\n        ''' Subtract count, but keep only results with positive counts.\n\n        >>> Counter('abbbc') - Counter('bccd')\n        Counter({'b': 2, 'a': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem, count in self.items():\n            newcount = count - other[elem]\n            if newcount > 0:\n                result[elem] = newcount\n        for elem, count in other.items():\n            if elem not in self and count < 0:\n                result[elem] = 0 - count\n        return result\n\n    def __or__(self, other):\n        '''Union is the maximum of value in either of the input counters.\n\n        >>> Counter('abbb') | Counter('bcc')\n        Counter({'b': 3, 'c': 2, 'a': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem, count in self.items():\n            other_count = other[elem]\n            newcount = other_count if count < other_count else count\n            if newcount > 0:\n                result[elem] = newcount\n        for elem, count in other.items():\n            if elem not in self and count > 0:\n                result[elem] = count\n        return result\n\n    def __and__(self, other):\n        ''' Intersection is the minimum of corresponding counts.\n\n        >>> Counter('abbb') & Counter('bcc')\n        Counter({'b': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem, count in self.items():\n            other_count = other[elem]\n            newcount = count if count < other_count else other_count\n            if newcount > 0:\n                result[elem] = newcount\n        return result\n\n    def __pos__(self):\n        'Adds an empty counter, effectively stripping negative and zero counts'\n        result = Counter()\n        for elem, count in self.items():\n            if count > 0:\n                result[elem] = count\n        return result\n\n    def __neg__(self):\n        '''Subtracts from an empty counter.  Strips positive and zero counts,\n        and flips the sign on negative counts.\n\n        '''\n        result = Counter()\n        for elem, count in self.items():\n            if count < 0:\n                result[elem] = 0 - count\n        return result\n\n    def _keep_positive(self):\n        '''Internal method to strip elements with a negative or zero count'''\n        nonpositive = [elem for elem, count in self.items() if not count > 0]\n        for elem in nonpositive:\n            del self[elem]\n        return self\n\n    def __iadd__(self, other):\n        '''Inplace add from another counter, keeping only positive counts.\n\n        >>> c = Counter('abbb')\n        >>> c += Counter('bcc')\n        >>> c\n        Counter({'b': 4, 'c': 2, 'a': 1})\n\n        '''\n        for elem, count in other.items():\n            self[elem] += count\n        return self._keep_positive()\n\n    def __isub__(self, other):\n        '''Inplace subtract counter, but keep only results with positive counts.\n\n        >>> c = Counter('abbbc')\n        >>> c -= Counter('bccd')\n        >>> c\n        Counter({'b': 2, 'a': 1})\n\n        '''\n        for elem, count in other.items():\n            self[elem] -= count\n        return self._keep_positive()\n\n    def __ior__(self, other):\n        '''Inplace union is the maximum of value from either counter.\n\n        >>> c = Counter('abbb')\n        >>> c |= Counter('bcc')\n        >>> c\n        Counter({'b': 3, 'c': 2, 'a': 1})\n\n        '''\n        for elem, other_count in other.items():\n            count = self[elem]\n            if other_count > count:\n                self[elem] = other_count\n        return self._keep_positive()\n\n    def __iand__(self, other):\n        '''Inplace intersection is the minimum of corresponding counts.\n\n        >>> c = Counter('abbb')\n        >>> c &= Counter('bcc')\n        >>> c\n        Counter({'b': 1})\n\n        '''\n        for elem, count in self.items():\n            other_count = other[elem]\n            if other_count < count:\n                self[elem] = other_count\n        return self._keep_positive()\n\n\n########################################################################\n###  ChainMap\n########################################################################\n\nclass ChainMap(_collections_abc.MutableMapping):\n    ''' A ChainMap groups multiple dicts (or other mappings) together\n    to create a single, updateable view.\n\n    The underlying mappings are stored in a list.  That list is public and can\n    be accessed or updated using the *maps* attribute.  There is no other\n    state.\n\n    Lookups search the underlying mappings successively until a key is found.\n    In contrast, writes, updates, and deletions only operate on the first\n    mapping.\n\n    '''\n\n    def __init__(self, *maps):\n        '''Initialize a ChainMap by setting *maps* to the given mappings.\n        If no mappings are provided, a single empty dictionary is used.\n\n        '''\n        self.maps = list(maps) or [{}]          # always at least one map\n\n    def __missing__(self, key):\n        raise KeyError(key)\n\n    def __getitem__(self, key):\n        for mapping in self.maps:\n            try:\n                return mapping[key]             # can't use 'key in mapping' with defaultdict\n            except KeyError:\n                pass\n        return self.__missing__(key)            # support subclasses that define __missing__\n\n    def get(self, key, default=None):\n        return self[key] if key in self else default\n\n    def __len__(self):\n        return len(set().union(*self.maps))     # reuses stored hash values if possible\n\n    def __iter__(self):\n        d = {}\n        for mapping in map(dict.fromkeys, reversed(self.maps)):\n            d |= mapping                        # reuses stored hash values if possible\n        return iter(d)\n\n    def __contains__(self, key):\n        return any(key in m for m in self.maps)\n\n    def __bool__(self):\n        return any(self.maps)\n\n    @_recursive_repr()\n    def __repr__(self):\n        return f'{self.__class__.__name__}({\", \".join(map(repr, self.maps))})'\n\n    @classmethod\n    def fromkeys(cls, iterable, value=None, /):\n        'Create a new ChainMap with keys from iterable and values set to value.'\n        return cls(dict.fromkeys(iterable, value))\n\n    def copy(self):\n        'New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'\n        return self.__class__(self.maps[0].copy(), *self.maps[1:])\n\n    __copy__ = copy\n\n    def new_child(self, m=None, **kwargs):      # like Django's Context.push()\n        '''New ChainMap with a new map followed by all previous maps.\n        If no map is provided, an empty dict is used.\n        Keyword arguments update the map or new empty dict.\n        '''\n        if m is None:\n            m = kwargs\n        elif kwargs:\n            m.update(kwargs)\n        return self.__class__(m, *self.maps)\n\n    @property\n    def parents(self):                          # like Django's Context.pop()\n        'New ChainMap from maps[1:].'\n        return self.__class__(*self.maps[1:])\n\n    def __setitem__(self, key, value):\n        self.maps[0][key] = value\n\n    def __delitem__(self, key):\n        try:\n            del self.maps[0][key]\n        except KeyError:\n            raise KeyError(f'Key not found in the first mapping: {key!r}')\n\n    def popitem(self):\n        'Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'\n        try:\n            return self.maps[0].popitem()\n        except KeyError:\n            raise KeyError('No keys found in the first mapping.')\n\n    def pop(self, key, *args):\n        'Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'\n        try:\n            return self.maps[0].pop(key, *args)\n        except KeyError:\n            raise KeyError(f'Key not found in the first mapping: {key!r}')\n\n    def clear(self):\n        'Clear maps[0], leaving maps[1:] intact.'\n        self.maps[0].clear()\n\n    def __ior__(self, other):\n        self.maps[0].update(other)\n        return self\n\n    def __or__(self, other):\n        if not isinstance(other, _collections_abc.Mapping):\n            return NotImplemented\n        m = self.copy()\n        m.maps[0].update(other)\n        return m\n\n    def __ror__(self, other):\n        if not isinstance(other, _collections_abc.Mapping):\n            return NotImplemented\n        m = dict(other)\n        for child in reversed(self.maps):\n            m.update(child)\n        return self.__class__(m)\n\n\n################################################################################\n### UserDict\n################################################################################\n\nclass UserDict(_collections_abc.MutableMapping):\n\n    # Start by filling-out the abstract methods\n    def __init__(self, dict=None, /, **kwargs):\n        self.data = {}\n        if dict is not None:\n            self.update(dict)\n        if kwargs:\n            self.update(kwargs)\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, key):\n        if key in self.data:\n            return self.data[key]\n        if hasattr(self.__class__, \"__missing__\"):\n            return self.__class__.__missing__(self, key)\n        raise KeyError(key)\n\n    def __setitem__(self, key, item):\n        self.data[key] = item\n\n    def __delitem__(self, key):\n        del self.data[key]\n\n    def __iter__(self):\n        return iter(self.data)\n\n    # Modify __contains__ and get() to work like dict\n    # does when __missing__ is present.\n    def __contains__(self, key):\n        return key in self.data\n\n    def get(self, key, default=None):\n        if key in self:\n            return self[key]\n        return default\n\n\n    # Now, add the methods in dicts but not in MutableMapping\n    def __repr__(self):\n        return repr(self.data)\n\n    def __or__(self, other):\n        if isinstance(other, UserDict):\n            return self.__class__(self.data | other.data)\n        if isinstance(other, dict):\n            return self.__class__(self.data | other)\n        return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, UserDict):\n            return self.__class__(other.data | self.data)\n        if isinstance(other, dict):\n            return self.__class__(other | self.data)\n        return NotImplemented\n\n    def __ior__(self, other):\n        if isinstance(other, UserDict):\n            self.data |= other.data\n        else:\n            self.data |= other\n        return self\n\n    def __copy__(self):\n        inst = self.__class__.__new__(self.__class__)\n        inst.__dict__.update(self.__dict__)\n        # Create a copy and avoid triggering descriptors\n        inst.__dict__[\"data\"] = self.__dict__[\"data\"].copy()\n        return inst\n\n    def copy(self):\n        if self.__class__ is UserDict:\n            return UserDict(self.data.copy())\n        import copy\n        data = self.data\n        try:\n            self.data = {}\n            c = copy.copy(self)\n        finally:\n            self.data = data\n        c.update(self)\n        return c\n\n    @classmethod\n    def fromkeys(cls, iterable, value=None):\n        d = cls()\n        for key in iterable:\n            d[key] = value\n        return d\n\n\n################################################################################\n### UserList\n################################################################################\n\nclass UserList(_collections_abc.MutableSequence):\n    \"\"\"A more or less complete user-defined wrapper around list objects.\"\"\"\n\n    def __init__(self, initlist=None):\n        self.data = []\n        if initlist is not None:\n            # XXX should this accept an arbitrary sequence?\n            if type(initlist) == type(self.data):\n                self.data[:] = initlist\n            elif isinstance(initlist, UserList):\n                self.data[:] = initlist.data[:]\n            else:\n                self.data = list(initlist)\n\n    def __repr__(self):\n        return repr(self.data)\n\n    def __lt__(self, other):\n        return self.data < self.__cast(other)\n\n    def __le__(self, other):\n        return self.data <= self.__cast(other)\n\n    def __eq__(self, other):\n        return self.data == self.__cast(other)\n\n    def __gt__(self, other):\n        return self.data > self.__cast(other)\n\n    def __ge__(self, other):\n        return self.data >= self.__cast(other)\n\n    def __cast(self, other):\n        return other.data if isinstance(other, UserList) else other\n\n    def __contains__(self, item):\n        return item in self.data\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, i):\n        if isinstance(i, slice):\n            return self.__class__(self.data[i])\n        else:\n            return self.data[i]\n\n    def __setitem__(self, i, item):\n        self.data[i] = item\n\n    def __delitem__(self, i):\n        del self.data[i]\n\n    def __add__(self, other):\n        if isinstance(other, UserList):\n            return self.__class__(self.data + other.data)\n        elif isinstance(other, type(self.data)):\n            return self.__class__(self.data + other)\n        return self.__class__(self.data + list(other))\n\n    def __radd__(self, other):\n        if isinstance(other, UserList):\n            return self.__class__(other.data + self.data)\n        elif isinstance(other, type(self.data)):\n            return self.__class__(other + self.data)\n        return self.__class__(list(other) + self.data)\n\n    def __iadd__(self, other):\n        if isinstance(other, UserList):\n            self.data += other.data\n        elif isinstance(other, type(self.data)):\n            self.data += other\n        else:\n            self.data += list(other)\n        return self\n\n    def __mul__(self, n):\n        return self.__class__(self.data * n)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, n):\n        self.data *= n\n        return self\n\n    def __copy__(self):\n        inst = self.__class__.__new__(self.__class__)\n        inst.__dict__.update(self.__dict__)\n        # Create a copy and avoid triggering descriptors\n        inst.__dict__[\"data\"] = self.__dict__[\"data\"][:]\n        return inst\n\n    def append(self, item):\n        self.data.append(item)\n\n    def insert(self, i, item):\n        self.data.insert(i, item)\n\n    def pop(self, i=-1):\n        return self.data.pop(i)\n\n    def remove(self, item):\n        self.data.remove(item)\n\n    def clear(self):\n        self.data.clear()\n\n    def copy(self):\n        return self.__class__(self)\n\n    def count(self, item):\n        return self.data.count(item)\n\n    def index(self, item, *args):\n        return self.data.index(item, *args)\n\n    def reverse(self):\n        self.data.reverse()\n\n    def sort(self, /, *args, **kwds):\n        self.data.sort(*args, **kwds)\n\n    def extend(self, other):\n        if isinstance(other, UserList):\n            self.data.extend(other.data)\n        else:\n            self.data.extend(other)\n\n\n################################################################################\n### UserString\n################################################################################\n\nclass UserString(_collections_abc.Sequence):\n\n    def __init__(self, seq):\n        if isinstance(seq, str):\n            self.data = seq\n        elif isinstance(seq, UserString):\n            self.data = seq.data[:]\n        else:\n            self.data = str(seq)\n\n    def __str__(self):\n        return str(self.data)\n\n    def __repr__(self):\n        return repr(self.data)\n\n    def __int__(self):\n        return int(self.data)\n\n    def __float__(self):\n        return float(self.data)\n\n    def __complex__(self):\n        return complex(self.data)\n\n    def __hash__(self):\n        return hash(self.data)\n\n    def __getnewargs__(self):\n        return (self.data[:],)\n\n    def __eq__(self, string):\n        if isinstance(string, UserString):\n            return self.data == string.data\n        return self.data == string\n\n    def __lt__(self, string):\n        if isinstance(string, UserString):\n            return self.data < string.data\n        return self.data < string\n\n    def __le__(self, string):\n        if isinstance(string, UserString):\n            return self.data <= string.data\n        return self.data <= string\n\n    def __gt__(self, string):\n        if isinstance(string, UserString):\n            return self.data > string.data\n        return self.data > string\n\n    def __ge__(self, string):\n        if isinstance(string, UserString):\n            return self.data >= string.data\n        return self.data >= string\n\n    def __contains__(self, char):\n        if isinstance(char, UserString):\n            char = char.data\n        return char in self.data\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, index):\n        return self.__class__(self.data[index])\n\n    def __add__(self, other):\n        if isinstance(other, UserString):\n            return self.__class__(self.data + other.data)\n        elif isinstance(other, str):\n            return self.__class__(self.data + other)\n        return self.__class__(self.data + str(other))\n\n    def __radd__(self, other):\n        if isinstance(other, str):\n            return self.__class__(other + self.data)\n        return self.__class__(str(other) + self.data)\n\n    def __mul__(self, n):\n        return self.__class__(self.data * n)\n\n    __rmul__ = __mul__\n\n    def __mod__(self, args):\n        return self.__class__(self.data % args)\n\n    def __rmod__(self, template):\n        return self.__class__(str(template) % self)\n\n    # the following methods are defined in alphabetical order:\n    def capitalize(self):\n        return self.__class__(self.data.capitalize())\n\n    def casefold(self):\n        return self.__class__(self.data.casefold())\n\n    def center(self, width, *args):\n        return self.__class__(self.data.center(width, *args))\n\n    def count(self, sub, start=0, end=_sys.maxsize):\n        if isinstance(sub, UserString):\n            sub = sub.data\n        return self.data.count(sub, start, end)\n\n    def removeprefix(self, prefix, /):\n        if isinstance(prefix, UserString):\n            prefix = prefix.data\n        return self.__class__(self.data.removeprefix(prefix))\n\n    def removesuffix(self, suffix, /):\n        if isinstance(suffix, UserString):\n            suffix = suffix.data\n        return self.__class__(self.data.removesuffix(suffix))\n\n    def encode(self, encoding='utf-8', errors='strict'):\n        encoding = 'utf-8' if encoding is None else encoding\n        errors = 'strict' if errors is None else errors\n        return self.data.encode(encoding, errors)\n\n    def endswith(self, suffix, start=0, end=_sys.maxsize):\n        return self.data.endswith(suffix, start, end)\n\n    def expandtabs(self, tabsize=8):\n        return self.__class__(self.data.expandtabs(tabsize))\n\n    def find(self, sub, start=0, end=_sys.maxsize):\n        if isinstance(sub, UserString):\n            sub = sub.data\n        return self.data.find(sub, start, end)\n\n    def format(self, /, *args, **kwds):\n        return self.data.format(*args, **kwds)\n\n    def format_map(self, mapping):\n        return self.data.format_map(mapping)\n\n    def index(self, sub, start=0, end=_sys.maxsize):\n        return self.data.index(sub, start, end)\n\n    def isalpha(self):\n        return self.data.isalpha()\n\n    def isalnum(self):\n        return self.data.isalnum()\n\n    def isascii(self):\n        return self.data.isascii()\n\n    def isdecimal(self):\n        return self.data.isdecimal()\n\n    def isdigit(self):\n        return self.data.isdigit()\n\n    def isidentifier(self):\n        return self.data.isidentifier()\n\n    def islower(self):\n        return self.data.islower()\n\n    def isnumeric(self):\n        return self.data.isnumeric()\n\n    def isprintable(self):\n        return self.data.isprintable()\n\n    def isspace(self):\n        return self.data.isspace()\n\n    def istitle(self):\n        return self.data.istitle()\n\n    def isupper(self):\n        return self.data.isupper()\n\n    def join(self, seq):\n        return self.data.join(seq)\n\n    def ljust(self, width, *args):\n        return self.__class__(self.data.ljust(width, *args))\n\n    def lower(self):\n        return self.__class__(self.data.lower())\n\n    def lstrip(self, chars=None):\n        return self.__class__(self.data.lstrip(chars))\n\n    maketrans = str.maketrans\n\n    def partition(self, sep):\n        return self.data.partition(sep)\n\n    def replace(self, old, new, maxsplit=-1):\n        if isinstance(old, UserString):\n            old = old.data\n        if isinstance(new, UserString):\n            new = new.data\n        return self.__class__(self.data.replace(old, new, maxsplit))\n\n    def rfind(self, sub, start=0, end=_sys.maxsize):\n        if isinstance(sub, UserString):\n            sub = sub.data\n        return self.data.rfind(sub, start, end)\n\n    def rindex(self, sub, start=0, end=_sys.maxsize):\n        return self.data.rindex(sub, start, end)\n\n    def rjust(self, width, *args):\n        return self.__class__(self.data.rjust(width, *args))\n\n    def rpartition(self, sep):\n        return self.data.rpartition(sep)\n\n    def rstrip(self, chars=None):\n        return self.__class__(self.data.rstrip(chars))\n\n    def split(self, sep=None, maxsplit=-1):\n        return self.data.split(sep, maxsplit)\n\n    def rsplit(self, sep=None, maxsplit=-1):\n        return self.data.rsplit(sep, maxsplit)\n\n    def splitlines(self, keepends=False):\n        return self.data.splitlines(keepends)\n\n    def startswith(self, prefix, start=0, end=_sys.maxsize):\n        return self.data.startswith(prefix, start, end)\n\n    def strip(self, chars=None):\n        return self.__class__(self.data.strip(chars))\n\n    def swapcase(self):\n        return self.__class__(self.data.swapcase())\n\n    def title(self):\n        return self.__class__(self.data.title())\n\n    def translate(self, *args):\n        return self.__class__(self.data.translate(*args))\n\n    def upper(self):\n        return self.__class__(self.data.upper())\n\n    def zfill(self, width):\n        return self.__class__(self.data.zfill(width))\n", 1596], "C:\\Programming\\Python313\\Lib\\subprocess.py": ["# subprocess - Subprocesses with accessible I/O streams\n#\n# For more information about this module, see PEP 324.\n#\n# Copyright (c) 2003-2005 by Peter Astrand <astrand@lysator.liu.se>\n#\n# Licensed to PSF under a Contributor Agreement.\n\nr\"\"\"Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.\n\nFor a complete description of this module see the Python documentation.\n\nMain API\n========\nrun(...): Runs a command, waits for it to complete, then returns a\n          CompletedProcess instance.\nPopen(...): A class for flexibly executing a command in a new process\n\nConstants\n---------\nDEVNULL: Special value that indicates that os.devnull should be used\nPIPE:    Special value that indicates a pipe should be created\nSTDOUT:  Special value that indicates that stderr should go to stdout\n\n\nOlder API\n=========\ncall(...): Runs a command, waits for it to complete, then returns\n    the return code.\ncheck_call(...): Same as call() but raises CalledProcessError()\n    if return code is not 0\ncheck_output(...): Same as check_call() but returns the contents of\n    stdout instead of a return code\ngetoutput(...): Runs a command in the shell, waits for it to complete,\n    then returns the output\ngetstatusoutput(...): Runs a command in the shell, waits for it to complete,\n    then returns a (exitcode, output) tuple\n\"\"\"\n\nimport builtins\nimport errno\nimport io\nimport os\nimport time\nimport sys\nimport threading\nimport warnings\nimport contextlib\nfrom time import monotonic as _time\nimport types\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\n\n__all__ = [\"Popen\", \"PIPE\", \"STDOUT\", \"call\", \"check_call\", \"getstatusoutput\",\n           \"getoutput\", \"check_output\", \"run\", \"CalledProcessError\", \"DEVNULL\",\n           \"SubprocessError\", \"TimeoutExpired\", \"CompletedProcess\"]\n           # NOTE: We intentionally exclude list2cmdline as it is\n           # considered an internal implementation detail.  issue10838.\n\n# use presence of msvcrt to detect Windows-like platforms (see bpo-8110)\ntry:\n    import msvcrt\nexcept ModuleNotFoundError:\n    _mswindows = False\nelse:\n    _mswindows = True\n\n# some platforms do not support subprocesses\n_can_fork_exec = sys.platform not in {\"emscripten\", \"wasi\", \"ios\", \"tvos\", \"watchos\"}\n\nif _mswindows:\n    import _winapi\n    from _winapi import (CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS_GROUP,\n                         STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,\n                         STD_ERROR_HANDLE, SW_HIDE,\n                         STARTF_USESTDHANDLES, STARTF_USESHOWWINDOW,\n                         STARTF_FORCEONFEEDBACK, STARTF_FORCEOFFFEEDBACK,\n                         ABOVE_NORMAL_PRIORITY_CLASS, BELOW_NORMAL_PRIORITY_CLASS,\n                         HIGH_PRIORITY_CLASS, IDLE_PRIORITY_CLASS,\n                         NORMAL_PRIORITY_CLASS, REALTIME_PRIORITY_CLASS,\n                         CREATE_NO_WINDOW, DETACHED_PROCESS,\n                         CREATE_DEFAULT_ERROR_MODE, CREATE_BREAKAWAY_FROM_JOB)\n\n    __all__.extend([\"CREATE_NEW_CONSOLE\", \"CREATE_NEW_PROCESS_GROUP\",\n                    \"STD_INPUT_HANDLE\", \"STD_OUTPUT_HANDLE\",\n                    \"STD_ERROR_HANDLE\", \"SW_HIDE\",\n                    \"STARTF_USESTDHANDLES\", \"STARTF_USESHOWWINDOW\",\n                    \"STARTF_FORCEONFEEDBACK\", \"STARTF_FORCEOFFFEEDBACK\",\n                    \"STARTUPINFO\",\n                    \"ABOVE_NORMAL_PRIORITY_CLASS\", \"BELOW_NORMAL_PRIORITY_CLASS\",\n                    \"HIGH_PRIORITY_CLASS\", \"IDLE_PRIORITY_CLASS\",\n                    \"NORMAL_PRIORITY_CLASS\", \"REALTIME_PRIORITY_CLASS\",\n                    \"CREATE_NO_WINDOW\", \"DETACHED_PROCESS\",\n                    \"CREATE_DEFAULT_ERROR_MODE\", \"CREATE_BREAKAWAY_FROM_JOB\"])\nelse:\n    if _can_fork_exec:\n        from _posixsubprocess import fork_exec as _fork_exec\n        # used in methods that are called by __del__\n        class _del_safe:\n            waitpid = os.waitpid\n            waitstatus_to_exitcode = os.waitstatus_to_exitcode\n            WIFSTOPPED = os.WIFSTOPPED\n            WSTOPSIG = os.WSTOPSIG\n            WNOHANG = os.WNOHANG\n            ECHILD = errno.ECHILD\n    else:\n        class _del_safe:\n            waitpid = None\n            waitstatus_to_exitcode = None\n            WIFSTOPPED = None\n            WSTOPSIG = None\n            WNOHANG = None\n            ECHILD = errno.ECHILD\n\n    import select\n    import selectors\n\n\n# Exception classes used by this module.\nclass SubprocessError(Exception): pass\n\n\nclass CalledProcessError(SubprocessError):\n    \"\"\"Raised when run() is called with check=True and the process\n    returns a non-zero exit status.\n\n    Attributes:\n      cmd, returncode, stdout, stderr, output\n    \"\"\"\n    def __init__(self, returncode, cmd, output=None, stderr=None):\n        self.returncode = returncode\n        self.cmd = cmd\n        self.output = output\n        self.stderr = stderr\n\n    def __str__(self):\n        if self.returncode and self.returncode < 0:\n            # Lazy import to improve module import time\n            import signal\n            try:\n                return \"Command '%s' died with %r.\" % (\n                        self.cmd, signal.Signals(-self.returncode))\n            except ValueError:\n                return \"Command '%s' died with unknown signal %d.\" % (\n                        self.cmd, -self.returncode)\n        else:\n            return \"Command '%s' returned non-zero exit status %d.\" % (\n                    self.cmd, self.returncode)\n\n    @property\n    def stdout(self):\n        \"\"\"Alias for output attribute, to match stderr\"\"\"\n        return self.output\n\n    @stdout.setter\n    def stdout(self, value):\n        # There's no obvious reason to set this, but allow it anyway so\n        # .stdout is a transparent alias for .output\n        self.output = value\n\n\nclass TimeoutExpired(SubprocessError):\n    \"\"\"This exception is raised when the timeout expires while waiting for a\n    child process.\n\n    Attributes:\n        cmd, output, stdout, stderr, timeout\n    \"\"\"\n    def __init__(self, cmd, timeout, output=None, stderr=None):\n        self.cmd = cmd\n        self.timeout = timeout\n        self.output = output\n        self.stderr = stderr\n\n    def __str__(self):\n        return (\"Command '%s' timed out after %s seconds\" %\n                (self.cmd, self.timeout))\n\n    @property\n    def stdout(self):\n        return self.output\n\n    @stdout.setter\n    def stdout(self, value):\n        # There's no obvious reason to set this, but allow it anyway so\n        # .stdout is a transparent alias for .output\n        self.output = value\n\n\nif _mswindows:\n    class STARTUPINFO:\n        def __init__(self, *, dwFlags=0, hStdInput=None, hStdOutput=None,\n                     hStdError=None, wShowWindow=0, lpAttributeList=None):\n            self.dwFlags = dwFlags\n            self.hStdInput = hStdInput\n            self.hStdOutput = hStdOutput\n            self.hStdError = hStdError\n            self.wShowWindow = wShowWindow\n            self.lpAttributeList = lpAttributeList or {\"handle_list\": []}\n\n        def copy(self):\n            attr_list = self.lpAttributeList.copy()\n            if 'handle_list' in attr_list:\n                attr_list['handle_list'] = list(attr_list['handle_list'])\n\n            return STARTUPINFO(dwFlags=self.dwFlags,\n                               hStdInput=self.hStdInput,\n                               hStdOutput=self.hStdOutput,\n                               hStdError=self.hStdError,\n                               wShowWindow=self.wShowWindow,\n                               lpAttributeList=attr_list)\n\n\n    class Handle(int):\n        closed = False\n\n        def Close(self, CloseHandle=_winapi.CloseHandle):\n            if not self.closed:\n                self.closed = True\n                CloseHandle(self)\n\n        def Detach(self):\n            if not self.closed:\n                self.closed = True\n                return int(self)\n            raise ValueError(\"already closed\")\n\n        def __repr__(self):\n            return \"%s(%d)\" % (self.__class__.__name__, int(self))\n\n        __del__ = Close\nelse:\n    # When select or poll has indicated that the file is writable,\n    # we can write up to _PIPE_BUF bytes without risk of blocking.\n    # POSIX defines PIPE_BUF as >= 512.\n    _PIPE_BUF = getattr(select, 'PIPE_BUF', 512)\n\n    # poll/select have the advantage of not requiring any extra file\n    # descriptor, contrarily to epoll/kqueue (also, they require a single\n    # syscall).\n    if hasattr(selectors, 'PollSelector'):\n        _PopenSelector = selectors.PollSelector\n    else:\n        _PopenSelector = selectors.SelectSelector\n\n\nif _mswindows:\n    # On Windows we just need to close `Popen._handle` when we no longer need\n    # it, so that the kernel can free it. `Popen._handle` gets closed\n    # implicitly when the `Popen` instance is finalized (see `Handle.__del__`,\n    # which is calling `CloseHandle` as requested in [1]), so there is nothing\n    # for `_cleanup` to do.\n    #\n    # [1] https://docs.microsoft.com/en-us/windows/desktop/ProcThread/\n    # creating-processes\n    _active = None\n\n    def _cleanup():\n        pass\nelse:\n    # This lists holds Popen instances for which the underlying process had not\n    # exited at the time its __del__ method got called: those processes are\n    # wait()ed for synchronously from _cleanup() when a new Popen object is\n    # created, to avoid zombie processes.\n    _active = []\n\n    def _cleanup():\n        if _active is None:\n            return\n        for inst in _active[:]:\n            res = inst._internal_poll(_deadstate=sys.maxsize)\n            if res is not None:\n                try:\n                    _active.remove(inst)\n                except ValueError:\n                    # This can happen if two threads create a new Popen instance.\n                    # It's harmless that it was already removed, so ignore.\n                    pass\n\nPIPE = -1\nSTDOUT = -2\nDEVNULL = -3\n\n\n# XXX This function is only used by multiprocessing and the test suite,\n# but it's here so that it can be imported when Python is compiled without\n# threads.\n\ndef _optim_args_from_interpreter_flags():\n    \"\"\"Return a list of command-line arguments reproducing the current\n    optimization settings in sys.flags.\"\"\"\n    args = []\n    value = sys.flags.optimize\n    if value > 0:\n        args.append('-' + 'O' * value)\n    return args\n\n\ndef _args_from_interpreter_flags():\n    \"\"\"Return a list of command-line arguments reproducing the current\n    settings in sys.flags, sys.warnoptions and sys._xoptions.\"\"\"\n    flag_opt_map = {\n        'debug': 'd',\n        # 'inspect': 'i',\n        # 'interactive': 'i',\n        'dont_write_bytecode': 'B',\n        'no_site': 'S',\n        'verbose': 'v',\n        'bytes_warning': 'b',\n        'quiet': 'q',\n        # -O is handled in _optim_args_from_interpreter_flags()\n    }\n    args = _optim_args_from_interpreter_flags()\n    for flag, opt in flag_opt_map.items():\n        v = getattr(sys.flags, flag)\n        if v > 0:\n            args.append('-' + opt * v)\n\n    if sys.flags.isolated:\n        args.append('-I')\n    else:\n        if sys.flags.ignore_environment:\n            args.append('-E')\n        if sys.flags.no_user_site:\n            args.append('-s')\n        if sys.flags.safe_path:\n            args.append('-P')\n\n    # -W options\n    warnopts = sys.warnoptions[:]\n    xoptions = getattr(sys, '_xoptions', {})\n    bytes_warning = sys.flags.bytes_warning\n    dev_mode = sys.flags.dev_mode\n\n    if bytes_warning > 1:\n        warnopts.remove(\"error::BytesWarning\")\n    elif bytes_warning:\n        warnopts.remove(\"default::BytesWarning\")\n    if dev_mode:\n        warnopts.remove('default')\n    for opt in warnopts:\n        args.append('-W' + opt)\n\n    # -X options\n    if dev_mode:\n        args.extend(('-X', 'dev'))\n    for opt in ('faulthandler', 'tracemalloc', 'importtime',\n                'frozen_modules', 'showrefcount', 'utf8', 'gil'):\n        if opt in xoptions:\n            value = xoptions[opt]\n            if value is True:\n                arg = opt\n            else:\n                arg = '%s=%s' % (opt, value)\n            args.extend(('-X', arg))\n\n    return args\n\n\ndef _text_encoding():\n    # Return default text encoding and emit EncodingWarning if\n    # sys.flags.warn_default_encoding is true.\n    if sys.flags.warn_default_encoding:\n        f = sys._getframe()\n        filename = f.f_code.co_filename\n        stacklevel = 2\n        while f := f.f_back:\n            if f.f_code.co_filename != filename:\n                break\n            stacklevel += 1\n        warnings.warn(\"'encoding' argument not specified.\",\n                      EncodingWarning, stacklevel)\n\n    if sys.flags.utf8_mode:\n        return \"utf-8\"\n    else:\n        # Lazy import to improve module import time\n        import locale\n        return locale.getencoding()\n\n\ndef call(*popenargs, timeout=None, **kwargs):\n    \"\"\"Run command with arguments.  Wait for command to complete or\n    for timeout seconds, then return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    retcode = call([\"ls\", \"-l\"])\n    \"\"\"\n    with Popen(*popenargs, **kwargs) as p:\n        try:\n            return p.wait(timeout=timeout)\n        except:  # Including KeyboardInterrupt, wait handled that.\n            p.kill()\n            # We don't call p.wait() again as p.__exit__ does that for us.\n            raise\n\n\ndef check_call(*popenargs, **kwargs):\n    \"\"\"Run command with arguments.  Wait for command to complete.  If\n    the exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n\n    The arguments are the same as for the call function.  Example:\n\n    check_call([\"ls\", \"-l\"])\n    \"\"\"\n    retcode = call(*popenargs, **kwargs)\n    if retcode:\n        cmd = kwargs.get(\"args\")\n        if cmd is None:\n            cmd = popenargs[0]\n        raise CalledProcessError(retcode, cmd)\n    return 0\n\n\ndef check_output(*popenargs, timeout=None, **kwargs):\n    r\"\"\"Run command with arguments and return its output.\n\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> check_output([\"ls\", \"-l\", \"/dev/null\"])\n    b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n\n    The stdout argument is not allowed as it is used internally.\n    To capture standard error in the result, use stderr=STDOUT.\n\n    >>> check_output([\"/bin/sh\", \"-c\",\n    ...               \"ls -l non_existent_file ; exit 0\"],\n    ...              stderr=STDOUT)\n    b'ls: non_existent_file: No such file or directory\\n'\n\n    There is an additional optional argument, \"input\", allowing you to\n    pass a string to the subprocess's stdin.  If you use this argument\n    you may not also use the Popen constructor's \"stdin\" argument, as\n    it too will be used internally.  Example:\n\n    >>> check_output([\"sed\", \"-e\", \"s/foo/bar/\"],\n    ...              input=b\"when in the course of fooman events\\n\")\n    b'when in the course of barman events\\n'\n\n    By default, all communication is in bytes, and therefore any \"input\"\n    should be bytes, and the return value will be bytes.  If in text mode,\n    any \"input\" should be a string, and the return value will be a string\n    decoded according to locale encoding, or by \"encoding\" if set. Text mode\n    is triggered by setting any of text, encoding, errors or universal_newlines.\n    \"\"\"\n    for kw in ('stdout', 'check'):\n        if kw in kwargs:\n            raise ValueError(f'{kw} argument not allowed, it will be overridden.')\n\n    if 'input' in kwargs and kwargs['input'] is None:\n        # Explicitly passing input=None was previously equivalent to passing an\n        # empty string. That is maintained here for backwards compatibility.\n        if kwargs.get('universal_newlines') or kwargs.get('text') or kwargs.get('encoding') \\\n                or kwargs.get('errors'):\n            empty = ''\n        else:\n            empty = b''\n        kwargs['input'] = empty\n\n    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,\n               **kwargs).stdout\n\n\nclass CompletedProcess(object):\n    \"\"\"A process that has finished running.\n\n    This is returned by run().\n\n    Attributes:\n      args: The list or str args passed to run().\n      returncode: The exit code of the process, negative for signals.\n      stdout: The standard output (None if not captured).\n      stderr: The standard error (None if not captured).\n    \"\"\"\n    def __init__(self, args, returncode, stdout=None, stderr=None):\n        self.args = args\n        self.returncode = returncode\n        self.stdout = stdout\n        self.stderr = stderr\n\n    def __repr__(self):\n        args = ['args={!r}'.format(self.args),\n                'returncode={!r}'.format(self.returncode)]\n        if self.stdout is not None:\n            args.append('stdout={!r}'.format(self.stdout))\n        if self.stderr is not None:\n            args.append('stderr={!r}'.format(self.stderr))\n        return \"{}({})\".format(type(self).__name__, ', '.join(args))\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n\n    def check_returncode(self):\n        \"\"\"Raise CalledProcessError if the exit code is non-zero.\"\"\"\n        if self.returncode:\n            raise CalledProcessError(self.returncode, self.args, self.stdout,\n                                     self.stderr)\n\n\ndef run(*popenargs,\n        input=None, capture_output=False, timeout=None, check=False, **kwargs):\n    \"\"\"Run command with arguments and return a CompletedProcess instance.\n\n    The returned instance will have attributes args, returncode, stdout and\n    stderr. By default, stdout and stderr are not captured, and those attributes\n    will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,\n    or pass capture_output=True to capture both.\n\n    If check is True and the exit code was non-zero, it raises a\n    CalledProcessError. The CalledProcessError object will have the return code\n    in the returncode attribute, and output & stderr attributes if those streams\n    were captured.\n\n    If timeout (seconds) is given and the process takes too long,\n     a TimeoutExpired exception will be raised.\n\n    There is an optional argument \"input\", allowing you to\n    pass bytes or a string to the subprocess's stdin.  If you use this argument\n    you may not also use the Popen constructor's \"stdin\" argument, as\n    it will be used internally.\n\n    By default, all communication is in bytes, and therefore any \"input\" should\n    be bytes, and the stdout and stderr will be bytes. If in text mode, any\n    \"input\" should be a string, and stdout and stderr will be strings decoded\n    according to locale encoding, or by \"encoding\" if set. Text mode is\n    triggered by setting any of text, encoding, errors or universal_newlines.\n\n    The other arguments are the same as for the Popen constructor.\n    \"\"\"\n    if input is not None:\n        if kwargs.get('stdin') is not None:\n            raise ValueError('stdin and input arguments may not both be used.')\n        kwargs['stdin'] = PIPE\n\n    if capture_output:\n        if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n            raise ValueError('stdout and stderr arguments may not be used '\n                             'with capture_output.')\n        kwargs['stdout'] = PIPE\n        kwargs['stderr'] = PIPE\n\n    with Popen(*popenargs, **kwargs) as process:\n        try:\n            stdout, stderr = process.communicate(input, timeout=timeout)\n        except TimeoutExpired as exc:\n            process.kill()\n            if _mswindows:\n                # Windows accumulates the output in a single blocking\n                # read() call run on child threads, with the timeout\n                # being done in a join() on those threads.  communicate()\n                # _after_ kill() is required to collect that and add it\n                # to the exception.\n                exc.stdout, exc.stderr = process.communicate()\n            else:\n                # POSIX _communicate already populated the output so\n                # far into the TimeoutExpired exception.\n                process.wait()\n            raise\n        except:  # Including KeyboardInterrupt, communicate handled that.\n            process.kill()\n            # We don't call process.wait() as .__exit__ does that for us.\n            raise\n        retcode = process.poll()\n        if check and retcode:\n            raise CalledProcessError(retcode, process.args,\n                                     output=stdout, stderr=stderr)\n    return CompletedProcess(process.args, retcode, stdout, stderr)\n\n\ndef list2cmdline(seq):\n    \"\"\"\n    Translate a sequence of arguments into a command line\n    string, using the same rules as the MS C runtime:\n\n    1) Arguments are delimited by white space, which is either a\n       space or a tab.\n\n    2) A string surrounded by double quotation marks is\n       interpreted as a single argument, regardless of white space\n       contained within.  A quoted string can be embedded in an\n       argument.\n\n    3) A double quotation mark preceded by a backslash is\n       interpreted as a literal double quotation mark.\n\n    4) Backslashes are interpreted literally, unless they\n       immediately precede a double quotation mark.\n\n    5) If backslashes immediately precede a double quotation mark,\n       every pair of backslashes is interpreted as a literal\n       backslash.  If the number of backslashes is odd, the last\n       backslash escapes the next double quotation mark as\n       described in rule 3.\n    \"\"\"\n\n    # See\n    # http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\n    # or search http://msdn.microsoft.com for\n    # \"Parsing C++ Command-Line Arguments\"\n    result = []\n    needquote = False\n    for arg in map(os.fsdecode, seq):\n        bs_buf = []\n\n        # Add a space to separate this argument from the others\n        if result:\n            result.append(' ')\n\n        needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg\n        if needquote:\n            result.append('\"')\n\n        for c in arg:\n            if c == '\\\\':\n                # Don't know if we need to double yet.\n                bs_buf.append(c)\n            elif c == '\"':\n                # Double backslashes.\n                result.append('\\\\' * len(bs_buf)*2)\n                bs_buf = []\n                result.append('\\\\\"')\n            else:\n                # Normal char\n                if bs_buf:\n                    result.extend(bs_buf)\n                    bs_buf = []\n                result.append(c)\n\n        # Add remaining backslashes, if any.\n        if bs_buf:\n            result.extend(bs_buf)\n\n        if needquote:\n            result.extend(bs_buf)\n            result.append('\"')\n\n    return ''.join(result)\n\n\n# Various tools for executing commands and looking at their output and status.\n#\n\ndef getstatusoutput(cmd, *, encoding=None, errors=None):\n    \"\"\"Return (exitcode, output) of executing cmd in a shell.\n\n    Execute the string 'cmd' in a shell with 'check_output' and\n    return a 2-tuple (status, output). The locale encoding is used\n    to decode the output and process newlines.\n\n    A trailing newline is stripped from the output.\n    The exit status for the command can be interpreted\n    according to the rules for the function 'wait'. Example:\n\n    >>> import subprocess\n    >>> subprocess.getstatusoutput('ls /bin/ls')\n    (0, '/bin/ls')\n    >>> subprocess.getstatusoutput('cat /bin/junk')\n    (1, 'cat: /bin/junk: No such file or directory')\n    >>> subprocess.getstatusoutput('/bin/junk')\n    (127, 'sh: /bin/junk: not found')\n    >>> subprocess.getstatusoutput('/bin/kill $$')\n    (-15, '')\n    \"\"\"\n    try:\n        data = check_output(cmd, shell=True, text=True, stderr=STDOUT,\n                            encoding=encoding, errors=errors)\n        exitcode = 0\n    except CalledProcessError as ex:\n        data = ex.output\n        exitcode = ex.returncode\n    if data[-1:] == '\\n':\n        data = data[:-1]\n    return exitcode, data\n\ndef getoutput(cmd, *, encoding=None, errors=None):\n    \"\"\"Return output (stdout or stderr) of executing cmd in a shell.\n\n    Like getstatusoutput(), except the exit status is ignored and the return\n    value is a string containing the command's output.  Example:\n\n    >>> import subprocess\n    >>> subprocess.getoutput('ls /bin/ls')\n    '/bin/ls'\n    \"\"\"\n    return getstatusoutput(cmd, encoding=encoding, errors=errors)[1]\n\n\n\ndef _use_posix_spawn():\n    \"\"\"Check if posix_spawn() can be used for subprocess.\n\n    subprocess requires a posix_spawn() implementation that properly reports\n    errors to the parent process, & sets errno on the following failures:\n\n    * Process attribute actions failed.\n    * File actions failed.\n    * exec() failed.\n\n    Prefer an implementation which can use vfork() in some cases for best\n    performance.\n    \"\"\"\n    if _mswindows or not hasattr(os, 'posix_spawn'):\n        # os.posix_spawn() is not available\n        return False\n\n    if sys.platform in ('darwin', 'sunos5'):\n        # posix_spawn() is a syscall on both macOS and Solaris,\n        # and properly reports errors\n        return True\n\n    # Check libc name and runtime libc version\n    try:\n        ver = os.confstr('CS_GNU_LIBC_VERSION')\n        # parse 'glibc 2.28' as ('glibc', (2, 28))\n        parts = ver.split(maxsplit=1)\n        if len(parts) != 2:\n            # reject unknown format\n            raise ValueError\n        libc = parts[0]\n        version = tuple(map(int, parts[1].split('.')))\n\n        if sys.platform == 'linux' and libc == 'glibc' and version >= (2, 24):\n            # glibc 2.24 has a new Linux posix_spawn implementation using vfork\n            # which properly reports errors to the parent process.\n            return True\n        # Note: Don't use the implementation in earlier glibc because it doesn't\n        # use vfork (even if glibc 2.26 added a pipe to properly report errors\n        # to the parent process).\n    except (AttributeError, ValueError, OSError):\n        # os.confstr() or CS_GNU_LIBC_VERSION value not available\n        pass\n\n    # By default, assume that posix_spawn() does not properly report errors.\n    return False\n\n\n# These are primarily fail-safe knobs for negatives. A True value does not\n# guarantee the given libc/syscall API will be used.\n_USE_POSIX_SPAWN = _use_posix_spawn()\n_USE_VFORK = True\n_HAVE_POSIX_SPAWN_CLOSEFROM = hasattr(os, 'POSIX_SPAWN_CLOSEFROM')\n\n\nclass Popen:\n    \"\"\" Execute a child program in a new process.\n\n    For a complete description of the arguments see the Python documentation.\n\n    Arguments:\n      args: A string, or a sequence of program arguments.\n\n      bufsize: supplied as the buffering argument to the open() function when\n          creating the stdin/stdout/stderr pipe file objects\n\n      executable: A replacement program to execute.\n\n      stdin, stdout and stderr: These specify the executed programs' standard\n          input, standard output and standard error file handles, respectively.\n\n      preexec_fn: (POSIX only) An object to be called in the child process\n          just before the child is executed.\n\n      close_fds: Controls closing or inheriting of file descriptors.\n\n      shell: If true, the command will be executed through the shell.\n\n      cwd: Sets the current directory before the child is executed.\n\n      env: Defines the environment variables for the new process.\n\n      text: If true, decode stdin, stdout and stderr using the given encoding\n          (if set) or the system default otherwise.\n\n      universal_newlines: Alias of text, provided for backwards compatibility.\n\n      startupinfo and creationflags (Windows only)\n\n      restore_signals (POSIX only)\n\n      start_new_session (POSIX only)\n\n      process_group (POSIX only)\n\n      group (POSIX only)\n\n      extra_groups (POSIX only)\n\n      user (POSIX only)\n\n      umask (POSIX only)\n\n      pass_fds (POSIX only)\n\n      encoding and errors: Text mode encoding and error handling to use for\n          file objects stdin, stdout and stderr.\n\n    Attributes:\n        stdin, stdout, stderr, pid, returncode\n    \"\"\"\n    _child_created = False  # Set here since __del__ checks it\n\n    def __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n                 shell=False, cwd=None, env=None, universal_newlines=None,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=(), *, user=None, group=None, extra_groups=None,\n                 encoding=None, errors=None, text=None, umask=-1, pipesize=-1,\n                 process_group=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        if not _can_fork_exec:\n            raise OSError(\n                errno.ENOTSUP, f\"{sys.platform} does not support processes.\"\n            )\n\n        _cleanup()\n        # Held while anything is calling waitpid before returncode has been\n        # updated to prevent clobbering returncode if wait() or poll() are\n        # called from multiple threads at once.  After acquiring the lock,\n        # code must re-check self.returncode to see if another thread just\n        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n\n        self._input = None\n        self._communication_started = False\n        if bufsize is None:\n            bufsize = -1  # Restore default\n        if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize must be an integer\")\n\n        if stdout is STDOUT:\n            raise ValueError(\"STDOUT can only be used for stderr\")\n\n        if pipesize is None:\n            pipesize = -1  # Restore default\n        if not isinstance(pipesize, int):\n            raise TypeError(\"pipesize must be an integer\")\n\n        if _mswindows:\n            if preexec_fn is not None:\n                raise ValueError(\"preexec_fn is not supported on Windows \"\n                                 \"platforms\")\n        else:\n            # POSIX\n            if pass_fds and not close_fds:\n                warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n                close_fds = True\n            if startupinfo is not None:\n                raise ValueError(\"startupinfo is only supported on Windows \"\n                                 \"platforms\")\n            if creationflags != 0:\n                raise ValueError(\"creationflags is only supported on Windows \"\n                                 \"platforms\")\n\n        self.args = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr = None\n        self.pid = None\n        self.returncode = None\n        self.encoding = encoding\n        self.errors = errors\n        self.pipesize = pipesize\n\n        # Validate the combinations of text and universal_newlines\n        if (text is not None and universal_newlines is not None\n            and bool(universal_newlines) != bool(text)):\n            raise SubprocessError('Cannot disambiguate when both text '\n                                  'and universal_newlines are supplied but '\n                                  'different. Pass one or the other.')\n\n        self.text_mode = encoding or errors or text or universal_newlines\n        if self.text_mode and encoding is None:\n            self.encoding = encoding = _text_encoding()\n\n        # How long to resume waiting on a child after the first ^C.\n        # There is no right value for this.  The purpose is to be polite\n        # yet remain good for interactive users trying to exit a tool.\n        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n\n        self._closed_child_pipe_fds = False\n\n        if self.text_mode:\n            if bufsize == 1:\n                line_buffering = True\n                # Use the default buffer size for the underlying binary streams\n                # since they don't support line buffering.\n                bufsize = -1\n            else:\n                line_buffering = False\n\n        if process_group is None:\n            process_group = -1  # The internal APIs are int-only\n\n        gid = None\n        if group is not None:\n            if not hasattr(os, 'setregid'):\n                raise ValueError(\"The 'group' parameter is not supported on the \"\n                                 \"current platform\")\n\n            elif isinstance(group, str):\n                try:\n                    import grp\n                except ImportError:\n                    raise ValueError(\"The group parameter cannot be a string \"\n                                     \"on systems without the grp module\")\n\n                gid = grp.getgrnam(group).gr_gid\n            elif isinstance(group, int):\n                gid = group\n            else:\n                raise TypeError(\"Group must be a string or an integer, not {}\"\n                                .format(type(group)))\n\n            if gid < 0:\n                raise ValueError(f\"Group ID cannot be negative, got {gid}\")\n\n        gids = None\n        if extra_groups is not None:\n            if not hasattr(os, 'setgroups'):\n                raise ValueError(\"The 'extra_groups' parameter is not \"\n                                 \"supported on the current platform\")\n\n            elif isinstance(extra_groups, str):\n                raise ValueError(\"Groups must be a list, not a string\")\n\n            gids = []\n            for extra_group in extra_groups:\n                if isinstance(extra_group, str):\n                    try:\n                        import grp\n                    except ImportError:\n                        raise ValueError(\"Items in extra_groups cannot be \"\n                                         \"strings on systems without the \"\n                                         \"grp module\")\n\n                    gids.append(grp.getgrnam(extra_group).gr_gid)\n                elif isinstance(extra_group, int):\n                    gids.append(extra_group)\n                else:\n                    raise TypeError(\"Items in extra_groups must be a string \"\n                                    \"or integer, not {}\"\n                                    .format(type(extra_group)))\n\n            # make sure that the gids are all positive here so we can do less\n            # checking in the C code\n            for gid_check in gids:\n                if gid_check < 0:\n                    raise ValueError(f\"Group ID cannot be negative, got {gid_check}\")\n\n        uid = None\n        if user is not None:\n            if not hasattr(os, 'setreuid'):\n                raise ValueError(\"The 'user' parameter is not supported on \"\n                                 \"the current platform\")\n\n            elif isinstance(user, str):\n                try:\n                    import pwd\n                except ImportError:\n                    raise ValueError(\"The user parameter cannot be a string \"\n                                     \"on systems without the pwd module\")\n                uid = pwd.getpwnam(user).pw_uid\n            elif isinstance(user, int):\n                uid = user\n            else:\n                raise TypeError(\"User must be a string or an integer\")\n\n            if uid < 0:\n                raise ValueError(f\"User ID cannot be negative, got {uid}\")\n\n        # Input and output objects. The general principle is like\n        # this:\n        #\n        # Parent                   Child\n        # ------                   -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n        #\n        # On POSIX, the child objects are file descriptors.  On\n        # Windows, these are Windows file handles.  The parent objects\n        # are file descriptors on both platforms.  The parent objects\n        # are -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n\n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread, errwrite) = self._get_handles(stdin, stdout, stderr)\n\n        # From here on, raising exceptions may cause file descriptor leakage\n\n        # We wrap OS handles *before* launching the child, otherwise a\n        # quickly terminating child could make our fds unwrappable\n        # (see #8458).\n\n        if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(), 0)\n\n        try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite, 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,\n                            line_buffering=line_buffering,\n                            encoding=encoding, errors=errors)\n            if c2pread != -1:\n                self.stdout = io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stdout = io.TextIOWrapper(self.stdout,\n                            encoding=encoding, errors=errors)\n            if errread != -1:\n                self.stderr = io.open(errread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n                            encoding=encoding, errors=errors)\n\n            self._execute_child(args, executable, preexec_fn, close_fds,\n                                pass_fds, cwd, env,\n                                startupinfo, creationflags, shell,\n                                p2cread, p2cwrite,\n                                c2pread, c2pwrite,\n                                errread, errwrite,\n                                restore_signals,\n                                gid, gids, uid, umask,\n                                start_new_session, process_group)\n        except:\n            # Cleanup if the child failed starting.\n            for f in filter(None, (self.stdin, self.stdout, self.stderr)):\n                try:\n                    f.close()\n                except OSError:\n                    pass  # Ignore EBADF or other errors.\n\n            if not self._closed_child_pipe_fds:\n                to_close = []\n                if stdin == PIPE:\n                    to_close.append(p2cread)\n                if stdout == PIPE:\n                    to_close.append(c2pwrite)\n                if stderr == PIPE:\n                    to_close.append(errwrite)\n                if hasattr(self, '_devnull'):\n                    to_close.append(self._devnull)\n                for fd in to_close:\n                    try:\n                        if _mswindows and isinstance(fd, Handle):\n                            fd.Close()\n                        else:\n                            os.close(fd)\n                    except OSError:\n                        pass\n\n            raise\n\n    def __repr__(self):\n        obj_repr = (\n            f\"<{self.__class__.__name__}: \"\n            f\"returncode: {self.returncode} args: {self.args!r}>\"\n        )\n        if len(obj_repr) > 80:\n            obj_repr = obj_repr[:76] + \"...>\"\n        return obj_repr\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n    @property\n    def universal_newlines(self):\n        # universal_newlines as retained as an alias of text_mode for API\n        # compatibility. bpo-31756\n        return self.text_mode\n\n    @universal_newlines.setter\n    def universal_newlines(self, universal_newlines):\n        self.text_mode = bool(universal_newlines)\n\n    def _translate_newlines(self, data, encoding, errors):\n        data = data.decode(encoding, errors)\n        return data.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, value, traceback):\n        if self.stdout:\n            self.stdout.close()\n        if self.stderr:\n            self.stderr.close()\n        try:  # Flushing a BufferedWriter may raise an error\n            if self.stdin:\n                self.stdin.close()\n        finally:\n            if exc_type == KeyboardInterrupt:\n                # https://bugs.python.org/issue25942\n                # In the case of a KeyboardInterrupt we assume the SIGINT\n                # was also already sent to our child processes.  We can't\n                # block indefinitely as that is not user friendly.\n                # If we have not already waited a brief amount of time in\n                # an interrupted .wait() or .communicate() call, do so here\n                # for consistency.\n                if self._sigint_wait_secs > 0:\n                    try:\n                        self._wait(timeout=self._sigint_wait_secs)\n                    except TimeoutExpired:\n                        pass\n                self._sigint_wait_secs = 0  # Note that this has been done.\n                return  # resume the KeyboardInterrupt\n\n            # Wait for the process to terminate, to avoid zombies.\n            self.wait()\n\n    def __del__(self, _maxsize=sys.maxsize, _warn=warnings.warn):\n        if not self._child_created:\n            # We didn't get to successfully create a child process.\n            return\n        if self.returncode is None:\n            # Not reading subprocess exit status creates a zombie process which\n            # is only destroyed at the parent python process exit\n            _warn(\"subprocess %s is still running\" % self.pid,\n                  ResourceWarning, source=self)\n        # In case the child hasn't been waited on, check if it's done.\n        self._internal_poll(_deadstate=_maxsize)\n        if self.returncode is None and _active is not None:\n            # Child is still running, keep us alive until we can wait on it.\n            _active.append(self)\n\n    def _get_devnull(self):\n        if not hasattr(self, '_devnull'):\n            self._devnull = os.open(os.devnull, os.O_RDWR)\n        return self._devnull\n\n    def _stdin_write(self, input):\n        if input:\n            try:\n                self.stdin.write(input)\n            except BrokenPipeError:\n                pass  # communicate() must ignore broken pipe errors.\n            except OSError as exc:\n                if exc.errno == errno.EINVAL:\n                    # bpo-19612, bpo-30418: On Windows, stdin.write() fails\n                    # with EINVAL if the child process exited or if the child\n                    # process is still running but closed the pipe.\n                    pass\n                else:\n                    raise\n\n        try:\n            self.stdin.close()\n        except BrokenPipeError:\n            pass  # communicate() must ignore broken pipe errors.\n        except OSError as exc:\n            if exc.errno == errno.EINVAL:\n                pass\n            else:\n                raise\n\n    def communicate(self, input=None, timeout=None):\n        \"\"\"Interact with process: Send data to stdin and close it.\n        Read data from stdout and stderr, until end-of-file is\n        reached.  Wait for process to terminate.\n\n        The optional \"input\" argument should be data to be sent to the\n        child process, or None, if no data should be sent to the child.\n        communicate() returns a tuple (stdout, stderr).\n\n        By default, all communication is in bytes, and therefore any\n        \"input\" should be bytes, and the (stdout, stderr) will be bytes.\n        If in text mode (indicated by self.text_mode), any \"input\" should\n        be a string, and (stdout, stderr) will be strings decoded\n        according to locale encoding, or by \"encoding\" if set. Text mode\n        is triggered by setting any of text, encoding, errors or\n        universal_newlines.\n        \"\"\"\n\n        if self._communication_started and input:\n            raise ValueError(\"Cannot send input after starting communication\")\n\n        # Optimization: If we are not worried about timeouts, we haven't\n        # started communicating, and we have one or zero pipes, using select()\n        # or threads is unnecessary.\n        if (timeout is None and not self._communication_started and\n            [self.stdin, self.stdout, self.stderr].count(None) >= 2):\n            stdout = None\n            stderr = None\n            if self.stdin:\n                self._stdin_write(input)\n            elif self.stdout:\n                stdout = self.stdout.read()\n                self.stdout.close()\n            elif self.stderr:\n                stderr = self.stderr.read()\n                self.stderr.close()\n            self.wait()\n        else:\n            if timeout is not None:\n                endtime = _time() + timeout\n            else:\n                endtime = None\n\n            try:\n                stdout, stderr = self._communicate(input, endtime, timeout)\n            except KeyboardInterrupt:\n                # https://bugs.python.org/issue25942\n                # See the detailed comment in .wait().\n                if timeout is not None:\n                    sigint_timeout = min(self._sigint_wait_secs,\n                                         self._remaining_time(endtime))\n                else:\n                    sigint_timeout = self._sigint_wait_secs\n                self._sigint_wait_secs = 0  # nothing else should wait.\n                try:\n                    self._wait(timeout=sigint_timeout)\n                except TimeoutExpired:\n                    pass\n                raise  # resume the KeyboardInterrupt\n\n            finally:\n                self._communication_started = True\n\n            sts = self.wait(timeout=self._remaining_time(endtime))\n\n        return (stdout, stderr)\n\n\n    def poll(self):\n        \"\"\"Check if child process has terminated. Set and return returncode\n        attribute.\"\"\"\n        return self._internal_poll()\n\n\n    def _remaining_time(self, endtime):\n        \"\"\"Convenience for _communicate when computing timeouts.\"\"\"\n        if endtime is None:\n            return None\n        else:\n            return endtime - _time()\n\n\n    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,\n                       skip_check_and_raise=False):\n        \"\"\"Convenience for checking if a timeout has expired.\"\"\"\n        if endtime is None:\n            return\n        if skip_check_and_raise or _time() > endtime:\n            raise TimeoutExpired(\n                    self.args, orig_timeout,\n                    output=b''.join(stdout_seq) if stdout_seq else None,\n                    stderr=b''.join(stderr_seq) if stderr_seq else None)\n\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for child process to terminate; returns self.returncode.\"\"\"\n        if timeout is not None:\n            endtime = _time() + timeout\n        try:\n            return self._wait(timeout=timeout)\n        except KeyboardInterrupt:\n            # https://bugs.python.org/issue25942\n            # The first keyboard interrupt waits briefly for the child to\n            # exit under the common assumption that it also received the ^C\n            # generated SIGINT and will exit rapidly.\n            if timeout is not None:\n                sigint_timeout = min(self._sigint_wait_secs,\n                                     self._remaining_time(endtime))\n            else:\n                sigint_timeout = self._sigint_wait_secs\n            self._sigint_wait_secs = 0  # nothing else should wait.\n            try:\n                self._wait(timeout=sigint_timeout)\n            except TimeoutExpired:\n                pass\n            raise  # resume the KeyboardInterrupt\n\n    def _close_pipe_fds(self,\n                        p2cread, p2cwrite,\n                        c2pread, c2pwrite,\n                        errread, errwrite):\n        # self._devnull is not always defined.\n        devnull_fd = getattr(self, '_devnull', None)\n\n        with contextlib.ExitStack() as stack:\n            if _mswindows:\n                if p2cread != -1:\n                    stack.callback(p2cread.Close)\n                if c2pwrite != -1:\n                    stack.callback(c2pwrite.Close)\n                if errwrite != -1:\n                    stack.callback(errwrite.Close)\n            else:\n                if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:\n                    stack.callback(os.close, p2cread)\n                if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:\n                    stack.callback(os.close, c2pwrite)\n                if errwrite != -1 and errread != -1 and errwrite != devnull_fd:\n                    stack.callback(os.close, errwrite)\n\n            if devnull_fd is not None:\n                stack.callback(os.close, devnull_fd)\n\n        # Prevent a double close of these handles/fds from __init__ on error.\n        self._closed_child_pipe_fds = True\n\n    @contextlib.contextmanager\n    def _on_error_fd_closer(self):\n        \"\"\"Helper to ensure file descriptors opened in _get_handles are closed\"\"\"\n        to_close = []\n        try:\n            yield to_close\n        except:\n            if hasattr(self, '_devnull'):\n                to_close.append(self._devnull)\n                del self._devnull\n            for fd in to_close:\n                try:\n                    if _mswindows and isinstance(fd, Handle):\n                        fd.Close()\n                    else:\n                        os.close(fd)\n                except OSError:\n                    pass\n            raise\n\n    if _mswindows:\n        #\n        # Windows methods\n        #\n        def _get_handles(self, stdin, stdout, stderr):\n            \"\"\"Construct and return tuple with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            \"\"\"\n            if stdin is None and stdout is None and stderr is None:\n                return (-1, -1, -1, -1, -1, -1)\n\n            p2cread, p2cwrite = -1, -1\n            c2pread, c2pwrite = -1, -1\n            errread, errwrite = -1, -1\n\n            with self._on_error_fd_closer() as err_close_fds:\n                if stdin is None:\n                    p2cread = _winapi.GetStdHandle(_winapi.STD_INPUT_HANDLE)\n                    if p2cread is None:\n                        p2cread, _ = _winapi.CreatePipe(None, 0)\n                        p2cread = Handle(p2cread)\n                        err_close_fds.append(p2cread)\n                        _winapi.CloseHandle(_)\n                elif stdin == PIPE:\n                    p2cread, p2cwrite = _winapi.CreatePipe(None, 0)\n                    p2cread, p2cwrite = Handle(p2cread), Handle(p2cwrite)\n                    err_close_fds.extend((p2cread, p2cwrite))\n                elif stdin == DEVNULL:\n                    p2cread = msvcrt.get_osfhandle(self._get_devnull())\n                elif isinstance(stdin, int):\n                    p2cread = msvcrt.get_osfhandle(stdin)\n                else:\n                    # Assuming file-like object\n                    p2cread = msvcrt.get_osfhandle(stdin.fileno())\n                p2cread = self._make_inheritable(p2cread)\n\n                if stdout is None:\n                    c2pwrite = _winapi.GetStdHandle(_winapi.STD_OUTPUT_HANDLE)\n                    if c2pwrite is None:\n                        _, c2pwrite = _winapi.CreatePipe(None, 0)\n                        c2pwrite = Handle(c2pwrite)\n                        err_close_fds.append(c2pwrite)\n                        _winapi.CloseHandle(_)\n                elif stdout == PIPE:\n                    c2pread, c2pwrite = _winapi.CreatePipe(None, 0)\n                    c2pread, c2pwrite = Handle(c2pread), Handle(c2pwrite)\n                    err_close_fds.extend((c2pread, c2pwrite))\n                elif stdout == DEVNULL:\n                    c2pwrite = msvcrt.get_osfhandle(self._get_devnull())\n                elif isinstance(stdout, int):\n                    c2pwrite = msvcrt.get_osfhandle(stdout)\n                else:\n                    # Assuming file-like object\n                    c2pwrite = msvcrt.get_osfhandle(stdout.fileno())\n                c2pwrite = self._make_inheritable(c2pwrite)\n\n                if stderr is None:\n                    errwrite = _winapi.GetStdHandle(_winapi.STD_ERROR_HANDLE)\n                    if errwrite is None:\n                        _, errwrite = _winapi.CreatePipe(None, 0)\n                        errwrite = Handle(errwrite)\n                        err_close_fds.append(errwrite)\n                        _winapi.CloseHandle(_)\n                elif stderr == PIPE:\n                    errread, errwrite = _winapi.CreatePipe(None, 0)\n                    errread, errwrite = Handle(errread), Handle(errwrite)\n                    err_close_fds.extend((errread, errwrite))\n                elif stderr == STDOUT:\n                    errwrite = c2pwrite\n                elif stderr == DEVNULL:\n                    errwrite = msvcrt.get_osfhandle(self._get_devnull())\n                elif isinstance(stderr, int):\n                    errwrite = msvcrt.get_osfhandle(stderr)\n                else:\n                    # Assuming file-like object\n                    errwrite = msvcrt.get_osfhandle(stderr.fileno())\n                errwrite = self._make_inheritable(errwrite)\n\n            return (p2cread, p2cwrite,\n                    c2pread, c2pwrite,\n                    errread, errwrite)\n\n\n        def _make_inheritable(self, handle):\n            \"\"\"Return a duplicate of handle, which is inheritable\"\"\"\n            h = _winapi.DuplicateHandle(\n                _winapi.GetCurrentProcess(), handle,\n                _winapi.GetCurrentProcess(), 0, 1,\n                _winapi.DUPLICATE_SAME_ACCESS)\n            return Handle(h)\n\n\n        def _filter_handle_list(self, handle_list):\n            \"\"\"Filter out console handles that can't be used\n            in lpAttributeList[\"handle_list\"] and make sure the list\n            isn't empty. This also removes duplicate handles.\"\"\"\n            # An handle with it's lowest two bits set might be a special console\n            # handle that if passed in lpAttributeList[\"handle_list\"], will\n            # cause it to fail.\n            return list({handle for handle in handle_list\n                         if handle & 0x3 != 0x3\n                         or _winapi.GetFileType(handle) !=\n                            _winapi.FILE_TYPE_CHAR})\n\n\n        def _execute_child(self, args, executable, preexec_fn, close_fds,\n                           pass_fds, cwd, env,\n                           startupinfo, creationflags, shell,\n                           p2cread, p2cwrite,\n                           c2pread, c2pwrite,\n                           errread, errwrite,\n                           unused_restore_signals,\n                           unused_gid, unused_gids, unused_uid,\n                           unused_umask,\n                           unused_start_new_session, unused_process_group):\n            \"\"\"Execute program (MS Windows version)\"\"\"\n\n            assert not pass_fds, \"pass_fds not supported on Windows.\"\n\n            if isinstance(args, str):\n                pass\n            elif isinstance(args, bytes):\n                if shell:\n                    raise TypeError('bytes args is not allowed on Windows')\n                args = list2cmdline([args])\n            elif isinstance(args, os.PathLike):\n                if shell:\n                    raise TypeError('path-like args is not allowed when '\n                                    'shell is true')\n                args = list2cmdline([args])\n            else:\n                args = list2cmdline(args)\n\n            if executable is not None:\n                executable = os.fsdecode(executable)\n\n            # Process startup details\n            if startupinfo is None:\n                startupinfo = STARTUPINFO()\n            else:\n                # bpo-34044: Copy STARTUPINFO since it is modified above,\n                # so the caller can reuse it multiple times.\n                startupinfo = startupinfo.copy()\n\n            use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)\n            if use_std_handles:\n                startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n                startupinfo.hStdInput = p2cread\n                startupinfo.hStdOutput = c2pwrite\n                startupinfo.hStdError = errwrite\n\n            attribute_list = startupinfo.lpAttributeList\n            have_handle_list = bool(attribute_list and\n                                    \"handle_list\" in attribute_list and\n                                    attribute_list[\"handle_list\"])\n\n            # If we were given an handle_list or need to create one\n            if have_handle_list or (use_std_handles and close_fds):\n                if attribute_list is None:\n                    attribute_list = startupinfo.lpAttributeList = {}\n                handle_list = attribute_list[\"handle_list\"] = \\\n                    list(attribute_list.get(\"handle_list\", []))\n\n                if use_std_handles:\n                    handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]\n\n                handle_list[:] = self._filter_handle_list(handle_list)\n\n                if handle_list:\n                    if not close_fds:\n                        warnings.warn(\"startupinfo.lpAttributeList['handle_list'] \"\n                                      \"overriding close_fds\", RuntimeWarning)\n\n                    # When using the handle_list we always request to inherit\n                    # handles but the only handles that will be inherited are\n                    # the ones in the handle_list\n                    close_fds = False\n\n            if shell:\n                startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n                startupinfo.wShowWindow = _winapi.SW_HIDE\n                if not executable:\n                    # gh-101283: without a fully-qualified path, before Windows\n                    # checks the system directories, it first looks in the\n                    # application directory, and also the current directory if\n                    # NeedCurrentDirectoryForExePathW(ExeName) is true, so try\n                    # to avoid executing unqualified \"cmd.exe\".\n                    comspec = os.environ.get('ComSpec')\n                    if not comspec:\n                        system_root = os.environ.get('SystemRoot', '')\n                        comspec = os.path.join(system_root, 'System32', 'cmd.exe')\n                        if not os.path.isabs(comspec):\n                            raise FileNotFoundError('shell not found: neither %ComSpec% nor %SystemRoot% is set')\n                    if os.path.isabs(comspec):\n                        executable = comspec\n                else:\n                    comspec = executable\n\n                args = '{} /c \"{}\"'.format (comspec, args)\n\n            if cwd is not None:\n                cwd = os.fsdecode(cwd)\n\n            sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n            # Start the process\n            try:\n                hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n                                         # no special security\n                                         None, None,\n                                         int(not close_fds),\n                                         creationflags,\n                                         env,\n                                         cwd,\n                                         startupinfo)\n            finally:\n                # Child is launched. Close the parent's copy of those pipe\n                # handles that only the child should have open.  You need\n                # to make sure that no handles to the write end of the\n                # output pipe are maintained in this process or else the\n                # pipe will not close when the child process exits and the\n                # ReadFile will hang.\n                self._close_pipe_fds(p2cread, p2cwrite,\n                                     c2pread, c2pwrite,\n                                     errread, errwrite)\n\n            # Retain the process handle, but close the thread handle\n            self._child_created = True\n            self._handle = Handle(hp)\n            self.pid = pid\n            _winapi.CloseHandle(ht)\n\n        def _internal_poll(self, _deadstate=None,\n                _WaitForSingleObject=_winapi.WaitForSingleObject,\n                _WAIT_OBJECT_0=_winapi.WAIT_OBJECT_0,\n                _GetExitCodeProcess=_winapi.GetExitCodeProcess):\n            \"\"\"Check if child process has terminated.  Returns returncode\n            attribute.\n\n            This method is called by __del__, so it can only refer to objects\n            in its local scope.\n\n            \"\"\"\n            if self.returncode is None:\n                if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:\n                    self.returncode = _GetExitCodeProcess(self._handle)\n            return self.returncode\n\n\n        def _wait(self, timeout):\n            \"\"\"Internal implementation of wait() on Windows.\"\"\"\n            if timeout is None:\n                timeout_millis = _winapi.INFINITE\n            elif timeout <= 0:\n                timeout_millis = 0\n            else:\n                timeout_millis = int(timeout * 1000)\n            if self.returncode is None:\n                # API note: Returns immediately if timeout_millis == 0.\n                result = _winapi.WaitForSingleObject(self._handle,\n                                                     timeout_millis)\n                if result == _winapi.WAIT_TIMEOUT:\n                    raise TimeoutExpired(self.args, timeout)\n                self.returncode = _winapi.GetExitCodeProcess(self._handle)\n            return self.returncode\n\n\n        def _readerthread(self, fh, buffer):\n            buffer.append(fh.read())\n            fh.close()\n\n\n        def _communicate(self, input, endtime, orig_timeout):\n            # Start reader threads feeding into a list hanging off of this\n            # object, unless they've already been started.\n            if self.stdout and not hasattr(self, \"_stdout_buff\"):\n                self._stdout_buff = []\n                self.stdout_thread = \\\n                        threading.Thread(target=self._readerthread,\n                                         args=(self.stdout, self._stdout_buff))\n                self.stdout_thread.daemon = True\n                self.stdout_thread.start()\n            if self.stderr and not hasattr(self, \"_stderr_buff\"):\n                self._stderr_buff = []\n                self.stderr_thread = \\\n                        threading.Thread(target=self._readerthread,\n                                         args=(self.stderr, self._stderr_buff))\n                self.stderr_thread.daemon = True\n                self.stderr_thread.start()\n\n            if self.stdin:\n                self._stdin_write(input)\n\n            # Wait for the reader threads, or time out.  If we time out, the\n            # threads remain reading and the fds left open in case the user\n            # calls communicate again.\n            if self.stdout is not None:\n                self.stdout_thread.join(self._remaining_time(endtime))\n                if self.stdout_thread.is_alive():\n                    raise TimeoutExpired(self.args, orig_timeout)\n            if self.stderr is not None:\n                self.stderr_thread.join(self._remaining_time(endtime))\n                if self.stderr_thread.is_alive():\n                    raise TimeoutExpired(self.args, orig_timeout)\n\n            # Collect the output from and close both pipes, now that we know\n            # both have been read successfully.\n            stdout = None\n            stderr = None\n            if self.stdout:\n                stdout = self._stdout_buff\n                self.stdout.close()\n            if self.stderr:\n                stderr = self._stderr_buff\n                self.stderr.close()\n\n            # All data exchanged.  Translate lists into strings.\n            stdout = stdout[0] if stdout else None\n            stderr = stderr[0] if stderr else None\n\n            return (stdout, stderr)\n\n        def send_signal(self, sig):\n            \"\"\"Send a signal to the process.\"\"\"\n            # Don't signal a process that we know has already died.\n            if self.returncode is not None:\n                return\n\n            # Lazy import to improve module import time\n            import signal\n            if sig == signal.SIGTERM:\n                self.terminate()\n            elif sig == signal.CTRL_C_EVENT:\n                os.kill(self.pid, signal.CTRL_C_EVENT)\n            elif sig == signal.CTRL_BREAK_EVENT:\n                os.kill(self.pid, signal.CTRL_BREAK_EVENT)\n            else:\n                raise ValueError(\"Unsupported signal: {}\".format(sig))\n\n        def terminate(self):\n            \"\"\"Terminates the process.\"\"\"\n            # Don't terminate a process that we know has already died.\n            if self.returncode is not None:\n                return\n            try:\n                _winapi.TerminateProcess(self._handle, 1)\n            except PermissionError:\n                # ERROR_ACCESS_DENIED (winerror 5) is received when the\n                # process already died.\n                rc = _winapi.GetExitCodeProcess(self._handle)\n                if rc == _winapi.STILL_ACTIVE:\n                    raise\n                self.returncode = rc\n\n        kill = terminate\n\n    else:\n        #\n        # POSIX methods\n        #\n        def _get_handles(self, stdin, stdout, stderr):\n            \"\"\"Construct and return tuple with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            \"\"\"\n            p2cread, p2cwrite = -1, -1\n            c2pread, c2pwrite = -1, -1\n            errread, errwrite = -1, -1\n\n            with self._on_error_fd_closer() as err_close_fds:\n                if stdin is None:\n                    pass\n                elif stdin == PIPE:\n                    p2cread, p2cwrite = os.pipe()\n                    err_close_fds.extend((p2cread, p2cwrite))\n                    if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                        fcntl.fcntl(p2cwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n                elif stdin == DEVNULL:\n                    p2cread = self._get_devnull()\n                elif isinstance(stdin, int):\n                    p2cread = stdin\n                else:\n                    # Assuming file-like object\n                    p2cread = stdin.fileno()\n\n                if stdout is None:\n                    pass\n                elif stdout == PIPE:\n                    c2pread, c2pwrite = os.pipe()\n                    err_close_fds.extend((c2pread, c2pwrite))\n                    if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                        fcntl.fcntl(c2pwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n                elif stdout == DEVNULL:\n                    c2pwrite = self._get_devnull()\n                elif isinstance(stdout, int):\n                    c2pwrite = stdout\n                else:\n                    # Assuming file-like object\n                    c2pwrite = stdout.fileno()\n\n                if stderr is None:\n                    pass\n                elif stderr == PIPE:\n                    errread, errwrite = os.pipe()\n                    err_close_fds.extend((errread, errwrite))\n                    if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                        fcntl.fcntl(errwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n                elif stderr == STDOUT:\n                    if c2pwrite != -1:\n                        errwrite = c2pwrite\n                    else: # child's stdout is not set, use parent's stdout\n                        errwrite = sys.__stdout__.fileno()\n                elif stderr == DEVNULL:\n                    errwrite = self._get_devnull()\n                elif isinstance(stderr, int):\n                    errwrite = stderr\n                else:\n                    # Assuming file-like object\n                    errwrite = stderr.fileno()\n\n            return (p2cread, p2cwrite,\n                    c2pread, c2pwrite,\n                    errread, errwrite)\n\n\n        def _posix_spawn(self, args, executable, env, restore_signals, close_fds,\n                         p2cread, p2cwrite,\n                         c2pread, c2pwrite,\n                         errread, errwrite):\n            \"\"\"Execute program using os.posix_spawn().\"\"\"\n            kwargs = {}\n            if restore_signals:\n                # Lazy import to improve module import time\n                import signal\n\n                # See _Py_RestoreSignals() in Python/pylifecycle.c\n                sigset = []\n                for signame in ('SIGPIPE', 'SIGXFZ', 'SIGXFSZ'):\n                    signum = getattr(signal, signame, None)\n                    if signum is not None:\n                        sigset.append(signum)\n                kwargs['setsigdef'] = sigset\n\n            file_actions = []\n            for fd in (p2cwrite, c2pread, errread):\n                if fd != -1:\n                    file_actions.append((os.POSIX_SPAWN_CLOSE, fd))\n            for fd, fd2 in (\n                (p2cread, 0),\n                (c2pwrite, 1),\n                (errwrite, 2),\n            ):\n                if fd != -1:\n                    file_actions.append((os.POSIX_SPAWN_DUP2, fd, fd2))\n\n            if close_fds:\n                file_actions.append((os.POSIX_SPAWN_CLOSEFROM, 3))\n\n            if file_actions:\n                kwargs['file_actions'] = file_actions\n\n            self.pid = os.posix_spawn(executable, args, env, **kwargs)\n            self._child_created = True\n\n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n\n        def _execute_child(self, args, executable, preexec_fn, close_fds,\n                           pass_fds, cwd, env,\n                           startupinfo, creationflags, shell,\n                           p2cread, p2cwrite,\n                           c2pread, c2pwrite,\n                           errread, errwrite,\n                           restore_signals,\n                           gid, gids, uid, umask,\n                           start_new_session, process_group):\n            \"\"\"Execute program (POSIX version)\"\"\"\n\n            if isinstance(args, (str, bytes)):\n                args = [args]\n            elif isinstance(args, os.PathLike):\n                if shell:\n                    raise TypeError('path-like args is not allowed when '\n                                    'shell is true')\n                args = [args]\n            else:\n                args = list(args)\n\n            if shell:\n                # On Android the default shell is at '/system/bin/sh'.\n                unix_shell = ('/system/bin/sh' if\n                          hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n                args = [unix_shell, \"-c\"] + args\n                if executable:\n                    args[0] = executable\n\n            if executable is None:\n                executable = args[0]\n\n            sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n            if (_USE_POSIX_SPAWN\n                    and os.path.dirname(executable)\n                    and preexec_fn is None\n                    and (not close_fds or _HAVE_POSIX_SPAWN_CLOSEFROM)\n                    and not pass_fds\n                    and cwd is None\n                    and (p2cread == -1 or p2cread > 2)\n                    and (c2pwrite == -1 or c2pwrite > 2)\n                    and (errwrite == -1 or errwrite > 2)\n                    and not start_new_session\n                    and process_group == -1\n                    and gid is None\n                    and gids is None\n                    and uid is None\n                    and umask < 0):\n                self._posix_spawn(args, executable, env, restore_signals, close_fds,\n                                  p2cread, p2cwrite,\n                                  c2pread, c2pwrite,\n                                  errread, errwrite)\n                return\n\n            orig_executable = executable\n\n            # For transferring possible exec failure from child to parent.\n            # Data format: \"exception name:hex errno:description\"\n            # Pickle is not used; it is complex and involves memory allocation.\n            errpipe_read, errpipe_write = os.pipe()\n            # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n            low_fds_to_close = []\n            while errpipe_write < 3:\n                low_fds_to_close.append(errpipe_write)\n                errpipe_write = os.dup(errpipe_write)\n            for low_fd in low_fds_to_close:\n                os.close(low_fd)\n            try:\n                try:\n                    # We must avoid complex work that could involve\n                    # malloc or free in the child process to avoid\n                    # potential deadlocks, thus we do all this here.\n                    # and pass it to fork_exec()\n\n                    if env is not None:\n                        env_list = []\n                        for k, v in env.items():\n                            k = os.fsencode(k)\n                            if b'=' in k:\n                                raise ValueError(\"illegal environment variable name\")\n                            env_list.append(k + b'=' + os.fsencode(v))\n                    else:\n                        env_list = None  # Use execv instead of execve.\n                    executable = os.fsencode(executable)\n                    if os.path.dirname(executable):\n                        executable_list = (executable,)\n                    else:\n                        # This matches the behavior of os._execvpe().\n                        executable_list = tuple(\n                            os.path.join(os.fsencode(dir), executable)\n                            for dir in os.get_exec_path(env))\n                    fds_to_keep = set(pass_fds)\n                    fds_to_keep.add(errpipe_write)\n                    self.pid = _fork_exec(\n                            args, executable_list,\n                            close_fds, tuple(sorted(map(int, fds_to_keep))),\n                            cwd, env_list,\n                            p2cread, p2cwrite, c2pread, c2pwrite,\n                            errread, errwrite,\n                            errpipe_read, errpipe_write,\n                            restore_signals, start_new_session,\n                            process_group, gid, gids, uid, umask,\n                            preexec_fn, _USE_VFORK)\n                    self._child_created = True\n                finally:\n                    # be sure the FD is closed no matter what\n                    os.close(errpipe_write)\n\n                self._close_pipe_fds(p2cread, p2cwrite,\n                                     c2pread, c2pwrite,\n                                     errread, errwrite)\n\n                # Wait for exec to fail or succeed; possibly raising an\n                # exception (limited in size)\n                errpipe_data = bytearray()\n                while True:\n                    part = os.read(errpipe_read, 50000)\n                    errpipe_data += part\n                    if not part or len(errpipe_data) > 50000:\n                        break\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_read)\n\n            if errpipe_data:\n                try:\n                    pid, sts = os.waitpid(self.pid, 0)\n                    if pid == self.pid:\n                        self._handle_exitstatus(sts)\n                    else:\n                        self.returncode = sys.maxsize\n                except ChildProcessError:\n                    pass\n\n                try:\n                    exception_name, hex_errno, err_msg = (\n                            errpipe_data.split(b':', 2))\n                    # The encoding here should match the encoding\n                    # written in by the subprocess implementations\n                    # like _posixsubprocess\n                    err_msg = err_msg.decode()\n                except ValueError:\n                    exception_name = b'SubprocessError'\n                    hex_errno = b'0'\n                    err_msg = 'Bad exception data from child: {!r}'.format(\n                                  bytes(errpipe_data))\n                child_exception_type = getattr(\n                        builtins, exception_name.decode('ascii'),\n                        SubprocessError)\n                if issubclass(child_exception_type, OSError) and hex_errno:\n                    errno_num = int(hex_errno, 16)\n                    if err_msg == \"noexec:chdir\":\n                        err_msg = \"\"\n                        # The error must be from chdir(cwd).\n                        err_filename = cwd\n                    elif err_msg == \"noexec\":\n                        err_msg = \"\"\n                        err_filename = None\n                    else:\n                        err_filename = orig_executable\n                    if errno_num != 0:\n                        err_msg = os.strerror(errno_num)\n                    if err_filename is not None:\n                        raise child_exception_type(errno_num, err_msg, err_filename)\n                    else:\n                        raise child_exception_type(errno_num, err_msg)\n                raise child_exception_type(err_msg)\n\n\n        def _handle_exitstatus(self, sts, _del_safe=_del_safe):\n            \"\"\"All callers to this function MUST hold self._waitpid_lock.\"\"\"\n            # This method is called (indirectly) by __del__, so it cannot\n            # refer to anything outside of its local scope.\n            if _del_safe.WIFSTOPPED(sts):\n                self.returncode = -_del_safe.WSTOPSIG(sts)\n            else:\n                self.returncode = _del_safe.waitstatus_to_exitcode(sts)\n\n        def _internal_poll(self, _deadstate=None, _del_safe=_del_safe):\n            \"\"\"Check if child process has terminated.  Returns returncode\n            attribute.\n\n            This method is called by __del__, so it cannot reference anything\n            outside of the local scope (nor can any methods it calls).\n\n            \"\"\"\n            if self.returncode is None:\n                if not self._waitpid_lock.acquire(False):\n                    # Something else is busy calling waitpid.  Don't allow two\n                    # at once.  We know nothing yet.\n                    return None\n                try:\n                    if self.returncode is not None:\n                        return self.returncode  # Another thread waited.\n                    pid, sts = _del_safe.waitpid(self.pid, _del_safe.WNOHANG)\n                    if pid == self.pid:\n                        self._handle_exitstatus(sts)\n                except OSError as e:\n                    if _deadstate is not None:\n                        self.returncode = _deadstate\n                    elif e.errno == _del_safe.ECHILD:\n                        # This happens if SIGCLD is set to be ignored or\n                        # waiting for child processes has otherwise been\n                        # disabled for our process.  This child is dead, we\n                        # can't get the status.\n                        # http://bugs.python.org/issue15756\n                        self.returncode = 0\n                finally:\n                    self._waitpid_lock.release()\n            return self.returncode\n\n\n        def _try_wait(self, wait_flags):\n            \"\"\"All callers to this function MUST hold self._waitpid_lock.\"\"\"\n            try:\n                (pid, sts) = os.waitpid(self.pid, wait_flags)\n            except ChildProcessError:\n                # This happens if SIGCLD is set to be ignored or waiting\n                # for child processes has otherwise been disabled for our\n                # process.  This child is dead, we can't get the status.\n                pid = self.pid\n                sts = 0\n            return (pid, sts)\n\n\n        def _wait(self, timeout):\n            \"\"\"Internal implementation of wait() on POSIX.\"\"\"\n            if self.returncode is not None:\n                return self.returncode\n\n            if timeout is not None:\n                endtime = _time() + timeout\n                # Enter a busy loop if we have a timeout.  This busy loop was\n                # cribbed from Lib/threading.py in Thread.wait() at r71065.\n                delay = 0.0005 # 500 us -> initial delay of 1 ms\n                while True:\n                    if self._waitpid_lock.acquire(False):\n                        try:\n                            if self.returncode is not None:\n                                break  # Another thread waited.\n                            (pid, sts) = self._try_wait(os.WNOHANG)\n                            assert pid == self.pid or pid == 0\n                            if pid == self.pid:\n                                self._handle_exitstatus(sts)\n                                break\n                        finally:\n                            self._waitpid_lock.release()\n                    remaining = self._remaining_time(endtime)\n                    if remaining <= 0:\n                        raise TimeoutExpired(self.args, timeout)\n                    delay = min(delay * 2, remaining, .05)\n                    time.sleep(delay)\n            else:\n                while self.returncode is None:\n                    with self._waitpid_lock:\n                        if self.returncode is not None:\n                            break  # Another thread waited.\n                        (pid, sts) = self._try_wait(0)\n                        # Check the pid and loop as waitpid has been known to\n                        # return 0 even without WNOHANG in odd situations.\n                        # http://bugs.python.org/issue14396.\n                        if pid == self.pid:\n                            self._handle_exitstatus(sts)\n            return self.returncode\n\n\n        def _communicate(self, input, endtime, orig_timeout):\n            if self.stdin and not self._communication_started:\n                # Flush stdio buffer.  This might block, if the user has\n                # been writing to .stdin in an uncontrolled fashion.\n                try:\n                    self.stdin.flush()\n                except BrokenPipeError:\n                    pass  # communicate() must ignore BrokenPipeError.\n                if not input:\n                    try:\n                        self.stdin.close()\n                    except BrokenPipeError:\n                        pass  # communicate() must ignore BrokenPipeError.\n\n            stdout = None\n            stderr = None\n\n            # Only create this mapping if we haven't already.\n            if not self._communication_started:\n                self._fileobj2output = {}\n                if self.stdout:\n                    self._fileobj2output[self.stdout] = []\n                if self.stderr:\n                    self._fileobj2output[self.stderr] = []\n\n            if self.stdout:\n                stdout = self._fileobj2output[self.stdout]\n            if self.stderr:\n                stderr = self._fileobj2output[self.stderr]\n\n            self._save_input(input)\n\n            if self._input:\n                input_view = memoryview(self._input)\n\n            with _PopenSelector() as selector:\n                if self.stdin and input:\n                    selector.register(self.stdin, selectors.EVENT_WRITE)\n                if self.stdout and not self.stdout.closed:\n                    selector.register(self.stdout, selectors.EVENT_READ)\n                if self.stderr and not self.stderr.closed:\n                    selector.register(self.stderr, selectors.EVENT_READ)\n\n                while selector.get_map():\n                    timeout = self._remaining_time(endtime)\n                    if timeout is not None and timeout < 0:\n                        self._check_timeout(endtime, orig_timeout,\n                                            stdout, stderr,\n                                            skip_check_and_raise=True)\n                        raise RuntimeError(  # Impossible :)\n                            '_check_timeout(..., skip_check_and_raise=True) '\n                            'failed to raise TimeoutExpired.')\n\n                    ready = selector.select(timeout)\n                    self._check_timeout(endtime, orig_timeout, stdout, stderr)\n\n                    # XXX Rewrite these to use non-blocking I/O on the file\n                    # objects; they are no longer using C stdio!\n\n                    for key, events in ready:\n                        if key.fileobj is self.stdin:\n                            chunk = input_view[self._input_offset :\n                                               self._input_offset + _PIPE_BUF]\n                            try:\n                                self._input_offset += os.write(key.fd, chunk)\n                            except BrokenPipeError:\n                                selector.unregister(key.fileobj)\n                                key.fileobj.close()\n                            else:\n                                if self._input_offset >= len(self._input):\n                                    selector.unregister(key.fileobj)\n                                    key.fileobj.close()\n                        elif key.fileobj in (self.stdout, self.stderr):\n                            data = os.read(key.fd, 32768)\n                            if not data:\n                                selector.unregister(key.fileobj)\n                                key.fileobj.close()\n                            self._fileobj2output[key.fileobj].append(data)\n\n            self.wait(timeout=self._remaining_time(endtime))\n\n            # All data exchanged.  Translate lists into strings.\n            if stdout is not None:\n                stdout = b''.join(stdout)\n            if stderr is not None:\n                stderr = b''.join(stderr)\n\n            # Translate newlines, if requested.\n            # This also turns bytes into strings.\n            if self.text_mode:\n                if stdout is not None:\n                    stdout = self._translate_newlines(stdout,\n                                                      self.stdout.encoding,\n                                                      self.stdout.errors)\n                if stderr is not None:\n                    stderr = self._translate_newlines(stderr,\n                                                      self.stderr.encoding,\n                                                      self.stderr.errors)\n\n            return (stdout, stderr)\n\n\n        def _save_input(self, input):\n            # This method is called from the _communicate_with_*() methods\n            # so that if we time out while communicating, we can continue\n            # sending input if we retry.\n            if self.stdin and self._input is None:\n                self._input_offset = 0\n                self._input = input\n                if input is not None and self.text_mode:\n                    self._input = self._input.encode(self.stdin.encoding,\n                                                     self.stdin.errors)\n\n\n        def send_signal(self, sig):\n            \"\"\"Send a signal to the process.\"\"\"\n            # bpo-38630: Polling reduces the risk of sending a signal to the\n            # wrong process if the process completed, the Popen.returncode\n            # attribute is still None, and the pid has been reassigned\n            # (recycled) to a new different process. This race condition can\n            # happens in two cases.\n            #\n            # Case 1. Thread A calls Popen.poll(), thread B calls\n            # Popen.send_signal(). In thread A, waitpid() succeed and returns\n            # the exit status. Thread B calls kill() because poll() in thread A\n            # did not set returncode yet. Calling poll() in thread B prevents\n            # the race condition thanks to Popen._waitpid_lock.\n            #\n            # Case 2. waitpid(pid, 0) has been called directly, without\n            # using Popen methods: returncode is still None is this case.\n            # Calling Popen.poll() will set returncode to a default value,\n            # since waitpid() fails with ProcessLookupError.\n            self.poll()\n            if self.returncode is not None:\n                # Skip signalling a process that we know has already died.\n                return\n\n            # The race condition can still happen if the race condition\n            # described above happens between the returncode test\n            # and the kill() call.\n            try:\n                os.kill(self.pid, sig)\n            except ProcessLookupError:\n                # Suppress the race condition error; bpo-40550.\n                pass\n\n        def terminate(self):\n            \"\"\"Terminate the process with SIGTERM\n            \"\"\"\n            # Lazy import to improve module import time\n            import signal\n            self.send_signal(signal.SIGTERM)\n\n        def kill(self):\n            \"\"\"Kill the process with SIGKILL\n            \"\"\"\n            # Lazy import to improve module import time\n            import signal\n            self.send_signal(signal.SIGKILL)\n", 2235], "C:\\Programming\\Python313\\Lib\\queue.py": ["'''A multi-producer, multi-consumer queue.'''\n\nimport threading\nimport types\nfrom collections import deque\nfrom heapq import heappush, heappop\nfrom time import monotonic as time\ntry:\n    from _queue import SimpleQueue\nexcept ImportError:\n    SimpleQueue = None\n\n__all__ = [\n    'Empty',\n    'Full',\n    'ShutDown',\n    'Queue',\n    'PriorityQueue',\n    'LifoQueue',\n    'SimpleQueue',\n]\n\n\ntry:\n    from _queue import Empty\nexcept ImportError:\n    class Empty(Exception):\n        'Exception raised by Queue.get(block=0)/get_nowait().'\n        pass\n\nclass Full(Exception):\n    'Exception raised by Queue.put(block=0)/put_nowait().'\n    pass\n\n\nclass ShutDown(Exception):\n    '''Raised when put/get with shut-down queue.'''\n\n\nclass Queue:\n    '''Create a queue object with a given maximum size.\n\n    If maxsize is <= 0, the queue size is infinite.\n    '''\n\n    def __init__(self, maxsize=0):\n        self.maxsize = maxsize\n        self._init(maxsize)\n\n        # mutex must be held whenever the queue is mutating.  All methods\n        # that acquire mutex must release it before returning.  mutex\n        # is shared between the three conditions, so acquiring and\n        # releasing the conditions also acquires and releases mutex.\n        self.mutex = threading.Lock()\n\n        # Notify not_empty whenever an item is added to the queue; a\n        # thread waiting to get is notified then.\n        self.not_empty = threading.Condition(self.mutex)\n\n        # Notify not_full whenever an item is removed from the queue;\n        # a thread waiting to put is notified then.\n        self.not_full = threading.Condition(self.mutex)\n\n        # Notify all_tasks_done whenever the number of unfinished tasks\n        # drops to zero; thread waiting to join() is notified to resume\n        self.all_tasks_done = threading.Condition(self.mutex)\n        self.unfinished_tasks = 0\n\n        # Queue shutdown state\n        self.is_shutdown = False\n\n    def task_done(self):\n        '''Indicate that a formerly enqueued task is complete.\n\n        Used by Queue consumer threads.  For each get() used to fetch a task,\n        a subsequent call to task_done() tells the queue that the processing\n        on the task is complete.\n\n        If a join() is currently blocking, it will resume when all items\n        have been processed (meaning that a task_done() call was received\n        for every item that had been put() into the queue).\n\n        shutdown(immediate=True) calls task_done() for each remaining item in\n        the queue.\n\n        Raises a ValueError if called more times than there were items\n        placed in the queue.\n        '''\n        with self.all_tasks_done:\n            unfinished = self.unfinished_tasks - 1\n            if unfinished <= 0:\n                if unfinished < 0:\n                    raise ValueError('task_done() called too many times')\n                self.all_tasks_done.notify_all()\n            self.unfinished_tasks = unfinished\n\n    def join(self):\n        '''Blocks until all items in the Queue have been gotten and processed.\n\n        The count of unfinished tasks goes up whenever an item is added to the\n        queue. The count goes down whenever a consumer thread calls task_done()\n        to indicate the item was retrieved and all work on it is complete.\n\n        When the count of unfinished tasks drops to zero, join() unblocks.\n        '''\n        with self.all_tasks_done:\n            while self.unfinished_tasks:\n                self.all_tasks_done.wait()\n\n    def qsize(self):\n        '''Return the approximate size of the queue (not reliable!).'''\n        with self.mutex:\n            return self._qsize()\n\n    def empty(self):\n        '''Return True if the queue is empty, False otherwise (not reliable!).\n\n        This method is likely to be removed at some point.  Use qsize() == 0\n        as a direct substitute, but be aware that either approach risks a race\n        condition where a queue can grow before the result of empty() or\n        qsize() can be used.\n\n        To create code that needs to wait for all queued tasks to be\n        completed, the preferred technique is to use the join() method.\n        '''\n        with self.mutex:\n            return not self._qsize()\n\n    def full(self):\n        '''Return True if the queue is full, False otherwise (not reliable!).\n\n        This method is likely to be removed at some point.  Use qsize() >= n\n        as a direct substitute, but be aware that either approach risks a race\n        condition where a queue can shrink before the result of full() or\n        qsize() can be used.\n        '''\n        with self.mutex:\n            return 0 < self.maxsize <= self._qsize()\n\n    def put(self, item, block=True, timeout=None):\n        '''Put an item into the queue.\n\n        If optional args 'block' is true and 'timeout' is None (the default),\n        block if necessary until a free slot is available. If 'timeout' is\n        a non-negative number, it blocks at most 'timeout' seconds and raises\n        the Full exception if no free slot was available within that time.\n        Otherwise ('block' is false), put an item on the queue if a free slot\n        is immediately available, else raise the Full exception ('timeout'\n        is ignored in that case).\n\n        Raises ShutDown if the queue has been shut down.\n        '''\n        with self.not_full:\n            if self.is_shutdown:\n                raise ShutDown\n            if self.maxsize > 0:\n                if not block:\n                    if self._qsize() >= self.maxsize:\n                        raise Full\n                elif timeout is None:\n                    while self._qsize() >= self.maxsize:\n                        self.not_full.wait()\n                        if self.is_shutdown:\n                            raise ShutDown\n                elif timeout < 0:\n                    raise ValueError(\"'timeout' must be a non-negative number\")\n                else:\n                    endtime = time() + timeout\n                    while self._qsize() >= self.maxsize:\n                        remaining = endtime - time()\n                        if remaining <= 0.0:\n                            raise Full\n                        self.not_full.wait(remaining)\n                        if self.is_shutdown:\n                            raise ShutDown\n            self._put(item)\n            self.unfinished_tasks += 1\n            self.not_empty.notify()\n\n    def get(self, block=True, timeout=None):\n        '''Remove and return an item from the queue.\n\n        If optional args 'block' is true and 'timeout' is None (the default),\n        block if necessary until an item is available. If 'timeout' is\n        a non-negative number, it blocks at most 'timeout' seconds and raises\n        the Empty exception if no item was available within that time.\n        Otherwise ('block' is false), return an item if one is immediately\n        available, else raise the Empty exception ('timeout' is ignored\n        in that case).\n\n        Raises ShutDown if the queue has been shut down and is empty,\n        or if the queue has been shut down immediately.\n        '''\n        with self.not_empty:\n            if self.is_shutdown and not self._qsize():\n                raise ShutDown\n            if not block:\n                if not self._qsize():\n                    raise Empty\n            elif timeout is None:\n                while not self._qsize():\n                    self.not_empty.wait()\n                    if self.is_shutdown and not self._qsize():\n                        raise ShutDown\n            elif timeout < 0:\n                raise ValueError(\"'timeout' must be a non-negative number\")\n            else:\n                endtime = time() + timeout\n                while not self._qsize():\n                    remaining = endtime - time()\n                    if remaining <= 0.0:\n                        raise Empty\n                    self.not_empty.wait(remaining)\n                    if self.is_shutdown and not self._qsize():\n                        raise ShutDown\n            item = self._get()\n            self.not_full.notify()\n            return item\n\n    def put_nowait(self, item):\n        '''Put an item into the queue without blocking.\n\n        Only enqueue the item if a free slot is immediately available.\n        Otherwise raise the Full exception.\n        '''\n        return self.put(item, block=False)\n\n    def get_nowait(self):\n        '''Remove and return an item from the queue without blocking.\n\n        Only get an item if one is immediately available. Otherwise\n        raise the Empty exception.\n        '''\n        return self.get(block=False)\n\n    def shutdown(self, immediate=False):\n        '''Shut-down the queue, making queue gets and puts raise ShutDown.\n\n        By default, gets will only raise once the queue is empty. Set\n        'immediate' to True to make gets raise immediately instead.\n\n        All blocked callers of put() and get() will be unblocked. If\n        'immediate', a task is marked as done for each item remaining in\n        the queue, which may unblock callers of join().\n        '''\n        with self.mutex:\n            self.is_shutdown = True\n            if immediate:\n                while self._qsize():\n                    self._get()\n                    if self.unfinished_tasks > 0:\n                        self.unfinished_tasks -= 1\n                # release all blocked threads in `join()`\n                self.all_tasks_done.notify_all()\n            # All getters need to re-check queue-empty to raise ShutDown\n            self.not_empty.notify_all()\n            self.not_full.notify_all()\n\n    # Override these methods to implement other queue organizations\n    # (e.g. stack or priority queue).\n    # These will only be called with appropriate locks held\n\n    # Initialize the queue representation\n    def _init(self, maxsize):\n        self.queue = deque()\n\n    def _qsize(self):\n        return len(self.queue)\n\n    # Put a new item in the queue\n    def _put(self, item):\n        self.queue.append(item)\n\n    # Get an item from the queue\n    def _get(self):\n        return self.queue.popleft()\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n\nclass PriorityQueue(Queue):\n    '''Variant of Queue that retrieves open entries in priority order (lowest first).\n\n    Entries are typically tuples of the form:  (priority number, data).\n    '''\n\n    def _init(self, maxsize):\n        self.queue = []\n\n    def _qsize(self):\n        return len(self.queue)\n\n    def _put(self, item):\n        heappush(self.queue, item)\n\n    def _get(self):\n        return heappop(self.queue)\n\n\nclass LifoQueue(Queue):\n    '''Variant of Queue that retrieves most recently added entries first.'''\n\n    def _init(self, maxsize):\n        self.queue = []\n\n    def _qsize(self):\n        return len(self.queue)\n\n    def _put(self, item):\n        self.queue.append(item)\n\n    def _get(self):\n        return self.queue.pop()\n\n\nclass _PySimpleQueue:\n    '''Simple, unbounded FIFO queue.\n\n    This pure Python implementation is not reentrant.\n    '''\n    # Note: while this pure Python version provides fairness\n    # (by using a threading.Semaphore which is itself fair, being based\n    #  on threading.Condition), fairness is not part of the API contract.\n    # This allows the C version to use a different implementation.\n\n    def __init__(self):\n        self._queue = deque()\n        self._count = threading.Semaphore(0)\n\n    def put(self, item, block=True, timeout=None):\n        '''Put the item on the queue.\n\n        The optional 'block' and 'timeout' arguments are ignored, as this method\n        never blocks.  They are provided for compatibility with the Queue class.\n        '''\n        self._queue.append(item)\n        self._count.release()\n\n    def get(self, block=True, timeout=None):\n        '''Remove and return an item from the queue.\n\n        If optional args 'block' is true and 'timeout' is None (the default),\n        block if necessary until an item is available. If 'timeout' is\n        a non-negative number, it blocks at most 'timeout' seconds and raises\n        the Empty exception if no item was available within that time.\n        Otherwise ('block' is false), return an item if one is immediately\n        available, else raise the Empty exception ('timeout' is ignored\n        in that case).\n        '''\n        if timeout is not None and timeout < 0:\n            raise ValueError(\"'timeout' must be a non-negative number\")\n        if not self._count.acquire(block, timeout):\n            raise Empty\n        return self._queue.popleft()\n\n    def put_nowait(self, item):\n        '''Put an item into the queue without blocking.\n\n        This is exactly equivalent to `put(item, block=False)` and is only provided\n        for compatibility with the Queue class.\n        '''\n        return self.put(item, block=False)\n\n    def get_nowait(self):\n        '''Remove and return an item from the queue without blocking.\n\n        Only get an item if one is immediately available. Otherwise\n        raise the Empty exception.\n        '''\n        return self.get(block=False)\n\n    def empty(self):\n        '''Return True if the queue is empty, False otherwise (not reliable!).'''\n        return len(self._queue) == 0\n\n    def qsize(self):\n        '''Return the approximate size of the queue (not reliable!).'''\n        return len(self._queue)\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n\nif SimpleQueue is None:\n    SimpleQueue = _PySimpleQueue\n", 384], "C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py": ["#\n# Module providing various facilities to other parts of the package\n#\n# multiprocessing/util.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\nimport os\nimport itertools\nimport sys\nimport weakref\nimport atexit\nimport threading        # we want threading to install it's\n                        # cleanup function before multiprocessing does\nfrom subprocess import _args_from_interpreter_flags\n\nfrom . import process\n\n__all__ = [\n    'sub_debug', 'debug', 'info', 'sub_warning', 'get_logger',\n    'log_to_stderr', 'get_temp_dir', 'register_after_fork',\n    'is_exiting', 'Finalize', 'ForkAwareThreadLock', 'ForkAwareLocal',\n    'close_all_fds_except', 'SUBDEBUG', 'SUBWARNING',\n    ]\n\n#\n# Logging\n#\n\nNOTSET = 0\nSUBDEBUG = 5\nDEBUG = 10\nINFO = 20\nSUBWARNING = 25\n\nLOGGER_NAME = 'multiprocessing'\nDEFAULT_LOGGING_FORMAT = '[%(levelname)s/%(processName)s] %(message)s'\n\n_logger = None\n_log_to_stderr = False\n\ndef sub_debug(msg, *args):\n    if _logger:\n        _logger.log(SUBDEBUG, msg, *args, stacklevel=2)\n\ndef debug(msg, *args):\n    if _logger:\n        _logger.log(DEBUG, msg, *args, stacklevel=2)\n\ndef info(msg, *args):\n    if _logger:\n        _logger.log(INFO, msg, *args, stacklevel=2)\n\ndef sub_warning(msg, *args):\n    if _logger:\n        _logger.log(SUBWARNING, msg, *args, stacklevel=2)\n\ndef get_logger():\n    '''\n    Returns logger used by multiprocessing\n    '''\n    global _logger\n    import logging\n\n    with logging._lock:\n        if not _logger:\n\n            _logger = logging.getLogger(LOGGER_NAME)\n            _logger.propagate = 0\n\n            # XXX multiprocessing should cleanup before logging\n            if hasattr(atexit, 'unregister'):\n                atexit.unregister(_exit_function)\n                atexit.register(_exit_function)\n            else:\n                atexit._exithandlers.remove((_exit_function, (), {}))\n                atexit._exithandlers.append((_exit_function, (), {}))\n\n    return _logger\n\ndef log_to_stderr(level=None):\n    '''\n    Turn on logging and add a handler which prints to stderr\n    '''\n    global _log_to_stderr\n    import logging\n\n    logger = get_logger()\n    formatter = logging.Formatter(DEFAULT_LOGGING_FORMAT)\n    handler = logging.StreamHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    if level:\n        logger.setLevel(level)\n    _log_to_stderr = True\n    return _logger\n\n\n# Abstract socket support\n\ndef _platform_supports_abstract_sockets():\n    return sys.platform in (\"linux\", \"android\")\n\n\ndef is_abstract_socket_namespace(address):\n    if not address:\n        return False\n    if isinstance(address, bytes):\n        return address[0] == 0\n    elif isinstance(address, str):\n        return address[0] == \"\\0\"\n    raise TypeError(f'address type of {address!r} unrecognized')\n\n\nabstract_sockets_supported = _platform_supports_abstract_sockets()\n\n#\n# Function returning a temp directory which will be removed on exit\n#\n\ndef _remove_temp_dir(rmtree, tempdir):\n    rmtree(tempdir)\n\n    current_process = process.current_process()\n    # current_process() can be None if the finalizer is called\n    # late during Python finalization\n    if current_process is not None:\n        current_process._config['tempdir'] = None\n\ndef get_temp_dir():\n    # get name of a temp directory which will be automatically cleaned up\n    tempdir = process.current_process()._config.get('tempdir')\n    if tempdir is None:\n        import shutil, tempfile\n        tempdir = tempfile.mkdtemp(prefix='pymp-')\n        info('created temp directory %s', tempdir)\n        # keep a strong reference to shutil.rmtree(), since the finalizer\n        # can be called late during Python shutdown\n        Finalize(None, _remove_temp_dir, args=(shutil.rmtree, tempdir),\n                 exitpriority=-100)\n        process.current_process()._config['tempdir'] = tempdir\n    return tempdir\n\n#\n# Support for reinitialization of objects when bootstrapping a child process\n#\n\n_afterfork_registry = weakref.WeakValueDictionary()\n_afterfork_counter = itertools.count()\n\ndef _run_after_forkers():\n    items = list(_afterfork_registry.items())\n    items.sort()\n    for (index, ident, func), obj in items:\n        try:\n            func(obj)\n        except Exception as e:\n            info('after forker raised exception %s', e)\n\ndef register_after_fork(obj, func):\n    _afterfork_registry[(next(_afterfork_counter), id(obj), func)] = obj\n\n#\n# Finalization using weakrefs\n#\n\n_finalizer_registry = {}\n_finalizer_counter = itertools.count()\n\n\nclass Finalize(object):\n    '''\n    Class which supports object finalization using weakrefs\n    '''\n    def __init__(self, obj, callback, args=(), kwargs=None, exitpriority=None):\n        if (exitpriority is not None) and not isinstance(exitpriority,int):\n            raise TypeError(\n                \"Exitpriority ({0!r}) must be None or int, not {1!s}\".format(\n                    exitpriority, type(exitpriority)))\n\n        if obj is not None:\n            self._weakref = weakref.ref(obj, self)\n        elif exitpriority is None:\n            raise ValueError(\"Without object, exitpriority cannot be None\")\n\n        self._callback = callback\n        self._args = args\n        self._kwargs = kwargs or {}\n        self._key = (exitpriority, next(_finalizer_counter))\n        self._pid = os.getpid()\n\n        _finalizer_registry[self._key] = self\n\n    def __call__(self, wr=None,\n                 # Need to bind these locally because the globals can have\n                 # been cleared at shutdown\n                 _finalizer_registry=_finalizer_registry,\n                 sub_debug=sub_debug, getpid=os.getpid):\n        '''\n        Run the callback unless it has already been called or cancelled\n        '''\n        try:\n            del _finalizer_registry[self._key]\n        except KeyError:\n            sub_debug('finalizer no longer registered')\n        else:\n            if self._pid != getpid():\n                sub_debug('finalizer ignored because different process')\n                res = None\n            else:\n                sub_debug('finalizer calling %s with args %s and kwargs %s',\n                          self._callback, self._args, self._kwargs)\n                res = self._callback(*self._args, **self._kwargs)\n            self._weakref = self._callback = self._args = \\\n                            self._kwargs = self._key = None\n            return res\n\n    def cancel(self):\n        '''\n        Cancel finalization of the object\n        '''\n        try:\n            del _finalizer_registry[self._key]\n        except KeyError:\n            pass\n        else:\n            self._weakref = self._callback = self._args = \\\n                            self._kwargs = self._key = None\n\n    def still_active(self):\n        '''\n        Return whether this finalizer is still waiting to invoke callback\n        '''\n        return self._key in _finalizer_registry\n\n    def __repr__(self):\n        try:\n            obj = self._weakref()\n        except (AttributeError, TypeError):\n            obj = None\n\n        if obj is None:\n            return '<%s object, dead>' % self.__class__.__name__\n\n        x = '<%s object, callback=%s' % (\n                self.__class__.__name__,\n                getattr(self._callback, '__name__', self._callback))\n        if self._args:\n            x += ', args=' + str(self._args)\n        if self._kwargs:\n            x += ', kwargs=' + str(self._kwargs)\n        if self._key[0] is not None:\n            x += ', exitpriority=' + str(self._key[0])\n        return x + '>'\n\n\ndef _run_finalizers(minpriority=None):\n    '''\n    Run all finalizers whose exit priority is not None and at least minpriority\n\n    Finalizers with highest priority are called first; finalizers with\n    the same priority will be called in reverse order of creation.\n    '''\n    if _finalizer_registry is None:\n        # This function may be called after this module's globals are\n        # destroyed.  See the _exit_function function in this module for more\n        # notes.\n        return\n\n    if minpriority is None:\n        f = lambda p : p[0] is not None\n    else:\n        f = lambda p : p[0] is not None and p[0] >= minpriority\n\n    # Careful: _finalizer_registry may be mutated while this function\n    # is running (either by a GC run or by another thread).\n\n    # list(_finalizer_registry) should be atomic, while\n    # list(_finalizer_registry.items()) is not.\n    keys = [key for key in list(_finalizer_registry) if f(key)]\n    keys.sort(reverse=True)\n\n    for key in keys:\n        finalizer = _finalizer_registry.get(key)\n        # key may have been removed from the registry\n        if finalizer is not None:\n            sub_debug('calling %s', finalizer)\n            try:\n                finalizer()\n            except Exception:\n                import traceback\n                traceback.print_exc()\n\n    if minpriority is None:\n        _finalizer_registry.clear()\n\n#\n# Clean up on exit\n#\n\ndef is_exiting():\n    '''\n    Returns true if the process is shutting down\n    '''\n    return _exiting or _exiting is None\n\n_exiting = False\n\ndef _exit_function(info=info, debug=debug, _run_finalizers=_run_finalizers,\n                   active_children=process.active_children,\n                   current_process=process.current_process):\n    # We hold on to references to functions in the arglist due to the\n    # situation described below, where this function is called after this\n    # module's globals are destroyed.\n\n    global _exiting\n\n    if not _exiting:\n        _exiting = True\n\n        info('process shutting down')\n        debug('running all \"atexit\" finalizers with priority >= 0')\n        _run_finalizers(0)\n\n        if current_process() is not None:\n            # We check if the current process is None here because if\n            # it's None, any call to ``active_children()`` will raise\n            # an AttributeError (active_children winds up trying to\n            # get attributes from util._current_process).  One\n            # situation where this can happen is if someone has\n            # manipulated sys.modules, causing this module to be\n            # garbage collected.  The destructor for the module type\n            # then replaces all values in the module dict with None.\n            # For instance, after setuptools runs a test it replaces\n            # sys.modules with a copy created earlier.  See issues\n            # #9775 and #15881.  Also related: #4106, #9205, and\n            # #9207.\n\n            for p in active_children():\n                if p.daemon:\n                    info('calling terminate() for daemon %s', p.name)\n                    p._popen.terminate()\n\n            for p in active_children():\n                info('calling join() for process %s', p.name)\n                p.join()\n\n        debug('running the remaining \"atexit\" finalizers')\n        _run_finalizers()\n\natexit.register(_exit_function)\n\n#\n# Some fork aware types\n#\n\nclass ForkAwareThreadLock(object):\n    def __init__(self):\n        self._lock = threading.Lock()\n        self.acquire = self._lock.acquire\n        self.release = self._lock.release\n        register_after_fork(self, ForkAwareThreadLock._at_fork_reinit)\n\n    def _at_fork_reinit(self):\n        self._lock._at_fork_reinit()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n\nclass ForkAwareLocal(threading.local):\n    def __init__(self):\n        register_after_fork(self, lambda obj : obj.__dict__.clear())\n    def __reduce__(self):\n        return type(self), ()\n\n#\n# Close fds except those specified\n#\n\ntry:\n    MAXFD = os.sysconf(\"SC_OPEN_MAX\")\nexcept Exception:\n    MAXFD = 256\n\ndef close_all_fds_except(fds):\n    fds = list(fds) + [-1, MAXFD]\n    fds.sort()\n    assert fds[-1] == MAXFD, 'fd too large'\n    for i in range(len(fds) - 1):\n        os.closerange(fds[i]+1, fds[i+1])\n#\n# Close sys.stdin and replace stdin with os.devnull\n#\n\ndef _close_stdin():\n    if sys.stdin is None:\n        return\n\n    try:\n        sys.stdin.close()\n    except (OSError, ValueError):\n        pass\n\n    try:\n        fd = os.open(os.devnull, os.O_RDONLY)\n        try:\n            sys.stdin = open(fd, encoding=\"utf-8\", closefd=False)\n        except:\n            os.close(fd)\n            raise\n    except (OSError, ValueError):\n        pass\n\n#\n# Flush standard streams, if any\n#\n\ndef _flush_std_streams():\n    try:\n        sys.stdout.flush()\n    except (AttributeError, ValueError):\n        pass\n    try:\n        sys.stderr.flush()\n    except (AttributeError, ValueError):\n        pass\n\n#\n# Start a program with only specified fds kept open\n#\n\ndef spawnv_passfds(path, args, passfds):\n    import _posixsubprocess\n    import subprocess\n    passfds = tuple(sorted(map(int, passfds)))\n    errpipe_read, errpipe_write = os.pipe()\n    try:\n        return _posixsubprocess.fork_exec(\n            args, [path], True, passfds, None, None,\n            -1, -1, -1, -1, -1, -1, errpipe_read, errpipe_write,\n            False, False, -1, None, None, None, -1, None,\n            subprocess._USE_VFORK)\n    finally:\n        os.close(errpipe_read)\n        os.close(errpipe_write)\n\n\ndef close_fds(*fds):\n    \"\"\"Close each file descriptor given as an argument\"\"\"\n    for fd in fds:\n        os.close(fd)\n\n\ndef _cleanup_tests():\n    \"\"\"Cleanup multiprocessing resources when multiprocessing tests\n    completed.\"\"\"\n\n    from test import support\n\n    # cleanup multiprocessing\n    process._cleanup()\n\n    # Stop the ForkServer process if it's running\n    from multiprocessing import forkserver\n    forkserver._forkserver._stop()\n\n    # Stop the ResourceTracker process if it's running\n    from multiprocessing import resource_tracker\n    resource_tracker._resource_tracker._stop()\n\n    # bpo-37421: Explicitly call _run_finalizers() to remove immediately\n    # temporary directories created by multiprocessing.util.get_temp_dir().\n    _run_finalizers()\n    support.gc_collect()\n\n    support.reap_children()\n", 483], "C:\\Programming\\Python313\\Lib\\weakref.py": ["\"\"\"Weak reference support for Python.\n\nThis module is an implementation of PEP 205:\n\nhttps://peps.python.org/pep-0205/\n\"\"\"\n\n# Naming convention: Variables named \"wr\" are weak reference objects;\n# they are called this instead of \"ref\" to avoid name collisions with\n# the module-global ref() function imported from _weakref.\n\nfrom _weakref import (\n     getweakrefcount,\n     getweakrefs,\n     ref,\n     proxy,\n     CallableProxyType,\n     ProxyType,\n     ReferenceType,\n     _remove_dead_weakref)\n\nfrom _weakrefset import WeakSet, _IterationGuard\n\nimport _collections_abc  # Import after _weakref to avoid circular import.\nimport sys\nimport itertools\n\nProxyTypes = (ProxyType, CallableProxyType)\n\n__all__ = [\"ref\", \"proxy\", \"getweakrefcount\", \"getweakrefs\",\n           \"WeakKeyDictionary\", \"ReferenceType\", \"ProxyType\",\n           \"CallableProxyType\", \"ProxyTypes\", \"WeakValueDictionary\",\n           \"WeakSet\", \"WeakMethod\", \"finalize\"]\n\n\n_collections_abc.MutableSet.register(WeakSet)\n\nclass WeakMethod(ref):\n    \"\"\"\n    A custom `weakref.ref` subclass which simulates a weak reference to\n    a bound method, working around the lifetime problem of bound methods.\n    \"\"\"\n\n    __slots__ = \"_func_ref\", \"_meth_type\", \"_alive\", \"__weakref__\"\n\n    def __new__(cls, meth, callback=None):\n        try:\n            obj = meth.__self__\n            func = meth.__func__\n        except AttributeError:\n            raise TypeError(\"argument should be a bound method, not {}\"\n                            .format(type(meth))) from None\n        def _cb(arg):\n            # The self-weakref trick is needed to avoid creating a reference\n            # cycle.\n            self = self_wr()\n            if self._alive:\n                self._alive = False\n                if callback is not None:\n                    callback(self)\n        self = ref.__new__(cls, obj, _cb)\n        self._func_ref = ref(func, _cb)\n        self._meth_type = type(meth)\n        self._alive = True\n        self_wr = ref(self)\n        return self\n\n    def __call__(self):\n        obj = super().__call__()\n        func = self._func_ref()\n        if obj is None or func is None:\n            return None\n        return self._meth_type(func, obj)\n\n    def __eq__(self, other):\n        if isinstance(other, WeakMethod):\n            if not self._alive or not other._alive:\n                return self is other\n            return ref.__eq__(self, other) and self._func_ref == other._func_ref\n        return NotImplemented\n\n    def __ne__(self, other):\n        if isinstance(other, WeakMethod):\n            if not self._alive or not other._alive:\n                return self is not other\n            return ref.__ne__(self, other) or self._func_ref != other._func_ref\n        return NotImplemented\n\n    __hash__ = ref.__hash__\n\n\nclass WeakValueDictionary(_collections_abc.MutableMapping):\n    \"\"\"Mapping class that references values weakly.\n\n    Entries in the dictionary will be discarded when no strong\n    reference to the value exists anymore\n    \"\"\"\n    # We inherit the constructor without worrying about the input\n    # dictionary; since it uses our .update() method, we get the right\n    # checks (if the other dictionary is a WeakValueDictionary,\n    # objects are unwrapped on the way out, and we always wrap on the\n    # way in).\n\n    def __init__(self, other=(), /, **kw):\n        def remove(wr, selfref=ref(self), _atomic_removal=_remove_dead_weakref):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(wr.key)\n                else:\n                    # Atomic removal is necessary since this function\n                    # can be called asynchronously by the GC\n                    _atomic_removal(self.data, wr.key)\n        self._remove = remove\n        # A list of keys to be removed\n        self._pending_removals = []\n        self._iterating = set()\n        self.data = {}\n        self.update(other, **kw)\n\n    def _commit_removals(self, _atomic_removal=_remove_dead_weakref):\n        pop = self._pending_removals.pop\n        d = self.data\n        # We shouldn't encounter any KeyError, because this method should\n        # always be called *before* mutating the dict.\n        while True:\n            try:\n                key = pop()\n            except IndexError:\n                return\n            _atomic_removal(d, key)\n\n    def __getitem__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        o = self.data[key]()\n        if o is None:\n            raise KeyError(key)\n        else:\n            return o\n\n    def __delitem__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        del self.data[key]\n\n    def __len__(self):\n        if self._pending_removals:\n            self._commit_removals()\n        return len(self.data)\n\n    def __contains__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            o = self.data[key]()\n        except KeyError:\n            return False\n        return o is not None\n\n    def __repr__(self):\n        return \"<%s at %#x>\" % (self.__class__.__name__, id(self))\n\n    def __setitem__(self, key, value):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data[key] = KeyedRef(value, self._remove, key)\n\n    def copy(self):\n        if self._pending_removals:\n            self._commit_removals()\n        new = WeakValueDictionary()\n        with _IterationGuard(self):\n            for key, wr in self.data.items():\n                o = wr()\n                if o is not None:\n                    new[key] = o\n        return new\n\n    __copy__ = copy\n\n    def __deepcopy__(self, memo):\n        from copy import deepcopy\n        if self._pending_removals:\n            self._commit_removals()\n        new = self.__class__()\n        with _IterationGuard(self):\n            for key, wr in self.data.items():\n                o = wr()\n                if o is not None:\n                    new[deepcopy(key, memo)] = o\n        return new\n\n    def get(self, key, default=None):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            wr = self.data[key]\n        except KeyError:\n            return default\n        else:\n            o = wr()\n            if o is None:\n                # This should only happen\n                return default\n            else:\n                return o\n\n    def items(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for k, wr in self.data.items():\n                v = wr()\n                if v is not None:\n                    yield k, v\n\n    def keys(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for k, wr in self.data.items():\n                if wr() is not None:\n                    yield k\n\n    __iter__ = keys\n\n    def itervaluerefs(self):\n        \"\"\"Return an iterator that yields the weak references to the values.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the values around longer than needed.\n\n        \"\"\"\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            yield from self.data.values()\n\n    def values(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for wr in self.data.values():\n                obj = wr()\n                if obj is not None:\n                    yield obj\n\n    def popitem(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            key, wr = self.data.popitem()\n            o = wr()\n            if o is not None:\n                return key, o\n\n    def pop(self, key, *args):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            o = self.data.pop(key)()\n        except KeyError:\n            o = None\n        if o is None:\n            if args:\n                return args[0]\n            else:\n                raise KeyError(key)\n        else:\n            return o\n\n    def setdefault(self, key, default=None):\n        try:\n            o = self.data[key]()\n        except KeyError:\n            o = None\n        if o is None:\n            if self._pending_removals:\n                self._commit_removals()\n            self.data[key] = KeyedRef(default, self._remove, key)\n            return default\n        else:\n            return o\n\n    def update(self, other=None, /, **kwargs):\n        if self._pending_removals:\n            self._commit_removals()\n        d = self.data\n        if other is not None:\n            if not hasattr(other, \"items\"):\n                other = dict(other)\n            for key, o in other.items():\n                d[key] = KeyedRef(o, self._remove, key)\n        for key, o in kwargs.items():\n            d[key] = KeyedRef(o, self._remove, key)\n\n    def valuerefs(self):\n        \"\"\"Return a list of weak references to the values.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the values around longer than needed.\n\n        \"\"\"\n        if self._pending_removals:\n            self._commit_removals()\n        return list(self.data.values())\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def __or__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.copy()\n            c.update(other)\n            return c\n        return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.__class__()\n            c.update(other)\n            c.update(self)\n            return c\n        return NotImplemented\n\n\nclass KeyedRef(ref):\n    \"\"\"Specialized reference that includes a key corresponding to the value.\n\n    This is used in the WeakValueDictionary to avoid having to create\n    a function object for each key stored in the mapping.  A shared\n    callback object can use the 'key' attribute of a KeyedRef instead\n    of getting a reference to the key from an enclosing scope.\n\n    \"\"\"\n\n    __slots__ = \"key\",\n\n    def __new__(type, ob, callback, key):\n        self = ref.__new__(type, ob, callback)\n        self.key = key\n        return self\n\n    def __init__(self, ob, callback, key):\n        super().__init__(ob, callback)\n\n\nclass WeakKeyDictionary(_collections_abc.MutableMapping):\n    \"\"\" Mapping class that references keys weakly.\n\n    Entries in the dictionary will be discarded when there is no\n    longer a strong reference to the key. This can be used to\n    associate additional data with an object owned by other parts of\n    an application without adding attributes to those objects. This\n    can be especially useful with objects that override attribute\n    accesses.\n    \"\"\"\n\n    def __init__(self, dict=None):\n        self.data = {}\n        def remove(k, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(k)\n                else:\n                    try:\n                        del self.data[k]\n                    except KeyError:\n                        pass\n        self._remove = remove\n        # A list of dead weakrefs (keys to be removed)\n        self._pending_removals = []\n        self._iterating = set()\n        self._dirty_len = False\n        if dict is not None:\n            self.update(dict)\n\n    def _commit_removals(self):\n        # NOTE: We don't need to call this method before mutating the dict,\n        # because a dead weakref never compares equal to a live weakref,\n        # even if they happened to refer to equal objects.\n        # However, it means keys may already have been removed.\n        pop = self._pending_removals.pop\n        d = self.data\n        while True:\n            try:\n                key = pop()\n            except IndexError:\n                return\n\n            try:\n                del d[key]\n            except KeyError:\n                pass\n\n    def _scrub_removals(self):\n        d = self.data\n        self._pending_removals = [k for k in self._pending_removals if k in d]\n        self._dirty_len = False\n\n    def __delitem__(self, key):\n        self._dirty_len = True\n        del self.data[ref(key)]\n\n    def __getitem__(self, key):\n        return self.data[ref(key)]\n\n    def __len__(self):\n        if self._dirty_len and self._pending_removals:\n            # self._pending_removals may still contain keys which were\n            # explicitly removed, we have to scrub them (see issue #21173).\n            self._scrub_removals()\n        return len(self.data) - len(self._pending_removals)\n\n    def __repr__(self):\n        return \"<%s at %#x>\" % (self.__class__.__name__, id(self))\n\n    def __setitem__(self, key, value):\n        self.data[ref(key, self._remove)] = value\n\n    def copy(self):\n        new = WeakKeyDictionary()\n        with _IterationGuard(self):\n            for key, value in self.data.items():\n                o = key()\n                if o is not None:\n                    new[o] = value\n        return new\n\n    __copy__ = copy\n\n    def __deepcopy__(self, memo):\n        from copy import deepcopy\n        new = self.__class__()\n        with _IterationGuard(self):\n            for key, value in self.data.items():\n                o = key()\n                if o is not None:\n                    new[o] = deepcopy(value, memo)\n        return new\n\n    def get(self, key, default=None):\n        return self.data.get(ref(key),default)\n\n    def __contains__(self, key):\n        try:\n            wr = ref(key)\n        except TypeError:\n            return False\n        return wr in self.data\n\n    def items(self):\n        with _IterationGuard(self):\n            for wr, value in self.data.items():\n                key = wr()\n                if key is not None:\n                    yield key, value\n\n    def keys(self):\n        with _IterationGuard(self):\n            for wr in self.data:\n                obj = wr()\n                if obj is not None:\n                    yield obj\n\n    __iter__ = keys\n\n    def values(self):\n        with _IterationGuard(self):\n            for wr, value in self.data.items():\n                if wr() is not None:\n                    yield value\n\n    def keyrefs(self):\n        \"\"\"Return a list of weak references to the keys.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the keys around longer than needed.\n\n        \"\"\"\n        return list(self.data)\n\n    def popitem(self):\n        self._dirty_len = True\n        while True:\n            key, value = self.data.popitem()\n            o = key()\n            if o is not None:\n                return o, value\n\n    def pop(self, key, *args):\n        self._dirty_len = True\n        return self.data.pop(ref(key), *args)\n\n    def setdefault(self, key, default=None):\n        return self.data.setdefault(ref(key, self._remove),default)\n\n    def update(self, dict=None, /, **kwargs):\n        d = self.data\n        if dict is not None:\n            if not hasattr(dict, \"items\"):\n                dict = type({})(dict)\n            for key, value in dict.items():\n                d[ref(key, self._remove)] = value\n        if len(kwargs):\n            self.update(kwargs)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def __or__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.copy()\n            c.update(other)\n            return c\n        return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.__class__()\n            c.update(other)\n            c.update(self)\n            return c\n        return NotImplemented\n\n\nclass finalize:\n    \"\"\"Class for finalization of weakrefable objects\n\n    finalize(obj, func, *args, **kwargs) returns a callable finalizer\n    object which will be called when obj is garbage collected. The\n    first time the finalizer is called it evaluates func(*arg, **kwargs)\n    and returns the result. After this the finalizer is dead, and\n    calling it just returns None.\n\n    When the program exits any remaining finalizers for which the\n    atexit attribute is true will be run in reverse order of creation.\n    By default atexit is true.\n    \"\"\"\n\n    # Finalizer objects don't have any state of their own.  They are\n    # just used as keys to lookup _Info objects in the registry.  This\n    # ensures that they cannot be part of a ref-cycle.\n\n    __slots__ = ()\n    _registry = {}\n    _shutdown = False\n    _index_iter = itertools.count()\n    _dirty = False\n    _registered_with_atexit = False\n\n    class _Info:\n        __slots__ = (\"weakref\", \"func\", \"args\", \"kwargs\", \"atexit\", \"index\")\n\n    def __init__(self, obj, func, /, *args, **kwargs):\n        if not self._registered_with_atexit:\n            # We may register the exit function more than once because\n            # of a thread race, but that is harmless\n            import atexit\n            atexit.register(self._exitfunc)\n            finalize._registered_with_atexit = True\n        info = self._Info()\n        info.weakref = ref(obj, self)\n        info.func = func\n        info.args = args\n        info.kwargs = kwargs or None\n        info.atexit = True\n        info.index = next(self._index_iter)\n        self._registry[self] = info\n        finalize._dirty = True\n\n    def __call__(self, _=None):\n        \"\"\"If alive then mark as dead and return func(*args, **kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.pop(self, None)\n        if info and not self._shutdown:\n            return info.func(*info.args, **(info.kwargs or {}))\n\n    def detach(self):\n        \"\"\"If alive then mark as dead and return (obj, func, args, kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is not None and self._registry.pop(self, None):\n            return (obj, info.func, info.args, info.kwargs or {})\n\n    def peek(self):\n        \"\"\"If alive then return (obj, func, args, kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is not None:\n            return (obj, info.func, info.args, info.kwargs or {})\n\n    @property\n    def alive(self):\n        \"\"\"Whether finalizer is alive\"\"\"\n        return self in self._registry\n\n    @property\n    def atexit(self):\n        \"\"\"Whether finalizer should be called at exit\"\"\"\n        info = self._registry.get(self)\n        return bool(info) and info.atexit\n\n    @atexit.setter\n    def atexit(self, value):\n        info = self._registry.get(self)\n        if info:\n            info.atexit = bool(value)\n\n    def __repr__(self):\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is None:\n            return '<%s object at %#x; dead>' % (type(self).__name__, id(self))\n        else:\n            return '<%s object at %#x; for %r at %#x>' % \\\n                (type(self).__name__, id(self), type(obj).__name__, id(obj))\n\n    @classmethod\n    def _select_for_exit(cls):\n        # Return live finalizers marked for exit, oldest first\n        L = [(f,i) for (f,i) in cls._registry.items() if i.atexit]\n        L.sort(key=lambda item:item[1].index)\n        return [f for (f,i) in L]\n\n    @classmethod\n    def _exitfunc(cls):\n        # At shutdown invoke finalizers for which atexit is true.\n        # This is called once all other non-daemonic threads have been\n        # joined.\n        reenable_gc = False\n        try:\n            if cls._registry:\n                import gc\n                if gc.isenabled():\n                    reenable_gc = True\n                    gc.disable()\n                pending = None\n                while True:\n                    if pending is None or finalize._dirty:\n                        pending = cls._select_for_exit()\n                        finalize._dirty = False\n                    if not pending:\n                        break\n                    f = pending.pop()\n                    try:\n                        # gc is disabled, so (assuming no daemonic\n                        # threads) the following is the only line in\n                        # this function which might trigger creation\n                        # of a new finalizer\n                        f()\n                    except Exception:\n                        sys.excepthook(*sys.exc_info())\n                    assert f not in cls._registry\n        finally:\n            # prevent any more finalizers from executing during shutdown\n            finalize._shutdown = True\n            if reenable_gc:\n                gc.enable()\n", 674], "C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py": ["#\n# A higher level module for using sockets (or Windows named pipes)\n#\n# multiprocessing/connection.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\n__all__ = [ 'Client', 'Listener', 'Pipe', 'wait' ]\n\nimport errno\nimport io\nimport os\nimport sys\nimport socket\nimport struct\nimport time\nimport tempfile\nimport itertools\n\n\nfrom . import util\n\nfrom . import AuthenticationError, BufferTooShort\nfrom .context import reduction\n_ForkingPickler = reduction.ForkingPickler\n\ntry:\n    import _multiprocessing\n    import _winapi\n    from _winapi import WAIT_OBJECT_0, WAIT_ABANDONED_0, WAIT_TIMEOUT, INFINITE\nexcept ImportError:\n    if sys.platform == 'win32':\n        raise\n    _winapi = None\n\n#\n#\n#\n\nBUFSIZE = 8192\n# A very generous timeout when it comes to local connections...\nCONNECTION_TIMEOUT = 20.\n\n_mmap_counter = itertools.count()\n\ndefault_family = 'AF_INET'\nfamilies = ['AF_INET']\n\nif hasattr(socket, 'AF_UNIX'):\n    default_family = 'AF_UNIX'\n    families += ['AF_UNIX']\n\nif sys.platform == 'win32':\n    default_family = 'AF_PIPE'\n    families += ['AF_PIPE']\n\n\ndef _init_timeout(timeout=CONNECTION_TIMEOUT):\n    return time.monotonic() + timeout\n\ndef _check_timeout(t):\n    return time.monotonic() > t\n\n#\n#\n#\n\ndef arbitrary_address(family):\n    '''\n    Return an arbitrary free address for the given family\n    '''\n    if family == 'AF_INET':\n        return ('localhost', 0)\n    elif family == 'AF_UNIX':\n        return tempfile.mktemp(prefix='listener-', dir=util.get_temp_dir())\n    elif family == 'AF_PIPE':\n        return tempfile.mktemp(prefix=r'\\\\.\\pipe\\pyc-%d-%d-' %\n                               (os.getpid(), next(_mmap_counter)), dir=\"\")\n    else:\n        raise ValueError('unrecognized family')\n\ndef _validate_family(family):\n    '''\n    Checks if the family is valid for the current environment.\n    '''\n    if sys.platform != 'win32' and family == 'AF_PIPE':\n        raise ValueError('Family %s is not recognized.' % family)\n\n    if sys.platform == 'win32' and family == 'AF_UNIX':\n        # double check\n        if not hasattr(socket, family):\n            raise ValueError('Family %s is not recognized.' % family)\n\ndef address_type(address):\n    '''\n    Return the types of the address\n\n    This can be 'AF_INET', 'AF_UNIX', or 'AF_PIPE'\n    '''\n    if type(address) == tuple:\n        return 'AF_INET'\n    elif type(address) is str and address.startswith('\\\\\\\\'):\n        return 'AF_PIPE'\n    elif type(address) is str or util.is_abstract_socket_namespace(address):\n        return 'AF_UNIX'\n    else:\n        raise ValueError('address type of %r unrecognized' % address)\n\n#\n# Connection classes\n#\n\nclass _ConnectionBase:\n    _handle = None\n\n    def __init__(self, handle, readable=True, writable=True):\n        handle = handle.__index__()\n        if handle < 0:\n            raise ValueError(\"invalid handle\")\n        if not readable and not writable:\n            raise ValueError(\n                \"at least one of `readable` and `writable` must be True\")\n        self._handle = handle\n        self._readable = readable\n        self._writable = writable\n\n    # XXX should we use util.Finalize instead of a __del__?\n\n    def __del__(self):\n        if self._handle is not None:\n            self._close()\n\n    def _check_closed(self):\n        if self._handle is None:\n            raise OSError(\"handle is closed\")\n\n    def _check_readable(self):\n        if not self._readable:\n            raise OSError(\"connection is write-only\")\n\n    def _check_writable(self):\n        if not self._writable:\n            raise OSError(\"connection is read-only\")\n\n    def _bad_message_length(self):\n        if self._writable:\n            self._readable = False\n        else:\n            self.close()\n        raise OSError(\"bad message length\")\n\n    @property\n    def closed(self):\n        \"\"\"True if the connection is closed\"\"\"\n        return self._handle is None\n\n    @property\n    def readable(self):\n        \"\"\"True if the connection is readable\"\"\"\n        return self._readable\n\n    @property\n    def writable(self):\n        \"\"\"True if the connection is writable\"\"\"\n        return self._writable\n\n    def fileno(self):\n        \"\"\"File descriptor or handle of the connection\"\"\"\n        self._check_closed()\n        return self._handle\n\n    def close(self):\n        \"\"\"Close the connection\"\"\"\n        if self._handle is not None:\n            try:\n                self._close()\n            finally:\n                self._handle = None\n\n    def send_bytes(self, buf, offset=0, size=None):\n        \"\"\"Send the bytes data from a bytes-like object\"\"\"\n        self._check_closed()\n        self._check_writable()\n        m = memoryview(buf)\n        if m.itemsize > 1:\n            m = m.cast('B')\n        n = m.nbytes\n        if offset < 0:\n            raise ValueError(\"offset is negative\")\n        if n < offset:\n            raise ValueError(\"buffer length < offset\")\n        if size is None:\n            size = n - offset\n        elif size < 0:\n            raise ValueError(\"size is negative\")\n        elif offset + size > n:\n            raise ValueError(\"buffer length < offset + size\")\n        self._send_bytes(m[offset:offset + size])\n\n    def send(self, obj):\n        \"\"\"Send a (picklable) object\"\"\"\n        self._check_closed()\n        self._check_writable()\n        self._send_bytes(_ForkingPickler.dumps(obj))\n\n    def recv_bytes(self, maxlength=None):\n        \"\"\"\n        Receive bytes data as a bytes object.\n        \"\"\"\n        self._check_closed()\n        self._check_readable()\n        if maxlength is not None and maxlength < 0:\n            raise ValueError(\"negative maxlength\")\n        buf = self._recv_bytes(maxlength)\n        if buf is None:\n            self._bad_message_length()\n        return buf.getvalue()\n\n    def recv_bytes_into(self, buf, offset=0):\n        \"\"\"\n        Receive bytes data into a writeable bytes-like object.\n        Return the number of bytes read.\n        \"\"\"\n        self._check_closed()\n        self._check_readable()\n        with memoryview(buf) as m:\n            # Get bytesize of arbitrary buffer\n            itemsize = m.itemsize\n            bytesize = itemsize * len(m)\n            if offset < 0:\n                raise ValueError(\"negative offset\")\n            elif offset > bytesize:\n                raise ValueError(\"offset too large\")\n            result = self._recv_bytes()\n            size = result.tell()\n            if bytesize < offset + size:\n                raise BufferTooShort(result.getvalue())\n            # Message can fit in dest\n            result.seek(0)\n            result.readinto(m[offset // itemsize :\n                              (offset + size) // itemsize])\n            return size\n\n    def recv(self):\n        \"\"\"Receive a (picklable) object\"\"\"\n        self._check_closed()\n        self._check_readable()\n        buf = self._recv_bytes()\n        return _ForkingPickler.loads(buf.getbuffer())\n\n    def poll(self, timeout=0.0):\n        \"\"\"Whether there is any input available to be read\"\"\"\n        self._check_closed()\n        self._check_readable()\n        return self._poll(timeout)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self.close()\n\n\nif _winapi:\n\n    class PipeConnection(_ConnectionBase):\n        \"\"\"\n        Connection class based on a Windows named pipe.\n        Overlapped I/O is used, so the handles must have been created\n        with FILE_FLAG_OVERLAPPED.\n        \"\"\"\n        _got_empty_message = False\n        _send_ov = None\n\n        def _close(self, _CloseHandle=_winapi.CloseHandle):\n            ov = self._send_ov\n            if ov is not None:\n                # Interrupt WaitForMultipleObjects() in _send_bytes()\n                ov.cancel()\n            _CloseHandle(self._handle)\n\n        def _send_bytes(self, buf):\n            if self._send_ov is not None:\n                # A connection should only be used by a single thread\n                raise ValueError(\"concurrent send_bytes() calls \"\n                                 \"are not supported\")\n            ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)\n            self._send_ov = ov\n            try:\n                if err == _winapi.ERROR_IO_PENDING:\n                    waitres = _winapi.WaitForMultipleObjects(\n                        [ov.event], False, INFINITE)\n                    assert waitres == WAIT_OBJECT_0\n            except:\n                ov.cancel()\n                raise\n            finally:\n                self._send_ov = None\n                nwritten, err = ov.GetOverlappedResult(True)\n            if err == _winapi.ERROR_OPERATION_ABORTED:\n                # close() was called by another thread while\n                # WaitForMultipleObjects() was waiting for the overlapped\n                # operation.\n                raise OSError(errno.EPIPE, \"handle is closed\")\n            assert err == 0\n            assert nwritten == len(buf)\n\n        def _recv_bytes(self, maxsize=None):\n            if self._got_empty_message:\n                self._got_empty_message = False\n                return io.BytesIO()\n            else:\n                bsize = 128 if maxsize is None else min(maxsize, 128)\n                try:\n                    ov, err = _winapi.ReadFile(self._handle, bsize,\n                                                overlapped=True)\n                    try:\n                        if err == _winapi.ERROR_IO_PENDING:\n                            waitres = _winapi.WaitForMultipleObjects(\n                                [ov.event], False, INFINITE)\n                            assert waitres == WAIT_OBJECT_0\n                    except:\n                        ov.cancel()\n                        raise\n                    finally:\n                        nread, err = ov.GetOverlappedResult(True)\n                        if err == 0:\n                            f = io.BytesIO()\n                            f.write(ov.getbuffer())\n                            return f\n                        elif err == _winapi.ERROR_MORE_DATA:\n                            return self._get_more_data(ov, maxsize)\n                except OSError as e:\n                    if e.winerror == _winapi.ERROR_BROKEN_PIPE:\n                        raise EOFError\n                    else:\n                        raise\n            raise RuntimeError(\"shouldn't get here; expected KeyboardInterrupt\")\n\n        def _poll(self, timeout):\n            if (self._got_empty_message or\n                        _winapi.PeekNamedPipe(self._handle)[0] != 0):\n                return True\n            return bool(wait([self], timeout))\n\n        def _get_more_data(self, ov, maxsize):\n            buf = ov.getbuffer()\n            f = io.BytesIO()\n            f.write(buf)\n            left = _winapi.PeekNamedPipe(self._handle)[1]\n            assert left > 0\n            if maxsize is not None and len(buf) + left > maxsize:\n                self._bad_message_length()\n            ov, err = _winapi.ReadFile(self._handle, left, overlapped=True)\n            rbytes, err = ov.GetOverlappedResult(True)\n            assert err == 0\n            assert rbytes == left\n            f.write(ov.getbuffer())\n            return f\n\n\nclass Connection(_ConnectionBase):\n    \"\"\"\n    Connection class based on an arbitrary file descriptor (Unix only), or\n    a socket handle (Windows).\n    \"\"\"\n\n    if _winapi:\n        def _close(self, _close=_multiprocessing.closesocket):\n            _close(self._handle)\n        _write = _multiprocessing.send\n        _read = _multiprocessing.recv\n    else:\n        def _close(self, _close=os.close):\n            _close(self._handle)\n        _write = os.write\n        _read = os.read\n\n    def _send(self, buf, write=_write):\n        remaining = len(buf)\n        while True:\n            n = write(self._handle, buf)\n            remaining -= n\n            if remaining == 0:\n                break\n            buf = buf[n:]\n\n    def _recv(self, size, read=_read):\n        buf = io.BytesIO()\n        handle = self._handle\n        remaining = size\n        while remaining > 0:\n            chunk = read(handle, remaining)\n            n = len(chunk)\n            if n == 0:\n                if remaining == size:\n                    raise EOFError\n                else:\n                    raise OSError(\"got end of file during message\")\n            buf.write(chunk)\n            remaining -= n\n        return buf\n\n    def _send_bytes(self, buf):\n        n = len(buf)\n        if n > 0x7fffffff:\n            pre_header = struct.pack(\"!i\", -1)\n            header = struct.pack(\"!Q\", n)\n            self._send(pre_header)\n            self._send(header)\n            self._send(buf)\n        else:\n            # For wire compatibility with 3.7 and lower\n            header = struct.pack(\"!i\", n)\n            if n > 16384:\n                # The payload is large so Nagle's algorithm won't be triggered\n                # and we'd better avoid the cost of concatenation.\n                self._send(header)\n                self._send(buf)\n            else:\n                # Issue #20540: concatenate before sending, to avoid delays due\n                # to Nagle's algorithm on a TCP socket.\n                # Also note we want to avoid sending a 0-length buffer separately,\n                # to avoid \"broken pipe\" errors if the other end closed the pipe.\n                self._send(header + buf)\n\n    def _recv_bytes(self, maxsize=None):\n        buf = self._recv(4)\n        size, = struct.unpack(\"!i\", buf.getvalue())\n        if size == -1:\n            buf = self._recv(8)\n            size, = struct.unpack(\"!Q\", buf.getvalue())\n        if maxsize is not None and size > maxsize:\n            return None\n        return self._recv(size)\n\n    def _poll(self, timeout):\n        r = wait([self], timeout)\n        return bool(r)\n\n\n#\n# Public functions\n#\n\nclass Listener(object):\n    '''\n    Returns a listener object.\n\n    This is a wrapper for a bound socket which is 'listening' for\n    connections, or for a Windows named pipe.\n    '''\n    def __init__(self, address=None, family=None, backlog=1, authkey=None):\n        family = family or (address and address_type(address)) \\\n                 or default_family\n        address = address or arbitrary_address(family)\n\n        _validate_family(family)\n        if family == 'AF_PIPE':\n            self._listener = PipeListener(address, backlog)\n        else:\n            self._listener = SocketListener(address, family, backlog)\n\n        if authkey is not None and not isinstance(authkey, bytes):\n            raise TypeError('authkey should be a byte string')\n\n        self._authkey = authkey\n\n    def accept(self):\n        '''\n        Accept a connection on the bound socket or named pipe of `self`.\n\n        Returns a `Connection` object.\n        '''\n        if self._listener is None:\n            raise OSError('listener is closed')\n\n        c = self._listener.accept()\n        if self._authkey is not None:\n            deliver_challenge(c, self._authkey)\n            answer_challenge(c, self._authkey)\n        return c\n\n    def close(self):\n        '''\n        Close the bound socket or named pipe of `self`.\n        '''\n        listener = self._listener\n        if listener is not None:\n            self._listener = None\n            listener.close()\n\n    @property\n    def address(self):\n        return self._listener._address\n\n    @property\n    def last_accepted(self):\n        return self._listener._last_accepted\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self.close()\n\n\ndef Client(address, family=None, authkey=None):\n    '''\n    Returns a connection to the address of a `Listener`\n    '''\n    family = family or address_type(address)\n    _validate_family(family)\n    if family == 'AF_PIPE':\n        c = PipeClient(address)\n    else:\n        c = SocketClient(address)\n\n    if authkey is not None and not isinstance(authkey, bytes):\n        raise TypeError('authkey should be a byte string')\n\n    if authkey is not None:\n        answer_challenge(c, authkey)\n        deliver_challenge(c, authkey)\n\n    return c\n\n\nif sys.platform != 'win32':\n\n    def Pipe(duplex=True):\n        '''\n        Returns pair of connection objects at either end of a pipe\n        '''\n        if duplex:\n            s1, s2 = socket.socketpair()\n            s1.setblocking(True)\n            s2.setblocking(True)\n            c1 = Connection(s1.detach())\n            c2 = Connection(s2.detach())\n        else:\n            fd1, fd2 = os.pipe()\n            c1 = Connection(fd1, writable=False)\n            c2 = Connection(fd2, readable=False)\n\n        return c1, c2\n\nelse:\n\n    def Pipe(duplex=True):\n        '''\n        Returns pair of connection objects at either end of a pipe\n        '''\n        address = arbitrary_address('AF_PIPE')\n        if duplex:\n            openmode = _winapi.PIPE_ACCESS_DUPLEX\n            access = _winapi.GENERIC_READ | _winapi.GENERIC_WRITE\n            obsize, ibsize = BUFSIZE, BUFSIZE\n        else:\n            openmode = _winapi.PIPE_ACCESS_INBOUND\n            access = _winapi.GENERIC_WRITE\n            obsize, ibsize = 0, BUFSIZE\n\n        h1 = _winapi.CreateNamedPipe(\n            address, openmode | _winapi.FILE_FLAG_OVERLAPPED |\n            _winapi.FILE_FLAG_FIRST_PIPE_INSTANCE,\n            _winapi.PIPE_TYPE_MESSAGE | _winapi.PIPE_READMODE_MESSAGE |\n            _winapi.PIPE_WAIT,\n            1, obsize, ibsize, _winapi.NMPWAIT_WAIT_FOREVER,\n            # default security descriptor: the handle cannot be inherited\n            _winapi.NULL\n            )\n        h2 = _winapi.CreateFile(\n            address, access, 0, _winapi.NULL, _winapi.OPEN_EXISTING,\n            _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL\n            )\n        _winapi.SetNamedPipeHandleState(\n            h2, _winapi.PIPE_READMODE_MESSAGE, None, None\n            )\n\n        overlapped = _winapi.ConnectNamedPipe(h1, overlapped=True)\n        _, err = overlapped.GetOverlappedResult(True)\n        assert err == 0\n\n        c1 = PipeConnection(h1, writable=duplex)\n        c2 = PipeConnection(h2, readable=duplex)\n\n        return c1, c2\n\n#\n# Definitions for connections based on sockets\n#\n\nclass SocketListener(object):\n    '''\n    Representation of a socket which is bound to an address and listening\n    '''\n    def __init__(self, address, family, backlog=1):\n        self._socket = socket.socket(getattr(socket, family))\n        try:\n            # SO_REUSEADDR has different semantics on Windows (issue #2550).\n            if os.name == 'posix':\n                self._socket.setsockopt(socket.SOL_SOCKET,\n                                        socket.SO_REUSEADDR, 1)\n            self._socket.setblocking(True)\n            self._socket.bind(address)\n            self._socket.listen(backlog)\n            self._address = self._socket.getsockname()\n        except OSError:\n            self._socket.close()\n            raise\n        self._family = family\n        self._last_accepted = None\n\n        if family == 'AF_UNIX' and not util.is_abstract_socket_namespace(address):\n            # Linux abstract socket namespaces do not need to be explicitly unlinked\n            self._unlink = util.Finalize(\n                self, os.unlink, args=(address,), exitpriority=0\n                )\n        else:\n            self._unlink = None\n\n    def accept(self):\n        s, self._last_accepted = self._socket.accept()\n        s.setblocking(True)\n        return Connection(s.detach())\n\n    def close(self):\n        try:\n            self._socket.close()\n        finally:\n            unlink = self._unlink\n            if unlink is not None:\n                self._unlink = None\n                unlink()\n\n\ndef SocketClient(address):\n    '''\n    Return a connection object connected to the socket given by `address`\n    '''\n    family = address_type(address)\n    with socket.socket( getattr(socket, family) ) as s:\n        s.setblocking(True)\n        s.connect(address)\n        return Connection(s.detach())\n\n#\n# Definitions for connections based on named pipes\n#\n\nif sys.platform == 'win32':\n\n    class PipeListener(object):\n        '''\n        Representation of a named pipe\n        '''\n        def __init__(self, address, backlog=None):\n            self._address = address\n            self._handle_queue = [self._new_handle(first=True)]\n\n            self._last_accepted = None\n            util.sub_debug('listener created with address=%r', self._address)\n            self.close = util.Finalize(\n                self, PipeListener._finalize_pipe_listener,\n                args=(self._handle_queue, self._address), exitpriority=0\n                )\n\n        def _new_handle(self, first=False):\n            flags = _winapi.PIPE_ACCESS_DUPLEX | _winapi.FILE_FLAG_OVERLAPPED\n            if first:\n                flags |= _winapi.FILE_FLAG_FIRST_PIPE_INSTANCE\n            return _winapi.CreateNamedPipe(\n                self._address, flags,\n                _winapi.PIPE_TYPE_MESSAGE | _winapi.PIPE_READMODE_MESSAGE |\n                _winapi.PIPE_WAIT,\n                _winapi.PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE,\n                _winapi.NMPWAIT_WAIT_FOREVER, _winapi.NULL\n                )\n\n        def accept(self):\n            self._handle_queue.append(self._new_handle())\n            handle = self._handle_queue.pop(0)\n            try:\n                ov = _winapi.ConnectNamedPipe(handle, overlapped=True)\n            except OSError as e:\n                if e.winerror != _winapi.ERROR_NO_DATA:\n                    raise\n                # ERROR_NO_DATA can occur if a client has already connected,\n                # written data and then disconnected -- see Issue 14725.\n            else:\n                try:\n                    res = _winapi.WaitForMultipleObjects(\n                        [ov.event], False, INFINITE)\n                except:\n                    ov.cancel()\n                    _winapi.CloseHandle(handle)\n                    raise\n                finally:\n                    _, err = ov.GetOverlappedResult(True)\n                    assert err == 0\n            return PipeConnection(handle)\n\n        @staticmethod\n        def _finalize_pipe_listener(queue, address):\n            util.sub_debug('closing listener with address=%r', address)\n            for handle in queue:\n                _winapi.CloseHandle(handle)\n\n    def PipeClient(address):\n        '''\n        Return a connection object connected to the pipe given by `address`\n        '''\n        t = _init_timeout()\n        while 1:\n            try:\n                _winapi.WaitNamedPipe(address, 1000)\n                h = _winapi.CreateFile(\n                    address, _winapi.GENERIC_READ | _winapi.GENERIC_WRITE,\n                    0, _winapi.NULL, _winapi.OPEN_EXISTING,\n                    _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL\n                    )\n            except OSError as e:\n                if e.winerror not in (_winapi.ERROR_SEM_TIMEOUT,\n                                      _winapi.ERROR_PIPE_BUSY) or _check_timeout(t):\n                    raise\n            else:\n                break\n        else:\n            raise\n\n        _winapi.SetNamedPipeHandleState(\n            h, _winapi.PIPE_READMODE_MESSAGE, None, None\n            )\n        return PipeConnection(h)\n\n#\n# Authentication stuff\n#\n\nMESSAGE_LENGTH = 40  # MUST be > 20\n\n_CHALLENGE = b'#CHALLENGE#'\n_WELCOME = b'#WELCOME#'\n_FAILURE = b'#FAILURE#'\n\n# multiprocessing.connection Authentication Handshake Protocol Description\n# (as documented for reference after reading the existing code)\n# =============================================================================\n#\n# On Windows: native pipes with \"overlapped IO\" are used to send the bytes,\n# instead of the length prefix SIZE scheme described below. (ie: the OS deals\n# with message sizes for us)\n#\n# Protocol error behaviors:\n#\n# On POSIX, any failure to receive the length prefix into SIZE, for SIZE greater\n# than the requested maxsize to receive, or receiving fewer than SIZE bytes\n# results in the connection being closed and auth to fail.\n#\n# On Windows, receiving too few bytes is never a low level _recv_bytes read\n# error, receiving too many will trigger an error only if receive maxsize\n# value was larger than 128 OR the if the data arrived in smaller pieces.\n#\n#      Serving side                           Client side\n#     ------------------------------  ---------------------------------------\n# 0.                                  Open a connection on the pipe.\n# 1.  Accept connection.\n# 2.  Random 20+ bytes -> MESSAGE\n#     Modern servers always send\n#     more than 20 bytes and include\n#     a {digest} prefix on it with\n#     their preferred HMAC digest.\n#     Legacy ones send ==20 bytes.\n# 3.  send 4 byte length (net order)\n#     prefix followed by:\n#       b'#CHALLENGE#' + MESSAGE\n# 4.                                  Receive 4 bytes, parse as network byte\n#                                     order integer. If it is -1, receive an\n#                                     additional 8 bytes, parse that as network\n#                                     byte order. The result is the length of\n#                                     the data that follows -> SIZE.\n# 5.                                  Receive min(SIZE, 256) bytes -> M1\n# 6.                                  Assert that M1 starts with:\n#                                       b'#CHALLENGE#'\n# 7.                                  Strip that prefix from M1 into -> M2\n# 7.1.                                Parse M2: if it is exactly 20 bytes in\n#                                     length this indicates a legacy server\n#                                     supporting only HMAC-MD5. Otherwise the\n# 7.2.                                preferred digest is looked up from an\n#                                     expected \"{digest}\" prefix on M2. No prefix\n#                                     or unsupported digest? <- AuthenticationError\n# 7.3.                                Put divined algorithm name in -> D_NAME\n# 8.                                  Compute HMAC-D_NAME of AUTHKEY, M2 -> C_DIGEST\n# 9.                                  Send 4 byte length prefix (net order)\n#                                     followed by C_DIGEST bytes.\n# 10. Receive 4 or 4+8 byte length\n#     prefix (#4 dance) -> SIZE.\n# 11. Receive min(SIZE, 256) -> C_D.\n# 11.1. Parse C_D: legacy servers\n#     accept it as is, \"md5\" -> D_NAME\n# 11.2. modern servers check the length\n#     of C_D, IF it is 16 bytes?\n# 11.2.1. \"md5\" -> D_NAME\n#         and skip to step 12.\n# 11.3. longer? expect and parse a \"{digest}\"\n#     prefix into -> D_NAME.\n#     Strip the prefix and store remaining\n#     bytes in -> C_D.\n# 11.4. Don't like D_NAME? <- AuthenticationError\n# 12. Compute HMAC-D_NAME of AUTHKEY,\n#     MESSAGE into -> M_DIGEST.\n# 13. Compare M_DIGEST == C_D:\n# 14a: Match? Send length prefix &\n#       b'#WELCOME#'\n#    <- RETURN\n# 14b: Mismatch? Send len prefix &\n#       b'#FAILURE#'\n#    <- CLOSE & AuthenticationError\n# 15.                                 Receive 4 or 4+8 byte length prefix (net\n#                                     order) again as in #4 into -> SIZE.\n# 16.                                 Receive min(SIZE, 256) bytes -> M3.\n# 17.                                 Compare M3 == b'#WELCOME#':\n# 17a.                                Match? <- RETURN\n# 17b.                                Mismatch? <- CLOSE & AuthenticationError\n#\n# If this RETURNed, the connection remains open: it has been authenticated.\n#\n# Length prefixes are used consistently. Even on the legacy protocol, this\n# was good fortune and allowed us to evolve the protocol by using the length\n# of the opening challenge or length of the returned digest as a signal as\n# to which protocol the other end supports.\n\n_ALLOWED_DIGESTS = frozenset(\n        {b'md5', b'sha256', b'sha384', b'sha3_256', b'sha3_384'})\n_MAX_DIGEST_LEN = max(len(_) for _ in _ALLOWED_DIGESTS)\n\n# Old hmac-md5 only server versions from Python <=3.11 sent a message of this\n# length. It happens to not match the length of any supported digest so we can\n# use a message of this length to indicate that we should work in backwards\n# compatible md5-only mode without a {digest_name} prefix on our response.\n_MD5ONLY_MESSAGE_LENGTH = 20\n_MD5_DIGEST_LEN = 16\n_LEGACY_LENGTHS = (_MD5ONLY_MESSAGE_LENGTH, _MD5_DIGEST_LEN)\n\n\ndef _get_digest_name_and_payload(message):  # type: (bytes) -> tuple[str, bytes]\n    \"\"\"Returns a digest name and the payload for a response hash.\n\n    If a legacy protocol is detected based on the message length\n    or contents the digest name returned will be empty to indicate\n    legacy mode where MD5 and no digest prefix should be sent.\n    \"\"\"\n    # modern message format: b\"{digest}payload\" longer than 20 bytes\n    # legacy message format: 16 or 20 byte b\"payload\"\n    if len(message) in _LEGACY_LENGTHS:\n        # Either this was a legacy server challenge, or we're processing\n        # a reply from a legacy client that sent an unprefixed 16-byte\n        # HMAC-MD5 response. All messages using the modern protocol will\n        # be longer than either of these lengths.\n        return '', message\n    if (message.startswith(b'{') and\n        (curly := message.find(b'}', 1, _MAX_DIGEST_LEN+2)) > 0):\n        digest = message[1:curly]\n        if digest in _ALLOWED_DIGESTS:\n            payload = message[curly+1:]\n            return digest.decode('ascii'), payload\n    raise AuthenticationError(\n            'unsupported message length, missing digest prefix, '\n            f'or unsupported digest: {message=}')\n\n\ndef _create_response(authkey, message):\n    \"\"\"Create a MAC based on authkey and message\n\n    The MAC algorithm defaults to HMAC-MD5, unless MD5 is not available or\n    the message has a '{digest_name}' prefix. For legacy HMAC-MD5, the response\n    is the raw MAC, otherwise the response is prefixed with '{digest_name}',\n    e.g. b'{sha256}abcdefg...'\n\n    Note: The MAC protects the entire message including the digest_name prefix.\n    \"\"\"\n    import hmac\n    digest_name = _get_digest_name_and_payload(message)[0]\n    # The MAC protects the entire message: digest header and payload.\n    if not digest_name:\n        # Legacy server without a {digest} prefix on message.\n        # Generate a legacy non-prefixed HMAC-MD5 reply.\n        try:\n            return hmac.new(authkey, message, 'md5').digest()\n        except ValueError:\n            # HMAC-MD5 is not available (FIPS mode?), fall back to\n            # HMAC-SHA2-256 modern protocol. The legacy server probably\n            # doesn't support it and will reject us anyways. :shrug:\n            digest_name = 'sha256'\n    # Modern protocol, indicate the digest used in the reply.\n    response = hmac.new(authkey, message, digest_name).digest()\n    return b'{%s}%s' % (digest_name.encode('ascii'), response)\n\n\ndef _verify_challenge(authkey, message, response):\n    \"\"\"Verify MAC challenge\n\n    If our message did not include a digest_name prefix, the client is allowed\n    to select a stronger digest_name from _ALLOWED_DIGESTS.\n\n    In case our message is prefixed, a client cannot downgrade to a weaker\n    algorithm, because the MAC is calculated over the entire message\n    including the '{digest_name}' prefix.\n    \"\"\"\n    import hmac\n    response_digest, response_mac = _get_digest_name_and_payload(response)\n    response_digest = response_digest or 'md5'\n    try:\n        expected = hmac.new(authkey, message, response_digest).digest()\n    except ValueError:\n        raise AuthenticationError(f'{response_digest=} unsupported')\n    if len(expected) != len(response_mac):\n        raise AuthenticationError(\n                f'expected {response_digest!r} of length {len(expected)} '\n                f'got {len(response_mac)}')\n    if not hmac.compare_digest(expected, response_mac):\n        raise AuthenticationError('digest received was wrong')\n\n\ndef deliver_challenge(connection, authkey: bytes, digest_name='sha256'):\n    if not isinstance(authkey, bytes):\n        raise ValueError(\n            \"Authkey must be bytes, not {0!s}\".format(type(authkey)))\n    assert MESSAGE_LENGTH > _MD5ONLY_MESSAGE_LENGTH, \"protocol constraint\"\n    message = os.urandom(MESSAGE_LENGTH)\n    message = b'{%s}%s' % (digest_name.encode('ascii'), message)\n    # Even when sending a challenge to a legacy client that does not support\n    # digest prefixes, they'll take the entire thing as a challenge and\n    # respond to it with a raw HMAC-MD5.\n    connection.send_bytes(_CHALLENGE + message)\n    response = connection.recv_bytes(256)        # reject large message\n    try:\n        _verify_challenge(authkey, message, response)\n    except AuthenticationError:\n        connection.send_bytes(_FAILURE)\n        raise\n    else:\n        connection.send_bytes(_WELCOME)\n\n\ndef answer_challenge(connection, authkey: bytes):\n    if not isinstance(authkey, bytes):\n        raise ValueError(\n            \"Authkey must be bytes, not {0!s}\".format(type(authkey)))\n    message = connection.recv_bytes(256)         # reject large message\n    if not message.startswith(_CHALLENGE):\n        raise AuthenticationError(\n                f'Protocol error, expected challenge: {message=}')\n    message = message[len(_CHALLENGE):]\n    if len(message) < _MD5ONLY_MESSAGE_LENGTH:\n        raise AuthenticationError(f'challenge too short: {len(message)} bytes')\n    digest = _create_response(authkey, message)\n    connection.send_bytes(digest)\n    response = connection.recv_bytes(256)        # reject large message\n    if response != _WELCOME:\n        raise AuthenticationError('digest sent was rejected')\n\n#\n# Support for using xmlrpclib for serialization\n#\n\nclass ConnectionWrapper(object):\n    def __init__(self, conn, dumps, loads):\n        self._conn = conn\n        self._dumps = dumps\n        self._loads = loads\n        for attr in ('fileno', 'close', 'poll', 'recv_bytes', 'send_bytes'):\n            obj = getattr(conn, attr)\n            setattr(self, attr, obj)\n    def send(self, obj):\n        s = self._dumps(obj)\n        self._conn.send_bytes(s)\n    def recv(self):\n        s = self._conn.recv_bytes()\n        return self._loads(s)\n\ndef _xml_dumps(obj):\n    return xmlrpclib.dumps((obj,), None, None, None, 1).encode('utf-8')\n\ndef _xml_loads(s):\n    (obj,), method = xmlrpclib.loads(s.decode('utf-8'))\n    return obj\n\nclass XmlListener(Listener):\n    def accept(self):\n        global xmlrpclib\n        import xmlrpc.client as xmlrpclib\n        obj = Listener.accept(self)\n        return ConnectionWrapper(obj, _xml_dumps, _xml_loads)\n\ndef XmlClient(*args, **kwds):\n    global xmlrpclib\n    import xmlrpc.client as xmlrpclib\n    return ConnectionWrapper(Client(*args, **kwds), _xml_dumps, _xml_loads)\n\n#\n# Wait\n#\n\nif sys.platform == 'win32':\n\n    def _exhaustive_wait(handles, timeout):\n        # Return ALL handles which are currently signalled.  (Only\n        # returning the first signalled might create starvation issues.)\n        L = list(handles)\n        ready = []\n        # Windows limits WaitForMultipleObjects at 64 handles, and we use a\n        # few for synchronisation, so we switch to batched waits at 60.\n        if len(L) > 60:\n            try:\n                res = _winapi.BatchedWaitForMultipleObjects(L, False, timeout)\n            except TimeoutError:\n                return []\n            ready.extend(L[i] for i in res)\n            if res:\n                L = [h for i, h in enumerate(L) if i > res[0] & i not in res]\n            timeout = 0\n        while L:\n            short_L = L[:60] if len(L) > 60 else L\n            res = _winapi.WaitForMultipleObjects(short_L, False, timeout)\n            if res == WAIT_TIMEOUT:\n                break\n            elif WAIT_OBJECT_0 <= res < WAIT_OBJECT_0 + len(L):\n                res -= WAIT_OBJECT_0\n            elif WAIT_ABANDONED_0 <= res < WAIT_ABANDONED_0 + len(L):\n                res -= WAIT_ABANDONED_0\n            else:\n                raise RuntimeError('Should not get here')\n            ready.append(L[res])\n            L = L[res+1:]\n            timeout = 0\n        return ready\n\n    _ready_errors = {_winapi.ERROR_BROKEN_PIPE, _winapi.ERROR_NETNAME_DELETED}\n\n    def wait(object_list, timeout=None):\n        '''\n        Wait till an object in object_list is ready/readable.\n\n        Returns list of those objects in object_list which are ready/readable.\n        '''\n        if timeout is None:\n            timeout = INFINITE\n        elif timeout < 0:\n            timeout = 0\n        else:\n            timeout = int(timeout * 1000 + 0.5)\n\n        object_list = list(object_list)\n        waithandle_to_obj = {}\n        ov_list = []\n        ready_objects = set()\n        ready_handles = set()\n\n        try:\n            for o in object_list:\n                try:\n                    fileno = getattr(o, 'fileno')\n                except AttributeError:\n                    waithandle_to_obj[o.__index__()] = o\n                else:\n                    # start an overlapped read of length zero\n                    try:\n                        ov, err = _winapi.ReadFile(fileno(), 0, True)\n                    except OSError as e:\n                        ov, err = None, e.winerror\n                        if err not in _ready_errors:\n                            raise\n                    if err == _winapi.ERROR_IO_PENDING:\n                        ov_list.append(ov)\n                        waithandle_to_obj[ov.event] = o\n                    else:\n                        # If o.fileno() is an overlapped pipe handle and\n                        # err == 0 then there is a zero length message\n                        # in the pipe, but it HAS NOT been consumed...\n                        if ov and sys.getwindowsversion()[:2] >= (6, 2):\n                            # ... except on Windows 8 and later, where\n                            # the message HAS been consumed.\n                            try:\n                                _, err = ov.GetOverlappedResult(False)\n                            except OSError as e:\n                                err = e.winerror\n                            if not err and hasattr(o, '_got_empty_message'):\n                                o._got_empty_message = True\n                        ready_objects.add(o)\n                        timeout = 0\n\n            ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)\n        finally:\n            # request that overlapped reads stop\n            for ov in ov_list:\n                ov.cancel()\n\n            # wait for all overlapped reads to stop\n            for ov in ov_list:\n                try:\n                    _, err = ov.GetOverlappedResult(True)\n                except OSError as e:\n                    err = e.winerror\n                    if err not in _ready_errors:\n                        raise\n                if err != _winapi.ERROR_OPERATION_ABORTED:\n                    o = waithandle_to_obj[ov.event]\n                    ready_objects.add(o)\n                    if err == 0:\n                        # If o.fileno() is an overlapped pipe handle then\n                        # a zero length message HAS been consumed.\n                        if hasattr(o, '_got_empty_message'):\n                            o._got_empty_message = True\n\n        ready_objects.update(waithandle_to_obj[h] for h in ready_handles)\n        return [o for o in object_list if o in ready_objects]\n\nelse:\n\n    import selectors\n\n    # poll/select have the advantage of not requiring any extra file\n    # descriptor, contrarily to epoll/kqueue (also, they require a single\n    # syscall).\n    if hasattr(selectors, 'PollSelector'):\n        _WaitSelector = selectors.PollSelector\n    else:\n        _WaitSelector = selectors.SelectSelector\n\n    def wait(object_list, timeout=None):\n        '''\n        Wait till an object in object_list is ready/readable.\n\n        Returns list of those objects in object_list which are ready/readable.\n        '''\n        with _WaitSelector() as selector:\n            for obj in object_list:\n                selector.register(obj, selectors.EVENT_READ)\n\n            if timeout is not None:\n                deadline = time.monotonic() + timeout\n\n            while True:\n                ready = selector.select(timeout)\n                if ready:\n                    return [key.fileobj for (key, events) in ready]\n                else:\n                    if timeout is not None:\n                        timeout = deadline - time.monotonic()\n                        if timeout < 0:\n                            return ready\n\n#\n# Make connection and socket objects shareable if possible\n#\n\nif sys.platform == 'win32':\n    def reduce_connection(conn):\n        handle = conn.fileno()\n        with socket.fromfd(handle, socket.AF_INET, socket.SOCK_STREAM) as s:\n            from . import resource_sharer\n            ds = resource_sharer.DupSocket(s)\n            return rebuild_connection, (ds, conn.readable, conn.writable)\n    def rebuild_connection(ds, readable, writable):\n        sock = ds.detach()\n        return Connection(sock.detach(), readable, writable)\n    reduction.register(Connection, reduce_connection)\n\n    def reduce_pipe_connection(conn):\n        access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |\n                  (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))\n        dh = reduction.DupHandle(conn.fileno(), access)\n        return rebuild_pipe_connection, (dh, conn.readable, conn.writable)\n    def rebuild_pipe_connection(dh, readable, writable):\n        handle = dh.detach()\n        return PipeConnection(handle, readable, writable)\n    reduction.register(PipeConnection, reduce_pipe_connection)\n\nelse:\n    def reduce_connection(conn):\n        df = reduction.DupFd(conn.fileno())\n        return rebuild_connection, (df, conn.readable, conn.writable)\n    def rebuild_connection(df, readable, writable):\n        fd = df.detach()\n        return Connection(fd, readable, writable)\n    reduction.register(Connection, reduce_connection)\n", 1190], "C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py": ["#\n# Module which deals with pickling of objects.\n#\n# multiprocessing/reduction.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\nfrom abc import ABCMeta\nimport copyreg\nimport functools\nimport io\nimport os\nimport pickle\nimport socket\nimport sys\n\nfrom . import context\n\n__all__ = ['send_handle', 'recv_handle', 'ForkingPickler', 'register', 'dump']\n\n\nHAVE_SEND_HANDLE = (sys.platform == 'win32' or\n                    (hasattr(socket, 'CMSG_LEN') and\n                     hasattr(socket, 'SCM_RIGHTS') and\n                     hasattr(socket.socket, 'sendmsg')))\n\n#\n# Pickler subclass\n#\n\nclass ForkingPickler(pickle.Pickler):\n    '''Pickler subclass used by multiprocessing.'''\n    _extra_reducers = {}\n    _copyreg_dispatch_table = copyreg.dispatch_table\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.dispatch_table = self._copyreg_dispatch_table.copy()\n        self.dispatch_table.update(self._extra_reducers)\n\n    @classmethod\n    def register(cls, type, reduce):\n        '''Register a reduce function for a type.'''\n        cls._extra_reducers[type] = reduce\n\n    @classmethod\n    def dumps(cls, obj, protocol=None):\n        buf = io.BytesIO()\n        cls(buf, protocol).dump(obj)\n        return buf.getbuffer()\n\n    loads = pickle.loads\n\nregister = ForkingPickler.register\n\ndef dump(obj, file, protocol=None):\n    '''Replacement for pickle.dump() using ForkingPickler.'''\n    ForkingPickler(file, protocol).dump(obj)\n\n#\n# Platform specific definitions\n#\n\nif sys.platform == 'win32':\n    # Windows\n    __all__ += ['DupHandle', 'duplicate', 'steal_handle']\n    import _winapi\n\n    def duplicate(handle, target_process=None, inheritable=False,\n                  *, source_process=None):\n        '''Duplicate a handle.  (target_process is a handle not a pid!)'''\n        current_process = _winapi.GetCurrentProcess()\n        if source_process is None:\n            source_process = current_process\n        if target_process is None:\n            target_process = current_process\n        return _winapi.DuplicateHandle(\n            source_process, handle, target_process,\n            0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)\n\n    def steal_handle(source_pid, handle):\n        '''Steal a handle from process identified by source_pid.'''\n        source_process_handle = _winapi.OpenProcess(\n            _winapi.PROCESS_DUP_HANDLE, False, source_pid)\n        try:\n            return _winapi.DuplicateHandle(\n                source_process_handle, handle,\n                _winapi.GetCurrentProcess(), 0, False,\n                _winapi.DUPLICATE_SAME_ACCESS | _winapi.DUPLICATE_CLOSE_SOURCE)\n        finally:\n            _winapi.CloseHandle(source_process_handle)\n\n    def send_handle(conn, handle, destination_pid):\n        '''Send a handle over a local connection.'''\n        dh = DupHandle(handle, _winapi.DUPLICATE_SAME_ACCESS, destination_pid)\n        conn.send(dh)\n\n    def recv_handle(conn):\n        '''Receive a handle over a local connection.'''\n        return conn.recv().detach()\n\n    class DupHandle(object):\n        '''Picklable wrapper for a handle.'''\n        def __init__(self, handle, access, pid=None):\n            if pid is None:\n                # We just duplicate the handle in the current process and\n                # let the receiving process steal the handle.\n                pid = os.getpid()\n            proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)\n            try:\n                self._handle = _winapi.DuplicateHandle(\n                    _winapi.GetCurrentProcess(),\n                    handle, proc, access, False, 0)\n            finally:\n                _winapi.CloseHandle(proc)\n            self._access = access\n            self._pid = pid\n\n        def detach(self):\n            '''Get the handle.  This should only be called once.'''\n            # retrieve handle from process which currently owns it\n            if self._pid == os.getpid():\n                # The handle has already been duplicated for this process.\n                return self._handle\n            # We must steal the handle from the process whose pid is self._pid.\n            proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False,\n                                       self._pid)\n            try:\n                return _winapi.DuplicateHandle(\n                    proc, self._handle, _winapi.GetCurrentProcess(),\n                    self._access, False, _winapi.DUPLICATE_CLOSE_SOURCE)\n            finally:\n                _winapi.CloseHandle(proc)\n\nelse:\n    # Unix\n    __all__ += ['DupFd', 'sendfds', 'recvfds']\n    import array\n\n    # On MacOSX we should acknowledge receipt of fds -- see Issue14669\n    ACKNOWLEDGE = sys.platform == 'darwin'\n\n    def sendfds(sock, fds):\n        '''Send an array of fds over an AF_UNIX socket.'''\n        fds = array.array('i', fds)\n        msg = bytes([len(fds) % 256])\n        sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)])\n        if ACKNOWLEDGE and sock.recv(1) != b'A':\n            raise RuntimeError('did not receive acknowledgement of fd')\n\n    def recvfds(sock, size):\n        '''Receive an array of fds over an AF_UNIX socket.'''\n        a = array.array('i')\n        bytes_size = a.itemsize * size\n        msg, ancdata, flags, addr = sock.recvmsg(1, socket.CMSG_SPACE(bytes_size))\n        if not msg and not ancdata:\n            raise EOFError\n        try:\n            if ACKNOWLEDGE:\n                sock.send(b'A')\n            if len(ancdata) != 1:\n                raise RuntimeError('received %d items of ancdata' %\n                                   len(ancdata))\n            cmsg_level, cmsg_type, cmsg_data = ancdata[0]\n            if (cmsg_level == socket.SOL_SOCKET and\n                cmsg_type == socket.SCM_RIGHTS):\n                if len(cmsg_data) % a.itemsize != 0:\n                    raise ValueError\n                a.frombytes(cmsg_data)\n                if len(a) % 256 != msg[0]:\n                    raise AssertionError(\n                        \"Len is {0:n} but msg[0] is {1!r}\".format(\n                            len(a), msg[0]))\n                return list(a)\n        except (ValueError, IndexError):\n            pass\n        raise RuntimeError('Invalid data received')\n\n    def send_handle(conn, handle, destination_pid):\n        '''Send a handle over a local connection.'''\n        with socket.fromfd(conn.fileno(), socket.AF_UNIX, socket.SOCK_STREAM) as s:\n            sendfds(s, [handle])\n\n    def recv_handle(conn):\n        '''Receive a handle over a local connection.'''\n        with socket.fromfd(conn.fileno(), socket.AF_UNIX, socket.SOCK_STREAM) as s:\n            return recvfds(s, 1)[0]\n\n    def DupFd(fd):\n        '''Return a wrapper for an fd.'''\n        popen_obj = context.get_spawning_popen()\n        if popen_obj is not None:\n            return popen_obj.DupFd(popen_obj.duplicate_for_child(fd))\n        elif HAVE_SEND_HANDLE:\n            from . import resource_sharer\n            return resource_sharer.DupFd(fd)\n        else:\n            raise ValueError('SCM_RIGHTS appears not to be available')\n\n#\n# Try making some callable types picklable\n#\n\ndef _reduce_method(m):\n    if m.__self__ is None:\n        return getattr, (m.__class__, m.__func__.__name__)\n    else:\n        return getattr, (m.__self__, m.__func__.__name__)\nclass _C:\n    def f(self):\n        pass\nregister(type(_C().f), _reduce_method)\n\n\ndef _reduce_method_descriptor(m):\n    return getattr, (m.__objclass__, m.__name__)\nregister(type(list.append), _reduce_method_descriptor)\nregister(type(int.__add__), _reduce_method_descriptor)\n\n\ndef _reduce_partial(p):\n    return _rebuild_partial, (p.func, p.args, p.keywords or {})\ndef _rebuild_partial(func, args, keywords):\n    return functools.partial(func, *args, **keywords)\nregister(functools.partial, _reduce_partial)\n\n#\n# Make sockets picklable\n#\n\nif sys.platform == 'win32':\n    def _reduce_socket(s):\n        from .resource_sharer import DupSocket\n        return _rebuild_socket, (DupSocket(s),)\n    def _rebuild_socket(ds):\n        return ds.detach()\n    register(socket.socket, _reduce_socket)\n\nelse:\n    def _reduce_socket(s):\n        df = DupFd(s.fileno())\n        return _rebuild_socket, (df, s.family, s.type, s.proto)\n    def _rebuild_socket(df, family, type, proto):\n        fd = df.detach()\n        return socket.socket(family, type, proto, fileno=fd)\n    register(socket.socket, _reduce_socket)\n\n\nclass AbstractReducer(metaclass=ABCMeta):\n    '''Abstract base class for use in implementing a Reduction class\n    suitable for use in replacing the standard reduction mechanism\n    used in multiprocessing.'''\n    ForkingPickler = ForkingPickler\n    register = register\n    dump = dump\n    send_handle = send_handle\n    recv_handle = recv_handle\n\n    if sys.platform == 'win32':\n        steal_handle = steal_handle\n        duplicate = duplicate\n        DupHandle = DupHandle\n    else:\n        sendfds = sendfds\n        recvfds = recvfds\n        DupFd = DupFd\n\n    _reduce_method = _reduce_method\n    _reduce_method_descriptor = _reduce_method_descriptor\n    _rebuild_partial = _rebuild_partial\n    _reduce_socket = _reduce_socket\n    _rebuild_socket = _rebuild_socket\n\n    def __init__(self, *args):\n        register(type(_C().f), _reduce_method)\n        register(type(list.append), _reduce_method_descriptor)\n        register(type(int.__add__), _reduce_method_descriptor)\n        register(functools.partial, _reduce_partial)\n        register(socket.socket, _reduce_socket)\n", 281], "C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py": ["#\n# Module implementing queues\n#\n# multiprocessing/queues.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\n__all__ = ['Queue', 'SimpleQueue', 'JoinableQueue']\n\nimport sys\nimport os\nimport threading\nimport collections\nimport time\nimport types\nimport weakref\nimport errno\n\nfrom queue import Empty, Full\n\nfrom . import connection\nfrom . import context\n_ForkingPickler = context.reduction.ForkingPickler\n\nfrom .util import debug, info, Finalize, register_after_fork, is_exiting\n\n#\n# Queue type using a pipe, buffer and thread\n#\n\nclass Queue(object):\n\n    def __init__(self, maxsize=0, *, ctx):\n        if maxsize <= 0:\n            # Can raise ImportError (see issues #3770 and #23400)\n            from .synchronize import SEM_VALUE_MAX as maxsize\n        self._maxsize = maxsize\n        self._reader, self._writer = connection.Pipe(duplex=False)\n        self._rlock = ctx.Lock()\n        self._opid = os.getpid()\n        if sys.platform == 'win32':\n            self._wlock = None\n        else:\n            self._wlock = ctx.Lock()\n        self._sem = ctx.BoundedSemaphore(maxsize)\n        # For use by concurrent.futures\n        self._ignore_epipe = False\n        self._reset()\n\n        if sys.platform != 'win32':\n            register_after_fork(self, Queue._after_fork)\n\n    def __getstate__(self):\n        context.assert_spawning(self)\n        return (self._ignore_epipe, self._maxsize, self._reader, self._writer,\n                self._rlock, self._wlock, self._sem, self._opid)\n\n    def __setstate__(self, state):\n        (self._ignore_epipe, self._maxsize, self._reader, self._writer,\n         self._rlock, self._wlock, self._sem, self._opid) = state\n        self._reset()\n\n    def _after_fork(self):\n        debug('Queue._after_fork()')\n        self._reset(after_fork=True)\n\n    def _reset(self, after_fork=False):\n        if after_fork:\n            self._notempty._at_fork_reinit()\n        else:\n            self._notempty = threading.Condition(threading.Lock())\n        self._buffer = collections.deque()\n        self._thread = None\n        self._jointhread = None\n        self._joincancelled = False\n        self._closed = False\n        self._close = None\n        self._send_bytes = self._writer.send_bytes\n        self._recv_bytes = self._reader.recv_bytes\n        self._poll = self._reader.poll\n\n    def put(self, obj, block=True, timeout=None):\n        if self._closed:\n            raise ValueError(f\"Queue {self!r} is closed\")\n        if not self._sem.acquire(block, timeout):\n            raise Full\n\n        with self._notempty:\n            if self._thread is None:\n                self._start_thread()\n            self._buffer.append(obj)\n            self._notempty.notify()\n\n    def get(self, block=True, timeout=None):\n        if self._closed:\n            raise ValueError(f\"Queue {self!r} is closed\")\n        if block and timeout is None:\n            with self._rlock:\n                res = self._recv_bytes()\n            self._sem.release()\n        else:\n            if block:\n                deadline = time.monotonic() + timeout\n            if not self._rlock.acquire(block, timeout):\n                raise Empty\n            try:\n                if block:\n                    timeout = deadline - time.monotonic()\n                    if not self._poll(timeout):\n                        raise Empty\n                elif not self._poll():\n                    raise Empty\n                res = self._recv_bytes()\n                self._sem.release()\n            finally:\n                self._rlock.release()\n        # unserialize the data after having released the lock\n        return _ForkingPickler.loads(res)\n\n    def qsize(self):\n        # Raises NotImplementedError on Mac OSX because of broken sem_getvalue()\n        return self._maxsize - self._sem._semlock._get_value()\n\n    def empty(self):\n        return not self._poll()\n\n    def full(self):\n        return self._sem._semlock._is_zero()\n\n    def get_nowait(self):\n        return self.get(False)\n\n    def put_nowait(self, obj):\n        return self.put(obj, False)\n\n    def close(self):\n        self._closed = True\n        close = self._close\n        if close:\n            self._close = None\n            close()\n\n    def join_thread(self):\n        debug('Queue.join_thread()')\n        assert self._closed, \"Queue {0!r} not closed\".format(self)\n        if self._jointhread:\n            self._jointhread()\n\n    def cancel_join_thread(self):\n        debug('Queue.cancel_join_thread()')\n        self._joincancelled = True\n        try:\n            self._jointhread.cancel()\n        except AttributeError:\n            pass\n\n    def _terminate_broken(self):\n        # Close a Queue on error.\n\n        # gh-94777: Prevent queue writing to a pipe which is no longer read.\n        self._reader.close()\n\n        # gh-107219: Close the connection writer which can unblock\n        # Queue._feed() if it was stuck in send_bytes().\n        if sys.platform == 'win32':\n            self._writer.close()\n\n        self.close()\n        self.join_thread()\n\n    def _start_thread(self):\n        debug('Queue._start_thread()')\n\n        # Start thread which transfers data from buffer to pipe\n        self._buffer.clear()\n        self._thread = threading.Thread(\n            target=Queue._feed,\n            args=(self._buffer, self._notempty, self._send_bytes,\n                  self._wlock, self._reader.close, self._writer.close,\n                  self._ignore_epipe, self._on_queue_feeder_error,\n                  self._sem),\n            name='QueueFeederThread',\n            daemon=True,\n        )\n\n        try:\n            debug('doing self._thread.start()')\n            self._thread.start()\n            debug('... done self._thread.start()')\n        except:\n            # gh-109047: During Python finalization, creating a thread\n            # can fail with RuntimeError.\n            self._thread = None\n            raise\n\n        if not self._joincancelled:\n            self._jointhread = Finalize(\n                self._thread, Queue._finalize_join,\n                [weakref.ref(self._thread)],\n                exitpriority=-5\n                )\n\n        # Send sentinel to the thread queue object when garbage collected\n        self._close = Finalize(\n            self, Queue._finalize_close,\n            [self._buffer, self._notempty],\n            exitpriority=10\n            )\n\n    @staticmethod\n    def _finalize_join(twr):\n        debug('joining queue thread')\n        thread = twr()\n        if thread is not None:\n            thread.join()\n            debug('... queue thread joined')\n        else:\n            debug('... queue thread already dead')\n\n    @staticmethod\n    def _finalize_close(buffer, notempty):\n        debug('telling queue thread to quit')\n        with notempty:\n            buffer.append(_sentinel)\n            notempty.notify()\n\n    @staticmethod\n    def _feed(buffer, notempty, send_bytes, writelock, reader_close,\n              writer_close, ignore_epipe, onerror, queue_sem):\n        debug('starting thread to feed data to pipe')\n        nacquire = notempty.acquire\n        nrelease = notempty.release\n        nwait = notempty.wait\n        bpopleft = buffer.popleft\n        sentinel = _sentinel\n        if sys.platform != 'win32':\n            wacquire = writelock.acquire\n            wrelease = writelock.release\n        else:\n            wacquire = None\n\n        while 1:\n            try:\n                nacquire()\n                try:\n                    if not buffer:\n                        nwait()\n                finally:\n                    nrelease()\n                try:\n                    while 1:\n                        obj = bpopleft()\n                        if obj is sentinel:\n                            debug('feeder thread got sentinel -- exiting')\n                            reader_close()\n                            writer_close()\n                            return\n\n                        # serialize the data before acquiring the lock\n                        obj = _ForkingPickler.dumps(obj)\n                        if wacquire is None:\n                            send_bytes(obj)\n                        else:\n                            wacquire()\n                            try:\n                                send_bytes(obj)\n                            finally:\n                                wrelease()\n                except IndexError:\n                    pass\n            except Exception as e:\n                if ignore_epipe and getattr(e, 'errno', 0) == errno.EPIPE:\n                    return\n                # Since this runs in a daemon thread the resources it uses\n                # may be become unusable while the process is cleaning up.\n                # We ignore errors which happen after the process has\n                # started to cleanup.\n                if is_exiting():\n                    info('error in queue thread: %s', e)\n                    return\n                else:\n                    # Since the object has not been sent in the queue, we need\n                    # to decrease the size of the queue. The error acts as\n                    # if the object had been silently removed from the queue\n                    # and this step is necessary to have a properly working\n                    # queue.\n                    queue_sem.release()\n                    onerror(e, obj)\n\n    @staticmethod\n    def _on_queue_feeder_error(e, obj):\n        \"\"\"\n        Private API hook called when feeding data in the background thread\n        raises an exception.  For overriding by concurrent.futures.\n        \"\"\"\n        import traceback\n        traceback.print_exc()\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n\n_sentinel = object()\n\n#\n# A queue type which also supports join() and task_done() methods\n#\n# Note that if you do not call task_done() for each finished task then\n# eventually the counter's semaphore may overflow causing Bad Things\n# to happen.\n#\n\nclass JoinableQueue(Queue):\n\n    def __init__(self, maxsize=0, *, ctx):\n        Queue.__init__(self, maxsize, ctx=ctx)\n        self._unfinished_tasks = ctx.Semaphore(0)\n        self._cond = ctx.Condition()\n\n    def __getstate__(self):\n        return Queue.__getstate__(self) + (self._cond, self._unfinished_tasks)\n\n    def __setstate__(self, state):\n        Queue.__setstate__(self, state[:-2])\n        self._cond, self._unfinished_tasks = state[-2:]\n\n    def put(self, obj, block=True, timeout=None):\n        if self._closed:\n            raise ValueError(f\"Queue {self!r} is closed\")\n        if not self._sem.acquire(block, timeout):\n            raise Full\n\n        with self._notempty, self._cond:\n            if self._thread is None:\n                self._start_thread()\n            self._buffer.append(obj)\n            self._unfinished_tasks.release()\n            self._notempty.notify()\n\n    def task_done(self):\n        with self._cond:\n            if not self._unfinished_tasks.acquire(False):\n                raise ValueError('task_done() called too many times')\n            if self._unfinished_tasks._semlock._is_zero():\n                self._cond.notify_all()\n\n    def join(self):\n        with self._cond:\n            if not self._unfinished_tasks._semlock._is_zero():\n                self._cond.wait()\n\n#\n# Simplified Queue type -- really just a locked pipe\n#\n\nclass SimpleQueue(object):\n\n    def __init__(self, *, ctx):\n        self._reader, self._writer = connection.Pipe(duplex=False)\n        self._rlock = ctx.Lock()\n        self._poll = self._reader.poll\n        if sys.platform == 'win32':\n            self._wlock = None\n        else:\n            self._wlock = ctx.Lock()\n\n    def close(self):\n        self._reader.close()\n        self._writer.close()\n\n    def empty(self):\n        return not self._poll()\n\n    def __getstate__(self):\n        context.assert_spawning(self)\n        return (self._reader, self._writer, self._rlock, self._wlock)\n\n    def __setstate__(self, state):\n        (self._reader, self._writer, self._rlock, self._wlock) = state\n        self._poll = self._reader.poll\n\n    def get(self):\n        with self._rlock:\n            res = self._reader.recv_bytes()\n        # unserialize the data after having released the lock\n        return _ForkingPickler.loads(res)\n\n    def put(self, obj):\n        # serialize the data before acquiring the lock\n        obj = _ForkingPickler.dumps(obj)\n        if self._wlock is None:\n            # writes to a message oriented win32 pipe are atomic\n            self._writer.send_bytes(obj)\n        else:\n            with self._wlock:\n                self._writer.send_bytes(obj)\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n", 399], "C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py": ["#\n# Module implementing synchronization primitives\n#\n# multiprocessing/synchronize.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\n__all__ = [\n    'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Condition', 'Event'\n    ]\n\nimport threading\nimport sys\nimport tempfile\nimport _multiprocessing\nimport time\n\nfrom . import context\nfrom . import process\nfrom . import util\n\n# Try to import the mp.synchronize module cleanly, if it fails\n# raise ImportError for platforms lacking a working sem_open implementation.\n# See issue 3770\ntry:\n    from _multiprocessing import SemLock, sem_unlink\nexcept (ImportError):\n    raise ImportError(\"This platform lacks a functioning sem_open\" +\n                      \" implementation, therefore, the required\" +\n                      \" synchronization primitives needed will not\" +\n                      \" function, see issue 3770.\")\n\n#\n# Constants\n#\n\nRECURSIVE_MUTEX, SEMAPHORE = list(range(2))\nSEM_VALUE_MAX = _multiprocessing.SemLock.SEM_VALUE_MAX\n\n#\n# Base class for semaphores and mutexes; wraps `_multiprocessing.SemLock`\n#\n\nclass SemLock(object):\n\n    _rand = tempfile._RandomNameSequence()\n\n    def __init__(self, kind, value, maxvalue, *, ctx):\n        if ctx is None:\n            ctx = context._default_context.get_context()\n        self._is_fork_ctx = ctx.get_start_method() == 'fork'\n        unlink_now = sys.platform == 'win32' or self._is_fork_ctx\n        for i in range(100):\n            try:\n                sl = self._semlock = _multiprocessing.SemLock(\n                    kind, value, maxvalue, self._make_name(),\n                    unlink_now)\n            except FileExistsError:\n                pass\n            else:\n                break\n        else:\n            raise FileExistsError('cannot find name for semaphore')\n\n        util.debug('created semlock with handle %s' % sl.handle)\n        self._make_methods()\n\n        if sys.platform != 'win32':\n            def _after_fork(obj):\n                obj._semlock._after_fork()\n            util.register_after_fork(self, _after_fork)\n\n        if self._semlock.name is not None:\n            # We only get here if we are on Unix with forking\n            # disabled.  When the object is garbage collected or the\n            # process shuts down we unlink the semaphore name\n            from .resource_tracker import register\n            register(self._semlock.name, \"semaphore\")\n            util.Finalize(self, SemLock._cleanup, (self._semlock.name,),\n                          exitpriority=0)\n\n    @staticmethod\n    def _cleanup(name):\n        from .resource_tracker import unregister\n        sem_unlink(name)\n        unregister(name, \"semaphore\")\n\n    def _make_methods(self):\n        self.acquire = self._semlock.acquire\n        self.release = self._semlock.release\n\n    def __enter__(self):\n        return self._semlock.__enter__()\n\n    def __exit__(self, *args):\n        return self._semlock.__exit__(*args)\n\n    def __getstate__(self):\n        context.assert_spawning(self)\n        sl = self._semlock\n        if sys.platform == 'win32':\n            h = context.get_spawning_popen().duplicate_for_child(sl.handle)\n        else:\n            if self._is_fork_ctx:\n                raise RuntimeError('A SemLock created in a fork context is being '\n                                   'shared with a process in a spawn context. This is '\n                                   'not supported. Please use the same context to create '\n                                   'multiprocessing objects and Process.')\n            h = sl.handle\n        return (h, sl.kind, sl.maxvalue, sl.name)\n\n    def __setstate__(self, state):\n        self._semlock = _multiprocessing.SemLock._rebuild(*state)\n        util.debug('recreated blocker with handle %r' % state[0])\n        self._make_methods()\n        # Ensure that deserialized SemLock can be serialized again (gh-108520).\n        self._is_fork_ctx = False\n\n    @staticmethod\n    def _make_name():\n        return '%s-%s' % (process.current_process()._config['semprefix'],\n                          next(SemLock._rand))\n\n#\n# Semaphore\n#\n\nclass Semaphore(SemLock):\n\n    def __init__(self, value=1, *, ctx):\n        SemLock.__init__(self, SEMAPHORE, value, SEM_VALUE_MAX, ctx=ctx)\n\n    def get_value(self):\n        return self._semlock._get_value()\n\n    def __repr__(self):\n        try:\n            value = self._semlock._get_value()\n        except Exception:\n            value = 'unknown'\n        return '<%s(value=%s)>' % (self.__class__.__name__, value)\n\n#\n# Bounded semaphore\n#\n\nclass BoundedSemaphore(Semaphore):\n\n    def __init__(self, value=1, *, ctx):\n        SemLock.__init__(self, SEMAPHORE, value, value, ctx=ctx)\n\n    def __repr__(self):\n        try:\n            value = self._semlock._get_value()\n        except Exception:\n            value = 'unknown'\n        return '<%s(value=%s, maxvalue=%s)>' % \\\n               (self.__class__.__name__, value, self._semlock.maxvalue)\n\n#\n# Non-recursive lock\n#\n\nclass Lock(SemLock):\n\n    def __init__(self, *, ctx):\n        SemLock.__init__(self, SEMAPHORE, 1, 1, ctx=ctx)\n\n    def __repr__(self):\n        try:\n            if self._semlock._is_mine():\n                name = process.current_process().name\n                if threading.current_thread().name != 'MainThread':\n                    name += '|' + threading.current_thread().name\n            elif not self._semlock._is_zero():\n                name = 'None'\n            elif self._semlock._count() > 0:\n                name = 'SomeOtherThread'\n            else:\n                name = 'SomeOtherProcess'\n        except Exception:\n            name = 'unknown'\n        return '<%s(owner=%s)>' % (self.__class__.__name__, name)\n\n#\n# Recursive lock\n#\n\nclass RLock(SemLock):\n\n    def __init__(self, *, ctx):\n        SemLock.__init__(self, RECURSIVE_MUTEX, 1, 1, ctx=ctx)\n\n    def __repr__(self):\n        try:\n            if self._semlock._is_mine():\n                name = process.current_process().name\n                if threading.current_thread().name != 'MainThread':\n                    name += '|' + threading.current_thread().name\n                count = self._semlock._count()\n            elif not self._semlock._is_zero():\n                name, count = 'None', 0\n            elif self._semlock._count() > 0:\n                name, count = 'SomeOtherThread', 'nonzero'\n            else:\n                name, count = 'SomeOtherProcess', 'nonzero'\n        except Exception:\n            name, count = 'unknown', 'unknown'\n        return '<%s(%s, %s)>' % (self.__class__.__name__, name, count)\n\n#\n# Condition variable\n#\n\nclass Condition(object):\n\n    def __init__(self, lock=None, *, ctx):\n        self._lock = lock or ctx.RLock()\n        self._sleeping_count = ctx.Semaphore(0)\n        self._woken_count = ctx.Semaphore(0)\n        self._wait_semaphore = ctx.Semaphore(0)\n        self._make_methods()\n\n    def __getstate__(self):\n        context.assert_spawning(self)\n        return (self._lock, self._sleeping_count,\n                self._woken_count, self._wait_semaphore)\n\n    def __setstate__(self, state):\n        (self._lock, self._sleeping_count,\n         self._woken_count, self._wait_semaphore) = state\n        self._make_methods()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n    def _make_methods(self):\n        self.acquire = self._lock.acquire\n        self.release = self._lock.release\n\n    def __repr__(self):\n        try:\n            num_waiters = (self._sleeping_count._semlock._get_value() -\n                           self._woken_count._semlock._get_value())\n        except Exception:\n            num_waiters = 'unknown'\n        return '<%s(%s, %s)>' % (self.__class__.__name__, self._lock, num_waiters)\n\n    def wait(self, timeout=None):\n        assert self._lock._semlock._is_mine(), \\\n               'must acquire() condition before using wait()'\n\n        # indicate that this thread is going to sleep\n        self._sleeping_count.release()\n\n        # release lock\n        count = self._lock._semlock._count()\n        for i in range(count):\n            self._lock.release()\n\n        try:\n            # wait for notification or timeout\n            return self._wait_semaphore.acquire(True, timeout)\n        finally:\n            # indicate that this thread has woken\n            self._woken_count.release()\n\n            # reacquire lock\n            for i in range(count):\n                self._lock.acquire()\n\n    def notify(self, n=1):\n        assert self._lock._semlock._is_mine(), 'lock is not owned'\n        assert not self._wait_semaphore.acquire(\n            False), ('notify: Should not have been able to acquire '\n                     + '_wait_semaphore')\n\n        # to take account of timeouts since last notify*() we subtract\n        # woken_count from sleeping_count and rezero woken_count\n        while self._woken_count.acquire(False):\n            res = self._sleeping_count.acquire(False)\n            assert res, ('notify: Bug in sleeping_count.acquire'\n                         + '- res should not be False')\n\n        sleepers = 0\n        while sleepers < n and self._sleeping_count.acquire(False):\n            self._wait_semaphore.release()        # wake up one sleeper\n            sleepers += 1\n\n        if sleepers:\n            for i in range(sleepers):\n                self._woken_count.acquire()       # wait for a sleeper to wake\n\n            # rezero wait_semaphore in case some timeouts just happened\n            while self._wait_semaphore.acquire(False):\n                pass\n\n    def notify_all(self):\n        self.notify(n=sys.maxsize)\n\n    def wait_for(self, predicate, timeout=None):\n        result = predicate()\n        if result:\n            return result\n        if timeout is not None:\n            endtime = time.monotonic() + timeout\n        else:\n            endtime = None\n            waittime = None\n        while not result:\n            if endtime is not None:\n                waittime = endtime - time.monotonic()\n                if waittime <= 0:\n                    break\n            self.wait(waittime)\n            result = predicate()\n        return result\n\n#\n# Event\n#\n\nclass Event(object):\n\n    def __init__(self, *, ctx):\n        self._cond = ctx.Condition(ctx.Lock())\n        self._flag = ctx.Semaphore(0)\n\n    def is_set(self):\n        with self._cond:\n            if self._flag.acquire(False):\n                self._flag.release()\n                return True\n            return False\n\n    def set(self):\n        with self._cond:\n            self._flag.acquire(False)\n            self._flag.release()\n            self._cond.notify_all()\n\n    def clear(self):\n        with self._cond:\n            self._flag.acquire(False)\n\n    def wait(self, timeout=None):\n        with self._cond:\n            if self._flag.acquire(False):\n                self._flag.release()\n            else:\n                self._cond.wait(timeout)\n\n            if self._flag.acquire(False):\n                self._flag.release()\n                return True\n            return False\n\n    def __repr__(self):\n        set_status = 'set' if self.is_set() else 'unset'\n        return f\"<{type(self).__qualname__} at {id(self):#x} {set_status}>\"\n#\n# Barrier\n#\n\nclass Barrier(threading.Barrier):\n\n    def __init__(self, parties, action=None, timeout=None, *, ctx):\n        import struct\n        from .heap import BufferWrapper\n        wrapper = BufferWrapper(struct.calcsize('i') * 2)\n        cond = ctx.Condition()\n        self.__setstate__((parties, action, timeout, cond, wrapper))\n        self._state = 0\n        self._count = 0\n\n    def __setstate__(self, state):\n        (self._parties, self._action, self._timeout,\n         self._cond, self._wrapper) = state\n        self._array = self._wrapper.create_memoryview().cast('i')\n\n    def __getstate__(self):\n        return (self._parties, self._action, self._timeout,\n                self._cond, self._wrapper)\n\n    @property\n    def _state(self):\n        return self._array[0]\n\n    @_state.setter\n    def _state(self, value):\n        self._array[0] = value\n\n    @property\n    def _count(self):\n        return self._array[1]\n\n    @_count.setter\n    def _count(self, value):\n        self._array[1] = value\n", 404], "C:\\Programming\\Python313\\Lib\\tempfile.py": ["\"\"\"Temporary files.\n\nThis module provides generic, low- and high-level interfaces for\ncreating temporary files and directories.  All of the interfaces\nprovided by this module can be used without fear of race conditions\nexcept for 'mktemp'.  'mktemp' is subject to race conditions and\nshould not be used; it is provided for backward compatibility only.\n\nThe default path names are returned as str.  If you supply bytes as\ninput, all return values will be in bytes.  Ex:\n\n    >>> tempfile.mkstemp()\n    (4, '/tmp/tmptpu9nin8')\n    >>> tempfile.mkdtemp(suffix=b'')\n    b'/tmp/tmppbi8f0hy'\n\nThis module also provides some data items to the user:\n\n  TMP_MAX  - maximum number of names that will be tried before\n             giving up.\n  tempdir  - If this is set to a string before the first use of\n             any routine from this module, it will be considered as\n             another candidate location to store temporary files.\n\"\"\"\n\n__all__ = [\n    \"NamedTemporaryFile\", \"TemporaryFile\", # high level safe interfaces\n    \"SpooledTemporaryFile\", \"TemporaryDirectory\",\n    \"mkstemp\", \"mkdtemp\",                  # low level safe interfaces\n    \"mktemp\",                              # deprecated unsafe interface\n    \"TMP_MAX\", \"gettempprefix\",            # constants\n    \"tempdir\", \"gettempdir\",\n    \"gettempprefixb\", \"gettempdirb\",\n   ]\n\n\n# Imports.\n\nimport functools as _functools\nimport warnings as _warnings\nimport io as _io\nimport os as _os\nimport shutil as _shutil\nimport errno as _errno\nfrom random import Random as _Random\nimport sys as _sys\nimport types as _types\nimport weakref as _weakref\nimport _thread\n_allocate_lock = _thread.allocate_lock\n\n_text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL\nif hasattr(_os, 'O_NOFOLLOW'):\n    _text_openflags |= _os.O_NOFOLLOW\n\n_bin_openflags = _text_openflags\nif hasattr(_os, 'O_BINARY'):\n    _bin_openflags |= _os.O_BINARY\n\nif hasattr(_os, 'TMP_MAX'):\n    TMP_MAX = _os.TMP_MAX\nelse:\n    TMP_MAX = 10000\n\n# This variable _was_ unused for legacy reasons, see issue 10354.\n# But as of 3.5 we actually use it at runtime so changing it would\n# have a possibly desirable side effect...  But we do not want to support\n# that as an API.  It is undocumented on purpose.  Do not depend on this.\ntemplate = \"tmp\"\n\n# Internal routines.\n\n_once_lock = _allocate_lock()\n\n\ndef _exists(fn):\n    try:\n        _os.lstat(fn)\n    except OSError:\n        return False\n    else:\n        return True\n\n\ndef _infer_return_type(*args):\n    \"\"\"Look at the type of all args and divine their implied return type.\"\"\"\n    return_type = None\n    for arg in args:\n        if arg is None:\n            continue\n\n        if isinstance(arg, _os.PathLike):\n            arg = _os.fspath(arg)\n\n        if isinstance(arg, bytes):\n            if return_type is str:\n                raise TypeError(\"Can't mix bytes and non-bytes in \"\n                                \"path components.\")\n            return_type = bytes\n        else:\n            if return_type is bytes:\n                raise TypeError(\"Can't mix bytes and non-bytes in \"\n                                \"path components.\")\n            return_type = str\n    if return_type is None:\n        if tempdir is None or isinstance(tempdir, str):\n            return str  # tempfile APIs return a str by default.\n        else:\n            # we could check for bytes but it'll fail later on anyway\n            return bytes\n    return return_type\n\n\ndef _sanitize_params(prefix, suffix, dir):\n    \"\"\"Common parameter processing for most APIs in this module.\"\"\"\n    output_type = _infer_return_type(prefix, suffix, dir)\n    if suffix is None:\n        suffix = output_type()\n    if prefix is None:\n        if output_type is str:\n            prefix = template\n        else:\n            prefix = _os.fsencode(template)\n    if dir is None:\n        if output_type is str:\n            dir = gettempdir()\n        else:\n            dir = gettempdirb()\n    return prefix, suffix, dir, output_type\n\n\nclass _RandomNameSequence:\n    \"\"\"An instance of _RandomNameSequence generates an endless\n    sequence of unpredictable strings which can safely be incorporated\n    into file names.  Each string is eight characters long.  Multiple\n    threads can safely use the same instance at the same time.\n\n    _RandomNameSequence is an iterator.\"\"\"\n\n    characters = \"abcdefghijklmnopqrstuvwxyz0123456789_\"\n\n    @property\n    def rng(self):\n        cur_pid = _os.getpid()\n        if cur_pid != getattr(self, '_rng_pid', None):\n            self._rng = _Random()\n            self._rng_pid = cur_pid\n        return self._rng\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return ''.join(self.rng.choices(self.characters, k=8))\n\ndef _candidate_tempdir_list():\n    \"\"\"Generate a list of candidate temporary directories which\n    _get_default_tempdir will try.\"\"\"\n\n    dirlist = []\n\n    # First, try the environment.\n    for envname in 'TMPDIR', 'TEMP', 'TMP':\n        dirname = _os.getenv(envname)\n        if dirname: dirlist.append(dirname)\n\n    # Failing that, try OS-specific locations.\n    if _os.name == 'nt':\n        dirlist.extend([ _os.path.expanduser(r'~\\AppData\\Local\\Temp'),\n                         _os.path.expandvars(r'%SYSTEMROOT%\\Temp'),\n                         r'c:\\temp', r'c:\\tmp', r'\\temp', r'\\tmp' ])\n    else:\n        dirlist.extend([ '/tmp', '/var/tmp', '/usr/tmp' ])\n\n    # As a last resort, the current directory.\n    try:\n        dirlist.append(_os.getcwd())\n    except (AttributeError, OSError):\n        dirlist.append(_os.curdir)\n\n    return dirlist\n\ndef _get_default_tempdir():\n    \"\"\"Calculate the default directory to use for temporary files.\n    This routine should be called exactly once.\n\n    We determine whether or not a candidate temp dir is usable by\n    trying to create and write to a file in that directory.  If this\n    is successful, the test file is deleted.  To prevent denial of\n    service, the name of the test file must be randomized.\"\"\"\n\n    namer = _RandomNameSequence()\n    dirlist = _candidate_tempdir_list()\n\n    for dir in dirlist:\n        if dir != _os.curdir:\n            dir = _os.path.abspath(dir)\n        # Try only a few names per directory.\n        for seq in range(100):\n            name = next(namer)\n            filename = _os.path.join(dir, name)\n            try:\n                fd = _os.open(filename, _bin_openflags, 0o600)\n                try:\n                    try:\n                        _os.write(fd, b'blat')\n                    finally:\n                        _os.close(fd)\n                finally:\n                    _os.unlink(filename)\n                return dir\n            except FileExistsError:\n                pass\n            except PermissionError:\n                # This exception is thrown when a directory with the chosen name\n                # already exists on windows.\n                if (_os.name == 'nt' and _os.path.isdir(dir) and\n                    _os.access(dir, _os.W_OK)):\n                    continue\n                break   # no point trying more names in this directory\n            except OSError:\n                break   # no point trying more names in this directory\n    raise FileNotFoundError(_errno.ENOENT,\n                            \"No usable temporary directory found in %s\" %\n                            dirlist)\n\n_name_sequence = None\n\ndef _get_candidate_names():\n    \"\"\"Common setup sequence for all user-callable interfaces.\"\"\"\n\n    global _name_sequence\n    if _name_sequence is None:\n        _once_lock.acquire()\n        try:\n            if _name_sequence is None:\n                _name_sequence = _RandomNameSequence()\n        finally:\n            _once_lock.release()\n    return _name_sequence\n\n\ndef _mkstemp_inner(dir, pre, suf, flags, output_type):\n    \"\"\"Code common to mkstemp, TemporaryFile, and NamedTemporaryFile.\"\"\"\n\n    dir = _os.path.abspath(dir)\n    names = _get_candidate_names()\n    if output_type is bytes:\n        names = map(_os.fsencode, names)\n\n    for seq in range(TMP_MAX):\n        name = next(names)\n        file = _os.path.join(dir, pre + name + suf)\n        _sys.audit(\"tempfile.mkstemp\", file)\n        try:\n            fd = _os.open(file, flags, 0o600)\n        except FileExistsError:\n            continue    # try again\n        except PermissionError:\n            # This exception is thrown when a directory with the chosen name\n            # already exists on windows.\n            if (_os.name == 'nt' and _os.path.isdir(dir) and\n                _os.access(dir, _os.W_OK)):\n                continue\n            else:\n                raise\n        return fd, file\n\n    raise FileExistsError(_errno.EEXIST,\n                          \"No usable temporary file name found\")\n\ndef _dont_follow_symlinks(func, path, *args):\n    # Pass follow_symlinks=False, unless not supported on this platform.\n    if func in _os.supports_follow_symlinks:\n        func(path, *args, follow_symlinks=False)\n    elif not _os.path.islink(path):\n        func(path, *args)\n\ndef _resetperms(path):\n    try:\n        chflags = _os.chflags\n    except AttributeError:\n        pass\n    else:\n        _dont_follow_symlinks(chflags, path, 0)\n    _dont_follow_symlinks(_os.chmod, path, 0o700)\n\n\n# User visible interfaces.\n\ndef gettempprefix():\n    \"\"\"The default prefix for temporary directories as string.\"\"\"\n    return _os.fsdecode(template)\n\ndef gettempprefixb():\n    \"\"\"The default prefix for temporary directories as bytes.\"\"\"\n    return _os.fsencode(template)\n\ntempdir = None\n\ndef _gettempdir():\n    \"\"\"Private accessor for tempfile.tempdir.\"\"\"\n    global tempdir\n    if tempdir is None:\n        _once_lock.acquire()\n        try:\n            if tempdir is None:\n                tempdir = _get_default_tempdir()\n        finally:\n            _once_lock.release()\n    return tempdir\n\ndef gettempdir():\n    \"\"\"Returns tempfile.tempdir as str.\"\"\"\n    return _os.fsdecode(_gettempdir())\n\ndef gettempdirb():\n    \"\"\"Returns tempfile.tempdir as bytes.\"\"\"\n    return _os.fsencode(_gettempdir())\n\ndef mkstemp(suffix=None, prefix=None, dir=None, text=False):\n    \"\"\"User-callable function to create and return a unique temporary\n    file.  The return value is a pair (fd, name) where fd is the\n    file descriptor returned by os.open, and name is the filename.\n\n    If 'suffix' is not None, the file name will end with that suffix,\n    otherwise there will be no suffix.\n\n    If 'prefix' is not None, the file name will begin with that prefix,\n    otherwise a default prefix is used.\n\n    If 'dir' is not None, the file will be created in that directory,\n    otherwise a default directory is used.\n\n    If 'text' is specified and true, the file is opened in text\n    mode.  Else (the default) the file is opened in binary mode.\n\n    If any of 'suffix', 'prefix' and 'dir' are not None, they must be the\n    same type.  If they are bytes, the returned name will be bytes; str\n    otherwise.\n\n    The file is readable and writable only by the creating user ID.\n    If the operating system uses permission bits to indicate whether a\n    file is executable, the file is executable by no one. The file\n    descriptor is not inherited by children of this process.\n\n    Caller is responsible for deleting the file when done with it.\n    \"\"\"\n\n    prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)\n\n    if text:\n        flags = _text_openflags\n    else:\n        flags = _bin_openflags\n\n    return _mkstemp_inner(dir, prefix, suffix, flags, output_type)\n\n\ndef mkdtemp(suffix=None, prefix=None, dir=None):\n    \"\"\"User-callable function to create and return a unique temporary\n    directory.  The return value is the pathname of the directory.\n\n    Arguments are as for mkstemp, except that the 'text' argument is\n    not accepted.\n\n    The directory is readable, writable, and searchable only by the\n    creating user.\n\n    Caller is responsible for deleting the directory when done with it.\n    \"\"\"\n\n    prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)\n\n    names = _get_candidate_names()\n    if output_type is bytes:\n        names = map(_os.fsencode, names)\n\n    for seq in range(TMP_MAX):\n        name = next(names)\n        file = _os.path.join(dir, prefix + name + suffix)\n        _sys.audit(\"tempfile.mkdtemp\", file)\n        try:\n            _os.mkdir(file, 0o700)\n        except FileExistsError:\n            continue    # try again\n        except PermissionError:\n            # This exception is thrown when a directory with the chosen name\n            # already exists on windows.\n            if (_os.name == 'nt' and _os.path.isdir(dir) and\n                _os.access(dir, _os.W_OK)):\n                continue\n            else:\n                raise\n        return _os.path.abspath(file)\n\n    raise FileExistsError(_errno.EEXIST,\n                          \"No usable temporary directory name found\")\n\ndef mktemp(suffix=\"\", prefix=template, dir=None):\n    \"\"\"User-callable function to return a unique temporary file name.  The\n    file is not created.\n\n    Arguments are similar to mkstemp, except that the 'text' argument is\n    not accepted, and suffix=None, prefix=None and bytes file names are not\n    supported.\n\n    THIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may\n    refer to a file that did not exist at some point, but by the time\n    you get around to creating it, someone else may have beaten you to\n    the punch.\n    \"\"\"\n\n##    from warnings import warn as _warn\n##    _warn(\"mktemp is a potential security risk to your program\",\n##          RuntimeWarning, stacklevel=2)\n\n    if dir is None:\n        dir = gettempdir()\n\n    names = _get_candidate_names()\n    for seq in range(TMP_MAX):\n        name = next(names)\n        file = _os.path.join(dir, prefix + name + suffix)\n        if not _exists(file):\n            return file\n\n    raise FileExistsError(_errno.EEXIST,\n                          \"No usable temporary filename found\")\n\n\nclass _TemporaryFileCloser:\n    \"\"\"A separate object allowing proper closing of a temporary file's\n    underlying file object, without adding a __del__ method to the\n    temporary file.\"\"\"\n\n    cleanup_called = False\n    close_called = False\n\n    def __init__(self, file, name, delete=True, delete_on_close=True):\n        self.file = file\n        self.name = name\n        self.delete = delete\n        self.delete_on_close = delete_on_close\n\n    def cleanup(self, windows=(_os.name == 'nt'), unlink=_os.unlink):\n        if not self.cleanup_called:\n            self.cleanup_called = True\n            try:\n                if not self.close_called:\n                    self.close_called = True\n                    self.file.close()\n            finally:\n                # Windows provides delete-on-close as a primitive, in which\n                # case the file was deleted by self.file.close().\n                if self.delete and not (windows and self.delete_on_close):\n                    try:\n                        unlink(self.name)\n                    except FileNotFoundError:\n                        pass\n\n    def close(self):\n        if not self.close_called:\n            self.close_called = True\n            try:\n                self.file.close()\n            finally:\n                if self.delete and self.delete_on_close:\n                    self.cleanup()\n\n    def __del__(self):\n        self.cleanup()\n\n\nclass _TemporaryFileWrapper:\n    \"\"\"Temporary file wrapper\n\n    This class provides a wrapper around files opened for\n    temporary use.  In particular, it seeks to automatically\n    remove the file when it is no longer needed.\n    \"\"\"\n\n    def __init__(self, file, name, delete=True, delete_on_close=True):\n        self.file = file\n        self.name = name\n        self._closer = _TemporaryFileCloser(file, name, delete,\n                                            delete_on_close)\n\n    def __getattr__(self, name):\n        # Attribute lookups are delegated to the underlying file\n        # and cached for non-numeric results\n        # (i.e. methods are cached, closed and friends are not)\n        file = self.__dict__['file']\n        a = getattr(file, name)\n        if hasattr(a, '__call__'):\n            func = a\n            @_functools.wraps(func)\n            def func_wrapper(*args, **kwargs):\n                return func(*args, **kwargs)\n            # Avoid closing the file as long as the wrapper is alive,\n            # see issue #18879.\n            func_wrapper._closer = self._closer\n            a = func_wrapper\n        if not isinstance(a, int):\n            setattr(self, name, a)\n        return a\n\n    # The underlying __enter__ method returns the wrong object\n    # (self.file) so override it to return the wrapper\n    def __enter__(self):\n        self.file.__enter__()\n        return self\n\n    # Need to trap __exit__ as well to ensure the file gets\n    # deleted when used in a with statement\n    def __exit__(self, exc, value, tb):\n        result = self.file.__exit__(exc, value, tb)\n        self._closer.cleanup()\n        return result\n\n    def close(self):\n        \"\"\"\n        Close the temporary file, possibly deleting it.\n        \"\"\"\n        self._closer.close()\n\n    # iter() doesn't use __getattr__ to find the __iter__ method\n    def __iter__(self):\n        # Don't return iter(self.file), but yield from it to avoid closing\n        # file as long as it's being used as iterator (see issue #23700).  We\n        # can't use 'yield from' here because iter(file) returns the file\n        # object itself, which has a close method, and thus the file would get\n        # closed when the generator is finalized, due to PEP380 semantics.\n        for line in self.file:\n            yield line\n\ndef NamedTemporaryFile(mode='w+b', buffering=-1, encoding=None,\n                       newline=None, suffix=None, prefix=None,\n                       dir=None, delete=True, *, errors=None,\n                       delete_on_close=True):\n    \"\"\"Create and return a temporary file.\n    Arguments:\n    'prefix', 'suffix', 'dir' -- as for mkstemp.\n    'mode' -- the mode argument to io.open (default \"w+b\").\n    'buffering' -- the buffer size argument to io.open (default -1).\n    'encoding' -- the encoding argument to io.open (default None)\n    'newline' -- the newline argument to io.open (default None)\n    'delete' -- whether the file is automatically deleted (default True).\n    'delete_on_close' -- if 'delete', whether the file is deleted on close\n       (default True) or otherwise either on context manager exit\n       (if context manager was used) or on object finalization. .\n    'errors' -- the errors argument to io.open (default None)\n    The file is created as mkstemp() would do it.\n\n    Returns an object with a file-like interface; the name of the file\n    is accessible as its 'name' attribute.  The file will be automatically\n    deleted when it is closed unless the 'delete' argument is set to False.\n\n    On POSIX, NamedTemporaryFiles cannot be automatically deleted if\n    the creating process is terminated abruptly with a SIGKILL signal.\n    Windows can delete the file even in this case.\n    \"\"\"\n\n    prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)\n\n    flags = _bin_openflags\n\n    # Setting O_TEMPORARY in the flags causes the OS to delete\n    # the file when it is closed.  This is only supported by Windows.\n    if _os.name == 'nt' and delete and delete_on_close:\n        flags |= _os.O_TEMPORARY\n\n    if \"b\" not in mode:\n        encoding = _io.text_encoding(encoding)\n\n    name = None\n    def opener(*args):\n        nonlocal name\n        fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)\n        return fd\n    try:\n        file = _io.open(dir, mode, buffering=buffering,\n                        newline=newline, encoding=encoding, errors=errors,\n                        opener=opener)\n        try:\n            raw = getattr(file, 'buffer', file)\n            raw = getattr(raw, 'raw', raw)\n            raw.name = name\n            return _TemporaryFileWrapper(file, name, delete, delete_on_close)\n        except:\n            file.close()\n            raise\n    except:\n        if name is not None and not (\n            _os.name == 'nt' and delete and delete_on_close):\n            _os.unlink(name)\n        raise\n\nif _os.name != 'posix' or _sys.platform == 'cygwin':\n    # On non-POSIX and Cygwin systems, assume that we cannot unlink a file\n    # while it is open.\n    TemporaryFile = NamedTemporaryFile\n\nelse:\n    # Is the O_TMPFILE flag available and does it work?\n    # The flag is set to False if os.open(dir, os.O_TMPFILE) raises an\n    # IsADirectoryError exception\n    _O_TMPFILE_WORKS = hasattr(_os, 'O_TMPFILE')\n\n    def TemporaryFile(mode='w+b', buffering=-1, encoding=None,\n                      newline=None, suffix=None, prefix=None,\n                      dir=None, *, errors=None):\n        \"\"\"Create and return a temporary file.\n        Arguments:\n        'prefix', 'suffix', 'dir' -- as for mkstemp.\n        'mode' -- the mode argument to io.open (default \"w+b\").\n        'buffering' -- the buffer size argument to io.open (default -1).\n        'encoding' -- the encoding argument to io.open (default None)\n        'newline' -- the newline argument to io.open (default None)\n        'errors' -- the errors argument to io.open (default None)\n        The file is created as mkstemp() would do it.\n\n        Returns an object with a file-like interface.  The file has no\n        name, and will cease to exist when it is closed.\n        \"\"\"\n        global _O_TMPFILE_WORKS\n\n        if \"b\" not in mode:\n            encoding = _io.text_encoding(encoding)\n\n        prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)\n\n        flags = _bin_openflags\n        if _O_TMPFILE_WORKS:\n            fd = None\n            def opener(*args):\n                nonlocal fd\n                flags2 = (flags | _os.O_TMPFILE) & ~_os.O_CREAT\n                fd = _os.open(dir, flags2, 0o600)\n                return fd\n            try:\n                file = _io.open(dir, mode, buffering=buffering,\n                                newline=newline, encoding=encoding,\n                                errors=errors, opener=opener)\n                raw = getattr(file, 'buffer', file)\n                raw = getattr(raw, 'raw', raw)\n                raw.name = fd\n                return file\n            except IsADirectoryError:\n                # Linux kernel older than 3.11 ignores the O_TMPFILE flag:\n                # O_TMPFILE is read as O_DIRECTORY. Trying to open a directory\n                # with O_RDWR|O_DIRECTORY fails with IsADirectoryError, a\n                # directory cannot be open to write. Set flag to False to not\n                # try again.\n                _O_TMPFILE_WORKS = False\n            except OSError:\n                # The filesystem of the directory does not support O_TMPFILE.\n                # For example, OSError(95, 'Operation not supported').\n                #\n                # On Linux kernel older than 3.11, trying to open a regular\n                # file (or a symbolic link to a regular file) with O_TMPFILE\n                # fails with NotADirectoryError, because O_TMPFILE is read as\n                # O_DIRECTORY.\n                pass\n            # Fallback to _mkstemp_inner().\n\n        fd = None\n        def opener(*args):\n            nonlocal fd\n            fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)\n            try:\n                _os.unlink(name)\n            except BaseException as e:\n                _os.close(fd)\n                raise\n            return fd\n        file = _io.open(dir, mode, buffering=buffering,\n                        newline=newline, encoding=encoding, errors=errors,\n                        opener=opener)\n        raw = getattr(file, 'buffer', file)\n        raw = getattr(raw, 'raw', raw)\n        raw.name = fd\n        return file\n\nclass SpooledTemporaryFile(_io.IOBase):\n    \"\"\"Temporary file wrapper, specialized to switch from BytesIO\n    or StringIO to a real file when it exceeds a certain size or\n    when a fileno is needed.\n    \"\"\"\n    _rolled = False\n\n    def __init__(self, max_size=0, mode='w+b', buffering=-1,\n                 encoding=None, newline=None,\n                 suffix=None, prefix=None, dir=None, *, errors=None):\n        if 'b' in mode:\n            self._file = _io.BytesIO()\n        else:\n            encoding = _io.text_encoding(encoding)\n            self._file = _io.TextIOWrapper(_io.BytesIO(),\n                            encoding=encoding, errors=errors,\n                            newline=newline)\n        self._max_size = max_size\n        self._rolled = False\n        self._TemporaryFileArgs = {'mode': mode, 'buffering': buffering,\n                                   'suffix': suffix, 'prefix': prefix,\n                                   'encoding': encoding, 'newline': newline,\n                                   'dir': dir, 'errors': errors}\n\n    __class_getitem__ = classmethod(_types.GenericAlias)\n\n    def _check(self, file):\n        if self._rolled: return\n        max_size = self._max_size\n        if max_size and file.tell() > max_size:\n            self.rollover()\n\n    def rollover(self):\n        if self._rolled: return\n        file = self._file\n        newfile = self._file = TemporaryFile(**self._TemporaryFileArgs)\n        del self._TemporaryFileArgs\n\n        pos = file.tell()\n        if hasattr(newfile, 'buffer'):\n            newfile.buffer.write(file.detach().getvalue())\n        else:\n            newfile.write(file.getvalue())\n        newfile.seek(pos, 0)\n\n        self._rolled = True\n\n    # The method caching trick from NamedTemporaryFile\n    # won't work here, because _file may change from a\n    # BytesIO/StringIO instance to a real file. So we list\n    # all the methods directly.\n\n    # Context management protocol\n    def __enter__(self):\n        if self._file.closed:\n            raise ValueError(\"Cannot enter context with closed file\")\n        return self\n\n    def __exit__(self, exc, value, tb):\n        self._file.close()\n\n    # file protocol\n    def __iter__(self):\n        return self._file.__iter__()\n\n    def __del__(self):\n        if not self.closed:\n            _warnings.warn(\n                \"Unclosed file {!r}\".format(self),\n                ResourceWarning,\n                stacklevel=2,\n                source=self\n            )\n            self.close()\n\n    def close(self):\n        self._file.close()\n\n    @property\n    def closed(self):\n        return self._file.closed\n\n    @property\n    def encoding(self):\n        return self._file.encoding\n\n    @property\n    def errors(self):\n        return self._file.errors\n\n    def fileno(self):\n        self.rollover()\n        return self._file.fileno()\n\n    def flush(self):\n        self._file.flush()\n\n    def isatty(self):\n        return self._file.isatty()\n\n    @property\n    def mode(self):\n        try:\n            return self._file.mode\n        except AttributeError:\n            return self._TemporaryFileArgs['mode']\n\n    @property\n    def name(self):\n        try:\n            return self._file.name\n        except AttributeError:\n            return None\n\n    @property\n    def newlines(self):\n        return self._file.newlines\n\n    def readable(self):\n        return self._file.readable()\n\n    def read(self, *args):\n        return self._file.read(*args)\n\n    def read1(self, *args):\n        return self._file.read1(*args)\n\n    def readinto(self, b):\n        return self._file.readinto(b)\n\n    def readinto1(self, b):\n        return self._file.readinto1(b)\n\n    def readline(self, *args):\n        return self._file.readline(*args)\n\n    def readlines(self, *args):\n        return self._file.readlines(*args)\n\n    def seekable(self):\n        return self._file.seekable()\n\n    def seek(self, *args):\n        return self._file.seek(*args)\n\n    def tell(self):\n        return self._file.tell()\n\n    def truncate(self, size=None):\n        if size is None:\n            return self._file.truncate()\n        else:\n            if size > self._max_size:\n                self.rollover()\n            return self._file.truncate(size)\n\n    def writable(self):\n        return self._file.writable()\n\n    def write(self, s):\n        file = self._file\n        rv = file.write(s)\n        self._check(file)\n        return rv\n\n    def writelines(self, iterable):\n        file = self._file\n        rv = file.writelines(iterable)\n        self._check(file)\n        return rv\n\n    def detach(self):\n        return self._file.detach()\n\n\nclass TemporaryDirectory:\n    \"\"\"Create and return a temporary directory.  This has the same\n    behavior as mkdtemp but can be used as a context manager.  For\n    example:\n\n        with TemporaryDirectory() as tmpdir:\n            ...\n\n    Upon exiting the context, the directory and everything contained\n    in it are removed (unless delete=False is passed or an exception\n    is raised during cleanup and ignore_cleanup_errors is not True).\n\n    Optional Arguments:\n        suffix - A str suffix for the directory name.  (see mkdtemp)\n        prefix - A str prefix for the directory name.  (see mkdtemp)\n        dir - A directory to create this temp dir in.  (see mkdtemp)\n        ignore_cleanup_errors - False; ignore exceptions during cleanup?\n        delete - True; whether the directory is automatically deleted.\n    \"\"\"\n\n    def __init__(self, suffix=None, prefix=None, dir=None,\n                 ignore_cleanup_errors=False, *, delete=True):\n        self.name = mkdtemp(suffix, prefix, dir)\n        self._ignore_cleanup_errors = ignore_cleanup_errors\n        self._delete = delete\n        self._finalizer = _weakref.finalize(\n            self, self._cleanup, self.name,\n            warn_message=\"Implicitly cleaning up {!r}\".format(self),\n            ignore_errors=self._ignore_cleanup_errors, delete=self._delete)\n\n    @classmethod\n    def _rmtree(cls, name, ignore_errors=False, repeated=False):\n        def onexc(func, path, exc):\n            if isinstance(exc, PermissionError):\n                if repeated and path == name:\n                    if ignore_errors:\n                        return\n                    raise\n\n                try:\n                    if path != name:\n                        _resetperms(_os.path.dirname(path))\n                    _resetperms(path)\n\n                    try:\n                        _os.unlink(path)\n                    except IsADirectoryError:\n                        cls._rmtree(path, ignore_errors=ignore_errors)\n                    except PermissionError:\n                        # The PermissionError handler was originally added for\n                        # FreeBSD in directories, but it seems that it is raised\n                        # on Windows too.\n                        # bpo-43153: Calling _rmtree again may\n                        # raise NotADirectoryError and mask the PermissionError.\n                        # So we must re-raise the current PermissionError if\n                        # path is not a directory.\n                        if not _os.path.isdir(path) or _os.path.isjunction(path):\n                            if ignore_errors:\n                                return\n                            raise\n                        cls._rmtree(path, ignore_errors=ignore_errors,\n                                    repeated=(path == name))\n                except FileNotFoundError:\n                    pass\n            elif isinstance(exc, FileNotFoundError):\n                pass\n            else:\n                if not ignore_errors:\n                    raise\n\n        _shutil.rmtree(name, onexc=onexc)\n\n    @classmethod\n    def _cleanup(cls, name, warn_message, ignore_errors=False, delete=True):\n        if delete:\n            cls._rmtree(name, ignore_errors=ignore_errors)\n            _warnings.warn(warn_message, ResourceWarning)\n\n    def __repr__(self):\n        return \"<{} {!r}>\".format(self.__class__.__name__, self.name)\n\n    def __enter__(self):\n        return self.name\n\n    def __exit__(self, exc, value, tb):\n        if self._delete:\n            self.cleanup()\n\n    def cleanup(self):\n        if self._finalizer.detach() or _os.path.exists(self.name):\n            self._rmtree(self.name, ignore_errors=self._ignore_cleanup_errors)\n\n    __class_getitem__ = classmethod(_types.GenericAlias)\n", 952], "C:\\Programming\\Python313\\Lib\\random.py": ["\"\"\"Random variable generators.\n\n    bytes\n    -----\n           uniform bytes (values between 0 and 255)\n\n    integers\n    --------\n           uniform within range\n\n    sequences\n    ---------\n           pick random element\n           pick random sample\n           pick weighted random sample\n           generate random permutation\n\n    distributions on the real line:\n    ------------------------------\n           uniform\n           triangular\n           normal (Gaussian)\n           lognormal\n           negative exponential\n           gamma\n           beta\n           pareto\n           Weibull\n\n    distributions on the circle (angles 0 to 2pi)\n    ---------------------------------------------\n           circular uniform\n           von Mises\n\n    discrete distributions\n    ----------------------\n           binomial\n\n\nGeneral notes on the underlying Mersenne Twister core generator:\n\n* The period is 2**19937-1.\n* It is one of the most extensively tested generators in existence.\n* The random() method is implemented in C, executes in a single Python step,\n  and is, therefore, threadsafe.\n\n\"\"\"\n\n# Translated by Guido van Rossum from C source provided by\n# Adrian Baddeley.  Adapted by Raymond Hettinger for use with\n# the Mersenne Twister  and os.urandom() core generators.\n\nfrom math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil\nfrom math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin\nfrom math import tau as TWOPI, floor as _floor, isfinite as _isfinite\nfrom math import lgamma as _lgamma, fabs as _fabs, log2 as _log2\nfrom os import urandom as _urandom\nfrom _collections_abc import Sequence as _Sequence\nfrom operator import index as _index\nfrom itertools import accumulate as _accumulate, repeat as _repeat\nfrom bisect import bisect as _bisect\nimport os as _os\nimport _random\n\n__all__ = [\n    \"Random\",\n    \"SystemRandom\",\n    \"betavariate\",\n    \"binomialvariate\",\n    \"choice\",\n    \"choices\",\n    \"expovariate\",\n    \"gammavariate\",\n    \"gauss\",\n    \"getrandbits\",\n    \"getstate\",\n    \"lognormvariate\",\n    \"normalvariate\",\n    \"paretovariate\",\n    \"randbytes\",\n    \"randint\",\n    \"random\",\n    \"randrange\",\n    \"sample\",\n    \"seed\",\n    \"setstate\",\n    \"shuffle\",\n    \"triangular\",\n    \"uniform\",\n    \"vonmisesvariate\",\n    \"weibullvariate\",\n]\n\nNV_MAGICCONST = 4 * _exp(-0.5) / _sqrt(2.0)\nLOG4 = _log(4.0)\nSG_MAGICCONST = 1.0 + _log(4.5)\nBPF = 53        # Number of bits in a float\nRECIP_BPF = 2 ** -BPF\n_ONE = 1\n_sha512 = None\n\n\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n\n    Used to instantiate instances of Random to get generators that don't\n    share state.\n\n    Class Random can also be subclassed if you want to use a different basic\n    generator of your own devising: in that case, override the following\n    methods:  random(), seed(), getstate(), and setstate().\n    Optionally, implement a getrandbits() method so that randrange()\n    can cover arbitrarily large ranges.\n\n    \"\"\"\n\n    VERSION = 3     # used by getstate/setstate\n\n    def __init__(self, x=None):\n        \"\"\"Initialize an instance.\n\n        Optional argument x controls seeding, as for Random.seed().\n        \"\"\"\n\n        self.seed(x)\n        self.gauss_next = None\n\n    def seed(self, a=None, version=2):\n        \"\"\"Initialize internal state from a seed.\n\n        The only supported seed types are None, int, float,\n        str, bytes, and bytearray.\n\n        None or no argument seeds from current time or from an operating\n        system specific randomness source if available.\n\n        If *a* is an int, all bits are used.\n\n        For version 2 (the default), all of the bits are used if *a* is a str,\n        bytes, or bytearray.  For version 1 (provided for reproducing random\n        sequences from older versions of Python), the algorithm for str and\n        bytes generates a narrower range of seeds.\n\n        \"\"\"\n\n        if version == 1 and isinstance(a, (str, bytes)):\n            a = a.decode('latin-1') if isinstance(a, bytes) else a\n            x = ord(a[0]) << 7 if a else 0\n            for c in map(ord, a):\n                x = ((1000003 * x) ^ c) & 0xFFFFFFFFFFFFFFFF\n            x ^= len(a)\n            a = -2 if x == -1 else x\n\n        elif version == 2 and isinstance(a, (str, bytes, bytearray)):\n            global _sha512\n            if _sha512 is None:\n                try:\n                    # hashlib is pretty heavy to load, try lean internal\n                    # module first\n                    from _sha2 import sha512 as _sha512\n                except ImportError:\n                    # fallback to official implementation\n                    from hashlib import sha512 as _sha512\n\n            if isinstance(a, str):\n                a = a.encode()\n            a = int.from_bytes(a + _sha512(a).digest())\n\n        elif not isinstance(a, (type(None), int, float, str, bytes, bytearray)):\n            raise TypeError('The only supported seed types are:\\n'\n                            'None, int, float, str, bytes, and bytearray.')\n\n        super().seed(a)\n        self.gauss_next = None\n\n    def getstate(self):\n        \"\"\"Return internal state; can be passed to setstate() later.\"\"\"\n        return self.VERSION, super().getstate(), self.gauss_next\n\n    def setstate(self, state):\n        \"\"\"Restore internal state from object returned by getstate().\"\"\"\n        version = state[0]\n        if version == 3:\n            version, internalstate, self.gauss_next = state\n            super().setstate(internalstate)\n        elif version == 2:\n            version, internalstate, self.gauss_next = state\n            # In version 2, the state was saved as signed ints, which causes\n            #   inconsistencies between 32/64-bit systems. The state is\n            #   really unsigned 32-bit ints, so we convert negative ints from\n            #   version 2 to positive longs for version 3.\n            try:\n                internalstate = tuple(x % (2 ** 32) for x in internalstate)\n            except ValueError as e:\n                raise TypeError from e\n            super().setstate(internalstate)\n        else:\n            raise ValueError(\"state with version %s passed to \"\n                             \"Random.setstate() of version %s\" %\n                             (version, self.VERSION))\n\n\n    ## -------------------------------------------------------\n    ## ---- Methods below this point do not need to be overridden or extended\n    ## ---- when subclassing for the purpose of using a different core generator.\n\n\n    ## -------------------- pickle support  -------------------\n\n    # Issue 17489: Since __reduce__ was defined to fix #759889 this is no\n    # longer called; we leave it here because it has been here since random was\n    # rewritten back in 2001 and why risk breaking something.\n    def __getstate__(self):  # for pickle\n        return self.getstate()\n\n    def __setstate__(self, state):  # for pickle\n        self.setstate(state)\n\n    def __reduce__(self):\n        return self.__class__, (), self.getstate()\n\n\n    ## ---- internal support method for evenly distributed integers ----\n\n    def __init_subclass__(cls, /, **kwargs):\n        \"\"\"Control how subclasses generate random integers.\n\n        The algorithm a subclass can use depends on the random() and/or\n        getrandbits() implementation available to it and determines\n        whether it can generate random integers from arbitrarily large\n        ranges.\n        \"\"\"\n\n        for c in cls.__mro__:\n            if '_randbelow' in c.__dict__:\n                # just inherit it\n                break\n            if 'getrandbits' in c.__dict__:\n                cls._randbelow = cls._randbelow_with_getrandbits\n                break\n            if 'random' in c.__dict__:\n                cls._randbelow = cls._randbelow_without_getrandbits\n                break\n\n    def _randbelow_with_getrandbits(self, n):\n        \"Return a random int in the range [0,n).  Defined for n > 0.\"\n\n        getrandbits = self.getrandbits\n        k = n.bit_length()\n        r = getrandbits(k)  # 0 <= r < 2**k\n        while r >= n:\n            r = getrandbits(k)\n        return r\n\n    def _randbelow_without_getrandbits(self, n, maxsize=1<<BPF):\n        \"\"\"Return a random int in the range [0,n).  Defined for n > 0.\n\n        The implementation does not use getrandbits, but only random.\n        \"\"\"\n\n        random = self.random\n        if n >= maxsize:\n            from warnings import warn\n            warn(\"Underlying random() generator does not supply \\n\"\n                 \"enough bits to choose from a population range this large.\\n\"\n                 \"To remove the range limitation, add a getrandbits() method.\")\n            return _floor(random() * n)\n        rem = maxsize % n\n        limit = (maxsize - rem) / maxsize   # int(limit * maxsize) % n == 0\n        r = random()\n        while r >= limit:\n            r = random()\n        return _floor(r * maxsize) % n\n\n    _randbelow = _randbelow_with_getrandbits\n\n\n    ## --------------------------------------------------------\n    ## ---- Methods below this point generate custom distributions\n    ## ---- based on the methods defined above.  They do not\n    ## ---- directly touch the underlying generator and only\n    ## ---- access randomness through the methods:  random(),\n    ## ---- getrandbits(), or _randbelow().\n\n\n    ## -------------------- bytes methods ---------------------\n\n    def randbytes(self, n):\n        \"\"\"Generate n random bytes.\"\"\"\n        return self.getrandbits(n * 8).to_bytes(n, 'little')\n\n\n    ## -------------------- integer methods  -------------------\n\n    def randrange(self, start, stop=None, step=_ONE):\n        \"\"\"Choose a random item from range(stop) or range(start, stop[, step]).\n\n        Roughly equivalent to ``choice(range(start, stop, step))`` but\n        supports arbitrarily large ranges and is optimized for common cases.\n\n        \"\"\"\n\n        # This code is a bit messy to make it fast for the\n        # common case while still doing adequate error checking.\n        istart = _index(start)\n        if stop is None:\n            # We don't check for \"step != 1\" because it hasn't been\n            # type checked and converted to an integer yet.\n            if step is not _ONE:\n                raise TypeError(\"Missing a non-None stop argument\")\n            if istart > 0:\n                return self._randbelow(istart)\n            raise ValueError(\"empty range for randrange()\")\n\n        # Stop argument supplied.\n        istop = _index(stop)\n        width = istop - istart\n        istep = _index(step)\n        # Fast path.\n        if istep == 1:\n            if width > 0:\n                return istart + self._randbelow(width)\n            raise ValueError(f\"empty range in randrange({start}, {stop})\")\n\n        # Non-unit step argument supplied.\n        if istep > 0:\n            n = (width + istep - 1) // istep\n        elif istep < 0:\n            n = (width + istep + 1) // istep\n        else:\n            raise ValueError(\"zero step for randrange()\")\n        if n <= 0:\n            raise ValueError(f\"empty range in randrange({start}, {stop}, {step})\")\n        return istart + istep * self._randbelow(n)\n\n    def randint(self, a, b):\n        \"\"\"Return random integer in range [a, b], including both end points.\n        \"\"\"\n\n        return self.randrange(a, b+1)\n\n\n    ## -------------------- sequence methods  -------------------\n\n    def choice(self, seq):\n        \"\"\"Choose a random element from a non-empty sequence.\"\"\"\n\n        # As an accommodation for NumPy, we don't use \"if not seq\"\n        # because bool(numpy.array()) raises a ValueError.\n        if not len(seq):\n            raise IndexError('Cannot choose from an empty sequence')\n        return seq[self._randbelow(len(seq))]\n\n    def shuffle(self, x):\n        \"\"\"Shuffle list x in place, and return None.\"\"\"\n\n        randbelow = self._randbelow\n        for i in reversed(range(1, len(x))):\n            # pick an element in x[:i+1] with which to exchange x[i]\n            j = randbelow(i + 1)\n            x[i], x[j] = x[j], x[i]\n\n    def sample(self, population, k, *, counts=None):\n        \"\"\"Chooses k unique random elements from a population sequence.\n\n        Returns a new list containing elements from the population while\n        leaving the original population unchanged.  The resulting list is\n        in selection order so that all sub-slices will also be valid random\n        samples.  This allows raffle winners (the sample) to be partitioned\n        into grand prize and second place winners (the subslices).\n\n        Members of the population need not be hashable or unique.  If the\n        population contains repeats, then each occurrence is a possible\n        selection in the sample.\n\n        Repeated elements can be specified one at a time or with the optional\n        counts parameter.  For example:\n\n            sample(['red', 'blue'], counts=[4, 2], k=5)\n\n        is equivalent to:\n\n            sample(['red', 'red', 'red', 'red', 'blue', 'blue'], k=5)\n\n        To choose a sample from a range of integers, use range() for the\n        population argument.  This is especially fast and space efficient\n        for sampling from a large population:\n\n            sample(range(10000000), 60)\n\n        \"\"\"\n\n        # Sampling without replacement entails tracking either potential\n        # selections (the pool) in a list or previous selections in a set.\n\n        # When the number of selections is small compared to the\n        # population, then tracking selections is efficient, requiring\n        # only a small set and an occasional reselection.  For\n        # a larger number of selections, the pool tracking method is\n        # preferred since the list takes less space than the\n        # set and it doesn't suffer from frequent reselections.\n\n        # The number of calls to _randbelow() is kept at or near k, the\n        # theoretical minimum.  This is important because running time\n        # is dominated by _randbelow() and because it extracts the\n        # least entropy from the underlying random number generators.\n\n        # Memory requirements are kept to the smaller of a k-length\n        # set or an n-length list.\n\n        # There are other sampling algorithms that do not require\n        # auxiliary memory, but they were rejected because they made\n        # too many calls to _randbelow(), making them slower and\n        # causing them to eat more entropy than necessary.\n\n        if not isinstance(population, _Sequence):\n            raise TypeError(\"Population must be a sequence.  \"\n                            \"For dicts or sets, use sorted(d).\")\n        n = len(population)\n        if counts is not None:\n            cum_counts = list(_accumulate(counts))\n            if len(cum_counts) != n:\n                raise ValueError('The number of counts does not match the population')\n            total = cum_counts.pop()\n            if not isinstance(total, int):\n                raise TypeError('Counts must be integers')\n            if total <= 0:\n                raise ValueError('Total of counts must be greater than zero')\n            selections = self.sample(range(total), k=k)\n            bisect = _bisect\n            return [population[bisect(cum_counts, s)] for s in selections]\n        randbelow = self._randbelow\n        if not 0 <= k <= n:\n            raise ValueError(\"Sample larger than population or is negative\")\n        result = [None] * k\n        setsize = 21        # size of a small set minus size of an empty list\n        if k > 5:\n            setsize += 4 ** _ceil(_log(k * 3, 4))  # table size for big sets\n        if n <= setsize:\n            # An n-length list is smaller than a k-length set.\n            # Invariant:  non-selected at pool[0 : n-i]\n            pool = list(population)\n            for i in range(k):\n                j = randbelow(n - i)\n                result[i] = pool[j]\n                pool[j] = pool[n - i - 1]  # move non-selected item into vacancy\n        else:\n            selected = set()\n            selected_add = selected.add\n            for i in range(k):\n                j = randbelow(n)\n                while j in selected:\n                    j = randbelow(n)\n                selected_add(j)\n                result[i] = population[j]\n        return result\n\n    def choices(self, population, weights=None, *, cum_weights=None, k=1):\n        \"\"\"Return a k sized list of population elements chosen with replacement.\n\n        If the relative weights or cumulative weights are not specified,\n        the selections are made with equal probability.\n\n        \"\"\"\n        random = self.random\n        n = len(population)\n        if cum_weights is None:\n            if weights is None:\n                floor = _floor\n                n += 0.0    # convert to float for a small speed improvement\n                return [population[floor(random() * n)] for i in _repeat(None, k)]\n            try:\n                cum_weights = list(_accumulate(weights))\n            except TypeError:\n                if not isinstance(weights, int):\n                    raise\n                k = weights\n                raise TypeError(\n                    f'The number of choices must be a keyword argument: {k=}'\n                ) from None\n        elif weights is not None:\n            raise TypeError('Cannot specify both weights and cumulative weights')\n        if len(cum_weights) != n:\n            raise ValueError('The number of weights does not match the population')\n        total = cum_weights[-1] + 0.0   # convert to float\n        if total <= 0.0:\n            raise ValueError('Total of weights must be greater than zero')\n        if not _isfinite(total):\n            raise ValueError('Total of weights must be finite')\n        bisect = _bisect\n        hi = n - 1\n        return [population[bisect(cum_weights, random() * total, 0, hi)]\n                for i in _repeat(None, k)]\n\n\n    ## -------------------- real-valued distributions  -------------------\n\n    def uniform(self, a, b):\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        The mean (expected value) and variance of the random variable are:\n\n            E[X] = (a + b) / 2\n            Var[X] = (b - a) ** 2 / 12\n\n        \"\"\"\n        return a + (b - a) * self.random()\n\n    def triangular(self, low=0.0, high=1.0, mode=None):\n        \"\"\"Triangular distribution.\n\n        Continuous distribution bounded by given lower and upper limits,\n        and having a given mode value in-between.\n\n        http://en.wikipedia.org/wiki/Triangular_distribution\n\n        The mean (expected value) and variance of the random variable are:\n\n            E[X] = (low + high + mode) / 3\n            Var[X] = (low**2 + high**2 + mode**2 - low*high - low*mode - high*mode) / 18\n\n        \"\"\"\n        u = self.random()\n        try:\n            c = 0.5 if mode is None else (mode - low) / (high - low)\n        except ZeroDivisionError:\n            return low\n        if u > c:\n            u = 1.0 - u\n            c = 1.0 - c\n            low, high = high, low\n        return low + (high - low) * _sqrt(u * c)\n\n    def normalvariate(self, mu=0.0, sigma=1.0):\n        \"\"\"Normal distribution.\n\n        mu is the mean, and sigma is the standard deviation.\n\n        \"\"\"\n        # Uses Kinderman and Monahan method. Reference: Kinderman,\n        # A.J. and Monahan, J.F., \"Computer generation of random\n        # variables using the ratio of uniform deviates\", ACM Trans\n        # Math Software, 3, (1977), pp257-260.\n\n        random = self.random\n        while True:\n            u1 = random()\n            u2 = 1.0 - random()\n            z = NV_MAGICCONST * (u1 - 0.5) / u2\n            zz = z * z / 4.0\n            if zz <= -_log(u2):\n                break\n        return mu + z * sigma\n\n    def gauss(self, mu=0.0, sigma=1.0):\n        \"\"\"Gaussian distribution.\n\n        mu is the mean, and sigma is the standard deviation.  This is\n        slightly faster than the normalvariate() function.\n\n        Not thread-safe without a lock around calls.\n\n        \"\"\"\n        # When x and y are two variables from [0, 1), uniformly\n        # distributed, then\n        #\n        #    cos(2*pi*x)*sqrt(-2*log(1-y))\n        #    sin(2*pi*x)*sqrt(-2*log(1-y))\n        #\n        # are two *independent* variables with normal distribution\n        # (mu = 0, sigma = 1).\n        # (Lambert Meertens)\n        # (corrected version; bug discovered by Mike Miller, fixed by LM)\n\n        # Multithreading note: When two threads call this function\n        # simultaneously, it is possible that they will receive the\n        # same return value.  The window is very small though.  To\n        # avoid this, you have to use a lock around all calls.  (I\n        # didn't want to slow this down in the serial case by using a\n        # lock here.)\n\n        random = self.random\n        z = self.gauss_next\n        self.gauss_next = None\n        if z is None:\n            x2pi = random() * TWOPI\n            g2rad = _sqrt(-2.0 * _log(1.0 - random()))\n            z = _cos(x2pi) * g2rad\n            self.gauss_next = _sin(x2pi) * g2rad\n\n        return mu + z * sigma\n\n    def lognormvariate(self, mu, sigma):\n        \"\"\"Log normal distribution.\n\n        If you take the natural logarithm of this distribution, you'll get a\n        normal distribution with mean mu and standard deviation sigma.\n        mu can have any value, and sigma must be greater than zero.\n\n        \"\"\"\n        return _exp(self.normalvariate(mu, sigma))\n\n    def expovariate(self, lambd=1.0):\n        \"\"\"Exponential distribution.\n\n        lambd is 1.0 divided by the desired mean.  It should be\n        nonzero.  (The parameter would be called \"lambda\", but that is\n        a reserved word in Python.)  Returned values range from 0 to\n        positive infinity if lambd is positive, and from negative\n        infinity to 0 if lambd is negative.\n\n        The mean (expected value) and variance of the random variable are:\n\n            E[X] = 1 / lambd\n            Var[X] = 1 / lambd ** 2\n\n        \"\"\"\n        # we use 1-random() instead of random() to preclude the\n        # possibility of taking the log of zero.\n\n        return -_log(1.0 - self.random()) / lambd\n\n    def vonmisesvariate(self, mu, kappa):\n        \"\"\"Circular data distribution.\n\n        mu is the mean angle, expressed in radians between 0 and 2*pi, and\n        kappa is the concentration parameter, which must be greater than or\n        equal to zero.  If kappa is equal to zero, this distribution reduces\n        to a uniform random angle over the range 0 to 2*pi.\n\n        \"\"\"\n        # Based upon an algorithm published in: Fisher, N.I.,\n        # \"Statistical Analysis of Circular Data\", Cambridge\n        # University Press, 1993.\n\n        # Thanks to Magnus Kessler for a correction to the\n        # implementation of step 4.\n\n        random = self.random\n        if kappa <= 1e-6:\n            return TWOPI * random()\n\n        s = 0.5 / kappa\n        r = s + _sqrt(1.0 + s * s)\n\n        while True:\n            u1 = random()\n            z = _cos(_pi * u1)\n\n            d = z / (r + z)\n            u2 = random()\n            if u2 < 1.0 - d * d or u2 <= (1.0 - d) * _exp(d):\n                break\n\n        q = 1.0 / r\n        f = (q + z) / (1.0 + q * z)\n        u3 = random()\n        if u3 > 0.5:\n            theta = (mu + _acos(f)) % TWOPI\n        else:\n            theta = (mu - _acos(f)) % TWOPI\n\n        return theta\n\n    def gammavariate(self, alpha, beta):\n        \"\"\"Gamma distribution.  Not the gamma function!\n\n        Conditions on the parameters are alpha > 0 and beta > 0.\n\n        The probability distribution function is:\n\n                    x ** (alpha - 1) * math.exp(-x / beta)\n          pdf(x) =  --------------------------------------\n                      math.gamma(alpha) * beta ** alpha\n\n        The mean (expected value) and variance of the random variable are:\n\n            E[X] = alpha * beta\n            Var[X] = alpha * beta ** 2\n\n        \"\"\"\n\n        # Warning: a few older sources define the gamma distribution in terms\n        # of alpha > -1.0\n        if alpha <= 0.0 or beta <= 0.0:\n            raise ValueError('gammavariate: alpha and beta must be > 0.0')\n\n        random = self.random\n        if alpha > 1.0:\n\n            # Uses R.C.H. Cheng, \"The generation of Gamma\n            # variables with non-integral shape parameters\",\n            # Applied Statistics, (1977), 26, No. 1, p71-74\n\n            ainv = _sqrt(2.0 * alpha - 1.0)\n            bbb = alpha - LOG4\n            ccc = alpha + ainv\n\n            while True:\n                u1 = random()\n                if not 1e-7 < u1 < 0.9999999:\n                    continue\n                u2 = 1.0 - random()\n                v = _log(u1 / (1.0 - u1)) / ainv\n                x = alpha * _exp(v)\n                z = u1 * u1 * u2\n                r = bbb + ccc * v - x\n                if r + SG_MAGICCONST - 4.5 * z >= 0.0 or r >= _log(z):\n                    return x * beta\n\n        elif alpha == 1.0:\n            # expovariate(1/beta)\n            return -_log(1.0 - random()) * beta\n\n        else:\n            # alpha is between 0 and 1 (exclusive)\n            # Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle\n            while True:\n                u = random()\n                b = (_e + alpha) / _e\n                p = b * u\n                if p <= 1.0:\n                    x = p ** (1.0 / alpha)\n                else:\n                    x = -_log((b - p) / alpha)\n                u1 = random()\n                if p > 1.0:\n                    if u1 <= x ** (alpha - 1.0):\n                        break\n                elif u1 <= _exp(-x):\n                    break\n            return x * beta\n\n    def betavariate(self, alpha, beta):\n        \"\"\"Beta distribution.\n\n        Conditions on the parameters are alpha > 0 and beta > 0.\n        Returned values range between 0 and 1.\n\n        The mean (expected value) and variance of the random variable are:\n\n            E[X] = alpha / (alpha + beta)\n            Var[X] = alpha * beta / ((alpha + beta)**2 * (alpha + beta + 1))\n\n        \"\"\"\n        ## See\n        ## http://mail.python.org/pipermail/python-bugs-list/2001-January/003752.html\n        ## for Ivan Frohne's insightful analysis of why the original implementation:\n        ##\n        ##    def betavariate(self, alpha, beta):\n        ##        # Discrete Event Simulation in C, pp 87-88.\n        ##\n        ##        y = self.expovariate(alpha)\n        ##        z = self.expovariate(1.0/beta)\n        ##        return z/(y+z)\n        ##\n        ## was dead wrong, and how it probably got that way.\n\n        # This version due to Janne Sinkkonen, and matches all the std\n        # texts (e.g., Knuth Vol 2 Ed 3 pg 134 \"the beta distribution\").\n        y = self.gammavariate(alpha, 1.0)\n        if y:\n            return y / (y + self.gammavariate(beta, 1.0))\n        return 0.0\n\n    def paretovariate(self, alpha):\n        \"\"\"Pareto distribution.  alpha is the shape parameter.\"\"\"\n        # Jain, pg. 495\n\n        u = 1.0 - self.random()\n        return u ** (-1.0 / alpha)\n\n    def weibullvariate(self, alpha, beta):\n        \"\"\"Weibull distribution.\n\n        alpha is the scale parameter and beta is the shape parameter.\n\n        \"\"\"\n        # Jain, pg. 499; bug fix courtesy Bill Arms\n\n        u = 1.0 - self.random()\n        return alpha * (-_log(u)) ** (1.0 / beta)\n\n\n    ## -------------------- discrete  distributions  ---------------------\n\n    def binomialvariate(self, n=1, p=0.5):\n        \"\"\"Binomial random variable.\n\n        Gives the number of successes for *n* independent trials\n        with the probability of success in each trial being *p*:\n\n            sum(random() < p for i in range(n))\n\n        Returns an integer in the range:   0 <= X <= n\n\n        The mean (expected value) and variance of the random variable are:\n\n            E[X] = n * p\n            Var[x] = n * p * (1 - p)\n\n        \"\"\"\n        # Error check inputs and handle edge cases\n        if n < 0:\n            raise ValueError(\"n must be non-negative\")\n        if p <= 0.0 or p >= 1.0:\n            if p == 0.0:\n                return 0\n            if p == 1.0:\n                return n\n            raise ValueError(\"p must be in the range 0.0 <= p <= 1.0\")\n\n        random = self.random\n\n        # Fast path for a common case\n        if n == 1:\n            return _index(random() < p)\n\n        # Exploit symmetry to establish:  p <= 0.5\n        if p > 0.5:\n            return n - self.binomialvariate(n, 1.0 - p)\n\n        if n * p < 10.0:\n            # BG: Geometric method by Devroye with running time of O(np).\n            # https://dl.acm.org/doi/pdf/10.1145/42372.42381\n            x = y = 0\n            c = _log2(1.0 - p)\n            if not c:\n                return x\n            while True:\n                y += _floor(_log2(random()) / c) + 1\n                if y > n:\n                    return x\n                x += 1\n\n        # BTRS: Transformed rejection with squeeze method by Wolfgang H\u00f6rmann\n        # https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.47.8407&rep=rep1&type=pdf\n        assert n*p >= 10.0 and p <= 0.5\n        setup_complete = False\n\n        spq = _sqrt(n * p * (1.0 - p))  # Standard deviation of the distribution\n        b = 1.15 + 2.53 * spq\n        a = -0.0873 + 0.0248 * b + 0.01 * p\n        c = n * p + 0.5\n        vr = 0.92 - 4.2 / b\n\n        while True:\n\n            u = random()\n            u -= 0.5\n            us = 0.5 - _fabs(u)\n            k = _floor((2.0 * a / us + b) * u + c)\n            if k < 0 or k > n:\n                continue\n\n            # The early-out \"squeeze\" test substantially reduces\n            # the number of acceptance condition evaluations.\n            v = random()\n            if us >= 0.07 and v <= vr:\n                return k\n\n            # Acceptance-rejection test.\n            # Note, the original paper erroneously omits the call to log(v)\n            # when comparing to the log of the rescaled binomial distribution.\n            if not setup_complete:\n                alpha = (2.83 + 5.1 / b) * spq\n                lpq = _log(p / (1.0 - p))\n                m = _floor((n + 1) * p)         # Mode of the distribution\n                h = _lgamma(m + 1) + _lgamma(n - m + 1)\n                setup_complete = True           # Only needs to be done once\n            v *= alpha / (a / (us * us) + b)\n            if _log(v) <= h - _lgamma(k + 1) - _lgamma(n - k + 1) + (k - m) * lpq:\n                return k\n\n\n## ------------------------------------------------------------------\n## --------------- Operating System Random Source  ------------------\n\n\nclass SystemRandom(Random):\n    \"\"\"Alternate random number generator using sources provided\n    by the operating system (such as /dev/urandom on Unix or\n    CryptGenRandom on Windows).\n\n     Not available on all systems (see os.urandom() for details).\n\n    \"\"\"\n\n    def random(self):\n        \"\"\"Get the next random number in the range 0.0 <= X < 1.0.\"\"\"\n        return (int.from_bytes(_urandom(7)) >> 3) * RECIP_BPF\n\n    def getrandbits(self, k):\n        \"\"\"getrandbits(k) -> x.  Generates an int with k random bits.\"\"\"\n        if k < 0:\n            raise ValueError('number of bits must be non-negative')\n        numbytes = (k + 7) // 8                       # bits / 8 and rounded up\n        x = int.from_bytes(_urandom(numbytes))\n        return x >> (numbytes * 8 - k)                # trim excess bits\n\n    def randbytes(self, n):\n        \"\"\"Generate n random bytes.\"\"\"\n        # os.urandom(n) fails with ValueError for n < 0\n        # and returns an empty bytes string for n == 0.\n        return _urandom(n)\n\n    def seed(self, *args, **kwds):\n        \"Stub method.  Not used for a system random number generator.\"\n        return None\n\n    def _notimplemented(self, *args, **kwds):\n        \"Method should not be called for a system random number generator.\"\n        raise NotImplementedError('System entropy source does not have state.')\n    getstate = setstate = _notimplemented\n\n\n# ----------------------------------------------------------------------\n# Create one instance, seeded from current time, and export its methods\n# as module-level functions.  The functions share state across all uses\n# (both in the user's code and in the Python libraries), but that's fine\n# for most programs and is easier for the casual user than making them\n# instantiate their own Random() instance.\n\n_inst = Random()\nseed = _inst.seed\nrandom = _inst.random\nuniform = _inst.uniform\ntriangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n\n\n## ------------------------------------------------------\n## ----------------- test program -----------------------\n\ndef _test_generator(n, func, args):\n    from statistics import stdev, fmean as mean\n    from time import perf_counter\n\n    t0 = perf_counter()\n    data = [func(*args) for i in _repeat(None, n)]\n    t1 = perf_counter()\n\n    xbar = mean(data)\n    sigma = stdev(data, xbar)\n    low = min(data)\n    high = max(data)\n\n    print(f'{t1 - t0:.3f} sec, {n} times {func.__name__}{args!r}')\n    print('avg %g, stddev %g, min %g, max %g\\n' % (xbar, sigma, low, high))\n\n\ndef _test(N=10_000):\n    _test_generator(N, random, ())\n    _test_generator(N, normalvariate, (0.0, 1.0))\n    _test_generator(N, lognormvariate, (0.0, 1.0))\n    _test_generator(N, vonmisesvariate, (0.0, 1.0))\n    _test_generator(N, binomialvariate, (15, 0.60))\n    _test_generator(N, binomialvariate, (100, 0.75))\n    _test_generator(N, gammavariate, (0.01, 1.0))\n    _test_generator(N, gammavariate, (0.1, 1.0))\n    _test_generator(N, gammavariate, (0.1, 2.0))\n    _test_generator(N, gammavariate, (0.5, 1.0))\n    _test_generator(N, gammavariate, (0.9, 1.0))\n    _test_generator(N, gammavariate, (1.0, 1.0))\n    _test_generator(N, gammavariate, (2.0, 1.0))\n    _test_generator(N, gammavariate, (20.0, 1.0))\n    _test_generator(N, gammavariate, (200.0, 1.0))\n    _test_generator(N, gauss, (0.0, 1.0))\n    _test_generator(N, betavariate, (3.0, 3.0))\n    _test_generator(N, triangular, (0.0, 1.0, 1.0 / 3.0))\n\n\n## ------------------------------------------------------\n## ------------------ fork support  ---------------------\n\nif hasattr(_os, \"fork\"):\n    _os.register_at_fork(after_in_child=_inst.seed)\n\n\n# ------------------------------------------------------\n# -------------- command-line interface ----------------\n\n\ndef _parse_args(arg_list: list[str] | None):\n    import argparse\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawTextHelpFormatter)\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"-c\", \"--choice\", nargs=\"+\",\n        help=\"print a random choice\")\n    group.add_argument(\n        \"-i\", \"--integer\", type=int, metavar=\"N\",\n        help=\"print a random integer between 1 and N inclusive\")\n    group.add_argument(\n        \"-f\", \"--float\", type=float, metavar=\"N\",\n        help=\"print a random floating-point number between 0 and N inclusive\")\n    group.add_argument(\n        \"--test\", type=int, const=10_000, nargs=\"?\",\n        help=argparse.SUPPRESS)\n    parser.add_argument(\"input\", nargs=\"*\",\n                        help=\"\"\"\\\nif no options given, output depends on the input\n    string or multiple: same as --choice\n    integer: same as --integer\n    float: same as --float\"\"\")\n    args = parser.parse_args(arg_list)\n    return args, parser.format_help()\n\n\ndef main(arg_list: list[str] | None = None) -> int | str:\n    args, help_text = _parse_args(arg_list)\n\n    # Explicit arguments\n    if args.choice:\n        return choice(args.choice)\n\n    if args.integer is not None:\n        return randint(1, args.integer)\n\n    if args.float is not None:\n        return uniform(0, args.float)\n\n    if args.test:\n        _test(args.test)\n        return \"\"\n\n    # No explicit argument, select based on input\n    if len(args.input) == 1:\n        val = args.input[0]\n        try:\n            # Is it an integer?\n            val = int(val)\n            return randint(1, val)\n        except ValueError:\n            try:\n                # Is it a float?\n                val = float(val)\n                return uniform(0, val)\n            except ValueError:\n                # Split in case of space-separated string: \"a b c\"\n                return choice(val.split())\n\n    if len(args.input) >= 2:\n        return choice(args.input)\n\n    return help_text\n\n\nif __name__ == '__main__':\n    print(main())\n", 1070], "C:\\Programming\\Python313\\Lib\\ntpath.py": ["# Module 'ntpath' -- common operations on WinNT/Win95 pathnames\n\"\"\"Common pathname manipulations, WindowsNT/95 version.\n\nInstead of importing this module directly, import os and refer to this\nmodule as os.path.\n\"\"\"\n\n# strings representing various path-related bits and pieces\n# These are primarily for export; internally, they are hardcoded.\n# Should be set before imports for resolving cyclic dependency.\ncurdir = '.'\npardir = '..'\nextsep = '.'\nsep = '\\\\'\npathsep = ';'\naltsep = '/'\ndefpath = '.;C:\\\\bin'\ndevnull = 'nul'\n\nimport os\nimport sys\nimport genericpath\nfrom genericpath import *\n\n__all__ = [\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"splitroot\",\"split\",\"splitext\",\n           \"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n           \"getatime\",\"getctime\", \"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n           \"ismount\",\"isreserved\",\"expanduser\",\"expandvars\",\"normpath\",\n           \"abspath\",\"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\n           \"extsep\",\"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\",\n           \"samefile\", \"sameopenfile\", \"samestat\", \"commonpath\", \"isjunction\",\n           \"isdevdrive\"]\n\ndef _get_bothseps(path):\n    if isinstance(path, bytes):\n        return b'\\\\/'\n    else:\n        return '\\\\/'\n\n# Normalize the case of a pathname and map slashes to backslashes.\n# Other normalizations (such as optimizing '../' away) are not done\n# (this is done by normpath).\n\ntry:\n    from _winapi import (\n        LCMapStringEx as _LCMapStringEx,\n        LOCALE_NAME_INVARIANT as _LOCALE_NAME_INVARIANT,\n        LCMAP_LOWERCASE as _LCMAP_LOWERCASE)\n\n    def normcase(s):\n        \"\"\"Normalize case of pathname.\n\n        Makes all characters lowercase and all slashes into backslashes.\n        \"\"\"\n        s = os.fspath(s)\n        if not s:\n            return s\n        if isinstance(s, bytes):\n            encoding = sys.getfilesystemencoding()\n            s = s.decode(encoding, 'surrogateescape').replace('/', '\\\\')\n            s = _LCMapStringEx(_LOCALE_NAME_INVARIANT,\n                               _LCMAP_LOWERCASE, s)\n            return s.encode(encoding, 'surrogateescape')\n        else:\n            return _LCMapStringEx(_LOCALE_NAME_INVARIANT,\n                                  _LCMAP_LOWERCASE,\n                                  s.replace('/', '\\\\'))\nexcept ImportError:\n    def normcase(s):\n        \"\"\"Normalize case of pathname.\n\n        Makes all characters lowercase and all slashes into backslashes.\n        \"\"\"\n        s = os.fspath(s)\n        if isinstance(s, bytes):\n            return os.fsencode(os.fsdecode(s).replace('/', '\\\\').lower())\n        return s.replace('/', '\\\\').lower()\n\n\ndef isabs(s):\n    \"\"\"Test whether a path is absolute\"\"\"\n    s = os.fspath(s)\n    if isinstance(s, bytes):\n        sep = b'\\\\'\n        altsep = b'/'\n        colon_sep = b':\\\\'\n        double_sep = b'\\\\\\\\'\n    else:\n        sep = '\\\\'\n        altsep = '/'\n        colon_sep = ':\\\\'\n        double_sep = '\\\\\\\\'\n    s = s[:3].replace(altsep, sep)\n    # Absolute: UNC, device, and paths with a drive and root.\n    return s.startswith(colon_sep, 1) or s.startswith(double_sep)\n\n\n# Join two (or more) paths.\ndef join(path, *paths):\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        seps = b'\\\\/'\n        colon_seps = b':\\\\/'\n    else:\n        sep = '\\\\'\n        seps = '\\\\/'\n        colon_seps = ':\\\\/'\n    try:\n        result_drive, result_root, result_path = splitroot(path)\n        for p in paths:\n            p_drive, p_root, p_path = splitroot(p)\n            if p_root:\n                # Second path is absolute\n                if p_drive or not result_drive:\n                    result_drive = p_drive\n                result_root = p_root\n                result_path = p_path\n                continue\n            elif p_drive and p_drive != result_drive:\n                if p_drive.lower() != result_drive.lower():\n                    # Different drives => ignore the first path entirely\n                    result_drive = p_drive\n                    result_root = p_root\n                    result_path = p_path\n                    continue\n                # Same drive in different case\n                result_drive = p_drive\n            # Second path is relative to the first\n            if result_path and result_path[-1] not in seps:\n                result_path = result_path + sep\n            result_path = result_path + p_path\n        ## add separator between UNC and non-absolute path\n        if (result_path and not result_root and\n            result_drive and result_drive[-1] not in colon_seps):\n            return result_drive + sep + result_path\n        return result_drive + result_root + result_path\n    except (TypeError, AttributeError, BytesWarning):\n        genericpath._check_arg_types('join', path, *paths)\n        raise\n\n\n# Split a path in a drive specification (a drive letter followed by a\n# colon) and the path specification.\n# It is always true that drivespec + pathspec == p\ndef splitdrive(p):\n    \"\"\"Split a pathname into drive/UNC sharepoint and relative path specifiers.\n    Returns a 2-tuple (drive_or_unc, path); either part may be empty.\n\n    If you assign\n        result = splitdrive(p)\n    It is always true that:\n        result[0] + result[1] == p\n\n    If the path contained a drive letter, drive_or_unc will contain everything\n    up to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\n    If the path contained a UNC path, the drive_or_unc will contain the host name\n    and share up to but not including the fourth directory separator character.\n    e.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\n    Paths cannot contain both a drive letter and a UNC path.\n\n    \"\"\"\n    drive, root, tail = splitroot(p)\n    return drive, root + tail\n\n\ntry:\n    from nt import _path_splitroot_ex as splitroot\nexcept ImportError:\n    def splitroot(p):\n        \"\"\"Split a pathname into drive, root and tail.\n\n        The tail contains anything after the root.\"\"\"\n        p = os.fspath(p)\n        if isinstance(p, bytes):\n            sep = b'\\\\'\n            altsep = b'/'\n            colon = b':'\n            unc_prefix = b'\\\\\\\\?\\\\UNC\\\\'\n            empty = b''\n        else:\n            sep = '\\\\'\n            altsep = '/'\n            colon = ':'\n            unc_prefix = '\\\\\\\\?\\\\UNC\\\\'\n            empty = ''\n        normp = p.replace(altsep, sep)\n        if normp[:1] == sep:\n            if normp[1:2] == sep:\n                # UNC drives, e.g. \\\\server\\share or \\\\?\\UNC\\server\\share\n                # Device drives, e.g. \\\\.\\device or \\\\?\\device\n                start = 8 if normp[:8].upper() == unc_prefix else 2\n                index = normp.find(sep, start)\n                if index == -1:\n                    return p, empty, empty\n                index2 = normp.find(sep, index + 1)\n                if index2 == -1:\n                    return p, empty, empty\n                return p[:index2], p[index2:index2 + 1], p[index2 + 1:]\n            else:\n                # Relative path with root, e.g. \\Windows\n                return empty, p[:1], p[1:]\n        elif normp[1:2] == colon:\n            if normp[2:3] == sep:\n                # Absolute drive-letter path, e.g. X:\\Windows\n                return p[:2], p[2:3], p[3:]\n            else:\n                # Relative path with drive, e.g. X:Windows\n                return p[:2], empty, p[2:]\n        else:\n            # Relative path, e.g. Windows\n            return empty, empty, p\n\n\n# Split a path in head (everything up to the last '/') and tail (the\n# rest).  After the trailing '/' is stripped, the invariant\n# join(head, tail) == p holds.\n# The resulting head won't end in '/' unless it is the root.\n\ndef split(p):\n    \"\"\"Split a pathname.\n\n    Return tuple (head, tail) where tail is everything after the final slash.\n    Either part may be empty.\"\"\"\n    p = os.fspath(p)\n    seps = _get_bothseps(p)\n    d, r, p = splitroot(p)\n    # set i to index beyond p's last slash\n    i = len(p)\n    while i and p[i-1] not in seps:\n        i -= 1\n    head, tail = p[:i], p[i:]  # now tail has no slashes\n    return d + r + head.rstrip(seps), tail\n\n\n# Split a path in root and extension.\n# The extension is everything starting at the last dot in the last\n# pathname component; the root is everything before that.\n# It is always true that root + ext == p.\n\ndef splitext(p):\n    p = os.fspath(p)\n    if isinstance(p, bytes):\n        return genericpath._splitext(p, b'\\\\', b'/', b'.')\n    else:\n        return genericpath._splitext(p, '\\\\', '/', '.')\nsplitext.__doc__ = genericpath._splitext.__doc__\n\n\n# Return the tail (basename) part of a path.\n\ndef basename(p):\n    \"\"\"Returns the final component of a pathname\"\"\"\n    return split(p)[1]\n\n\n# Return the head (dirname) part of a path.\n\ndef dirname(p):\n    \"\"\"Returns the directory component of a pathname\"\"\"\n    return split(p)[0]\n\n\n# Is a path a mount point?\n# Any drive letter root (eg c:\\)\n# Any share UNC (eg \\\\server\\share)\n# Any volume mounted on a filesystem folder\n#\n# No one method detects all three situations. Historically we've lexically\n# detected drive letter roots and share UNCs. The canonical approach to\n# detecting mounted volumes (querying the reparse tag) fails for the most\n# common case: drive letter roots. The alternative which uses GetVolumePathName\n# fails if the drive letter is the result of a SUBST.\ntry:\n    from nt import _getvolumepathname\nexcept ImportError:\n    _getvolumepathname = None\ndef ismount(path):\n    \"\"\"Test whether a path is a mount point (a drive root, the root of a\n    share, or a mounted volume)\"\"\"\n    path = os.fspath(path)\n    seps = _get_bothseps(path)\n    path = abspath(path)\n    drive, root, rest = splitroot(path)\n    if drive and drive[0] in seps:\n        return not rest\n    if root and not rest:\n        return True\n\n    if _getvolumepathname:\n        x = path.rstrip(seps)\n        y =_getvolumepathname(path).rstrip(seps)\n        return x.casefold() == y.casefold()\n    else:\n        return False\n\n\n_reserved_chars = frozenset(\n    {chr(i) for i in range(32)} |\n    {'\"', '*', ':', '<', '>', '?', '|', '/', '\\\\'}\n)\n\n_reserved_names = frozenset(\n    {'CON', 'PRN', 'AUX', 'NUL', 'CONIN$', 'CONOUT$'} |\n    {f'COM{c}' for c in '123456789\\xb9\\xb2\\xb3'} |\n    {f'LPT{c}' for c in '123456789\\xb9\\xb2\\xb3'}\n)\n\ndef isreserved(path):\n    \"\"\"Return true if the pathname is reserved by the system.\"\"\"\n    # Refer to \"Naming Files, Paths, and Namespaces\":\n    # https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n    path = os.fsdecode(splitroot(path)[2]).replace(altsep, sep)\n    return any(_isreservedname(name) for name in reversed(path.split(sep)))\n\ndef _isreservedname(name):\n    \"\"\"Return true if the filename is reserved by the system.\"\"\"\n    # Trailing dots and spaces are reserved.\n    if name[-1:] in ('.', ' '):\n        return name not in ('.', '..')\n    # Wildcards, separators, colon, and pipe (*?\"<>/\\:|) are reserved.\n    # ASCII control characters (0-31) are reserved.\n    # Colon is reserved for file streams (e.g. \"name:stream[:type]\").\n    if _reserved_chars.intersection(name):\n        return True\n    # DOS device names are reserved (e.g. \"nul\" or \"nul .txt\"). The rules\n    # are complex and vary across Windows versions. On the side of\n    # caution, return True for names that may not be reserved.\n    return name.partition('.')[0].rstrip(' ').upper() in _reserved_names\n\n\n# Expand paths beginning with '~' or '~user'.\n# '~' means $HOME; '~user' means that user's home directory.\n# If the path doesn't begin with '~', or if the user or $HOME is unknown,\n# the path is returned unchanged (leaving error reporting to whatever\n# function is called with the expanded path as argument).\n# See also module 'glob' for expansion of *, ? and [...] in pathnames.\n# (A function should also be defined to do full *sh-style environment\n# variable expansion.)\n\ndef expanduser(path):\n    \"\"\"Expand ~ and ~user constructs.\n\n    If user or $HOME is unknown, do nothing.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        seps = b'\\\\/'\n        tilde = b'~'\n    else:\n        seps = '\\\\/'\n        tilde = '~'\n    if not path.startswith(tilde):\n        return path\n    i, n = 1, len(path)\n    while i < n and path[i] not in seps:\n        i += 1\n\n    if 'USERPROFILE' in os.environ:\n        userhome = os.environ['USERPROFILE']\n    elif 'HOMEPATH' not in os.environ:\n        return path\n    else:\n        drive = os.environ.get('HOMEDRIVE', '')\n        userhome = join(drive, os.environ['HOMEPATH'])\n\n    if i != 1: #~user\n        target_user = path[1:i]\n        if isinstance(target_user, bytes):\n            target_user = os.fsdecode(target_user)\n        current_user = os.environ.get('USERNAME')\n\n        if target_user != current_user:\n            # Try to guess user home directory.  By default all user\n            # profile directories are located in the same place and are\n            # named by corresponding usernames.  If userhome isn't a\n            # normal profile directory, this guess is likely wrong,\n            # so we bail out.\n            if current_user != basename(userhome):\n                return path\n            userhome = join(dirname(userhome), target_user)\n\n    if isinstance(path, bytes):\n        userhome = os.fsencode(userhome)\n\n    return userhome + path[i:]\n\n\n# Expand paths containing shell variable substitutions.\n# The following rules apply:\n#       - no expansion within single quotes\n#       - '$$' is translated into '$'\n#       - '%%' is translated into '%' if '%%' are not seen in %var1%%var2%\n#       - ${varname} is accepted.\n#       - $varname is accepted.\n#       - %varname% is accepted.\n#       - varnames can be made out of letters, digits and the characters '_-'\n#         (though is not verified in the ${varname} and %varname% cases)\n# XXX With COMMAND.COM you can use any characters in a variable name,\n# XXX except '^|<>='.\n\ndef expandvars(path):\n    \"\"\"Expand shell variables of the forms $var, ${var} and %var%.\n\n    Unknown variables are left unchanged.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        if b'$' not in path and b'%' not in path:\n            return path\n        import string\n        varchars = bytes(string.ascii_letters + string.digits + '_-', 'ascii')\n        quote = b'\\''\n        percent = b'%'\n        brace = b'{'\n        rbrace = b'}'\n        dollar = b'$'\n        environ = getattr(os, 'environb', None)\n    else:\n        if '$' not in path and '%' not in path:\n            return path\n        import string\n        varchars = string.ascii_letters + string.digits + '_-'\n        quote = '\\''\n        percent = '%'\n        brace = '{'\n        rbrace = '}'\n        dollar = '$'\n        environ = os.environ\n    res = path[:0]\n    index = 0\n    pathlen = len(path)\n    while index < pathlen:\n        c = path[index:index+1]\n        if c == quote:   # no expansion within single quotes\n            path = path[index + 1:]\n            pathlen = len(path)\n            try:\n                index = path.index(c)\n                res += c + path[:index + 1]\n            except ValueError:\n                res += c + path\n                index = pathlen - 1\n        elif c == percent:  # variable or '%'\n            if path[index + 1:index + 2] == percent:\n                res += c\n                index += 1\n            else:\n                path = path[index+1:]\n                pathlen = len(path)\n                try:\n                    index = path.index(percent)\n                except ValueError:\n                    res += percent + path\n                    index = pathlen - 1\n                else:\n                    var = path[:index]\n                    try:\n                        if environ is None:\n                            value = os.fsencode(os.environ[os.fsdecode(var)])\n                        else:\n                            value = environ[var]\n                    except KeyError:\n                        value = percent + var + percent\n                    res += value\n        elif c == dollar:  # variable or '$$'\n            if path[index + 1:index + 2] == dollar:\n                res += c\n                index += 1\n            elif path[index + 1:index + 2] == brace:\n                path = path[index+2:]\n                pathlen = len(path)\n                try:\n                    index = path.index(rbrace)\n                except ValueError:\n                    res += dollar + brace + path\n                    index = pathlen - 1\n                else:\n                    var = path[:index]\n                    try:\n                        if environ is None:\n                            value = os.fsencode(os.environ[os.fsdecode(var)])\n                        else:\n                            value = environ[var]\n                    except KeyError:\n                        value = dollar + brace + var + rbrace\n                    res += value\n            else:\n                var = path[:0]\n                index += 1\n                c = path[index:index + 1]\n                while c and c in varchars:\n                    var += c\n                    index += 1\n                    c = path[index:index + 1]\n                try:\n                    if environ is None:\n                        value = os.fsencode(os.environ[os.fsdecode(var)])\n                    else:\n                        value = environ[var]\n                except KeyError:\n                    value = dollar + var\n                res += value\n                if c:\n                    index -= 1\n        else:\n            res += c\n        index += 1\n    return res\n\n\n# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A\\B.\n# Previously, this function also truncated pathnames to 8+3 format,\n# but as this module is called \"ntpath\", that's obviously wrong!\ntry:\n    from nt import _path_normpath as normpath\n\nexcept ImportError:\n    def normpath(path):\n        \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"\n        path = os.fspath(path)\n        if isinstance(path, bytes):\n            sep = b'\\\\'\n            altsep = b'/'\n            curdir = b'.'\n            pardir = b'..'\n        else:\n            sep = '\\\\'\n            altsep = '/'\n            curdir = '.'\n            pardir = '..'\n        path = path.replace(altsep, sep)\n        drive, root, path = splitroot(path)\n        prefix = drive + root\n        comps = path.split(sep)\n        i = 0\n        while i < len(comps):\n            if not comps[i] or comps[i] == curdir:\n                del comps[i]\n            elif comps[i] == pardir:\n                if i > 0 and comps[i-1] != pardir:\n                    del comps[i-1:i+1]\n                    i -= 1\n                elif i == 0 and root:\n                    del comps[i]\n                else:\n                    i += 1\n            else:\n                i += 1\n        # If the path is now empty, substitute '.'\n        if not prefix and not comps:\n            comps.append(curdir)\n        return prefix + sep.join(comps)\n\n\n# Return an absolute path.\ntry:\n    from nt import _getfullpathname\n\nexcept ImportError: # not running on Windows - mock up something sensible\n    def abspath(path):\n        \"\"\"Return the absolute version of a path.\"\"\"\n        path = os.fspath(path)\n        if not isabs(path):\n            if isinstance(path, bytes):\n                cwd = os.getcwdb()\n            else:\n                cwd = os.getcwd()\n            path = join(cwd, path)\n        return normpath(path)\n\nelse:  # use native Windows method on Windows\n    def abspath(path):\n        \"\"\"Return the absolute version of a path.\"\"\"\n        try:\n            return _getfullpathname(normpath(path))\n        except (OSError, ValueError):\n            # See gh-75230, handle outside for cleaner traceback\n            pass\n        path = os.fspath(path)\n        if not isabs(path):\n            if isinstance(path, bytes):\n                sep = b'\\\\'\n                getcwd = os.getcwdb\n            else:\n                sep = '\\\\'\n                getcwd = os.getcwd\n            drive, root, path = splitroot(path)\n            # Either drive or root can be nonempty, but not both.\n            if drive or root:\n                try:\n                    path = join(_getfullpathname(drive + root), path)\n                except (OSError, ValueError):\n                    # Drive \"\\0:\" cannot exist; use the root directory.\n                    path = drive + sep + path\n            else:\n                path = join(getcwd(), path)\n        return normpath(path)\n\ntry:\n    from nt import _findfirstfile, _getfinalpathname, readlink as _nt_readlink\nexcept ImportError:\n    # realpath is a no-op on systems without _getfinalpathname support.\n    realpath = abspath\nelse:\n    def _readlink_deep(path):\n        # These error codes indicate that we should stop reading links and\n        # return the path we currently have.\n        # 1: ERROR_INVALID_FUNCTION\n        # 2: ERROR_FILE_NOT_FOUND\n        # 3: ERROR_DIRECTORY_NOT_FOUND\n        # 5: ERROR_ACCESS_DENIED\n        # 21: ERROR_NOT_READY (implies drive with no media)\n        # 32: ERROR_SHARING_VIOLATION (probably an NTFS paging file)\n        # 50: ERROR_NOT_SUPPORTED (implies no support for reparse points)\n        # 67: ERROR_BAD_NET_NAME (implies remote server unavailable)\n        # 87: ERROR_INVALID_PARAMETER\n        # 4390: ERROR_NOT_A_REPARSE_POINT\n        # 4392: ERROR_INVALID_REPARSE_DATA\n        # 4393: ERROR_REPARSE_TAG_INVALID\n        allowed_winerror = 1, 2, 3, 5, 21, 32, 50, 67, 87, 4390, 4392, 4393\n\n        seen = set()\n        while normcase(path) not in seen:\n            seen.add(normcase(path))\n            try:\n                old_path = path\n                path = _nt_readlink(path)\n                # Links may be relative, so resolve them against their\n                # own location\n                if not isabs(path):\n                    # If it's something other than a symlink, we don't know\n                    # what it's actually going to be resolved against, so\n                    # just return the old path.\n                    if not islink(old_path):\n                        path = old_path\n                        break\n                    path = normpath(join(dirname(old_path), path))\n            except OSError as ex:\n                if ex.winerror in allowed_winerror:\n                    break\n                raise\n            except ValueError:\n                # Stop on reparse points that are not symlinks\n                break\n        return path\n\n    def _getfinalpathname_nonstrict(path):\n        # These error codes indicate that we should stop resolving the path\n        # and return the value we currently have.\n        # 1: ERROR_INVALID_FUNCTION\n        # 2: ERROR_FILE_NOT_FOUND\n        # 3: ERROR_DIRECTORY_NOT_FOUND\n        # 5: ERROR_ACCESS_DENIED\n        # 21: ERROR_NOT_READY (implies drive with no media)\n        # 32: ERROR_SHARING_VIOLATION (probably an NTFS paging file)\n        # 50: ERROR_NOT_SUPPORTED\n        # 53: ERROR_BAD_NETPATH\n        # 65: ERROR_NETWORK_ACCESS_DENIED\n        # 67: ERROR_BAD_NET_NAME (implies remote server unavailable)\n        # 87: ERROR_INVALID_PARAMETER\n        # 123: ERROR_INVALID_NAME\n        # 161: ERROR_BAD_PATHNAME\n        # 1920: ERROR_CANT_ACCESS_FILE\n        # 1921: ERROR_CANT_RESOLVE_FILENAME (implies unfollowable symlink)\n        allowed_winerror = 1, 2, 3, 5, 21, 32, 50, 53, 65, 67, 87, 123, 161, 1920, 1921\n\n        # Non-strict algorithm is to find as much of the target directory\n        # as we can and join the rest.\n        tail = path[:0]\n        while path:\n            try:\n                path = _getfinalpathname(path)\n                return join(path, tail) if tail else path\n            except OSError as ex:\n                if ex.winerror not in allowed_winerror:\n                    raise\n                try:\n                    # The OS could not resolve this path fully, so we attempt\n                    # to follow the link ourselves. If we succeed, join the tail\n                    # and return.\n                    new_path = _readlink_deep(path)\n                    if new_path != path:\n                        return join(new_path, tail) if tail else new_path\n                except OSError:\n                    # If we fail to readlink(), let's keep traversing\n                    pass\n                # If we get these errors, try to get the real name of the file without accessing it.\n                if ex.winerror in (1, 5, 32, 50, 87, 1920, 1921):\n                    try:\n                        name = _findfirstfile(path)\n                        path, _ = split(path)\n                    except OSError:\n                        path, name = split(path)\n                else:\n                    path, name = split(path)\n                if path and not name:\n                    return path + tail\n                tail = join(name, tail) if tail else name\n        return tail\n\n    def realpath(path, *, strict=False):\n        path = normpath(path)\n        if isinstance(path, bytes):\n            prefix = b'\\\\\\\\?\\\\'\n            unc_prefix = b'\\\\\\\\?\\\\UNC\\\\'\n            new_unc_prefix = b'\\\\\\\\'\n            cwd = os.getcwdb()\n            # bpo-38081: Special case for realpath(b'nul')\n            devnull = b'nul'\n            if normcase(path) == devnull:\n                return b'\\\\\\\\.\\\\NUL'\n        else:\n            prefix = '\\\\\\\\?\\\\'\n            unc_prefix = '\\\\\\\\?\\\\UNC\\\\'\n            new_unc_prefix = '\\\\\\\\'\n            cwd = os.getcwd()\n            # bpo-38081: Special case for realpath('nul')\n            devnull = 'nul'\n            if normcase(path) == devnull:\n                return '\\\\\\\\.\\\\NUL'\n        had_prefix = path.startswith(prefix)\n        if not had_prefix and not isabs(path):\n            path = join(cwd, path)\n        try:\n            path = _getfinalpathname(path)\n            initial_winerror = 0\n        except ValueError as ex:\n            # gh-106242: Raised for embedded null characters\n            # In strict mode, we convert into an OSError.\n            # Non-strict mode returns the path as-is, since we've already\n            # made it absolute.\n            if strict:\n                raise OSError(str(ex)) from None\n            path = normpath(path)\n        except OSError as ex:\n            if strict:\n                raise\n            initial_winerror = ex.winerror\n            path = _getfinalpathname_nonstrict(path)\n        # The path returned by _getfinalpathname will always start with \\\\?\\ -\n        # strip off that prefix unless it was already provided on the original\n        # path.\n        if not had_prefix and path.startswith(prefix):\n            # For UNC paths, the prefix will actually be \\\\?\\UNC\\\n            # Handle that case as well.\n            if path.startswith(unc_prefix):\n                spath = new_unc_prefix + path[len(unc_prefix):]\n            else:\n                spath = path[len(prefix):]\n            # Ensure that the non-prefixed path resolves to the same path\n            try:\n                if _getfinalpathname(spath) == path:\n                    path = spath\n            except ValueError as ex:\n                # Unexpected, as an invalid path should not have gained a prefix\n                # at any point, but we ignore this error just in case.\n                pass\n            except OSError as ex:\n                # If the path does not exist and originally did not exist, then\n                # strip the prefix anyway.\n                if ex.winerror == initial_winerror:\n                    path = spath\n        return path\n\n\n# All supported version have Unicode filename support.\nsupports_unicode_filenames = True\n\ndef relpath(path, start=None):\n    \"\"\"Return a relative version of a path\"\"\"\n    path = os.fspath(path)\n    if not path:\n        raise ValueError(\"no path specified\")\n\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        curdir = b'.'\n        pardir = b'..'\n    else:\n        sep = '\\\\'\n        curdir = '.'\n        pardir = '..'\n\n    if start is None:\n        start = curdir\n    else:\n        start = os.fspath(start)\n\n    try:\n        start_abs = abspath(start)\n        path_abs = abspath(path)\n        start_drive, _, start_rest = splitroot(start_abs)\n        path_drive, _, path_rest = splitroot(path_abs)\n        if normcase(start_drive) != normcase(path_drive):\n            raise ValueError(\"path is on mount %r, start on mount %r\" % (\n                path_drive, start_drive))\n\n        start_list = start_rest.split(sep) if start_rest else []\n        path_list = path_rest.split(sep) if path_rest else []\n        # Work out how much of the filepath is shared by start and path.\n        i = 0\n        for e1, e2 in zip(start_list, path_list):\n            if normcase(e1) != normcase(e2):\n                break\n            i += 1\n\n        rel_list = [pardir] * (len(start_list)-i) + path_list[i:]\n        if not rel_list:\n            return curdir\n        return sep.join(rel_list)\n    except (TypeError, ValueError, AttributeError, BytesWarning, DeprecationWarning):\n        genericpath._check_arg_types('relpath', path, start)\n        raise\n\n\n# Return the longest common sub-path of the iterable of paths given as input.\n# The function is case-insensitive and 'separator-insensitive', i.e. if the\n# only difference between two paths is the use of '\\' versus '/' as separator,\n# they are deemed to be equal.\n#\n# However, the returned path will have the standard '\\' separator (even if the\n# given paths had the alternative '/' separator) and will have the case of the\n# first path given in the iterable. Additionally, any trailing separator is\n# stripped from the returned path.\n\ndef commonpath(paths):\n    \"\"\"Given an iterable of path names, returns the longest common sub-path.\"\"\"\n    paths = tuple(map(os.fspath, paths))\n    if not paths:\n        raise ValueError('commonpath() arg is an empty iterable')\n\n    if isinstance(paths[0], bytes):\n        sep = b'\\\\'\n        altsep = b'/'\n        curdir = b'.'\n    else:\n        sep = '\\\\'\n        altsep = '/'\n        curdir = '.'\n\n    try:\n        drivesplits = [splitroot(p.replace(altsep, sep).lower()) for p in paths]\n        split_paths = [p.split(sep) for d, r, p in drivesplits]\n\n        # Check that all drive letters or UNC paths match. The check is made only\n        # now otherwise type errors for mixing strings and bytes would not be\n        # caught.\n        if len({d for d, r, p in drivesplits}) != 1:\n            raise ValueError(\"Paths don't have the same drive\")\n\n        drive, root, path = splitroot(paths[0].replace(altsep, sep))\n        if len({r for d, r, p in drivesplits}) != 1:\n            if drive:\n                raise ValueError(\"Can't mix absolute and relative paths\")\n            else:\n                raise ValueError(\"Can't mix rooted and not-rooted paths\")\n\n        common = path.split(sep)\n        common = [c for c in common if c and c != curdir]\n\n        split_paths = [[c for c in s if c and c != curdir] for s in split_paths]\n        s1 = min(split_paths)\n        s2 = max(split_paths)\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                common = common[:i]\n                break\n        else:\n            common = common[:len(s1)]\n\n        return drive + root + sep.join(common)\n    except (TypeError, AttributeError):\n        genericpath._check_arg_types('commonpath', *paths)\n        raise\n\n\ntry:\n    # The isdir(), isfile(), islink(), exists() and lexists() implementations\n    # in genericpath use os.stat(). This is overkill on Windows. Use simpler\n    # builtin functions if they are available.\n    from nt import _path_isdir as isdir\n    from nt import _path_isfile as isfile\n    from nt import _path_islink as islink\n    from nt import _path_isjunction as isjunction\n    from nt import _path_exists as exists\n    from nt import _path_lexists as lexists\nexcept ImportError:\n    # Use genericpath.* as imported above\n    pass\n\n\ntry:\n    from nt import _path_isdevdrive\n    def isdevdrive(path):\n        \"\"\"Determines whether the specified path is on a Windows Dev Drive.\"\"\"\n        try:\n            return _path_isdevdrive(abspath(path))\n        except OSError:\n            return False\nexcept ImportError:\n    # Use genericpath.isdevdrive as imported above\n    pass\n", 903], "C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py": ["#\n# Module providing the `Process` class which emulates `threading.Thread`\n#\n# multiprocessing/process.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\n__all__ = ['BaseProcess', 'current_process', 'active_children',\n           'parent_process']\n\n#\n# Imports\n#\n\nimport os\nimport sys\nimport signal\nimport itertools\nimport threading\nfrom _weakrefset import WeakSet\n\n#\n#\n#\n\ntry:\n    ORIGINAL_DIR = os.path.abspath(os.getcwd())\nexcept OSError:\n    ORIGINAL_DIR = None\n\n#\n# Public functions\n#\n\ndef current_process():\n    '''\n    Return process object representing the current process\n    '''\n    return _current_process\n\ndef active_children():\n    '''\n    Return list of process objects corresponding to live child processes\n    '''\n    _cleanup()\n    return list(_children)\n\n\ndef parent_process():\n    '''\n    Return process object representing the parent process\n    '''\n    return _parent_process\n\n#\n#\n#\n\ndef _cleanup():\n    # check for processes which have finished\n    for p in list(_children):\n        if (child_popen := p._popen) and child_popen.poll() is not None:\n            _children.discard(p)\n\n#\n# The `Process` class\n#\n\nclass BaseProcess(object):\n    '''\n    Process objects represent activity that is run in a separate process\n\n    The class is analogous to `threading.Thread`\n    '''\n    def _Popen(self):\n        raise NotImplementedError\n\n    def __init__(self, group=None, target=None, name=None, args=(), kwargs={},\n                 *, daemon=None):\n        assert group is None, 'group argument must be None for now'\n        count = next(_process_counter)\n        self._identity = _current_process._identity + (count,)\n        self._config = _current_process._config.copy()\n        self._parent_pid = os.getpid()\n        self._parent_name = _current_process.name\n        self._popen = None\n        self._closed = False\n        self._target = target\n        self._args = tuple(args)\n        self._kwargs = dict(kwargs)\n        self._name = name or type(self).__name__ + '-' + \\\n                     ':'.join(str(i) for i in self._identity)\n        if daemon is not None:\n            self.daemon = daemon\n        _dangling.add(self)\n\n    def _check_closed(self):\n        if self._closed:\n            raise ValueError(\"process object is closed\")\n\n    def run(self):\n        '''\n        Method to be run in sub-process; can be overridden in sub-class\n        '''\n        if self._target:\n            self._target(*self._args, **self._kwargs)\n\n    def start(self):\n        '''\n        Start child process\n        '''\n        self._check_closed()\n        assert self._popen is None, 'cannot start a process twice'\n        assert self._parent_pid == os.getpid(), \\\n               'can only start a process object created by current process'\n        assert not _current_process._config.get('daemon'), \\\n               'daemonic processes are not allowed to have children'\n        _cleanup()\n        self._popen = self._Popen(self)\n        self._sentinel = self._popen.sentinel\n        # Avoid a refcycle if the target function holds an indirect\n        # reference to the process object (see bpo-30775)\n        del self._target, self._args, self._kwargs\n        _children.add(self)\n\n    def terminate(self):\n        '''\n        Terminate process; sends SIGTERM signal or uses TerminateProcess()\n        '''\n        self._check_closed()\n        self._popen.terminate()\n\n    def kill(self):\n        '''\n        Terminate process; sends SIGKILL signal or uses TerminateProcess()\n        '''\n        self._check_closed()\n        self._popen.kill()\n\n    def join(self, timeout=None):\n        '''\n        Wait until child process terminates\n        '''\n        self._check_closed()\n        assert self._parent_pid == os.getpid(), 'can only join a child process'\n        assert self._popen is not None, 'can only join a started process'\n        res = self._popen.wait(timeout)\n        if res is not None:\n            _children.discard(self)\n\n    def is_alive(self):\n        '''\n        Return whether process is alive\n        '''\n        self._check_closed()\n        if self is _current_process:\n            return True\n        assert self._parent_pid == os.getpid(), 'can only test a child process'\n\n        if self._popen is None:\n            return False\n\n        returncode = self._popen.poll()\n        if returncode is None:\n            return True\n        else:\n            _children.discard(self)\n            return False\n\n    def close(self):\n        '''\n        Close the Process object.\n\n        This method releases resources held by the Process object.  It is\n        an error to call this method if the child process is still running.\n        '''\n        if self._popen is not None:\n            if self._popen.poll() is None:\n                raise ValueError(\"Cannot close a process while it is still running. \"\n                                 \"You should first call join() or terminate().\")\n            self._popen.close()\n            self._popen = None\n            del self._sentinel\n            _children.discard(self)\n        self._closed = True\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert isinstance(name, str), 'name must be a string'\n        self._name = name\n\n    @property\n    def daemon(self):\n        '''\n        Return whether process is a daemon\n        '''\n        return self._config.get('daemon', False)\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        '''\n        Set whether process is a daemon\n        '''\n        assert self._popen is None, 'process has already started'\n        self._config['daemon'] = daemonic\n\n    @property\n    def authkey(self):\n        return self._config['authkey']\n\n    @authkey.setter\n    def authkey(self, authkey):\n        '''\n        Set authorization key of process\n        '''\n        self._config['authkey'] = AuthenticationString(authkey)\n\n    @property\n    def exitcode(self):\n        '''\n        Return exit code of process or `None` if it has yet to stop\n        '''\n        self._check_closed()\n        if self._popen is None:\n            return self._popen\n        return self._popen.poll()\n\n    @property\n    def ident(self):\n        '''\n        Return identifier (PID) of process or `None` if it has yet to start\n        '''\n        self._check_closed()\n        if self is _current_process:\n            return os.getpid()\n        else:\n            return self._popen and self._popen.pid\n\n    pid = ident\n\n    @property\n    def sentinel(self):\n        '''\n        Return a file descriptor (Unix) or handle (Windows) suitable for\n        waiting for process termination.\n        '''\n        self._check_closed()\n        try:\n            return self._sentinel\n        except AttributeError:\n            raise ValueError(\"process not started\") from None\n\n    def __repr__(self):\n        exitcode = None\n        if self is _current_process:\n            status = 'started'\n        elif self._closed:\n            status = 'closed'\n        elif self._parent_pid != os.getpid():\n            status = 'unknown'\n        elif self._popen is None:\n            status = 'initial'\n        else:\n            exitcode = self._popen.poll()\n            if exitcode is not None:\n                status = 'stopped'\n            else:\n                status = 'started'\n\n        info = [type(self).__name__, 'name=%r' % self._name]\n        if self._popen is not None:\n            info.append('pid=%s' % self._popen.pid)\n        info.append('parent=%s' % self._parent_pid)\n        info.append(status)\n        if exitcode is not None:\n            exitcode = _exitcode_to_name.get(exitcode, exitcode)\n            info.append('exitcode=%s' % exitcode)\n        if self.daemon:\n            info.append('daemon')\n        return '<%s>' % ' '.join(info)\n\n    ##\n\n    def _bootstrap(self, parent_sentinel=None):\n        from . import util, context\n        global _current_process, _parent_process, _process_counter, _children\n\n        try:\n            if self._start_method is not None:\n                context._force_start_method(self._start_method)\n            _process_counter = itertools.count(1)\n            _children = set()\n            util._close_stdin()\n            old_process = _current_process\n            _current_process = self\n            _parent_process = _ParentProcess(\n                self._parent_name, self._parent_pid, parent_sentinel)\n            if threading._HAVE_THREAD_NATIVE_ID:\n                threading.main_thread()._set_native_id()\n            try:\n                self._after_fork()\n            finally:\n                # delay finalization of the old process object until after\n                # _run_after_forkers() is executed\n                del old_process\n            util.info('child process calling self.run()')\n            self.run()\n            exitcode = 0\n        except SystemExit as e:\n            if e.code is None:\n                exitcode = 0\n            elif isinstance(e.code, int):\n                exitcode = e.code\n            else:\n                sys.stderr.write(str(e.code) + '\\n')\n                exitcode = 1\n        except:\n            exitcode = 1\n            import traceback\n            sys.stderr.write('Process %s:\\n' % self.name)\n            traceback.print_exc()\n        finally:\n            threading._shutdown()\n            util.info('process exiting with exitcode %d' % exitcode)\n            util._flush_std_streams()\n\n        return exitcode\n\n    @staticmethod\n    def _after_fork():\n        from . import util\n        util._finalizer_registry.clear()\n        util._run_after_forkers()\n\n\n#\n# We subclass bytes to avoid accidental transmission of auth keys over network\n#\n\nclass AuthenticationString(bytes):\n    def __reduce__(self):\n        from .context import get_spawning_popen\n        if get_spawning_popen() is None:\n            raise TypeError(\n                'Pickling an AuthenticationString object is '\n                'disallowed for security reasons'\n                )\n        return AuthenticationString, (bytes(self),)\n\n\n#\n# Create object representing the parent process\n#\n\nclass _ParentProcess(BaseProcess):\n\n    def __init__(self, name, pid, sentinel):\n        self._identity = ()\n        self._name = name\n        self._pid = pid\n        self._parent_pid = None\n        self._popen = None\n        self._closed = False\n        self._sentinel = sentinel\n        self._config = {}\n\n    def is_alive(self):\n        from multiprocessing.connection import wait\n        return not wait([self._sentinel], timeout=0)\n\n    @property\n    def ident(self):\n        return self._pid\n\n    def join(self, timeout=None):\n        '''\n        Wait until parent process terminates\n        '''\n        from multiprocessing.connection import wait\n        wait([self._sentinel], timeout=timeout)\n\n    pid = ident\n\n#\n# Create object representing the main process\n#\n\nclass _MainProcess(BaseProcess):\n\n    def __init__(self):\n        self._identity = ()\n        self._name = 'MainProcess'\n        self._parent_pid = None\n        self._popen = None\n        self._closed = False\n        self._config = {'authkey': AuthenticationString(os.urandom(32)),\n                        'semprefix': '/mp'}\n        # Note that some versions of FreeBSD only allow named\n        # semaphores to have names of up to 14 characters.  Therefore\n        # we choose a short prefix.\n        #\n        # On MacOSX in a sandbox it may be necessary to use a\n        # different prefix -- see #19478.\n        #\n        # Everything in self._config will be inherited by descendant\n        # processes.\n\n    def close(self):\n        pass\n\n\n_parent_process = None\n_current_process = _MainProcess()\n_process_counter = itertools.count(1)\n_children = set()\ndel _MainProcess\n\n#\n# Give names to some return codes\n#\n\n_exitcode_to_name = {}\n\nfor name, signum in list(signal.__dict__.items()):\n    if name[:3]=='SIG' and '_' not in name:\n        _exitcode_to_name[-signum] = f'-{name}'\ndel name, signum\n\n# For debug and leak testing\n_dangling = WeakSet()\n", 436], "C:\\Programming\\Python313\\Lib\\threading.py": ["\"\"\"Thread module emulating a subset of Java's threading model.\"\"\"\n\nimport os as _os\nimport sys as _sys\nimport _thread\nimport warnings\n\nfrom time import monotonic as _time\nfrom _weakrefset import WeakSet\nfrom itertools import count as _count\ntry:\n    from _collections import deque as _deque\nexcept ImportError:\n    from collections import deque as _deque\n\n# Note regarding PEP 8 compliant names\n#  This threading model was originally inspired by Java, and inherited\n# the convention of camelCase function and method names from that\n# language. Those original names are not in any imminent danger of\n# being deprecated (even for Py3k),so this module provides them as an\n# alias for the PEP 8 compliant names\n# Note that using the new PEP 8 compliant names facilitates substitution\n# with the multiprocessing module, which doesn't provide the old\n# Java inspired names.\n\n__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',\n           'enumerate', 'main_thread', 'TIMEOUT_MAX',\n           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',\n           'Barrier', 'BrokenBarrierError', 'Timer', 'ThreadError',\n           'setprofile', 'settrace', 'local', 'stack_size',\n           'excepthook', 'ExceptHookArgs', 'gettrace', 'getprofile',\n           'setprofile_all_threads','settrace_all_threads']\n\n# Rename some stuff so \"from threading import *\" is safe\n_start_joinable_thread = _thread.start_joinable_thread\n_daemon_threads_allowed = _thread.daemon_threads_allowed\n_allocate_lock = _thread.allocate_lock\n_LockType = _thread.LockType\n_thread_shutdown = _thread._shutdown\n_make_thread_handle = _thread._make_thread_handle\n_ThreadHandle = _thread._ThreadHandle\nget_ident = _thread.get_ident\n_get_main_thread_ident = _thread._get_main_thread_ident\n_is_main_interpreter = _thread._is_main_interpreter\ntry:\n    get_native_id = _thread.get_native_id\n    _HAVE_THREAD_NATIVE_ID = True\n    __all__.append('get_native_id')\nexcept AttributeError:\n    _HAVE_THREAD_NATIVE_ID = False\nThreadError = _thread.error\ntry:\n    _CRLock = _thread.RLock\nexcept AttributeError:\n    _CRLock = None\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\n\ntry:\n    from _thread import _local as local\nexcept ImportError:\n    from _threading_local import local\n\n# Support for profile and trace hooks\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n    \"\"\"Set a profile function for all threads started from the threading module.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n    \"\"\"\n    global _profile_hook\n    _profile_hook = func\n\ndef setprofile_all_threads(func):\n    \"\"\"Set a profile function for all threads started from the threading module\n    and all Python threads that are currently executing.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n    \"\"\"\n    setprofile(func)\n    _sys._setprofileallthreads(func)\n\ndef getprofile():\n    \"\"\"Get the profiler function as set by threading.setprofile().\"\"\"\n    return _profile_hook\n\ndef settrace(func):\n    \"\"\"Set a trace function for all threads started from the threading module.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n    \"\"\"\n    global _trace_hook\n    _trace_hook = func\n\ndef settrace_all_threads(func):\n    \"\"\"Set a trace function for all threads started from the threading module\n    and all Python threads that are currently executing.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n    \"\"\"\n    settrace(func)\n    _sys._settraceallthreads(func)\n\ndef gettrace():\n    \"\"\"Get the trace function as set by threading.settrace().\"\"\"\n    return _trace_hook\n\n# Synchronization classes\n\nLock = _LockType\n\ndef RLock(*args, **kwargs):\n    \"\"\"Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    \"\"\"\n    if args or kwargs:\n        warnings.warn(\n            'Passing arguments to RLock is deprecated and will be removed in 3.15',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    if _CRLock is None:\n        return _PyRLock(*args, **kwargs)\n    return _CRLock(*args, **kwargs)\n\nclass _RLock:\n    \"\"\"This class implements reentrant lock objects.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it\n    again without blocking; the thread must release it once for each time it\n    has acquired it.\n\n    \"\"\"\n\n    def __init__(self):\n        self._block = _allocate_lock()\n        self._owner = None\n        self._count = 0\n\n    def __repr__(self):\n        owner = self._owner\n        try:\n            owner = _active[owner].name\n        except KeyError:\n            pass\n        return \"<%s %s.%s object owner=%r count=%d at %s>\" % (\n            \"locked\" if self._block.locked() else \"unlocked\",\n            self.__class__.__module__,\n            self.__class__.__qualname__,\n            owner,\n            self._count,\n            hex(id(self))\n        )\n\n    def _at_fork_reinit(self):\n        self._block._at_fork_reinit()\n        self._owner = None\n        self._count = 0\n\n    def acquire(self, blocking=True, timeout=-1):\n        \"\"\"Acquire a lock, blocking or non-blocking.\n\n        When invoked without arguments: if this thread already owns the lock,\n        increment the recursion level by one, and return immediately. Otherwise,\n        if another thread owns the lock, block until the lock is unlocked. Once\n        the lock is unlocked (not owned by any thread), then grab ownership, set\n        the recursion level to one, and return. If more than one thread is\n        blocked waiting until the lock is unlocked, only one at a time will be\n        able to grab ownership of the lock. There is no return value in this\n        case.\n\n        When invoked with the blocking argument set to true, do the same thing\n        as when called without arguments, and return true.\n\n        When invoked with the blocking argument set to false, do not block. If a\n        call without an argument would block, return false immediately;\n        otherwise, do the same thing as when called without arguments, and\n        return true.\n\n        When invoked with the floating-point timeout argument set to a positive\n        value, block for at most the number of seconds specified by timeout\n        and as long as the lock cannot be acquired.  Return true if the lock has\n        been acquired, false if the timeout has elapsed.\n\n        \"\"\"\n        me = get_ident()\n        if self._owner == me:\n            self._count += 1\n            return 1\n        rc = self._block.acquire(blocking, timeout)\n        if rc:\n            self._owner = me\n            self._count = 1\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a lock, decrementing the recursion level.\n\n        If after the decrement it is zero, reset the lock to unlocked (not owned\n        by any thread), and if any other threads are blocked waiting for the\n        lock to become unlocked, allow exactly one of them to proceed. If after\n        the decrement the recursion level is still nonzero, the lock remains\n        locked and owned by the calling thread.\n\n        Only call this method when the calling thread owns the lock. A\n        RuntimeError is raised if this method is called when the lock is\n        unlocked.\n\n        There is no return value.\n\n        \"\"\"\n        if self._owner != get_ident():\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        self._count = count = self._count - 1\n        if not count:\n            self._owner = None\n            self._block.release()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n    # Internal methods used by condition variables\n\n    def _acquire_restore(self, state):\n        self._block.acquire()\n        self._count, self._owner = state\n\n    def _release_save(self):\n        if self._count == 0:\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        count = self._count\n        self._count = 0\n        owner = self._owner\n        self._owner = None\n        self._block.release()\n        return (count, owner)\n\n    def _is_owned(self):\n        return self._owner == get_ident()\n\n    # Internal method used for reentrancy checks\n\n    def _recursion_count(self):\n        if self._owner != get_ident():\n            return 0\n        return self._count\n\n_PyRLock = _RLock\n\n\nclass Condition:\n    \"\"\"Class that implements a condition variable.\n\n    A condition variable allows one or more threads to wait until they are\n    notified by another thread.\n\n    If the lock argument is given and not None, it must be a Lock or RLock\n    object, and it is used as the underlying lock. Otherwise, a new RLock object\n    is created and used as the underlying lock.\n\n    \"\"\"\n\n    def __init__(self, lock=None):\n        if lock is None:\n            lock = RLock()\n        self._lock = lock\n        # Export the lock's acquire() and release() methods\n        self.acquire = lock.acquire\n        self.release = lock.release\n        # If the lock defines _release_save() and/or _acquire_restore(),\n        # these override the default implementations (which just call\n        # release() and acquire() on the lock).  Ditto for _is_owned().\n        if hasattr(lock, '_release_save'):\n            self._release_save = lock._release_save\n        if hasattr(lock, '_acquire_restore'):\n            self._acquire_restore = lock._acquire_restore\n        if hasattr(lock, '_is_owned'):\n            self._is_owned = lock._is_owned\n        self._waiters = _deque()\n\n    def _at_fork_reinit(self):\n        self._lock._at_fork_reinit()\n        self._waiters.clear()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n    def __repr__(self):\n        return \"<Condition(%s, %d)>\" % (self._lock, len(self._waiters))\n\n    def _release_save(self):\n        self._lock.release()           # No state to save\n\n    def _acquire_restore(self, x):\n        self._lock.acquire()           # Ignore saved state\n\n    def _is_owned(self):\n        # Return True if lock is owned by current_thread.\n        # This method is called only if _lock doesn't have _is_owned().\n        if self._lock.acquire(False):\n            self._lock.release()\n            return False\n        else:\n            return True\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n\n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n                waiter.acquire()\n                gotit = True\n            else:\n                if timeout > 0:\n                    gotit = waiter.acquire(True, timeout)\n                else:\n                    gotit = waiter.acquire(False)\n            return gotit\n        finally:\n            self._acquire_restore(saved_state)\n            if not gotit:\n                try:\n                    self._waiters.remove(waiter)\n                except ValueError:\n                    pass\n\n    def wait_for(self, predicate, timeout=None):\n        \"\"\"Wait until a condition evaluates to True.\n\n        predicate should be a callable which result will be interpreted as a\n        boolean value.  A timeout may be provided giving the maximum time to\n        wait.\n\n        \"\"\"\n        endtime = None\n        waittime = timeout\n        result = predicate()\n        while not result:\n            if waittime is not None:\n                if endtime is None:\n                    endtime = _time() + waittime\n                else:\n                    waittime = endtime - _time()\n                    if waittime <= 0:\n                        break\n            self.wait(waittime)\n            result = predicate()\n        return result\n\n    def notify(self, n=1):\n        \"\"\"Wake up one or more threads waiting on this condition, if any.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method wakes up at most n of the threads waiting for the condition\n        variable; it is a no-op if no threads are waiting.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot notify on un-acquired lock\")\n        waiters = self._waiters\n        while waiters and n > 0:\n            waiter = waiters[0]\n            try:\n                waiter.release()\n            except RuntimeError:\n                # gh-92530: The previous call of notify() released the lock,\n                # but was interrupted before removing it from the queue.\n                # It can happen if a signal handler raises an exception,\n                # like CTRL+C which raises KeyboardInterrupt.\n                pass\n            else:\n                n -= 1\n            try:\n                waiters.remove(waiter)\n            except ValueError:\n                pass\n\n    def notify_all(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        If the calling thread has not acquired the lock when this method\n        is called, a RuntimeError is raised.\n\n        \"\"\"\n        self.notify(len(self._waiters))\n\n    def notifyAll(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        This method is deprecated, use notify_all() instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('notifyAll() is deprecated, use notify_all() instead',\n                      DeprecationWarning, stacklevel=2)\n        self.notify_all()\n\n\nclass Semaphore:\n    \"\"\"This class implements semaphore objects.\n\n    Semaphores manage a counter representing the number of release() calls minus\n    the number of acquire() calls, plus an initial value. The acquire() method\n    blocks if necessary until it can return without making the counter\n    negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    # After Tim Peters' semaphore class, but not quite the same (no maximum)\n\n    def __init__(self, value=1):\n        if value < 0:\n            raise ValueError(\"semaphore initial value must be >= 0\")\n        self._cond = Condition(Lock())\n        self._value = value\n\n    def __repr__(self):\n        cls = self.__class__\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" value={self._value}>\")\n\n    def acquire(self, blocking=True, timeout=None):\n        \"\"\"Acquire a semaphore, decrementing the internal counter by one.\n\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n\n        When invoked with a timeout other than None, it will block for at\n        most timeout seconds.  If acquire does not complete successfully in\n        that interval, return false.  Return true otherwise.\n\n        \"\"\"\n        if not blocking and timeout is not None:\n            raise ValueError(\"can't specify timeout for non-blocking acquire\")\n        rc = False\n        endtime = None\n        with self._cond:\n            while self._value == 0:\n                if not blocking:\n                    break\n                if timeout is not None:\n                    if endtime is None:\n                        endtime = _time() + timeout\n                    else:\n                        timeout = endtime - _time()\n                        if timeout <= 0:\n                            break\n                self._cond.wait(timeout)\n            else:\n                self._value -= 1\n                rc = True\n        return rc\n\n    __enter__ = acquire\n\n    def release(self, n=1):\n        \"\"\"Release a semaphore, incrementing the internal counter by one or more.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        \"\"\"\n        if n < 1:\n            raise ValueError('n must be one or more')\n        with self._cond:\n            self._value += n\n            self._cond.notify(n)\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass BoundedSemaphore(Semaphore):\n    \"\"\"Implements a bounded semaphore.\n\n    A bounded semaphore checks to make sure its current value doesn't exceed its\n    initial value. If it does, ValueError is raised. In most situations\n    semaphores are used to guard resources with limited capacity.\n\n    If the semaphore is released too many times it's a sign of a bug. If not\n    given, value defaults to 1.\n\n    Like regular semaphores, bounded semaphores manage a counter representing\n    the number of release() calls minus the number of acquire() calls, plus an\n    initial value. The acquire() method blocks if necessary until it can return\n    without making the counter negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    def __init__(self, value=1):\n        super().__init__(value)\n        self._initial_value = value\n\n    def __repr__(self):\n        cls = self.__class__\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" value={self._value}/{self._initial_value}>\")\n\n    def release(self, n=1):\n        \"\"\"Release a semaphore, incrementing the internal counter by one or more.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        If the number of releases exceeds the number of acquires,\n        raise a ValueError.\n\n        \"\"\"\n        if n < 1:\n            raise ValueError('n must be one or more')\n        with self._cond:\n            if self._value + n > self._initial_value:\n                raise ValueError(\"Semaphore released too many times\")\n            self._value += n\n            self._cond.notify(n)\n\n\nclass Event:\n    \"\"\"Class implementing event objects.\n\n    Events manage a flag that can be set to true with the set() method and reset\n    to false with the clear() method. The wait() method blocks until the flag is\n    true.  The flag is initially false.\n\n    \"\"\"\n\n    # After Tim Peters' event class (without is_posted())\n\n    def __init__(self):\n        self._cond = Condition(Lock())\n        self._flag = False\n\n    def __repr__(self):\n        cls = self.__class__\n        status = 'set' if self._flag else 'unset'\n        return f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}: {status}>\"\n\n    def _at_fork_reinit(self):\n        # Private method called by Thread._after_fork()\n        self._cond._at_fork_reinit()\n\n    def is_set(self):\n        \"\"\"Return true if and only if the internal flag is true.\"\"\"\n        return self._flag\n\n    def isSet(self):\n        \"\"\"Return true if and only if the internal flag is true.\n\n        This method is deprecated, use is_set() instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('isSet() is deprecated, use is_set() instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.is_set()\n\n    def set(self):\n        \"\"\"Set the internal flag to true.\n\n        All threads waiting for it to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        \"\"\"\n        with self._cond:\n            self._flag = True\n            self._cond.notify_all()\n\n    def clear(self):\n        \"\"\"Reset the internal flag to false.\n\n        Subsequently, threads calling wait() will block until set() is called to\n        set the internal flag to true again.\n\n        \"\"\"\n        with self._cond:\n            self._flag = False\n\n    def wait(self, timeout=None):\n        \"\"\"Block until the internal flag is true.\n\n        If the internal flag is true on entry, return immediately. Otherwise,\n        block until another thread calls set() to set the flag to true, or until\n        the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        This method returns the internal flag on exit, so it will always return\n        True except if a timeout is given and the operation times out.\n\n        \"\"\"\n        with self._cond:\n            signaled = self._flag\n            if not signaled:\n                signaled = self._cond.wait(timeout)\n            return signaled\n\n\n# A barrier class.  Inspired in part by the pthread_barrier_* api and\n# the CyclicBarrier class from Java.  See\n# http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and\n# http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/\n#        CyclicBarrier.html\n# for information.\n# We maintain two main states, 'filling' and 'draining' enabling the barrier\n# to be cyclic.  Threads are not allowed into it until it has fully drained\n# since the previous cycle.  In addition, a 'resetting' state exists which is\n# similar to 'draining' except that threads leave with a BrokenBarrierError,\n# and a 'broken' state in which all threads get the exception.\nclass Barrier:\n    \"\"\"Implements a Barrier.\n\n    Useful for synchronizing a fixed number of threads at known synchronization\n    points.  Threads block on 'wait()' and are simultaneously awoken once they\n    have all made that call.\n\n    \"\"\"\n\n    def __init__(self, parties, action=None, timeout=None):\n        \"\"\"Create a barrier, initialised to 'parties' threads.\n\n        'action' is a callable which, when supplied, will be called by one of\n        the threads after they have all entered the barrier and just prior to\n        releasing them all. If a 'timeout' is provided, it is used as the\n        default for all subsequent 'wait()' calls.\n\n        \"\"\"\n        if parties < 1:\n            raise ValueError(\"parties must be >= 1\")\n        self._cond = Condition(Lock())\n        self._action = action\n        self._timeout = timeout\n        self._parties = parties\n        self._state = 0  # 0 filling, 1 draining, -1 resetting, -2 broken\n        self._count = 0\n\n    def __repr__(self):\n        cls = self.__class__\n        if self.broken:\n            return f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}: broken>\"\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" waiters={self.n_waiting}/{self.parties}>\")\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for the barrier.\n\n        When the specified number of threads have started waiting, they are all\n        simultaneously awoken. If an 'action' was provided for the barrier, one\n        of the threads will have executed that callback prior to returning.\n        Returns an individual index number from 0 to 'parties-1'.\n\n        \"\"\"\n        if timeout is None:\n            timeout = self._timeout\n        with self._cond:\n            self._enter() # Block while the barrier drains.\n            index = self._count\n            self._count += 1\n            try:\n                if index + 1 == self._parties:\n                    # We release the barrier\n                    self._release()\n                else:\n                    # We wait until someone releases us\n                    self._wait(timeout)\n                return index\n            finally:\n                self._count -= 1\n                # Wake up any threads waiting for barrier to drain.\n                self._exit()\n\n    # Block until the barrier is ready for us, or raise an exception\n    # if it is broken.\n    def _enter(self):\n        while self._state in (-1, 1):\n            # It is draining or resetting, wait until done\n            self._cond.wait()\n        #see if the barrier is in a broken state\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 0\n\n    # Optionally run the 'action' and release the threads waiting\n    # in the barrier.\n    def _release(self):\n        try:\n            if self._action:\n                self._action()\n            # enter draining state\n            self._state = 1\n            self._cond.notify_all()\n        except:\n            #an exception during the _action handler.  Break and reraise\n            self._break()\n            raise\n\n    # Wait in the barrier until we are released.  Raise an exception\n    # if the barrier is reset or broken.\n    def _wait(self, timeout):\n        if not self._cond.wait_for(lambda : self._state != 0, timeout):\n            #timed out.  Break the barrier\n            self._break()\n            raise BrokenBarrierError\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 1\n\n    # If we are the last thread to exit the barrier, signal any threads\n    # waiting for the barrier to drain.\n    def _exit(self):\n        if self._count == 0:\n            if self._state in (-1, 1):\n                #resetting or draining\n                self._state = 0\n                self._cond.notify_all()\n\n    def reset(self):\n        \"\"\"Reset the barrier to the initial state.\n\n        Any threads currently waiting will get the BrokenBarrier exception\n        raised.\n\n        \"\"\"\n        with self._cond:\n            if self._count > 0:\n                if self._state == 0:\n                    #reset the barrier, waking up threads\n                    self._state = -1\n                elif self._state == -2:\n                    #was broken, set it to reset state\n                    #which clears when the last thread exits\n                    self._state = -1\n            else:\n                self._state = 0\n            self._cond.notify_all()\n\n    def abort(self):\n        \"\"\"Place the barrier into a 'broken' state.\n\n        Useful in case of error.  Any currently waiting threads and threads\n        attempting to 'wait()' will have BrokenBarrierError raised.\n\n        \"\"\"\n        with self._cond:\n            self._break()\n\n    def _break(self):\n        # An internal error was detected.  The barrier is set to\n        # a broken state all parties awakened.\n        self._state = -2\n        self._cond.notify_all()\n\n    @property\n    def parties(self):\n        \"\"\"Return the number of threads required to trip the barrier.\"\"\"\n        return self._parties\n\n    @property\n    def n_waiting(self):\n        \"\"\"Return the number of threads currently waiting at the barrier.\"\"\"\n        # We don't need synchronization here since this is an ephemeral result\n        # anyway.  It returns the correct value in the steady state.\n        if self._state == 0:\n            return self._count\n        return 0\n\n    @property\n    def broken(self):\n        \"\"\"Return True if the barrier is in a broken state.\"\"\"\n        return self._state == -2\n\n# exception raised by the Barrier class\nclass BrokenBarrierError(RuntimeError):\n    pass\n\n\n# Helper to generate new thread names\n_counter = _count(1).__next__\ndef _newname(name_template):\n    return name_template % _counter()\n\n# Active thread administration.\n#\n# bpo-44422: Use a reentrant lock to allow reentrant calls to functions like\n# threading.enumerate().\n_active_limbo_lock = RLock()\n_active = {}    # maps thread id to Thread object\n_limbo = {}\n_dangling = WeakSet()\n\n\n# Main class for threads\n\nclass Thread:\n    \"\"\"A class that represents a thread of control.\n\n    This class can be safely subclassed in a limited fashion. There are two ways\n    to specify the activity: by passing a callable object to the constructor, or\n    by overriding the run() method in a subclass.\n\n    \"\"\"\n\n    _initialized = False\n\n    def __init__(self, group=None, target=None, name=None,\n                 args=(), kwargs=None, *, daemon=None):\n        \"\"\"This constructor should always be called with keyword arguments. Arguments are:\n\n        *group* should be None; reserved for future extension when a ThreadGroup\n        class is implemented.\n\n        *target* is the callable object to be invoked by the run()\n        method. Defaults to None, meaning nothing is called.\n\n        *name* is the thread name. By default, a unique name is constructed of\n        the form \"Thread-N\" where N is a small decimal number.\n\n        *args* is a list or tuple of arguments for the target invocation. Defaults to ().\n\n        *kwargs* is a dictionary of keyword arguments for the target\n        invocation. Defaults to {}.\n\n        If a subclass overrides the constructor, it must make sure to invoke\n        the base class constructor (Thread.__init__()) before doing anything\n        else to the thread.\n\n        \"\"\"\n        assert group is None, \"group argument must be None for now\"\n        if kwargs is None:\n            kwargs = {}\n        if name:\n            name = str(name)\n        else:\n            name = _newname(\"Thread-%d\")\n            if target is not None:\n                try:\n                    target_name = target.__name__\n                    name += f\" ({target_name})\"\n                except AttributeError:\n                    pass\n\n        self._target = target\n        self._name = name\n        self._args = args\n        self._kwargs = kwargs\n        if daemon is not None:\n            if daemon and not _daemon_threads_allowed():\n                raise RuntimeError('daemon threads are disabled in this (sub)interpreter')\n            self._daemonic = daemon\n        else:\n            self._daemonic = current_thread().daemon\n        self._ident = None\n        if _HAVE_THREAD_NATIVE_ID:\n            self._native_id = None\n        self._handle = _ThreadHandle()\n        self._started = Event()\n        self._initialized = True\n        # Copy of sys.stderr used by self._invoke_excepthook()\n        self._stderr = _sys.stderr\n        self._invoke_excepthook = _make_invoke_excepthook()\n        # For debugging and _after_fork()\n        _dangling.add(self)\n\n    def _after_fork(self, new_ident=None):\n        # Private!  Called by threading._after_fork().\n        self._started._at_fork_reinit()\n        if new_ident is not None:\n            # This thread is alive.\n            self._ident = new_ident\n            assert self._handle.ident == new_ident\n        else:\n            # Otherwise, the thread is dead, Jim.  _PyThread_AfterFork()\n            # already marked our handle done.\n            pass\n\n    def __repr__(self):\n        assert self._initialized, \"Thread.__init__() was not called\"\n        status = \"initial\"\n        if self._started.is_set():\n            status = \"started\"\n        if self._handle.is_done():\n            status = \"stopped\"\n        if self._daemonic:\n            status += \" daemon\"\n        if self._ident is not None:\n            status += \" %s\" % self._ident\n        return \"<%s(%s, %s)>\" % (self.__class__.__name__, self._name, status)\n\n    def start(self):\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n        same thread object.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n            raise RuntimeError(\"threads can only be started once\")\n\n        with _active_limbo_lock:\n            _limbo[self] = self\n        try:\n            # Start joinable thread\n            _start_joinable_thread(self._bootstrap, handle=self._handle,\n                                   daemon=self.daemon)\n        except Exception:\n            with _active_limbo_lock:\n                del _limbo[self]\n            raise\n        self._started.wait()  # Will set ident and native_id\n\n    def run(self):\n        \"\"\"Method representing the thread's activity.\n\n        You may override this method in a subclass. The standard run() method\n        invokes the callable object passed to the object's constructor as the\n        target argument, if any, with sequential and keyword arguments taken\n        from the args and kwargs arguments, respectively.\n\n        \"\"\"\n        try:\n            if self._target is not None:\n                self._target(*self._args, **self._kwargs)\n        finally:\n            # Avoid a refcycle if the thread is running a function with\n            # an argument that has a member that points to the thread.\n            del self._target, self._args, self._kwargs\n\n    def _bootstrap(self):\n        # Wrapper around the real bootstrap code that ignores\n        # exceptions during interpreter cleanup.  Those typically\n        # happen when a daemon thread wakes up at an unfortunate\n        # moment, finds the world around it destroyed, and raises some\n        # random exception *** while trying to report the exception in\n        # _bootstrap_inner() below ***.  Those random exceptions\n        # don't help anybody, and they confuse users, so we suppress\n        # them.  We suppress them only when it appears that the world\n        # indeed has already been destroyed, so that exceptions in\n        # _bootstrap_inner() during normal business hours are properly\n        # reported.  Also, we only suppress them for daemonic threads;\n        # if a non-daemonic encounters this, something else is wrong.\n        try:\n            self._bootstrap_inner()\n        except:\n            if self._daemonic and _sys is None:\n                return\n            raise\n\n    def _set_ident(self):\n        self._ident = get_ident()\n\n    if _HAVE_THREAD_NATIVE_ID:\n        def _set_native_id(self):\n            self._native_id = get_native_id()\n\n    def _bootstrap_inner(self):\n        try:\n            self._set_ident()\n            if _HAVE_THREAD_NATIVE_ID:\n                self._set_native_id()\n            self._started.set()\n            with _active_limbo_lock:\n                _active[self._ident] = self\n                del _limbo[self]\n\n            if _trace_hook:\n                _sys.settrace(_trace_hook)\n            if _profile_hook:\n                _sys.setprofile(_profile_hook)\n\n            try:\n                self.run()\n            except:\n                self._invoke_excepthook(self)\n        finally:\n            self._delete()\n\n    def _delete(self):\n        \"Remove current thread from the dict of currently running threads.\"\n        with _active_limbo_lock:\n            del _active[get_ident()]\n            # There must not be any python code between the previous line\n            # and after the lock is released.  Otherwise a tracing function\n            # could try to acquire the lock again in the same thread, (in\n            # current_thread()), and would block.\n\n    def join(self, timeout=None):\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n        called terminates -- either normally or through an unhandled exception\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof). As join() always returns None, you must call\n        is_alive() after join() to decide whether a timeout happened -- if the\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n        thread as that would cause a deadlock. It is also an error to join() a\n        thread before it has been started and attempts to do so raises the same\n        exception.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if not self._started.is_set():\n            raise RuntimeError(\"cannot join thread before it is started\")\n        if self is current_thread():\n            raise RuntimeError(\"cannot join current thread\")\n\n        # the behavior of a negative timeout isn't documented, but\n        # historically .join(timeout=x) for x<0 has acted as if timeout=0\n        if timeout is not None:\n            timeout = max(timeout, 0)\n\n        self._handle.join(timeout)\n\n    @property\n    def name(self):\n        \"\"\"A string used for identification purposes only.\n\n        It has no semantics. Multiple threads may be given the same name. The\n        initial name is set by the constructor.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert self._initialized, \"Thread.__init__() not called\"\n        self._name = str(name)\n\n    @property\n    def ident(self):\n        \"\"\"Thread identifier of this thread or None if it has not been started.\n\n        This is a nonzero integer. See the get_ident() function. Thread\n        identifiers may be recycled when a thread exits and another thread is\n        created. The identifier is available even after the thread has exited.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._ident\n\n    if _HAVE_THREAD_NATIVE_ID:\n        @property\n        def native_id(self):\n            \"\"\"Native integral thread ID of this thread, or None if it has not been started.\n\n            This is a non-negative integer. See the get_native_id() function.\n            This represents the Thread ID as reported by the kernel.\n\n            \"\"\"\n            assert self._initialized, \"Thread.__init__() not called\"\n            return self._native_id\n\n    def is_alive(self):\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n        after the run() method terminates. See also the module function\n        enumerate().\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._started.is_set() and not self._handle.is_done()\n\n    @property\n    def daemon(self):\n        \"\"\"A boolean value indicating whether this thread is a daemon thread.\n\n        This must be set before start() is called, otherwise RuntimeError is\n        raised. Its initial value is inherited from the creating thread; the\n        main thread is not a daemon thread and therefore all threads created in\n        the main thread default to daemon = False.\n\n        The entire Python program exits when only daemon threads are left.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._daemonic\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if daemonic and not _daemon_threads_allowed():\n            raise RuntimeError('daemon threads are disabled in this interpreter')\n        if self._started.is_set():\n            raise RuntimeError(\"cannot set daemon status of active thread\")\n        self._daemonic = daemonic\n\n    def isDaemon(self):\n        \"\"\"Return whether this thread is a daemon.\n\n        This method is deprecated, use the daemon attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.daemon\n\n    def setDaemon(self, daemonic):\n        \"\"\"Set whether this thread is a daemon.\n\n        This method is deprecated, use the .daemon property instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        self.daemon = daemonic\n\n    def getName(self):\n        \"\"\"Return a string used for identification purposes only.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('getName() is deprecated, get the name attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.name\n\n    def setName(self, name):\n        \"\"\"Set the name string for this thread.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('setName() is deprecated, set the name attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        self.name = name\n\n\ntry:\n    from _thread import (_excepthook as excepthook,\n                         _ExceptHookArgs as ExceptHookArgs)\nexcept ImportError:\n    # Simple Python implementation if _thread._excepthook() is not available\n    from traceback import print_exception as _print_exception\n    from collections import namedtuple\n\n    _ExceptHookArgs = namedtuple(\n        'ExceptHookArgs',\n        'exc_type exc_value exc_traceback thread')\n\n    def ExceptHookArgs(args):\n        return _ExceptHookArgs(*args)\n\n    def excepthook(args, /):\n        \"\"\"\n        Handle uncaught Thread.run() exception.\n        \"\"\"\n        if args.exc_type == SystemExit:\n            # silently ignore SystemExit\n            return\n\n        if _sys is not None and _sys.stderr is not None:\n            stderr = _sys.stderr\n        elif args.thread is not None:\n            stderr = args.thread._stderr\n            if stderr is None:\n                # do nothing if sys.stderr is None and sys.stderr was None\n                # when the thread was created\n                return\n        else:\n            # do nothing if sys.stderr is None and args.thread is None\n            return\n\n        if args.thread is not None:\n            name = args.thread.name\n        else:\n            name = get_ident()\n        print(f\"Exception in thread {name}:\",\n              file=stderr, flush=True)\n        _print_exception(args.exc_type, args.exc_value, args.exc_traceback,\n                         file=stderr)\n        stderr.flush()\n\n\n# Original value of threading.excepthook\n__excepthook__ = excepthook\n\n\ndef _make_invoke_excepthook():\n    # Create a local namespace to ensure that variables remain alive\n    # when _invoke_excepthook() is called, even if it is called late during\n    # Python shutdown. It is mostly needed for daemon threads.\n\n    old_excepthook = excepthook\n    old_sys_excepthook = _sys.excepthook\n    if old_excepthook is None:\n        raise RuntimeError(\"threading.excepthook is None\")\n    if old_sys_excepthook is None:\n        raise RuntimeError(\"sys.excepthook is None\")\n\n    sys_exc_info = _sys.exc_info\n    local_print = print\n    local_sys = _sys\n\n    def invoke_excepthook(thread):\n        global excepthook\n        try:\n            hook = excepthook\n            if hook is None:\n                hook = old_excepthook\n\n            args = ExceptHookArgs([*sys_exc_info(), thread])\n\n            hook(args)\n        except Exception as exc:\n            exc.__suppress_context__ = True\n            del exc\n\n            if local_sys is not None and local_sys.stderr is not None:\n                stderr = local_sys.stderr\n            else:\n                stderr = thread._stderr\n\n            local_print(\"Exception in threading.excepthook:\",\n                        file=stderr, flush=True)\n\n            if local_sys is not None and local_sys.excepthook is not None:\n                sys_excepthook = local_sys.excepthook\n            else:\n                sys_excepthook = old_sys_excepthook\n\n            sys_excepthook(*sys_exc_info())\n        finally:\n            # Break reference cycle (exception stored in a variable)\n            args = None\n\n    return invoke_excepthook\n\n\n# The timer class was contributed by Itamar Shtull-Trauring\n\nclass Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n            t = Timer(30.0, f, args=None, kwargs=None)\n            t.start()\n            t.cancel()     # stop the timer's action if it's still waiting\n\n    \"\"\"\n\n    def __init__(self, interval, function, args=None, kwargs=None):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args if args is not None else []\n        self.kwargs = kwargs if kwargs is not None else {}\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet.\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.is_set():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n\n# Special thread class to represent the main thread\n\nclass _MainThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=\"MainThread\", daemon=False)\n        self._started.set()\n        self._ident = _get_main_thread_ident()\n        self._handle = _make_thread_handle(self._ident)\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n\n# Helper thread-local instance to detect when a _DummyThread\n# is collected. Not a part of the public API.\n_thread_local_info = local()\n\n\nclass _DeleteDummyThreadOnDel:\n    '''\n    Helper class to remove a dummy thread from threading._active on __del__.\n    '''\n\n    def __init__(self, dummy_thread):\n        self._dummy_thread = dummy_thread\n        self._tident = dummy_thread.ident\n        # Put the thread on a thread local variable so that when\n        # the related thread finishes this instance is collected.\n        #\n        # Note: no other references to this instance may be created.\n        # If any client code creates a reference to this instance,\n        # the related _DummyThread will be kept forever!\n        _thread_local_info._track_dummy_thread_ref = self\n\n    def __del__(self):\n        with _active_limbo_lock:\n            if _active.get(self._tident) is self._dummy_thread:\n                _active.pop(self._tident, None)\n\n\n# Dummy thread class to represent threads not started here.\n# These should be added to `_active` and removed automatically\n# when they die, although they can't be waited for.\n# Their purpose is to return *something* from current_thread().\n# They are marked as daemon threads so we won't wait for them\n# when we exit (conform previous semantics).\n\nclass _DummyThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=_newname(\"Dummy-%d\"),\n                        daemon=_daemon_threads_allowed())\n        self._started.set()\n        self._set_ident()\n        self._handle = _make_thread_handle(self._ident)\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n        _DeleteDummyThreadOnDel(self)\n\n    def is_alive(self):\n        if not self._handle.is_done() and self._started.is_set():\n            return True\n        raise RuntimeError(\"thread is not alive\")\n\n    def join(self, timeout=None):\n        raise RuntimeError(\"cannot join a dummy thread\")\n\n    def _after_fork(self, new_ident=None):\n        if new_ident is not None:\n            self.__class__ = _MainThread\n            self._name = 'MainThread'\n            self._daemonic = False\n        Thread._after_fork(self, new_ident=new_ident)\n\n\n# Global API functions\n\ndef current_thread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    If the caller's thread of control was not created through the threading\n    module, a dummy thread object with limited functionality is returned.\n\n    \"\"\"\n    try:\n        return _active[get_ident()]\n    except KeyError:\n        return _DummyThread()\n\ndef currentThread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    This function is deprecated, use current_thread() instead.\n\n    \"\"\"\n    import warnings\n    warnings.warn('currentThread() is deprecated, use current_thread() instead',\n                  DeprecationWarning, stacklevel=2)\n    return current_thread()\n\ndef active_count():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    The returned count is equal to the length of the list returned by\n    enumerate().\n\n    \"\"\"\n    # NOTE: if the logic in here ever changes, update Modules/posixmodule.c\n    # warn_about_fork_with_threads() to match.\n    with _active_limbo_lock:\n        return len(_active) + len(_limbo)\n\ndef activeCount():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    This function is deprecated, use active_count() instead.\n\n    \"\"\"\n    import warnings\n    warnings.warn('activeCount() is deprecated, use active_count() instead',\n                  DeprecationWarning, stacklevel=2)\n    return active_count()\n\ndef _enumerate():\n    # Same as enumerate(), but without the lock. Internal use only.\n    return list(_active.values()) + list(_limbo.values())\n\ndef enumerate():\n    \"\"\"Return a list of all Thread objects currently alive.\n\n    The list includes daemonic threads, dummy thread objects created by\n    current_thread(), and the main thread. It excludes terminated threads and\n    threads that have not yet been started.\n\n    \"\"\"\n    with _active_limbo_lock:\n        return list(_active.values()) + list(_limbo.values())\n\n\n_threading_atexits = []\n_SHUTTING_DOWN = False\n\ndef _register_atexit(func, *arg, **kwargs):\n    \"\"\"CPython internal: register *func* to be called before joining threads.\n\n    The registered *func* is called with its arguments just before all\n    non-daemon threads are joined in `_shutdown()`. It provides a similar\n    purpose to `atexit.register()`, but its functions are called prior to\n    threading shutdown instead of interpreter shutdown.\n\n    For similarity to atexit, the registered functions are called in reverse.\n    \"\"\"\n    if _SHUTTING_DOWN:\n        raise RuntimeError(\"can't register atexit after shutdown\")\n\n    _threading_atexits.append(lambda: func(*arg, **kwargs))\n\n\nfrom _thread import stack_size\n\n# Create the main thread object,\n# and make it available for the interpreter\n# (Py_Main) as threading._shutdown.\n\n_main_thread = _MainThread()\n\ndef _shutdown():\n    \"\"\"\n    Wait until the Python thread state of all non-daemon threads get deleted.\n    \"\"\"\n    # Obscure: other threads may be waiting to join _main_thread.  That's\n    # dubious, but some code does it. We can't wait for it to be marked as done\n    # normally - that won't happen until the interpreter is nearly dead. So\n    # mark it done here.\n    if _main_thread._handle.is_done() and _is_main_interpreter():\n        # _shutdown() was already called\n        return\n\n    global _SHUTTING_DOWN\n    _SHUTTING_DOWN = True\n\n    # Call registered threading atexit functions before threads are joined.\n    # Order is reversed, similar to atexit.\n    for atexit_call in reversed(_threading_atexits):\n        atexit_call()\n\n    if _is_main_interpreter():\n        _main_thread._handle._set_done()\n\n    # Wait for all non-daemon threads to exit.\n    _thread_shutdown()\n\n\ndef main_thread():\n    \"\"\"Return the main thread object.\n\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    \"\"\"\n    # XXX Figure this out for subinterpreters.  (See gh-75698.)\n    return _main_thread\n\n\ndef _after_fork():\n    \"\"\"\n    Cleanup threading module state that should not exist after a fork.\n    \"\"\"\n    # Reset _active_limbo_lock, in case we forked while the lock was held\n    # by another (non-forked) thread.  http://bugs.python.org/issue874900\n    global _active_limbo_lock, _main_thread\n    _active_limbo_lock = RLock()\n\n    # fork() only copied the current thread; clear references to others.\n    new_active = {}\n\n    try:\n        current = _active[get_ident()]\n    except KeyError:\n        # fork() was called in a thread which was not spawned\n        # by threading.Thread. For example, a thread spawned\n        # by thread.start_new_thread().\n        current = _MainThread()\n\n    _main_thread = current\n\n    with _active_limbo_lock:\n        # Dangling thread instances must still have their locks reset,\n        # because someone may join() them.\n        threads = set(_enumerate())\n        threads.update(_dangling)\n        for thread in threads:\n            # Any lock/condition variable may be currently locked or in an\n            # invalid state, so we reinitialize them.\n            if thread is current:\n                # This is the one and only active thread.\n                ident = get_ident()\n                thread._after_fork(new_ident=ident)\n                new_active[ident] = thread\n            else:\n                # All the others are already stopped.\n                thread._after_fork()\n\n        _limbo.clear()\n        _active.clear()\n        _active.update(new_active)\n        assert len(_active) == 1\n\n\nif hasattr(_os, \"register_at_fork\"):\n    _os.register_at_fork(after_in_child=_after_fork)\n", 1599], "C:\\Programming\\Python313\\Lib\\_weakrefset.py": ["# Access WeakSet through the weakref module.\n# This code is separated-out because it is needed\n# by abc.py to load everything else at startup.\n\nfrom _weakref import ref\nfrom types import GenericAlias\n\n__all__ = ['WeakSet']\n\n\nclass _IterationGuard:\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n\n    def __enter__(self):\n        w = self.weakcontainer()\n        if w is not None:\n            w._iterating.add(self)\n        return self\n\n    def __exit__(self, e, t, b):\n        w = self.weakcontainer()\n        if w is not None:\n            s = w._iterating\n            s.remove(self)\n            if not s:\n                w._commit_removals()\n\n\nclass WeakSet:\n    def __init__(self, data=None):\n        self.data = set()\n        def _remove(item, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(item)\n                else:\n                    self.data.discard(item)\n        self._remove = _remove\n        # A list of keys to be removed\n        self._pending_removals = []\n        self._iterating = set()\n        if data is not None:\n            self.update(data)\n\n    def _commit_removals(self):\n        pop = self._pending_removals.pop\n        discard = self.data.discard\n        while True:\n            try:\n                item = pop()\n            except IndexError:\n                return\n            discard(item)\n\n    def __iter__(self):\n        with _IterationGuard(self):\n            for itemref in self.data:\n                item = itemref()\n                if item is not None:\n                    # Caveat: the iterator will keep a strong reference to\n                    # `item` until it is resumed or closed.\n                    yield item\n\n    def __len__(self):\n        return len(self.data) - len(self._pending_removals)\n\n    def __contains__(self, item):\n        try:\n            wr = ref(item)\n        except TypeError:\n            return False\n        return wr in self.data\n\n    def __reduce__(self):\n        return self.__class__, (list(self),), self.__getstate__()\n\n    def add(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.add(ref(item, self._remove))\n\n    def clear(self):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.clear()\n\n    def copy(self):\n        return self.__class__(self)\n\n    def pop(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            try:\n                itemref = self.data.pop()\n            except KeyError:\n                raise KeyError('pop from empty WeakSet') from None\n            item = itemref()\n            if item is not None:\n                return item\n\n    def remove(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.remove(ref(item))\n\n    def discard(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.discard(ref(item))\n\n    def update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        for element in other:\n            self.add(element)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def difference(self, other):\n        newset = self.copy()\n        newset.difference_update(other)\n        return newset\n    __sub__ = difference\n\n    def difference_update(self, other):\n        self.__isub__(other)\n    def __isub__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.difference_update(ref(item) for item in other)\n        return self\n\n    def intersection(self, other):\n        return self.__class__(item for item in other if item in self)\n    __and__ = intersection\n\n    def intersection_update(self, other):\n        self.__iand__(other)\n    def __iand__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.intersection_update(ref(item) for item in other)\n        return self\n\n    def issubset(self, other):\n        return self.data.issubset(ref(item) for item in other)\n    __le__ = issubset\n\n    def __lt__(self, other):\n        return self.data < set(map(ref, other))\n\n    def issuperset(self, other):\n        return self.data.issuperset(ref(item) for item in other)\n    __ge__ = issuperset\n\n    def __gt__(self, other):\n        return self.data > set(map(ref, other))\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.data == set(map(ref, other))\n\n    def symmetric_difference(self, other):\n        newset = self.copy()\n        newset.symmetric_difference_update(other)\n        return newset\n    __xor__ = symmetric_difference\n\n    def symmetric_difference_update(self, other):\n        self.__ixor__(other)\n    def __ixor__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.symmetric_difference_update(ref(item, self._remove) for item in other)\n        return self\n\n    def union(self, other):\n        return self.__class__(e for s in (self, other) for e in s)\n    __or__ = union\n\n    def isdisjoint(self, other):\n        return len(self.intersection(other)) == 0\n\n    def __repr__(self):\n        return repr(self.data)\n\n    __class_getitem__ = classmethod(GenericAlias)\n", 205], "C:\\Programming\\Python313\\Lib\\runpy.py": ["\"\"\"runpy.py - locating and running Python code using the module namespace\n\nProvides support for locating and running Python scripts using the Python\nmodule namespace instead of the native filesystem.\n\nThis allows Python code to play nicely with non-filesystem based PEP 302\nimporters when locating support scripts as well as when importing modules.\n\"\"\"\n# Written by Nick Coghlan <ncoghlan at gmail.com>\n#    to implement PEP 338 (Executing Modules as Scripts)\n\n\nimport sys\nimport importlib.machinery # importlib first so we can test #15386 via -m\nimport importlib.util\nimport io\nimport os\n\n__all__ = [\n    \"run_module\", \"run_path\",\n]\n\n# avoid 'import types' just for ModuleType\nModuleType = type(sys)\n\nclass _TempModule(object):\n    \"\"\"Temporarily replace a module in sys.modules with an empty namespace\"\"\"\n    def __init__(self, mod_name):\n        self.mod_name = mod_name\n        self.module = ModuleType(mod_name)\n        self._saved_module = []\n\n    def __enter__(self):\n        mod_name = self.mod_name\n        try:\n            self._saved_module.append(sys.modules[mod_name])\n        except KeyError:\n            pass\n        sys.modules[mod_name] = self.module\n        return self\n\n    def __exit__(self, *args):\n        if self._saved_module:\n            sys.modules[self.mod_name] = self._saved_module[0]\n        else:\n            del sys.modules[self.mod_name]\n        self._saved_module = []\n\nclass _ModifiedArgv0(object):\n    def __init__(self, value):\n        self.value = value\n        self._saved_value = self._sentinel = object()\n\n    def __enter__(self):\n        if self._saved_value is not self._sentinel:\n            raise RuntimeError(\"Already preserving saved value\")\n        self._saved_value = sys.argv[0]\n        sys.argv[0] = self.value\n\n    def __exit__(self, *args):\n        self.value = self._sentinel\n        sys.argv[0] = self._saved_value\n\n# TODO: Replace these helpers with importlib._bootstrap_external functions.\ndef _run_code(code, run_globals, init_globals=None,\n              mod_name=None, mod_spec=None,\n              pkg_name=None, script_name=None):\n    \"\"\"Helper to run code in nominated namespace\"\"\"\n    if init_globals is not None:\n        run_globals.update(init_globals)\n    if mod_spec is None:\n        loader = None\n        fname = script_name\n        cached = None\n    else:\n        loader = mod_spec.loader\n        fname = mod_spec.origin\n        cached = mod_spec.cached\n        if pkg_name is None:\n            pkg_name = mod_spec.parent\n    run_globals.update(__name__ = mod_name,\n                       __file__ = fname,\n                       __cached__ = cached,\n                       __doc__ = None,\n                       __loader__ = loader,\n                       __package__ = pkg_name,\n                       __spec__ = mod_spec)\n    exec(code, run_globals)\n    return run_globals\n\ndef _run_module_code(code, init_globals=None,\n                    mod_name=None, mod_spec=None,\n                    pkg_name=None, script_name=None):\n    \"\"\"Helper to run code in new namespace with sys modified\"\"\"\n    fname = script_name if mod_spec is None else mod_spec.origin\n    with _TempModule(mod_name) as temp_module, _ModifiedArgv0(fname):\n        mod_globals = temp_module.module.__dict__\n        _run_code(code, mod_globals, init_globals,\n                  mod_name, mod_spec, pkg_name, script_name)\n    # Copy the globals of the temporary module, as they\n    # may be cleared when the temporary module goes away\n    return mod_globals.copy()\n\n# Helper to get the full name, spec and code for a module\ndef _get_module_details(mod_name, error=ImportError):\n    if mod_name.startswith(\".\"):\n        raise error(\"Relative module names not supported\")\n    pkg_name, _, _ = mod_name.rpartition(\".\")\n    if pkg_name:\n        # Try importing the parent to avoid catching initialization errors\n        try:\n            __import__(pkg_name)\n        except ImportError as e:\n            # If the parent or higher ancestor package is missing, let the\n            # error be raised by find_spec() below and then be caught. But do\n            # not allow other errors to be caught.\n            if e.name is None or (e.name != pkg_name and\n                    not pkg_name.startswith(e.name + \".\")):\n                raise\n        # Warn if the module has already been imported under its normal name\n        existing = sys.modules.get(mod_name)\n        if existing is not None and not hasattr(existing, \"__path__\"):\n            from warnings import warn\n            msg = \"{mod_name!r} found in sys.modules after import of \" \\\n                \"package {pkg_name!r}, but prior to execution of \" \\\n                \"{mod_name!r}; this may result in unpredictable \" \\\n                \"behaviour\".format(mod_name=mod_name, pkg_name=pkg_name)\n            warn(RuntimeWarning(msg))\n\n    try:\n        spec = importlib.util.find_spec(mod_name)\n    except (ImportError, AttributeError, TypeError, ValueError) as ex:\n        # This hack fixes an impedance mismatch between pkgutil and\n        # importlib, where the latter raises other errors for cases where\n        # pkgutil previously raised ImportError\n        msg = \"Error while finding module specification for {!r} ({}: {})\"\n        if mod_name.endswith(\".py\"):\n            msg += (f\". Try using '{mod_name[:-3]}' instead of \"\n                    f\"'{mod_name}' as the module name.\")\n        raise error(msg.format(mod_name, type(ex).__name__, ex)) from ex\n    if spec is None:\n        raise error(\"No module named %s\" % mod_name)\n    if spec.submodule_search_locations is not None:\n        if mod_name == \"__main__\" or mod_name.endswith(\".__main__\"):\n            raise error(\"Cannot use package as __main__ module\")\n        try:\n            pkg_main_name = mod_name + \".__main__\"\n            return _get_module_details(pkg_main_name, error)\n        except error as e:\n            if mod_name not in sys.modules:\n                raise  # No module loaded; being a package is irrelevant\n            raise error((\"%s; %r is a package and cannot \" +\n                               \"be directly executed\") %(e, mod_name))\n    loader = spec.loader\n    if loader is None:\n        raise error(\"%r is a namespace package and cannot be executed\"\n                                                                 % mod_name)\n    try:\n        code = loader.get_code(mod_name)\n    except ImportError as e:\n        raise error(format(e)) from e\n    if code is None:\n        raise error(\"No code object available for %s\" % mod_name)\n    return mod_name, spec, code\n\nclass _Error(Exception):\n    \"\"\"Error that _run_module_as_main() should report without a traceback\"\"\"\n\n# XXX ncoghlan: Should this be documented and made public?\n# (Current thoughts: don't repeat the mistake that lead to its\n# creation when run_module() no longer met the needs of\n# mainmodule.c, but couldn't be changed because it was public)\ndef _run_module_as_main(mod_name, alter_argv=True):\n    \"\"\"Runs the designated module in the __main__ namespace\n\n       Note that the executed module will have full access to the\n       __main__ namespace. If this is not desirable, the run_module()\n       function should be used to run the module code in a fresh namespace.\n\n       At the very least, these variables in __main__ will be overwritten:\n           __name__\n           __file__\n           __cached__\n           __loader__\n           __package__\n    \"\"\"\n    try:\n        if alter_argv or mod_name != \"__main__\": # i.e. -m switch\n            mod_name, mod_spec, code = _get_module_details(mod_name, _Error)\n        else:          # i.e. directory or zipfile execution\n            mod_name, mod_spec, code = _get_main_module_details(_Error)\n    except _Error as exc:\n        msg = \"%s: %s\" % (sys.executable, exc)\n        sys.exit(msg)\n    main_globals = sys.modules[\"__main__\"].__dict__\n    if alter_argv:\n        sys.argv[0] = mod_spec.origin\n    return _run_code(code, main_globals, None,\n                     \"__main__\", mod_spec)\n\ndef run_module(mod_name, init_globals=None,\n               run_name=None, alter_sys=False):\n    \"\"\"Execute a module's code without importing it.\n\n       mod_name -- an absolute module name or package name.\n\n       Optional arguments:\n       init_globals -- dictionary used to pre-populate the module\u2019s\n       globals dictionary before the code is executed.\n\n       run_name -- if not None, this will be used for setting __name__;\n       otherwise, __name__ will be set to mod_name + '__main__' if the\n       named module is a package and to just mod_name otherwise.\n\n       alter_sys -- if True, sys.argv[0] is updated with the value of\n       __file__ and sys.modules[__name__] is updated with a temporary\n       module object for the module being executed. Both are\n       restored to their original values before the function returns.\n\n       Returns the resulting module globals dictionary.\n    \"\"\"\n    mod_name, mod_spec, code = _get_module_details(mod_name)\n    if run_name is None:\n        run_name = mod_name\n    if alter_sys:\n        return _run_module_code(code, init_globals, run_name, mod_spec)\n    else:\n        # Leave the sys module alone\n        return _run_code(code, {}, init_globals, run_name, mod_spec)\n\ndef _get_main_module_details(error=ImportError):\n    # Helper that gives a nicer error message when attempting to\n    # execute a zipfile or directory by invoking __main__.py\n    # Also moves the standard __main__ out of the way so that the\n    # preexisting __loader__ entry doesn't cause issues\n    main_name = \"__main__\"\n    saved_main = sys.modules[main_name]\n    del sys.modules[main_name]\n    try:\n        return _get_module_details(main_name)\n    except ImportError as exc:\n        if main_name in str(exc):\n            raise error(\"can't find %r module in %r\" %\n                              (main_name, sys.path[0])) from exc\n        raise\n    finally:\n        sys.modules[main_name] = saved_main\n\n\ndef _get_code_from_file(fname):\n    # Check for a compiled file first\n    from pkgutil import read_code\n    code_path = os.path.abspath(fname)\n    with io.open_code(code_path) as f:\n        code = read_code(f)\n    if code is None:\n        # That didn't work, so try it as normal source code\n        with io.open_code(code_path) as f:\n            code = compile(f.read(), fname, 'exec')\n    return code\n\ndef run_path(path_name, init_globals=None, run_name=None):\n    \"\"\"Execute code located at the specified filesystem location.\n\n       path_name -- filesystem location of a Python script, zipfile,\n       or directory containing a top level __main__.py script.\n\n       Optional arguments:\n       init_globals -- dictionary used to pre-populate the module\u2019s\n       globals dictionary before the code is executed.\n\n       run_name -- if not None, this will be used to set __name__;\n       otherwise, '<run_path>' will be used for __name__.\n\n       Returns the resulting module globals dictionary.\n    \"\"\"\n    if run_name is None:\n        run_name = \"<run_path>\"\n    pkg_name = run_name.rpartition(\".\")[0]\n    from pkgutil import get_importer\n    importer = get_importer(path_name)\n    path_name = os.fsdecode(path_name)\n    if isinstance(importer, type(None)):\n        # Not a valid sys.path entry, so run the code directly\n        # execfile() doesn't help as we want to allow compiled files\n        code = _get_code_from_file(path_name)\n        return _run_module_code(code, init_globals, run_name,\n                                pkg_name=pkg_name, script_name=path_name)\n    else:\n        # Finder is defined for path, so add it to\n        # the start of sys.path\n        sys.path.insert(0, path_name)\n        try:\n            # Here's where things are a little different from the run_module\n            # case. There, we only had to replace the module in sys while the\n            # code was running and doing so was somewhat optional. Here, we\n            # have no choice and we have to remove it even while we read the\n            # code. If we don't do this, a __loader__ attribute in the\n            # existing __main__ module may prevent location of the new module.\n            mod_name, mod_spec, code = _get_main_module_details()\n            with _TempModule(run_name) as temp_module, \\\n                 _ModifiedArgv0(path_name):\n                mod_globals = temp_module.module.__dict__\n                return _run_code(code, mod_globals, init_globals,\n                                    run_name, mod_spec, pkg_name).copy()\n        finally:\n            try:\n                sys.path.remove(path_name)\n            except ValueError:\n                pass\n\n\nif __name__ == \"__main__\":\n    # Run the module specified as the next command line argument\n    if len(sys.argv) < 2:\n        print(\"No module specified for execution\", file=sys.stderr)\n    else:\n        del sys.argv[0] # Make the requested module sys.argv[0]\n        _run_module_as_main(sys.argv[0])\n", 319], "C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py": ["#\n# Code used to start processes when using the spawn or forkserver\n# start methods.\n#\n# multiprocessing/spawn.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\nimport os\nimport sys\nimport runpy\nimport types\n\nfrom . import get_start_method, set_start_method\nfrom . import process\nfrom .context import reduction\nfrom . import util\n\n__all__ = ['_main', 'freeze_support', 'set_executable', 'get_executable',\n           'get_preparation_data', 'get_command_line', 'import_main_path']\n\n#\n# _python_exe is the assumed path to the python executable.\n# People embedding Python want to modify it.\n#\n\nif sys.platform != 'win32':\n    WINEXE = False\n    WINSERVICE = False\nelse:\n    WINEXE = getattr(sys, 'frozen', False)\n    WINSERVICE = sys.executable and sys.executable.lower().endswith(\"pythonservice.exe\")\n\ndef set_executable(exe):\n    global _python_exe\n    if exe is None:\n        _python_exe = exe\n    elif sys.platform == 'win32':\n        _python_exe = os.fsdecode(exe)\n    else:\n        _python_exe = os.fsencode(exe)\n\ndef get_executable():\n    return _python_exe\n\nif WINSERVICE:\n    set_executable(os.path.join(sys.exec_prefix, 'python.exe'))\nelse:\n    set_executable(sys.executable)\n\n#\n#\n#\n\ndef is_forking(argv):\n    '''\n    Return whether commandline indicates we are forking\n    '''\n    if len(argv) >= 2 and argv[1] == '--multiprocessing-fork':\n        return True\n    else:\n        return False\n\n\ndef freeze_support():\n    '''\n    Run code for process object if this in not the main process\n    '''\n    if is_forking(sys.argv):\n        kwds = {}\n        for arg in sys.argv[2:]:\n            name, value = arg.split('=')\n            if value == 'None':\n                kwds[name] = None\n            else:\n                kwds[name] = int(value)\n        spawn_main(**kwds)\n        sys.exit()\n\n\ndef get_command_line(**kwds):\n    '''\n    Returns prefix of command line used for spawning a child process\n    '''\n    if getattr(sys, 'frozen', False):\n        return ([sys.executable, '--multiprocessing-fork'] +\n                ['%s=%r' % item for item in kwds.items()])\n    else:\n        prog = 'from multiprocessing.spawn import spawn_main; spawn_main(%s)'\n        prog %= ', '.join('%s=%r' % item for item in kwds.items())\n        opts = util._args_from_interpreter_flags()\n        exe = get_executable()\n        return [exe] + opts + ['-c', prog, '--multiprocessing-fork']\n\n\ndef spawn_main(pipe_handle, parent_pid=None, tracker_fd=None):\n    '''\n    Run code specified by data received over pipe\n    '''\n    assert is_forking(sys.argv), \"Not forking\"\n    if sys.platform == 'win32':\n        import msvcrt\n        import _winapi\n\n        if parent_pid is not None:\n            source_process = _winapi.OpenProcess(\n                _winapi.SYNCHRONIZE | _winapi.PROCESS_DUP_HANDLE,\n                False, parent_pid)\n        else:\n            source_process = None\n        new_handle = reduction.duplicate(pipe_handle,\n                                         source_process=source_process)\n        fd = msvcrt.open_osfhandle(new_handle, os.O_RDONLY)\n        parent_sentinel = source_process\n    else:\n        from . import resource_tracker\n        resource_tracker._resource_tracker._fd = tracker_fd\n        fd = pipe_handle\n        parent_sentinel = os.dup(pipe_handle)\n    exitcode = _main(fd, parent_sentinel)\n    sys.exit(exitcode)\n\n\ndef _main(fd, parent_sentinel):\n    with os.fdopen(fd, 'rb', closefd=True) as from_parent:\n        process.current_process()._inheriting = True\n        try:\n            preparation_data = reduction.pickle.load(from_parent)\n            prepare(preparation_data)\n            self = reduction.pickle.load(from_parent)\n        finally:\n            del process.current_process()._inheriting\n    return self._bootstrap(parent_sentinel)\n\n\ndef _check_not_importing_main():\n    if getattr(process.current_process(), '_inheriting', False):\n        raise RuntimeError('''\n        An attempt has been made to start a new process before the\n        current process has finished its bootstrapping phase.\n\n        This probably means that you are not using fork to start your\n        child processes and you have forgotten to use the proper idiom\n        in the main module:\n\n            if __name__ == '__main__':\n                freeze_support()\n                ...\n\n        The \"freeze_support()\" line can be omitted if the program\n        is not going to be frozen to produce an executable.\n\n        To fix this issue, refer to the \"Safe importing of main module\"\n        section in https://docs.python.org/3/library/multiprocessing.html\n        ''')\n\n\ndef get_preparation_data(name):\n    '''\n    Return info about parent needed by child to unpickle process object\n    '''\n    _check_not_importing_main()\n    d = dict(\n        log_to_stderr=util._log_to_stderr,\n        authkey=process.current_process().authkey,\n        )\n\n    if util._logger is not None:\n        d['log_level'] = util._logger.getEffectiveLevel()\n\n    sys_path=sys.path.copy()\n    try:\n        i = sys_path.index('')\n    except ValueError:\n        pass\n    else:\n        sys_path[i] = process.ORIGINAL_DIR\n\n    d.update(\n        name=name,\n        sys_path=sys_path,\n        sys_argv=sys.argv,\n        orig_dir=process.ORIGINAL_DIR,\n        dir=os.getcwd(),\n        start_method=get_start_method(),\n        )\n\n    # Figure out whether to initialise main in the subprocess as a module\n    # or through direct execution (or to leave it alone entirely)\n    main_module = sys.modules['__main__']\n    main_mod_name = getattr(main_module.__spec__, \"name\", None)\n    if main_mod_name is not None:\n        d['init_main_from_name'] = main_mod_name\n    elif sys.platform != 'win32' or (not WINEXE and not WINSERVICE):\n        main_path = getattr(main_module, '__file__', None)\n        if main_path is not None:\n            if (not os.path.isabs(main_path) and\n                        process.ORIGINAL_DIR is not None):\n                main_path = os.path.join(process.ORIGINAL_DIR, main_path)\n            d['init_main_from_path'] = os.path.normpath(main_path)\n\n    return d\n\n#\n# Prepare current process\n#\n\nold_main_modules = []\n\ndef prepare(data):\n    '''\n    Try to get current process ready to unpickle process object\n    '''\n    if 'name' in data:\n        process.current_process().name = data['name']\n\n    if 'authkey' in data:\n        process.current_process().authkey = data['authkey']\n\n    if 'log_to_stderr' in data and data['log_to_stderr']:\n        util.log_to_stderr()\n\n    if 'log_level' in data:\n        util.get_logger().setLevel(data['log_level'])\n\n    if 'sys_path' in data:\n        sys.path = data['sys_path']\n\n    if 'sys_argv' in data:\n        sys.argv = data['sys_argv']\n\n    if 'dir' in data:\n        os.chdir(data['dir'])\n\n    if 'orig_dir' in data:\n        process.ORIGINAL_DIR = data['orig_dir']\n\n    if 'start_method' in data:\n        set_start_method(data['start_method'], force=True)\n\n    if 'init_main_from_name' in data:\n        _fixup_main_from_name(data['init_main_from_name'])\n    elif 'init_main_from_path' in data:\n        _fixup_main_from_path(data['init_main_from_path'])\n\n# Multiprocessing module helpers to fix up the main module in\n# spawned subprocesses\ndef _fixup_main_from_name(mod_name):\n    # __main__.py files for packages, directories, zip archives, etc, run\n    # their \"main only\" code unconditionally, so we don't even try to\n    # populate anything in __main__, nor do we make any changes to\n    # __main__ attributes\n    current_main = sys.modules['__main__']\n    if mod_name == \"__main__\" or mod_name.endswith(\".__main__\"):\n        return\n\n    # If this process was forked, __main__ may already be populated\n    if getattr(current_main.__spec__, \"name\", None) == mod_name:\n        return\n\n    # Otherwise, __main__ may contain some non-main code where we need to\n    # support unpickling it properly. We rerun it as __mp_main__ and make\n    # the normal __main__ an alias to that\n    old_main_modules.append(current_main)\n    main_module = types.ModuleType(\"__mp_main__\")\n    main_content = runpy.run_module(mod_name,\n                                    run_name=\"__mp_main__\",\n                                    alter_sys=True)\n    main_module.__dict__.update(main_content)\n    sys.modules['__main__'] = sys.modules['__mp_main__'] = main_module\n\n\ndef _fixup_main_from_path(main_path):\n    # If this process was forked, __main__ may already be populated\n    current_main = sys.modules['__main__']\n\n    # Unfortunately, the main ipython launch script historically had no\n    # \"if __name__ == '__main__'\" guard, so we work around that\n    # by treating it like a __main__.py file\n    # See https://github.com/ipython/ipython/issues/4698\n    main_name = os.path.splitext(os.path.basename(main_path))[0]\n    if main_name == 'ipython':\n        return\n\n    # Otherwise, if __file__ already has the setting we expect,\n    # there's nothing more to do\n    if getattr(current_main, '__file__', None) == main_path:\n        return\n\n    # If the parent process has sent a path through rather than a module\n    # name we assume it is an executable script that may contain\n    # non-main code that needs to be executed\n    old_main_modules.append(current_main)\n    main_module = types.ModuleType(\"__mp_main__\")\n    main_content = runpy.run_path(main_path,\n                                  run_name=\"__mp_main__\")\n    main_module.__dict__.update(main_content)\n    sys.modules['__main__'] = sys.modules['__mp_main__'] = main_module\n\n\ndef import_main_path(main_path):\n    '''\n    Set sys.modules['__main__'] to module at main_path\n    '''\n    _fixup_main_from_path(main_path)\n", 307], "C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py": ["import os\nimport msvcrt\nimport signal\nimport sys\nimport _winapi\nfrom subprocess import STARTUPINFO, STARTF_FORCEOFFFEEDBACK\n\nfrom .context import reduction, get_spawning_popen, set_spawning_popen\nfrom . import spawn\nfrom . import util\n\n__all__ = ['Popen']\n\n#\n#\n#\n\n# Exit code used by Popen.terminate()\nTERMINATE = 0x10000\nWINEXE = (sys.platform == 'win32' and getattr(sys, 'frozen', False))\nWINSERVICE = sys.executable.lower().endswith(\"pythonservice.exe\")\n\n\ndef _path_eq(p1, p2):\n    return p1 == p2 or os.path.normcase(p1) == os.path.normcase(p2)\n\nWINENV = not _path_eq(sys.executable, sys._base_executable)\n\n\ndef _close_handles(*handles):\n    for handle in handles:\n        _winapi.CloseHandle(handle)\n\n\n#\n# We define a Popen class similar to the one from subprocess, but\n# whose constructor takes a process object as its argument.\n#\n\nclass Popen(object):\n    '''\n    Start a subprocess to run the code of a process object\n    '''\n    method = 'spawn'\n\n    def __init__(self, process_obj):\n        prep_data = spawn.get_preparation_data(process_obj._name)\n\n        # read end of pipe will be duplicated by the child process\n        # -- see spawn_main() in spawn.py.\n        #\n        # bpo-33929: Previously, the read end of pipe was \"stolen\" by the child\n        # process, but it leaked a handle if the child process had been\n        # terminated before it could steal the handle from the parent process.\n        rhandle, whandle = _winapi.CreatePipe(None, 0)\n        wfd = msvcrt.open_osfhandle(whandle, 0)\n        cmd = spawn.get_command_line(parent_pid=os.getpid(),\n                                     pipe_handle=rhandle)\n\n        python_exe = spawn.get_executable()\n\n        # bpo-35797: When running in a venv, we bypass the redirect\n        # executor and launch our base Python.\n        if WINENV and _path_eq(python_exe, sys.executable):\n            cmd[0] = python_exe = sys._base_executable\n            env = os.environ.copy()\n            env[\"__PYVENV_LAUNCHER__\"] = sys.executable\n        else:\n            env = None\n\n        cmd = ' '.join('\"%s\"' % x for x in cmd)\n\n        with open(wfd, 'wb', closefd=True) as to_child:\n            # start process\n            try:\n                hp, ht, pid, tid = _winapi.CreateProcess(\n                    python_exe, cmd,\n                    None, None, False, 0, env, None,\n                    STARTUPINFO(dwFlags=STARTF_FORCEOFFFEEDBACK))\n                _winapi.CloseHandle(ht)\n            except:\n                _winapi.CloseHandle(rhandle)\n                raise\n\n            # set attributes of self\n            self.pid = pid\n            self.returncode = None\n            self._handle = hp\n            self.sentinel = int(hp)\n            self.finalizer = util.Finalize(self, _close_handles,\n                                           (self.sentinel, int(rhandle)))\n\n            # send information to child\n            set_spawning_popen(self)\n            try:\n                reduction.dump(prep_data, to_child)\n                reduction.dump(process_obj, to_child)\n            finally:\n                set_spawning_popen(None)\n\n    def duplicate_for_child(self, handle):\n        assert self is get_spawning_popen()\n        return reduction.duplicate(handle, self.sentinel)\n\n    def wait(self, timeout=None):\n        if self.returncode is not None:\n            return self.returncode\n\n        if timeout is None:\n            msecs = _winapi.INFINITE\n        else:\n            msecs = max(0, int(timeout * 1000 + 0.5))\n\n        res = _winapi.WaitForSingleObject(int(self._handle), msecs)\n        if res == _winapi.WAIT_OBJECT_0:\n            code = _winapi.GetExitCodeProcess(self._handle)\n            if code == TERMINATE:\n                code = -signal.SIGTERM\n            self.returncode = code\n\n        return self.returncode\n\n    def poll(self):\n        return self.wait(timeout=0)\n\n    def terminate(self):\n        if self.returncode is not None:\n            return\n\n        try:\n            _winapi.TerminateProcess(int(self._handle), TERMINATE)\n        except PermissionError:\n            # ERROR_ACCESS_DENIED (winerror 5) is received when the\n            # process already died.\n            code = _winapi.GetExitCodeProcess(int(self._handle))\n            if code == _winapi.STILL_ACTIVE:\n                raise\n\n        # gh-113009: Don't set self.returncode. Even if GetExitCodeProcess()\n        # returns an exit code different than STILL_ACTIVE, the process can\n        # still be running. Only set self.returncode once WaitForSingleObject()\n        # returns WAIT_OBJECT_0 in wait().\n\n    kill = terminate\n\n    def close(self):\n        self.finalizer()\n", 147], "C:\\Programming\\Python313\\Lib\\copyreg.py": ["\"\"\"Helper to provide extensibility for pickle.\n\nThis is only useful to add pickle support for extension types defined in\nC, not for instances of user-defined classes.\n\"\"\"\n\n__all__ = [\"pickle\", \"constructor\",\n           \"add_extension\", \"remove_extension\", \"clear_extension_cache\"]\n\ndispatch_table = {}\n\ndef pickle(ob_type, pickle_function, constructor_ob=None):\n    if not callable(pickle_function):\n        raise TypeError(\"reduction functions must be callable\")\n    dispatch_table[ob_type] = pickle_function\n\n    # The constructor_ob function is a vestige of safe for unpickling.\n    # There is no reason for the caller to pass it anymore.\n    if constructor_ob is not None:\n        constructor(constructor_ob)\n\ndef constructor(object):\n    if not callable(object):\n        raise TypeError(\"constructors must be callable\")\n\n# Example: provide pickling support for complex numbers.\n\ndef pickle_complex(c):\n    return complex, (c.real, c.imag)\n\npickle(complex, pickle_complex, complex)\n\ndef pickle_union(obj):\n    import functools, operator\n    return functools.reduce, (operator.or_, obj.__args__)\n\npickle(type(int | str), pickle_union)\n\n# Support for pickling new-style objects\n\ndef _reconstructor(cls, base, state):\n    if base is object:\n        obj = object.__new__(cls)\n    else:\n        obj = base.__new__(cls, state)\n        if base.__init__ != object.__init__:\n            base.__init__(obj, state)\n    return obj\n\n_HEAPTYPE = 1<<9\n_new_type = type(int.__new__)\n\n# Python code for object.__reduce_ex__ for protocols 0 and 1\n\ndef _reduce_ex(self, proto):\n    assert proto < 2\n    cls = self.__class__\n    for base in cls.__mro__:\n        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:\n            break\n        new = base.__new__\n        if isinstance(new, _new_type) and new.__self__ is base:\n            break\n    else:\n        base = object # not really reachable\n    if base is object:\n        state = None\n    else:\n        if base is cls:\n            raise TypeError(f\"cannot pickle {cls.__name__!r} object\")\n        state = base(self)\n    args = (cls, base, state)\n    try:\n        getstate = self.__getstate__\n    except AttributeError:\n        if getattr(self, \"__slots__\", None):\n            raise TypeError(f\"cannot pickle {cls.__name__!r} object: \"\n                            f\"a class that defines __slots__ without \"\n                            f\"defining __getstate__ cannot be pickled \"\n                            f\"with protocol {proto}\") from None\n        try:\n            dict = self.__dict__\n        except AttributeError:\n            dict = None\n    else:\n        if (type(self).__getstate__ is object.__getstate__ and\n            getattr(self, \"__slots__\", None)):\n            raise TypeError(\"a class that defines __slots__ without \"\n                            \"defining __getstate__ cannot be pickled\")\n        dict = getstate()\n    if dict:\n        return _reconstructor, args, dict\n    else:\n        return _reconstructor, args\n\n# Helper for __reduce_ex__ protocol 2\n\ndef __newobj__(cls, *args):\n    return cls.__new__(cls, *args)\n\ndef __newobj_ex__(cls, args, kwargs):\n    \"\"\"Used by pickle protocol 4, instead of __newobj__ to allow classes with\n    keyword-only arguments to be pickled correctly.\n    \"\"\"\n    return cls.__new__(cls, *args, **kwargs)\n\ndef _slotnames(cls):\n    \"\"\"Return a list of slot names for a given class.\n\n    This needs to find slots defined by the class and its bases, so we\n    can't simply return the __slots__ attribute.  We must walk down\n    the Method Resolution Order and concatenate the __slots__ of each\n    class found there.  (This assumes classes don't modify their\n    __slots__ attribute to misrepresent their slots after the class is\n    defined.)\n    \"\"\"\n\n    # Get the value from a cache in the class if possible\n    names = cls.__dict__.get(\"__slotnames__\")\n    if names is not None:\n        return names\n\n    # Not cached -- calculate the value\n    names = []\n    if not hasattr(cls, \"__slots__\"):\n        # This class has no slots\n        pass\n    else:\n        # Slots found -- gather slot names from all base classes\n        for c in cls.__mro__:\n            if \"__slots__\" in c.__dict__:\n                slots = c.__dict__['__slots__']\n                # if class has a single slot, it can be given as a string\n                if isinstance(slots, str):\n                    slots = (slots,)\n                for name in slots:\n                    # special descriptors\n                    if name in (\"__dict__\", \"__weakref__\"):\n                        continue\n                    # mangled names\n                    elif name.startswith('__') and not name.endswith('__'):\n                        stripped = c.__name__.lstrip('_')\n                        if stripped:\n                            names.append('_%s%s' % (stripped, name))\n                        else:\n                            names.append(name)\n                    else:\n                        names.append(name)\n\n    # Cache the outcome in the class if at all possible\n    try:\n        cls.__slotnames__ = names\n    except:\n        pass # But don't die if we can't\n\n    return names\n\n# A registry of extension codes.  This is an ad-hoc compression\n# mechanism.  Whenever a global reference to <module>, <name> is about\n# to be pickled, the (<module>, <name>) tuple is looked up here to see\n# if it is a registered extension code for it.  Extension codes are\n# universal, so that the meaning of a pickle does not depend on\n# context.  (There are also some codes reserved for local use that\n# don't have this restriction.)  Codes are positive ints; 0 is\n# reserved.\n\n_extension_registry = {}                # key -> code\n_inverted_registry = {}                 # code -> key\n_extension_cache = {}                   # code -> object\n# Don't ever rebind those names:  pickling grabs a reference to them when\n# it's initialized, and won't see a rebinding.\n\ndef add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")\n    key = (module, name)\n    if (_extension_registry.get(key) == code and\n        _inverted_registry.get(code) == key):\n        return # Redundant registrations are benign\n    if key in _extension_registry:\n        raise ValueError(\"key %s is already registered with code %s\" %\n                         (key, _extension_registry[key]))\n    if code in _inverted_registry:\n        raise ValueError(\"code %s is already in use for key %s\" %\n                         (code, _inverted_registry[code]))\n    _extension_registry[key] = code\n    _inverted_registry[code] = key\n\ndef remove_extension(module, name, code):\n    \"\"\"Unregister an extension code.  For testing only.\"\"\"\n    key = (module, name)\n    if (_extension_registry.get(key) != code or\n        _inverted_registry.get(code) != key):\n        raise ValueError(\"key %s is not registered with code %s\" %\n                         (key, code))\n    del _extension_registry[key]\n    del _inverted_registry[code]\n    if code in _extension_cache:\n        del _extension_cache[code]\n\ndef clear_extension_cache():\n    _extension_cache.clear()\n\n# Standard extension code assignments\n\n# Reserved ranges\n\n# First  Last Count  Purpose\n#     1   127   127  Reserved for Python standard library\n#   128   191    64  Reserved for Zope\n#   192   239    48  Reserved for 3rd parties\n#   240   255    16  Reserved for private use (will never be assigned)\n#   256   Inf   Inf  Reserved for future assignment\n\n# Extension codes are assigned by the Python Software Foundation.\n", 217]}, "functions": {"iinfo.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:692)": ["C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py", 692], "iinfo.max (C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py:716)": ["C:\\Programming\\Python313\\Lib\\site-packages\\numpy\\_core\\getlimits.py", 716], "PyAudio.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:589)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 589], "ConverterMapping.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:1339)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1339], "RawConfigParser.converters (C:\\Programming\\Python313\\Lib\\configparser.py:1222)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1222], "ConverterMapping.__iter__ (C:\\Programming\\Python313\\Lib\\configparser.py:1381)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1381], "SectionProxy.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:1262)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1262], "RawConfigParser.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:629)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 629], "PyAudio.Stream.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:297)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 297], "PyAudio.open (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:631)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 631], "MyFrame (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:902)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 902], "MyApp (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1074)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 1074], "BaseContext._check_available (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:213)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 213], "BaseContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:187)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 187], "DefaultContext.get_context (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:237)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 237], "DefaultContext.set_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:245)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 245], "_enum_to_int (C:\\Programming\\Python313\\Lib\\signal.py:36)": ["C:\\Programming\\Python313\\Lib\\signal.py", 36], "_int_to_enum (C:\\Programming\\Python313\\Lib\\signal.py:24)": ["C:\\Programming\\Python313\\Lib\\signal.py", 24], "signal (C:\\Programming\\Python313\\Lib\\signal.py:56)": ["C:\\Programming\\Python313\\Lib\\signal.py", 56], "_initStockObjects (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:161)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 161], "setlocale (C:\\Programming\\Python313\\Lib\\locale.py:600)": ["C:\\Programming\\Python313\\Lib\\locale.py", 600], "App.InitLocale (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2296)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 2296], "App.OnPreInit (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2234)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 2234], "IncrementalDecoder.__init__ (C:\\Programming\\Python313\\Lib\\codecs.py:263)": ["C:\\Programming\\Python313\\Lib\\codecs.py", 263], "_ReadState.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:551)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 551], "IncrementalDecoder.decode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:22)": ["C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py", 22], "_Line.__new__ (C:\\Programming\\Python313\\Lib\\configparser.py:558)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 558], "_Line.__init__ (C:\\Programming\\Python313\\Lib\\configparser.py:561)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 561], "_Line._strip_full (C:\\Programming\\Python313\\Lib\\configparser.py:584)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 584], "_Line._strip_inline.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\configparser.py:577)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 577], "isstring (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:573)": ["C:\\Programming\\Python313\\Lib\\re\\_compiler.py", 573], "Tokenizer.__next (C:\\Programming\\Python313\\Lib\\re\\_parser.py:239)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 239], "Tokenizer.__init__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:230)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 230], "State.__init__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:76)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 76], "Tokenizer.tell (C:\\Programming\\Python313\\Lib\\re\\_parser.py:292)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 292], "SubPattern.__init__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:112)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 112], "Tokenizer.get (C:\\Programming\\Python313\\Lib\\re\\_parser.py:260)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 260], "Tokenizer.match (C:\\Programming\\Python313\\Lib\\re\\_parser.py:255)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 255], "SubPattern.__len__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:163)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 163], "_parse (C:\\Programming\\Python313\\Lib\\re\\_parser.py:511)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 511], "_parse_sub (C:\\Programming\\Python313\\Lib\\re\\_parser.py:451)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 451], "SubPattern.append (C:\\Programming\\Python313\\Lib\\re\\_parser.py:175)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 175], "SubPattern.__getitem__ (C:\\Programming\\Python313\\Lib\\re\\_parser.py:167)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 167], "fix_flags (C:\\Programming\\Python313\\Lib\\re\\_parser.py:954)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 954], "parse (C:\\Programming\\Python313\\Lib\\re\\_parser.py:970)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 970], "SubPattern.getwidth (C:\\Programming\\Python313\\Lib\\re\\_parser.py:177)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 177], "_compile_info (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:514)": ["C:\\Programming\\Python313\\Lib\\re\\_compiler.py", 514], "_compile (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:37)": ["C:\\Programming\\Python313\\Lib\\re\\_compiler.py", 37], "_code (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:576)": ["C:\\Programming\\Python313\\Lib\\re\\_compiler.py", 576], "State.groups (C:\\Programming\\Python313\\Lib\\re\\_parser.py:82)": ["C:\\Programming\\Python313\\Lib\\re\\_parser.py", 82], "compile (C:\\Programming\\Python313\\Lib\\re\\_compiler.py:743)": ["C:\\Programming\\Python313\\Lib\\re\\_compiler.py", 743], "Flag._get_value (C:\\Programming\\Python313\\Lib\\enum.py:1585)": ["C:\\Programming\\Python313\\Lib\\enum.py", 1585], "Enum.__new__ (C:\\Programming\\Python313\\Lib\\enum.py:1152)": ["C:\\Programming\\Python313\\Lib\\enum.py", 1152], "EnumType.__call__ (C:\\Programming\\Python313\\Lib\\enum.py:695)": ["C:\\Programming\\Python313\\Lib\\enum.py", 695], "Flag.__and__ (C:\\Programming\\Python313\\Lib\\enum.py:1603)": ["C:\\Programming\\Python313\\Lib\\enum.py", 1603], "_compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:330)": ["C:\\Programming\\Python313\\Lib\\re\\__init__.py", 330], "compile (C:\\Programming\\Python313\\Lib\\re\\__init__.py:287)": ["C:\\Programming\\Python313\\Lib\\re\\__init__.py", 287], "_Line._strip_inline (C:\\Programming\\Python313\\Lib\\configparser.py:572)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 572], "_Line.clean (C:\\Programming\\Python313\\Lib\\configparser.py:564)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 564], "cached_property.__get__ (C:\\Programming\\Python313\\Lib\\functools.py:1026)": ["C:\\Programming\\Python313\\Lib\\functools.py", 1026], "RawConfigParser._handle_continuation_line (C:\\Programming\\Python313\\Lib\\configparser.py:1083)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1083], "RawConfigParser._handle_header (C:\\Programming\\Python313\\Lib\\configparser.py:1107)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1107], "RawConfigParser._handle_rest (C:\\Programming\\Python313\\Lib\\configparser.py:1093)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1093], "RawConfigParser.optionxform (C:\\Programming\\Python313\\Lib\\configparser.py:903)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 903], "RawConfigParser._handle_option (C:\\Programming\\Python313\\Lib\\configparser.py:1125)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1125], "_Line.has_comments (C:\\Programming\\Python313\\Lib\\configparser.py:568)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 568], "RawConfigParser._read_inner (C:\\Programming\\Python313\\Lib\\configparser.py:1054)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1054], "suppress.__init__ (C:\\Programming\\Python313\\Lib\\contextlib.py:444)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 444], "suppress.__enter__ (C:\\Programming\\Python313\\Lib\\contextlib.py:447)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 447], "suppress.__exit__ (C:\\Programming\\Python313\\Lib\\contextlib.py:450)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 450], "ParsingError._raise_all (C:\\Programming\\Python313\\Lib\\configparser.py:327)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 327], "Interpolation.before_read (C:\\Programming\\Python313\\Lib\\configparser.py:389)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 389], "RawConfigParser._join_multiline_values (C:\\Programming\\Python313\\Lib\\configparser.py:1156)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1156], "RawConfigParser._read (C:\\Programming\\Python313\\Lib\\configparser.py:1031)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1031], "_check_methods (C:\\Programming\\Python313\\Lib\\_collections_abc.py:108)": ["C:\\Programming\\Python313\\Lib\\_collections_abc.py", 108], "PathLike.__subclasshook__ (C:\\Programming\\Python313\\Lib\\os.py:1126)": ["C:\\Programming\\Python313\\Lib\\os.py", 1126], "ABCMeta.__subclasscheck__ (C:\\Programming\\Python313\\Lib\\abc.py:121)": ["C:\\Programming\\Python313\\Lib\\abc.py", 121], "ABCMeta.__instancecheck__ (C:\\Programming\\Python313\\Lib\\abc.py:117)": ["C:\\Programming\\Python313\\Lib\\abc.py", 117], "RawConfigParser.read (C:\\Programming\\Python313\\Lib\\configparser.py:716)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 716], "ChainMap.__init__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1003)": ["C:\\Programming\\Python313\\Lib\\collections\\__init__.py", 1003], "RawConfigParser._unify_values (C:\\Programming\\Python313\\Lib\\configparser.py:1174)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1174], "ChainMap.__getitem__ (C:\\Programming\\Python313\\Lib\\collections\\__init__.py:1013)": ["C:\\Programming\\Python313\\Lib\\collections\\__init__.py", 1013], "RawConfigParser.get (C:\\Programming\\Python313\\Lib\\configparser.py:794)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 794], "BasicInterpolation._interpolate_some (C:\\Programming\\Python313\\Lib\\configparser.py:426)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 426], "BasicInterpolation.before_get (C:\\Programming\\Python313\\Lib\\configparser.py:413)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 413], "RawConfigParser._get (C:\\Programming\\Python313\\Lib\\configparser.py:831)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 831], "RawConfigParser._get_conv (C:\\Programming\\Python313\\Lib\\configparser.py:834)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 834], "RawConfigParser.getint (C:\\Programming\\Python313\\Lib\\configparser.py:845)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 845], "RawConfigParser.getfloat (C:\\Programming\\Python313\\Lib\\configparser.py:850)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 850], "_cleanup (C:\\Programming\\Python313\\Lib\\subprocess.py:265)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 265], "_GeneratorContextManagerBase.__init__ (C:\\Programming\\Python313\\Lib\\contextlib.py:108)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 108], "contextmanager.<locals>.helper (C:\\Programming\\Python313\\Lib\\contextlib.py:303)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 303], "Popen._on_error_fd_closer (C:\\Programming\\Python313\\Lib\\subprocess.py:1323)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1323], "_GeneratorContextManager.__enter__ (C:\\Programming\\Python313\\Lib\\contextlib.py:136)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 136], "Popen._make_inheritable (C:\\Programming\\Python313\\Lib\\subprocess.py:1426)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1426], "_GeneratorContextManager.__exit__ (C:\\Programming\\Python313\\Lib\\contextlib.py:145)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 145], "Popen._get_handles (C:\\Programming\\Python313\\Lib\\subprocess.py:1347)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1347], "Handle.Close (C:\\Programming\\Python313\\Lib\\subprocess.py:224)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 224], "Handle.Detach (C:\\Programming\\Python313\\Lib\\subprocess.py:229)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 229], "_fscodec.<locals>.fsdecode (C:\\Programming\\Python313\\Lib\\os.py:855)": ["C:\\Programming\\Python313\\Lib\\os.py", 855], "list2cmdline (C:\\Programming\\Python313\\Lib\\subprocess.py:584)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 584], "STARTUPINFO.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:199)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 199], "Popen._filter_handle_list (C:\\Programming\\Python313\\Lib\\subprocess.py:1435)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1435], "_BaseExitStack.__init__ (C:\\Programming\\Python313\\Lib\\contextlib.py:485)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 485], "ExitStack.__enter__ (C:\\Programming\\Python313\\Lib\\contextlib.py:568)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 568], "_BaseExitStack._create_cb_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:479)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 479], "_BaseExitStack._push_exit_callback (C:\\Programming\\Python313\\Lib\\contextlib.py:552)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 552], "_BaseExitStack.callback (C:\\Programming\\Python313\\Lib\\contextlib.py:534)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 534], "_BaseExitStack._create_cb_wrapper.<locals>._exit_wrapper (C:\\Programming\\Python313\\Lib\\contextlib.py:481)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 481], "ExitStack.__exit__ (C:\\Programming\\Python313\\Lib\\contextlib.py:571)": ["C:\\Programming\\Python313\\Lib\\contextlib.py", 571], "Popen._close_pipe_fds (C:\\Programming\\Python313\\Lib\\subprocess.py:1294)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1294], "Popen._execute_child (C:\\Programming\\Python313\\Lib\\subprocess.py:1448)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1448], "Popen.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:816)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 816], "Popen.__enter__ (C:\\Programming\\Python313\\Lib\\subprocess.py:1101)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1101], "Popen._wait (C:\\Programming\\Python313\\Lib\\subprocess.py:1592)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1592], "Popen.wait (C:\\Programming\\Python313\\Lib\\subprocess.py:1271)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1271], "Popen.communicate (C:\\Programming\\Python313\\Lib\\subprocess.py:1177)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1177], "Popen._internal_poll (C:\\Programming\\Python313\\Lib\\subprocess.py:1575)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1575], "Popen.poll (C:\\Programming\\Python313\\Lib\\subprocess.py:1245)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1245], "Popen.__exit__ (C:\\Programming\\Python313\\Lib\\subprocess.py:1104)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1104], "CompletedProcess.__init__ (C:\\Programming\\Python313\\Lib\\subprocess.py:489)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 489], "run (C:\\Programming\\Python313\\Lib\\subprocess.py:514)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 514], "Popen.__del__ (C:\\Programming\\Python313\\Lib\\subprocess.py:1132)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 1132], "check_output (C:\\Programming\\Python313\\Lib\\subprocess.py:425)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 425], "get_commit_version (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:171)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 171], "PyEventBinder.Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1549)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 1549], "_EvtHandler_Bind (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1452)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 1452], "MyFrame.__init__ (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:903)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 903], "MyApp.OnInit (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1075)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 1075], "App.__init__ (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2151)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 2151], "getpreferredencoding (C:\\Programming\\Python313\\Lib\\locale.py:630)": ["C:\\Programming\\Python313\\Lib\\locale.py", 630], "Codec.decode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:14)": ["C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py", 14], "PyAudio._make_device_info_dictionary (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:840)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 840], "PyAudio.get_device_info_by_index (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:827)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 827], "func_on_button_setDevices_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:192)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 192], "MyFrame.on_button_setDevices_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1035)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 1035], "_PyEvent_Clone (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:1851)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 1851], "CallAfter (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3406)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 3406], "Full (C:\\Programming\\Python313\\Lib\\queue.py:31)": ["C:\\Programming\\Python313\\Lib\\queue.py", 31], "ShutDown (C:\\Programming\\Python313\\Lib\\queue.py:36)": ["C:\\Programming\\Python313\\Lib\\queue.py", 36], "Queue (C:\\Programming\\Python313\\Lib\\queue.py:40)": ["C:\\Programming\\Python313\\Lib\\queue.py", 40], "PriorityQueue (C:\\Programming\\Python313\\Lib\\queue.py:281)": ["C:\\Programming\\Python313\\Lib\\queue.py", 281], "LifoQueue (C:\\Programming\\Python313\\Lib\\queue.py:300)": ["C:\\Programming\\Python313\\Lib\\queue.py", 300], "_PySimpleQueue (C:\\Programming\\Python313\\Lib\\queue.py:316)": ["C:\\Programming\\Python313\\Lib\\queue.py", 316], "<module> (C:\\Programming\\Python313\\Lib\\queue.py:1)": ["C:\\Programming\\Python313\\Lib\\queue.py", 1], "_platform_supports_abstract_sockets (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:104)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py", 104], "WeakValueDictionary.update (C:\\Programming\\Python313\\Lib\\weakref.py:289)": ["C:\\Programming\\Python313\\Lib\\weakref.py", 289], "WeakValueDictionary.__init__ (C:\\Programming\\Python313\\Lib\\weakref.py:104)": ["C:\\Programming\\Python313\\Lib\\weakref.py", 104], "Finalize (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:174)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py", 174], "ForkAwareThreadLock (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:360)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py", 360], "ForkAwareLocal (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:377)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py", 377], "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:1)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py", 1], "_ConnectionBase (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:115)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 115], "PipeConnection (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:268)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 268], "Connection (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:364)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 364], "Listener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:448)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 448], "SocketListener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:596)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 596], "PipeListener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:656)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 656], "<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:838)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 838], "ConnectionWrapper (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:970)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 970], "XmlListener (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:992)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 992], "ForkingPickler.register (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:43)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py", 43], "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:1)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 1], "Queue (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:33)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py", 33], "JoinableQueue (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:314)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py", 314], "SimpleQueue (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:357)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py", 357], "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:1)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py", 1], "SemLock (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:46)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 46], "Semaphore (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:130)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 130], "BoundedSemaphore (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:149)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 149], "Lock (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:166)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 166], "RLock (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:191)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 191], "Condition (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:217)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 217], "Event (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:328)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 328], "Barrier (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:370)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 370], "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:1)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 1], "_get_candidate_names (C:\\Programming\\Python313\\Lib\\tempfile.py:229)": ["C:\\Programming\\Python313\\Lib\\tempfile.py", 229], "Random.seed (C:\\Programming\\Python313\\Lib\\random.py:128)": ["C:\\Programming\\Python313\\Lib\\random.py", 128], "Random.__init__ (C:\\Programming\\Python313\\Lib\\random.py:119)": ["C:\\Programming\\Python313\\Lib\\random.py", 119], "_RandomNameSequence.rng (C:\\Programming\\Python313\\Lib\\tempfile.py:142)": ["C:\\Programming\\Python313\\Lib\\tempfile.py", 142], "Random.choices (C:\\Programming\\Python313\\Lib\\random.py:458)": ["C:\\Programming\\Python313\\Lib\\random.py", 458], "_RandomNameSequence.__next__ (C:\\Programming\\Python313\\Lib\\tempfile.py:153)": ["C:\\Programming\\Python313\\Lib\\tempfile.py", 153], "join (C:\\Programming\\Python313\\Lib\\ntpath.py:99)": ["C:\\Programming\\Python313\\Lib\\ntpath.py", 99], "_exists (C:\\Programming\\Python313\\Lib\\tempfile.py:76)": ["C:\\Programming\\Python313\\Lib\\tempfile.py", 76], "mktemp (C:\\Programming\\Python313\\Lib\\tempfile.py:400)": ["C:\\Programming\\Python313\\Lib\\tempfile.py", 400], "arbitrary_address (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:70)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 70], "_ConnectionBase.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:118)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 118], "Pipe (C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py:552)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\connection.py", 552], "BaseContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:197)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 197], "current_process (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:37)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 37], "SemLock._make_name (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:121)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 121], "debug (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:48)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py", 48], "SemLock._make_methods (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:90)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 90], "SemLock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:50)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 50], "Lock.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:168)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 168], "BaseContext.Lock (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:65)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 65], "BoundedSemaphore.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py:151)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\synchronize.py", 151], "BaseContext.BoundedSemaphore (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:85)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 85], "Condition.__init__ (C:\\Programming\\Python313\\Lib\\threading.py:281)": ["C:\\Programming\\Python313\\Lib\\threading.py", 281], "Queue._reset (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:69)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py", 69], "Queue.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py:35)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\queues.py", 35], "BaseContext.Queue (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:100)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 100], "BaseProcess.name (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:189)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 189], "BaseProcess.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:94)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 94], "WeakSet.add (C:\\Programming\\Python313\\Lib\\_weakrefset.py:85)": ["C:\\Programming\\Python313\\Lib\\_weakrefset.py", 85], "BaseProcess.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:80)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 80], "BaseProcess._check_closed (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:99)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 99], "_cleanup (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:61)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 61], "_TempModule (C:\\Programming\\Python313\\Lib\\runpy.py:26)": ["C:\\Programming\\Python313\\Lib\\runpy.py", 26], "_ModifiedArgv0 (C:\\Programming\\Python313\\Lib\\runpy.py:49)": ["C:\\Programming\\Python313\\Lib\\runpy.py", 49], "_Error (C:\\Programming\\Python313\\Lib\\runpy.py:166)": ["C:\\Programming\\Python313\\Lib\\runpy.py", 166], "<module> (C:\\Programming\\Python313\\Lib\\runpy.py:1)": ["C:\\Programming\\Python313\\Lib\\runpy.py", 1], "set_executable (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:36)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py", 36], "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:1)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py", 1], "_path_eq (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:24)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py", 24], "Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:40)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py", 40], "<module> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:1)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py", 1], "_check_not_importing_main (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:138)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py", 138], "BaseProcess.authkey (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:213)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 213], "DefaultContext.get_start_method (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:253)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 253], "isabs (C:\\Programming\\Python313\\Lib\\ntpath.py:80)": ["C:\\Programming\\Python313\\Lib\\ntpath.py", 80], "get_preparation_data (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:160)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py", 160], "get_command_line.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:92)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py", 92], "_optim_args_from_interpreter_flags (C:\\Programming\\Python313\\Lib\\subprocess.py:296)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 296], "_args_from_interpreter_flags (C:\\Programming\\Python313\\Lib\\subprocess.py:306)": ["C:\\Programming\\Python313\\Lib\\subprocess.py", 306], "get_executable (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:45)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py", 45], "get_command_line (C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py:83)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\spawn.py", 83], "Popen.__init__.<locals>.<genexpr> (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:71)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py", 71], "Finalize.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py:178)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\util.py", 178], "set_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:369)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 369], "ForkingPickler.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:38)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py", 38], "get_spawning_popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:366)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 366], "AuthenticationString.__reduce__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:347)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 347], "dump (C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py:58)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\reduction.py", 58], "_slotnames (C:\\Programming\\Python313\\Lib\\copyreg.py:107)": ["C:\\Programming\\Python313\\Lib\\copyreg.py", 107], "Popen.__init__ (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:46)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py", 46], "SpawnProcess._Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:334)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 334], "Process._Popen (C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py:222)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\context.py", 222], "BaseProcess.start (C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py:110)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\process.py", 110], "Popen.wait (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:105)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py", 105], "Popen.poll (C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py:123)": ["C:\\Programming\\Python313\\Lib\\multiprocessing\\popen_spawn_win32.py", 123], "func_on_button_start_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:527)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 527], "MyFrame.on_button_start_click (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1040)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 1040], "MyFrame.update_status (C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py:1019)": ["C:\\Programming\\eclipse_workspace\\Python_AudioLogger\\Python_AudioLogger.py", 1019], "CallAfter.<locals>.<lambda> (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:3427)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 3427], "App.RestoreStdio (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2276)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 2276], "App.MainLoop (C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py:2258)": ["C:\\Programming\\Python313\\Lib\\site-packages\\wx\\core.py", 2258], "RawConfigParser._validate_value_types (C:\\Programming\\Python313\\Lib\\configparser.py:1201)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1201], "BasicInterpolation.before_set (C:\\Programming\\Python313\\Lib\\configparser.py:418)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 418], "RawConfigParser.set (C:\\Programming\\Python313\\Lib\\configparser.py:920)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 920], "ConfigParser.set (C:\\Programming\\Python313\\Lib\\configparser.py:1232)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 1232], "IncrementalEncoder.__init__ (C:\\Programming\\Python313\\Lib\\codecs.py:189)": ["C:\\Programming\\Python313\\Lib\\codecs.py", 189], "IncrementalEncoder.encode (C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py:18)": ["C:\\Programming\\Python313\\Lib\\encodings\\cp1252.py", 18], "Interpolation.before_write (C:\\Programming\\Python313\\Lib\\configparser.py:392)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 392], "RawConfigParser._write_section (C:\\Programming\\Python313\\Lib\\configparser.py:959)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 959], "RawConfigParser.write (C:\\Programming\\Python313\\Lib\\configparser.py:934)": ["C:\\Programming\\Python313\\Lib\\configparser.py", 934], "PyAudio.Stream.stop_stream (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:495)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 495], "PyAudio._remove_stream (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:654)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 654], "PyAudio.Stream.close (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:449)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 449], "PyAudio.terminate (C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py:594)": ["C:\\Programming\\Python313\\Lib\\site-packages\\pyaudio\\__init__.py", 594]}}}